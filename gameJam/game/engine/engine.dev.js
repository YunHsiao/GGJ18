
/*
 * engine-3d v0.13.0
 * (c) 2018 @cocos
 * Released under the MIT License.
 */

var cc = (function () {
'use strict';

var GL_NEAREST = 9728;                // gl.NEAREST
var GL_LINEAR = 9729;                 // gl.LINEAR
var GL_NEAREST_MIPMAP_NEAREST = 9984; // gl.NEAREST_MIPMAP_NEAREST
var GL_LINEAR_MIPMAP_NEAREST = 9985;  // gl.LINEAR_MIPMAP_NEAREST
var GL_NEAREST_MIPMAP_LINEAR = 9986;  // gl.NEAREST_MIPMAP_LINEAR
var GL_LINEAR_MIPMAP_LINEAR = 9987;   // gl.LINEAR_MIPMAP_LINEAR

// const GL_BYTE = 5120;                  // gl.BYTE
var GL_UNSIGNED_BYTE = 5121;            // gl.UNSIGNED_BYTE
// const GL_SHORT = 5122;                 // gl.SHORT
var GL_UNSIGNED_SHORT = 5123;           // gl.UNSIGNED_SHORT
var GL_UNSIGNED_INT = 5125;             // gl.UNSIGNED_INT
var GL_FLOAT = 5126;                    // gl.FLOAT
var GL_UNSIGNED_SHORT_5_6_5 = 33635;    // gl.UNSIGNED_SHORT_5_6_5
var GL_UNSIGNED_SHORT_4_4_4_4 = 32819;  // gl.UNSIGNED_SHORT_4_4_4_4
var GL_UNSIGNED_SHORT_5_5_5_1 = 32820;  // gl.UNSIGNED_SHORT_5_5_5_1
var GL_HALF_FLOAT_OES = 36193;          // gl.HALF_FLOAT_OES

var GL_DEPTH_COMPONENT = 6402; // gl.DEPTH_COMPONENT

var GL_ALPHA = 6406;            // gl.ALPHA
var GL_RGB = 6407;              // gl.RGB
var GL_RGBA = 6408;             // gl.RGBA
var GL_LUMINANCE = 6409;        // gl.LUMINANCE
var GL_LUMINANCE_ALPHA = 6410;  // gl.LUMINANCE_ALPHA

var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;   // ext.COMPRESSED_RGB_S3TC_DXT1_EXT
var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;  // ext.COMPRESSED_RGBA_S3TC_DXT1_EXT
var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;  // ext.COMPRESSED_RGBA_S3TC_DXT3_EXT
var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;  // ext.COMPRESSED_RGBA_S3TC_DXT5_EXT

var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00;  // ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01;  // ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02; // ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03; // ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG

var GL_COMPRESSED_RGB_ETC1_WEBGL = 0x8D64; // ext.COMPRESSED_RGB_ETC1_WEBGL

var _filterGL = [
  [ GL_NEAREST,  GL_NEAREST_MIPMAP_NEAREST, GL_NEAREST_MIPMAP_LINEAR ],
  [ GL_LINEAR,  GL_LINEAR_MIPMAP_NEAREST, GL_LINEAR_MIPMAP_LINEAR ] ];

var _textureFmtGL = [
  // TEXTURE_FMT_RGB_DXT1: 0
  { format: GL_RGB, internalFormat: GL_COMPRESSED_RGB_S3TC_DXT1_EXT, pixelType: null },

  // TEXTURE_FMT_RGBA_DXT1: 1
  { format: GL_RGBA, internalFormat: GL_COMPRESSED_RGBA_S3TC_DXT1_EXT, pixelType: null },

  // TEXTURE_FMT_RGBA_DXT3: 2
  { format: GL_RGBA, internalFormat: GL_COMPRESSED_RGBA_S3TC_DXT3_EXT, pixelType: null },

  // TEXTURE_FMT_RGBA_DXT5: 3
  { format: GL_RGBA, internalFormat: GL_COMPRESSED_RGBA_S3TC_DXT5_EXT, pixelType: null },

  // TEXTURE_FMT_RGB_ETC1: 4
  { format: GL_RGB, internalFormat: GL_COMPRESSED_RGB_ETC1_WEBGL, pixelType: null },

  // TEXTURE_FMT_RGB_PVRTC_2BPPV1: 5
  { format: GL_RGB, internalFormat: GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG, pixelType: null },

  // TEXTURE_FMT_RGBA_PVRTC_2BPPV1: 6
  { format: GL_RGBA, internalFormat: GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG, pixelType: null },

  // TEXTURE_FMT_RGB_PVRTC_4BPPV1: 7
  { format: GL_RGB, internalFormat: GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG, pixelType: null },

  // TEXTURE_FMT_RGBA_PVRTC_4BPPV1: 8
  { format: GL_RGBA, internalFormat: GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG, pixelType: null },

  // TEXTURE_FMT_A8: 9
  { format: GL_ALPHA, internalFormat: GL_ALPHA, pixelType: GL_UNSIGNED_BYTE },

  // TEXTURE_FMT_L8: 10
  { format: GL_LUMINANCE, internalFormat: GL_LUMINANCE, pixelType: GL_UNSIGNED_BYTE },

  // TEXTURE_FMT_L8_A8: 11
  { format: GL_LUMINANCE_ALPHA, internalFormat: GL_LUMINANCE_ALPHA, pixelType: GL_UNSIGNED_BYTE },

  // TEXTURE_FMT_R5_G6_B5: 12
  { format: GL_RGB, internalFormat: GL_RGB, pixelType: GL_UNSIGNED_SHORT_5_6_5 },

  // TEXTURE_FMT_R5_G5_B5_A1: 13
  { format: GL_RGBA, internalFormat: GL_RGBA, pixelType: GL_UNSIGNED_SHORT_5_5_5_1 },

  // TEXTURE_FMT_R4_G4_B4_A4: 14
  { format: GL_RGBA, internalFormat: GL_RGBA, pixelType: GL_UNSIGNED_SHORT_4_4_4_4 },

  // TEXTURE_FMT_RGB8: 15
  { format: GL_RGB, internalFormat: GL_RGB, pixelType: GL_UNSIGNED_BYTE },

  // TEXTURE_FMT_RGBA8: 16
  { format: GL_RGBA, internalFormat: GL_RGBA, pixelType: GL_UNSIGNED_BYTE },

  // TEXTURE_FMT_RGB16F: 17
  { format: GL_RGB, internalFormat: GL_RGB, pixelType: GL_HALF_FLOAT_OES },

  // TEXTURE_FMT_RGBA16F: 18
  { format: GL_RGBA, internalFormat: GL_RGBA, pixelType: GL_HALF_FLOAT_OES },

  // TEXTURE_FMT_RGB32F: 19
  { format: GL_RGB, internalFormat: GL_RGB, pixelType: GL_FLOAT },

  // TEXTURE_FMT_RGBA32F: 20
  { format: GL_RGBA, internalFormat: GL_RGBA, pixelType: GL_FLOAT },

  // TEXTURE_FMT_R32F: 21
  { format: null, internalFormat: null, pixelType: null },

  // TEXTURE_FMT_111110F: 22
  { format: null, internalFormat: null, pixelType: null },

  // TEXTURE_FMT_SRGB: 23
  { format: null, internalFormat: null, pixelType: null },

  // TEXTURE_FMT_SRGBA: 24
  { format: null, internalFormat: null, pixelType: null },

  // TEXTURE_FMT_D16: 25
  { format: GL_DEPTH_COMPONENT, internalFormat: GL_DEPTH_COMPONENT, pixelType: GL_UNSIGNED_SHORT },

  // TEXTURE_FMT_D32: 26
  { format: GL_DEPTH_COMPONENT, internalFormat: GL_DEPTH_COMPONENT, pixelType: GL_UNSIGNED_INT },

  // TEXTURE_FMT_D24S8: 27
  { format: null, internalFormat: null, pixelType: null } ];

/**
 * enums
 */
var enums = {
  // buffer usage
  USAGE_STATIC: 35044,  // gl.STATIC_DRAW
  USAGE_DYNAMIC: 35048, // gl.DYNAMIC_DRAW
  USAGE_STREAM: 35040,  // gl.STREAM_DRAW

  // index buffer format
  INDEX_FMT_UINT8: 5121,  // gl.UNSIGNED_BYTE
  INDEX_FMT_UINT16: 5123, // gl.UNSIGNED_SHORT
  INDEX_FMT_UINT32: 5125, // gl.UNSIGNED_INT (OES_element_index_uint)

  // vertex attribute semantic
  ATTR_POSITION: 'a_position',
  ATTR_NORMAL: 'a_normal',
  ATTR_TANGENT: 'a_tangent',
  ATTR_BITANGENT: 'a_bitangent',
  ATTR_WEIGHTS: 'a_weights',
  ATTR_JOINTS: 'a_joints',
  ATTR_COLOR: 'a_color',
  ATTR_COLOR0: 'a_color0',
  ATTR_COLOR1: 'a_color1',
  ATTR_UV: 'a_uv',
  ATTR_UV0: 'a_uv0',
  ATTR_UV1: 'a_uv1',
  ATTR_UV2: 'a_uv2',
  ATTR_UV3: 'a_uv3',
  ATTR_UV4: 'a_uv4',
  ATTR_UV5: 'a_uv5',
  ATTR_UV6: 'a_uv6',
  ATTR_UV7: 'a_uv7',

  // vertex attribute type
  ATTR_TYPE_INT8: 5120,    // gl.BYTE
  ATTR_TYPE_UINT8: 5121,   // gl.UNSIGNED_BYTE
  ATTR_TYPE_INT16: 5122,   // gl.SHORT
  ATTR_TYPE_UINT16: 5123,  // gl.UNSIGNED_SHORT
  ATTR_TYPE_INT32: 5124,   // gl.INT
  ATTR_TYPE_UINT32: 5125,  // gl.UNSIGNED_INT
  ATTR_TYPE_FLOAT32: 5126, // gl.FLOAT

  // texture filter
  FILTER_NEAREST: 0,
  FILTER_LINEAR: 1,

  // texture wrap mode
  WRAP_REPEAT: 10497, // gl.REPEAT
  WRAP_CLAMP: 33071,  // gl.CLAMP_TO_EDGE
  WRAP_MIRROR: 33648, // gl.MIRRORED_REPEAT

  // texture format
  // compress formats
  TEXTURE_FMT_RGB_DXT1: 0,
  TEXTURE_FMT_RGBA_DXT1: 1,
  TEXTURE_FMT_RGBA_DXT3: 2,
  TEXTURE_FMT_RGBA_DXT5: 3,
  TEXTURE_FMT_RGB_ETC1: 4,
  TEXTURE_FMT_RGB_PVRTC_2BPPV1: 5,
  TEXTURE_FMT_RGBA_PVRTC_2BPPV1: 6,
  TEXTURE_FMT_RGB_PVRTC_4BPPV1: 7,
  TEXTURE_FMT_RGBA_PVRTC_4BPPV1: 8,

  // normal formats
  TEXTURE_FMT_A8: 9,
  TEXTURE_FMT_L8: 10,
  TEXTURE_FMT_L8_A8: 11,
  TEXTURE_FMT_R5_G6_B5: 12,
  TEXTURE_FMT_R5_G5_B5_A1: 13,
  TEXTURE_FMT_R4_G4_B4_A4: 14,
  TEXTURE_FMT_RGB8: 15,
  TEXTURE_FMT_RGBA8: 16,
  TEXTURE_FMT_RGB16F: 17,
  TEXTURE_FMT_RGBA16F: 18,
  TEXTURE_FMT_RGB32F: 19,
  TEXTURE_FMT_RGBA32F: 20,
  TEXTURE_FMT_R32F: 21,
  TEXTURE_FMT_111110F: 22,
  TEXTURE_FMT_SRGB: 23,
  TEXTURE_FMT_SRGBA: 24,

  // depth formats
  TEXTURE_FMT_D16: 25,
  TEXTURE_FMT_D32: 26,
  TEXTURE_FMT_D24S8: 27,

  // depth and stencil function
  DS_FUNC_NEVER: 512,    // gl.NEVER
  DS_FUNC_LESS: 513,     // gl.LESS
  DS_FUNC_EQUAL: 514,    // gl.EQUAL
  DS_FUNC_LEQUAL: 515,   // gl.LEQUAL
  DS_FUNC_GREATER: 516,  // gl.GREATER
  DS_FUNC_NOTEQUAL: 517, // gl.NOTEQUAL
  DS_FUNC_GEQUAL: 518,   // gl.GEQUAL
  DS_FUNC_ALWAYS: 519,   // gl.ALWAYS

  // render-buffer format
  RB_FMT_RGBA4: 32854,    // gl.RGBA4
  RB_FMT_RGB5_A1: 32855,  // gl.RGB5_A1
  RB_FMT_RGB565: 36194,   // gl.RGB565
  RB_FMT_D16: 33189,      // gl.DEPTH_COMPONENT16
  RB_FMT_S8: 36168,       // gl.STENCIL_INDEX8
  RB_FMT_D24S8: 34041,    // gl.DEPTH_STENCIL

  // blend-equation
  BLEND_FUNC_ADD: 32774,              // gl.FUNC_ADD
  BLEND_FUNC_SUBTRACT: 32778,         // gl.FUNC_SUBTRACT
  BLEND_FUNC_REVERSE_SUBTRACT: 32779, // gl.FUNC_REVERSE_SUBTRACT

  // blend
  BLEND_ZERO: 0,                          // gl.ZERO
  BLEND_ONE: 1,                           // gl.ONE
  BLEND_SRC_COLOR: 768,                   // gl.SRC_COLOR
  BLEND_ONE_MINUS_SRC_COLOR: 769,         // gl.ONE_MINUS_SRC_COLOR
  BLEND_DST_COLOR: 774,                   // gl.DST_COLOR
  BLEND_ONE_MINUS_DST_COLOR: 775,         // gl.ONE_MINUS_DST_COLOR
  BLEND_SRC_ALPHA: 770,                   // gl.SRC_ALPHA
  BLEND_ONE_MINUS_SRC_ALPHA: 771,         // gl.ONE_MINUS_SRC_ALPHA
  BLEND_DST_ALPHA: 772,                   // gl.DST_ALPHA
  BLEND_ONE_MINUS_DST_ALPHA: 773,         // gl.ONE_MINUS_DST_ALPHA
  BLEND_CONSTANT_COLOR: 32769,            // gl.CONSTANT_COLOR
  BLEND_ONE_MINUS_CONSTANT_COLOR: 32770,  // gl.ONE_MINUS_CONSTANT_COLOR
  BLEND_CONSTANT_ALPHA: 32771,            // gl.CONSTANT_ALPHA
  BLEND_ONE_MINUS_CONSTANT_ALPHA: 32772,  // gl.ONE_MINUS_CONSTANT_ALPHA
  BLEND_SRC_ALPHA_SATURATE: 776,          // gl.SRC_ALPHA_SATURATE

  // stencil operation
  STENCIL_OP_KEEP: 7680,          // gl.KEEP
  STENCIL_OP_ZERO: 0,             // gl.ZERO
  STENCIL_OP_REPLACE: 7681,       // gl.REPLACE
  STENCIL_OP_INCR: 7682,          // gl.INCR
  STENCIL_OP_INCR_WRAP: 34055,    // gl.INCR_WRAP
  STENCIL_OP_DECR: 7683,          // gl.DECR
  STENCIL_OP_DECR_WRAP: 34056,    // gl.DECR_WRAP
  STENCIL_OP_INVERT: 5386,        // gl.INVERT

  // cull
  CULL_NONE: 0,
  CULL_FRONT: 1028,
  CULL_BACK: 1029,
  CULL_FRONT_AND_BACK: 1032,

  // primitive type
  PT_POINTS: 0,         // gl.POINTS
  PT_LINES: 1,          // gl.LINES
  PT_LINE_LOOP: 2,      // gl.LINE_LOOP
  PT_LINE_STRIP: 3,     // gl.LINE_STRIP
  PT_TRIANGLES: 4,      // gl.TRIANGLES
  PT_TRIANGLE_STRIP: 5, // gl.TRIANGLE_STRIP
  PT_TRIANGLE_FAN: 6,   // gl.TRIANGLE_FAN
};

/**
 * @method attrTypeBytes
 * @param {ATTR_TYPE_*} attrType
 */
function attrTypeBytes(attrType) {
  if (attrType === enums.ATTR_TYPE_INT8) {
    return 1;
  } else if (attrType === enums.ATTR_TYPE_UINT8) {
    return 1;
  } else if (attrType === enums.ATTR_TYPE_INT16) {
    return 2;
  } else if (attrType === enums.ATTR_TYPE_UINT16) {
    return 2;
  } else if (attrType === enums.ATTR_TYPE_INT32) {
    return 4;
  } else if (attrType === enums.ATTR_TYPE_UINT32) {
    return 4;
  } else if (attrType === enums.ATTR_TYPE_FLOAT32) {
    return 4;
  }

  console.warn(("Unknown ATTR_TYPE: " + attrType));
  return 0;
}

/**
 * @method glFilter
 * @param {WebGLContext} gl
 * @param {FILTER_*} filter
 * @param {FILTER_*} mipFilter
 */
function glFilter(gl, filter, mipFilter) {
  if ( mipFilter === void 0 ) mipFilter = -1;

  var result = _filterGL[filter][mipFilter+1];
  if (result === undefined) {
    console.warn(("Unknown FILTER: " + filter));
    return mipFilter === -1 ? gl.LINEAR : gl.LINEAR_MIPMAP_LINEAR;
  }

  return result;
}

/**
 * @method glTextureFmt
 * @param {TEXTURE_FMT_*} fmt
 */
function glTextureFmt(fmt) {
  var result = _textureFmtGL[fmt];
  if (result === undefined) {
    console.warn(("Unknown TEXTURE_FMT: " + fmt));
    return _textureFmtGL[enums.TEXTURE_FMT_RGBA8];
  }

  return result;
}

var VertexFormat = function VertexFormat(infos) {
  var this$1 = this;

  this._attr2el = {};
  this._elements = [];
  this._bytes = 0;

  var offset = 0;
  for (var i = 0, len = infos.length; i < len; ++i) {
    var info = infos[i];
    var el = {
      name: info.name,
      offset: offset,
      stride: 0,
      stream: -1,
      type: info.type,
      num: info.num,
      normalize: (info.normalize === undefined) ? false : info.normalize,
      bytes: info.num * attrTypeBytes(info.type),
    };

    this$1._attr2el[el.name] = el;
    this$1._elements.push(el);

    this$1._bytes += el.bytes;
    offset += el.bytes;
  }

  for (var i$1 = 0, len$1 = this._elements.length; i$1 < len$1; ++i$1) {
    var el$1 = this$1._elements[i$1];
    el$1.stride = this$1._bytes;
  }
};

/**
 * @method element
 * @param {string} attrName
 */
VertexFormat.prototype.element = function element (attrName) {
  return this._attr2el[attrName];
};

var IndexBuffer = function IndexBuffer(device, format, usage, data, numIndices) {
  this._device = device;
  this._format = format;
  this._usage = usage;
  this._numIndices = numIndices;
  this._bytesPerIndex = 0;

  // calculate bytes
  if (format === enums.INDEX_FMT_UINT8) {
    this._bytesPerIndex = 1;
  } else if (format === enums.INDEX_FMT_UINT16) {
    this._bytesPerIndex = 2;
  } else if (format === enums.INDEX_FMT_UINT32) {
    this._bytesPerIndex = 4;
  }
  this._bytes = this._bytesPerIndex * numIndices;

  // update
  this._glID = device._gl.createBuffer();
  this.update(0, data);

  // stats
  device._stats.ib += this._bytes;
};

var prototypeAccessors = { count: { configurable: true } };

/**
 * @method destroy
 */
IndexBuffer.prototype.destroy = function destroy () {
  if (this._glID === -1) {
    console.error('The buffer already destroyed');
    return;
  }

  var gl = this._device._gl;
  gl.deleteBuffer(this._glID);
  this._device._stats.ib -= this.bytes;

  this._glID = -1;
};

/**
 * @method update
 * @param {Number} offset
 * @param {ArrayBuffer} data
 */
IndexBuffer.prototype.update = function update (offset, data) {
  if (this._glID === -1) {
    console.error('The buffer is destroyed');
    return;
  }

  if (data && data.byteLength + offset > this._bytes) {
    console.error('Failed to update data, bytes exceed.');
    return;
  }

  var gl = this._device._gl;
  var glUsage = this._usage;

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._glID);
  if (!data) {
    if (this._bytes) {
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._bytes, glUsage);
    } else {
      console.warn('bufferData should not submit 0 bytes data');
    }
  } else {
    if (offset) {
      gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, offset, data);
    } else {
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, glUsage);
    }
  }
  this._device._restoreIndexBuffer();
};

prototypeAccessors.count.get = function () {
  return this._numIndices;
};

Object.defineProperties( IndexBuffer.prototype, prototypeAccessors );

var VertexBuffer = function VertexBuffer(device, format, usage, data, numVertices) {
  this._device = device;
  this._format = format;
  this._usage = usage;
  this._numVertices = numVertices;

  // calculate bytes
  this._bytes = this._format._bytes * numVertices;

  // update
  this._glID = device._gl.createBuffer();
  this.update(0, data);

  // stats
  device._stats.vb += this._bytes;
};

var prototypeAccessors$1 = { count: { configurable: true } };

/**
 * @method destroy
 */
VertexBuffer.prototype.destroy = function destroy () {
  if (this._glID === -1) {
    console.error('The buffer already destroyed');
    return;
  }

  var gl = this._device._gl;
  gl.deleteBuffer(this._glID);
  this._device._stats.vb -= this.bytes;

  this._glID = -1;
};

/**
 * @method update
 * @param {Number} offset
 * @param {ArrayBuffer} data
 */
VertexBuffer.prototype.update = function update (offset, data) {
  if (this._glID === -1) {
    console.error('The buffer is destroyed');
    return;
  }

  if (data && data.byteLength + offset > this._bytes) {
    console.error('Failed to update data, bytes exceed.');
    return;
  }

  var gl = this._device._gl;
  var glUsage = this._usage;

  gl.bindBuffer(gl.ARRAY_BUFFER, this._glID);
  if (!data) {
    if (this._bytes) {
      gl.bufferData(gl.ARRAY_BUFFER, this._bytes, glUsage);
    } else {
      console.warn('bufferData should not submit 0 bytes data');
    }
  } else {
    if (offset) {
      gl.bufferSubData(gl.ARRAY_BUFFER, offset, data);
    } else {
      gl.bufferData(gl.ARRAY_BUFFER, data, glUsage);
    }
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
};

prototypeAccessors$1.count.get = function () {
  return this._numVertices;
};

Object.defineProperties( VertexBuffer.prototype, prototypeAccessors$1 );

var _genID = 0;

function _parseError(out, type, errorLog) {
  errorLog.split('\n').forEach(function (msg) {
    if (msg.length < 5) {
      return;
    }

    var parts = /^ERROR\:\s+(\d+)\:(\d+)\:\s*(.*)$/.exec(msg);
    if (parts) {
      out.push({
        type: type,
        fileID: parts[1] | 0,
        line: parts[2] | 0,
        message: parts[3].trim()
      });
    } else if (msg.length > 0) {
      out.push({
        type: type,
        fileID: -1,
        line: 0,
        message: msg
      });
    }
  });
}

var Program = function Program(device, options) {
  this._device = device;

  // stores gl information: { location, type }
  this._attributes = [];
  this._uniforms = [];
  this._samplers = [];
  this._errors = [];
  this._linked = false;
  this._vertSource = options.vert;
  this._fragSource = options.frag;
  this._glID = null;
  this._id = _genID++;
};

var prototypeAccessors$2 = { id: { configurable: true } };

prototypeAccessors$2.id.get = function () {
  return this._id;
};

Program.prototype.link = function link () {
    var this$1 = this;

  if (this._linked) {
    return;
  }

  var gl = this._device._gl;

  var vertShader = _createShader(gl, gl.VERTEX_SHADER, this._vertSource);
  var fragShader = _createShader(gl, gl.FRAGMENT_SHADER, this._fragSource);

  var program = gl.createProgram();
  gl.attachShader(program, vertShader);
  gl.attachShader(program, fragShader);
  gl.linkProgram(program);

  var failed = false;
  var errors = this._errors;

  if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
    _parseError(errors, 'vs', gl.getShaderInfoLog(vertShader));
    failed = true;
  }

  if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
    _parseError(errors, 'fs', gl.getShaderInfoLog(fragShader));
    failed = true;
  }

  gl.deleteShader(vertShader);
  gl.deleteShader(fragShader);

  if (failed) {
    errors.forEach(function (err) {
      console.error(("Failed to compile " + (err.type) + " " + (err.fileID) + " (ln " + (err.line) + "): " + (err.message)));
    });
    return;
  }

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(("Failed to link shader program: " + (gl.getProgramInfoLog(program))));
    failed = true;
  }

  if (failed) {
    return;
  }

  this._glID = program;

  // parse attribute
  var numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (var i = 0; i < numAttributes; ++i) {
    var info = gl.getActiveAttrib(program, i);
    var location = gl.getAttribLocation(program, info.name);

    this$1._attributes.push({
      name: info.name,
      location: location,
      type: info.type,
    });
  }

  // parse uniform
  var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (var i$1 = 0; i$1 < numUniforms; ++i$1) {
    var info$1 = gl.getActiveUniform(program, i$1);
    var name = info$1.name;
    var location$1 = gl.getUniformLocation(program, name);
    var isArray = name.substr(name.length - 3) === '[0]';
    if (isArray) {
      name = name.substr(0, name.length - 3);
    }

    this$1._uniforms.push({
      name: name,
      location: location$1,
      type: info$1.type,
      size: isArray ? info$1.size : undefined, // used when uniform is an array
    });
  }

  this._linked = true;
};

Program.prototype.destroy = function destroy () {
  var gl = this._device._gl;
  gl.deleteProgram(this._glID);

  this._linked = false;
  this._glID = null;
  this._attributes = [];
  this._uniforms = [];
  this._samplers = [];
};

Object.defineProperties( Program.prototype, prototypeAccessors$2 );

function _createShader(gl, type, src) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);

  return shader;
}

var Texture = function Texture(device) {
  this._device = device;

  this._width = 4;
  this._height = 4;
  this._hasMipmap = false;
  this._compressed = false;

  this._anisotropy = 1;
  this._minFilter = enums.FILTER_LINEAR;
  this._magFilter = enums.FILTER_LINEAR;
  this._mipFilter = enums.FILTER_LINEAR;
  this._wrapS = enums.WRAP_REPEAT;
  this._wrapT = enums.WRAP_REPEAT;
  // wrapR available in webgl2
  // this._wrapR = enums.WRAP_REPEAT;
  this._format = enums.TEXTURE_FMT_RGBA8;

  this._target = -1;
};

/**
 * @method destroy
 */
Texture.prototype.destroy = function destroy () {
  if (this._glID === -1) {
    console.error('The texture already destroyed');
    return;
  }

  var gl = this._device._gl;
  gl.deleteTexture(this._glID);

  this._device._stats.tex -= this.bytes;
  this._glID = -1;
};

function isPow2(v) {
  return !(v & (v - 1)) && (!!v);
}

var Texture2D = (function (Texture$$1) {
  function Texture2D(device, options) {
    Texture$$1.call(this, device);

    var gl = this._device._gl;
    this._target = gl.TEXTURE_2D;
    this._glID = gl.createTexture();

    // always alloc texture in GPU when we create it.
    options.images = options.images || [null];
    this.update(options);
  }

  if ( Texture$$1 ) Texture2D.__proto__ = Texture$$1;
  Texture2D.prototype = Object.create( Texture$$1 && Texture$$1.prototype );
  Texture2D.prototype.constructor = Texture2D;

  /**
   * @method update
   * @param {Object} options
   * @param {Array} options.images
   * @param {Boolean} options.mipmap
   * @param {Number} options.width
   * @param {Number} options.height
   * @param {TEXTURE_FMT_*} options.format
   * @param {Number} options.anisotropy
   * @param {FILTER_*} options.minFilter
   * @param {FILTER_*} options.magFilter
   * @param {FILTER_*} options.mipFilter
   * @param {WRAP_*} options.wrapS
   * @param {WRAP_*} options.wrapT
   * @param {Boolean} options.flipY
   * @param {Boolean} options.premultiplyAlpha
   */
  Texture2D.prototype.update = function update (options) {
    var gl = this._device._gl;
    var genMipmap = this._hasMipmap;

    if (options) {
      if (options.width !== undefined) {
        this._width = options.width;
      }
      if (options.height !== undefined) {
        this._height = options.height;
      }
      if (options.anisotropy !== undefined) {
        this._anisotropy = options.anisotropy;
      }
      if (options.minFilter !== undefined) {
        this._minFilter = options.minFilter;
      }
      if (options.magFilter !== undefined) {
        this._magFilter = options.magFilter;
      }
      if (options.mipFilter !== undefined) {
        this._mipFilter = options.mipFilter;
      }
      if (options.wrapS !== undefined) {
        this._wrapS = options.wrapS;
      }
      if (options.wrapT !== undefined) {
        this._wrapT = options.wrapT;
      }
      if (options.format !== undefined) {
        this._format = options.format;
        this._compressed = (
          this._format >= enums.TEXTURE_FMT_RGB_DXT1 &&
          this._format <= enums.TEXTURE_FMT_RGBA_PVRTC_4BPPV1
        );
      }

      // check if generate mipmap
      if (options.mipmap !== undefined) {
        this._hasMipmap = options.mipmap;
        genMipmap = options.mipmap;
      }

      if (options.images !== undefined) {
        if (options.images.length > 1) {
          genMipmap = false;
          var maxLength = options.width > options.height ? options.width : options.height;
          if (maxLength >> (options.images.length - 1) !== 1) {
            console.error('texture-2d mipmap is invalid, should have a 1x1 mipmap.');
          }
        }
      }
    }

    // NOTE: get pot after this._width, this._height has been assigned.
    var pot = isPow2(this._width) && isPow2(this._height);
    if (!pot) {
      genMipmap = false;
    }

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this._glID);
    if (options.images !== undefined && options.images.length > 0) {
      this._setMipmap(options.images, options.flipY, options.premultiplyAlpha);
      if (options.images.length > 1) { this._hasMipmap = true; }
    }
    if (genMipmap) {
      gl.hint(gl.GENERATE_MIPMAP_HINT, gl.NICEST);
      gl.generateMipmap(gl.TEXTURE_2D);
      this._hasMipmap = true;
    }

    this._setTexInfo();
    this._device._restoreTexture(0);
  };

  /**
   * @method updateSubImage
   * @param {Object} options
   * @param {Number} options.x
   * @param {Number} options.y
   * @param {Number} options.width
   * @param {Number} options.height
   * @param {Number} options.level
   * @param {HTMLCanvasElement | HTMLImageElement | HTMLVideoElement | ArrayBufferView} options.image
   * @param {Boolean} options.flipY
   * @param {Boolean} options.premultiplyAlpha
   */
  Texture2D.prototype.updateSubImage = function updateSubImage (options) {
    var gl = this._device._gl;
    var glFmt = glTextureFmt(this._format);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this._glID);
    this._setSubImage(glFmt, options);
    this._device._restoreTexture(0);
  };

  /**
   * @method updateImage
   * @param {Object} options
   * @param {Number} options.width
   * @param {Number} options.height
   * @param {Number} options.level
   * @param {HTMLCanvasElement | HTMLImageElement | HTMLVideoElement | ArrayBufferView} options.image
   * @param {Boolean} options.flipY
   * @param {Boolean} options.premultiplyAlpha
   */
  Texture2D.prototype.updateImage = function updateImage (options) {
    var gl = this._device._gl;
    var glFmt = glTextureFmt(this._format);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this._glID);
    this._setImage(glFmt, options);
    this._device._restoreTexture(0);
  };

  Texture2D.prototype._setSubImage = function _setSubImage (glFmt, options) {
    var gl = this._device._gl;
    var flipY = options.flipY;
    var premultiplyAlpha = options.premultiplyAlpha;
    var img = options.image;

    if (
      img instanceof HTMLCanvasElement ||
      img instanceof HTMLImageElement ||
      img instanceof HTMLVideoElement
    ) {
      if (flipY === undefined) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      } else {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
      }

      if (premultiplyAlpha === undefined) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      } else {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
      }

      gl.texSubImage2D(gl.TEXTURE_2D, options.level, options.x, options.y, glFmt.format, glFmt.pixelType, img);
    } else {
      if (flipY === undefined) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      } else {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
      }

      if (premultiplyAlpha === undefined) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      } else {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
      }

      if (this._compressed) {
        gl.compressedTexSubImage2D(gl.TEXTURE_2D,
          options.level,
          options.x,
          options.y,
          options.width,
          options.height,
          glFmt.format,
          img
        );
      } else {
        gl.texSubImage2D(
          gl.TEXTURE_2D,
          options.level,
          options.x,
          options.y,
          options.width,
          options.height,
          glFmt.format,
          glFmt.pixelType,
          img
        );
      }
    }
  };

  Texture2D.prototype._setImage = function _setImage (glFmt, options) {
    var gl = this._device._gl;
    var flipY = options.flipY;
    var premultiplyAlpha = options.premultiplyAlpha;
    var img = options.image;

    if (
      img instanceof HTMLCanvasElement ||
      img instanceof HTMLImageElement ||
      img instanceof HTMLVideoElement
    ) {
      if (flipY === undefined) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      } else {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
      }

      if (premultiplyAlpha === undefined) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      } else {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
      }

      gl.texImage2D(
        gl.TEXTURE_2D,
        options.level,
        glFmt.internalFormat,
        glFmt.format,
        glFmt.pixelType,
        img
      );
    } else {
      if (flipY === undefined) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      } else {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
      }

      if (premultiplyAlpha === undefined) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      } else {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
      }

      if (this._compressed) {
        gl.compressedTexImage2D(
          gl.TEXTURE_2D,
          options.level,
          glFmt.internalFormat,
          options.width,
          options.height,
          0,
          img
        );
      } else {
        gl.texImage2D(
          gl.TEXTURE_2D,
          options.level,
          glFmt.internalFormat,
          options.width,
          options.height,
          0,
          glFmt.format,
          glFmt.pixelType,
          img
        );
      }
    }
  };

  Texture2D.prototype._setMipmap = function _setMipmap (images, flipY, premultiplyAlpha) {
    var this$1 = this;

    var glFmt = glTextureFmt(this._format);
    var options = {
      width: this._width,
      height: this._height,
      flipY: flipY,
      premultiplyAlpha: premultiplyAlpha,
      level: 0,
      image: null
    };

    for (var i = 0; i < images.length; ++i) {
      options.level = i;
      options.width = this$1._width >> i;
      options.height = this$1._height >> i;
      options.image = images[i];
      this$1._setImage(glFmt, options);
    }
  };

  Texture2D.prototype._setTexInfo = function _setTexInfo () {
    var gl = this._device._gl;
    var pot = isPow2(this._width) && isPow2(this._height);

    // WebGL1 doesn't support all wrap modes with NPOT textures
    if (!pot && (this._wrapS !== enums.WRAP_CLAMP || this._wrapT !== enums.WRAP_CLAMP)) {
      console.warn('WebGL1 doesn\'t support all wrap modes with NPOT textures');
      this._wrapS = enums.WRAP_CLAMP;
      this._wrapT = enums.WRAP_CLAMP;
    }

    var mipFilter = this._hasMipmap ? this._mipFilter : -1;
    if (!pot && mipFilter !== -1) {
      console.warn('NPOT textures do not support mipmap filter');
      mipFilter = -1;
    }

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glFilter(gl, this._minFilter, mipFilter));
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glFilter(gl, this._magFilter, -1));
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT);

    var ext = this._device.ext('EXT_texture_filter_anisotropic');
    if (ext) {
      gl.texParameteri(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, this._anisotropy);
    }
  };

  return Texture2D;
}(Texture));

var TextureCube = (function (Texture$$1) {
  function TextureCube(device, options) {
    Texture$$1.call(this, device);
    var gl = this._device._gl;
    this._target = gl.TEXTURE_CUBE_MAP;
    this._glID = gl.createTexture();
    this.update(options);
  }

  if ( Texture$$1 ) TextureCube.__proto__ = Texture$$1;
  TextureCube.prototype = Object.create( Texture$$1 && Texture$$1.prototype );
  TextureCube.prototype.constructor = TextureCube;

  /**
   * @method update
   * @param {Object} options
   * @param {Array} options.images
   * @param {Boolean} options.mipmap
   * @param {Number} options.width
   * @param {Number} options.height
   * @param {TEXTURE_FMT_*} options.format
   * @param {Number} options.anisotropy
   * @param {FILTER_*} options.minFilter
   * @param {FILTER_*} options.magFilter
   * @param {FILTER_*} options.mipFilter
   * @param {WRAP_*} options.wrapS
   * @param {WRAP_*} options.wrapT
   * @param {WRAP_*} options.wrapR
   * @param {Boolean} options.flipY
   * @param {Boolean} options.premultiplyAlpha
   */
  TextureCube.prototype.update = function update (options) {
    var gl = this._device._gl;
    var genMipmap = this._hasMipmap;

    if (options) {
      if (options.width !== undefined) {
        this._width = options.width;
      }
      if (options.height !== undefined) {
        this._height = options.height;
      }
      if (options.anisotropy !== undefined) {
        this._anisotropy = options.anisotropy;
      }
      if (options.minFilter !== undefined) {
        this._minFilter = options.minFilter;
      }
      if (options.magFilter !== undefined) {
        this._magFilter = options.magFilter;
      }
      if (options.mipFilter !== undefined) {
        this._mipFilter = options.mipFilter;
      }
      if (options.wrapS !== undefined) {
        this._wrapS = options.wrapS;
      }
      if (options.wrapT !== undefined) {
        this._wrapT = options.wrapT;
      }
      // wrapR available in webgl2
      // if (options.wrapR !== undefined) {
      //   this._wrapR = options.wrapR;
      // }
      if (options.format !== undefined) {
        this._format = options.format;
        this._compressed = (
          this._format >= enums.TEXTURE_FMT_RGB_DXT1 &&
          this._format <= enums.TEXTURE_FMT_RGBA_PVRTC_4BPPV1
        );
      }

      // check if generate mipmap
      if (options.mipmap !== undefined) {
        this._hasMipmap = options.mipmap;
        genMipmap = options.mipmap;
      }

      if (options.images !== undefined) {
        if (options.images.length > 1) {
          genMipmap = false;
          if (options.width !== options.height) {
            console.warn('texture-cube width and height should be identical.');
          }
          if (options.width >> (options.images.length - 1) !== 1) {
            console.error('texture-cube mipmap is invalid. please set mipmap as 1x1, 2x2, 4x4 ... nxn');
          }
        }
      }
    }

    // NOTE: get pot after this._width, this._height has been assigned.
    var pot = isPow2(this._width) && isPow2(this._height);
    if (!pot) {
      genMipmap = false;
    }

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._glID);
    if (options.images !== undefined && options.images.length > 0) {
      this._setMipmap(options.images, options.flipY, options.premultiplyAlpha);
      if (options.images.length > 1) { this._hasMipmap = true; }
    }
    if (genMipmap) {
      gl.hint(gl.GENERATE_MIPMAP_HINT, gl.NICEST);
      gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
      this._hasMipmap = true;
    }

    this._setTexInfo();

    this._device._restoreTexture(0);
  };

  /**
   * @method updateSubImage
   * @param {Object} options
   * @param {Number} options.x
   * @param {Number} options.y
   * @param {Number} options.width
   * @param {Number} options.height
   * @param {Number} options.level
   * @param {Number} options.faceIndex
   * @param {HTMLCanvasElement | HTMLImageElement | HTMLVideoElement | ArrayBufferView} options.image
   * @param {Boolean} options.flipY
   * @param {Boolean} options.premultiplyAlpha
   */
  TextureCube.prototype.updateSubImage = function updateSubImage (options) {
    var gl = this._device._gl;
    var glFmt = glTextureFmt(this._format);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._glID);
    this._setSubImage(glFmt, options);

    this._device._restoreTexture(0);
  };

  /**
   * @method updateImage
   * @param {Object} options
   * @param {Number} options.width
   * @param {Number} options.height
   * @param {Number} options.level
   * @param {Number} options.faceIndex
   * @param {HTMLCanvasElement | HTMLImageElement | HTMLVideoElement | ArrayBufferView} options.image
   * @param {Boolean} options.flipY
   * @param {Boolean} options.premultiplyAlpha
   */
  TextureCube.prototype.updateImage = function updateImage (options) {
    var gl = this._device._gl;
    var glFmt = glTextureFmt(this._format);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._glID);
    this._setImage(glFmt, options);
    this._device._restoreTexture(0);
  };

  TextureCube.prototype._setSubImage = function _setSubImage (glFmt, options) {
    var gl = this._device._gl;
    var flipY = options.flipY;
    var premultiplyAlpha = options.premultiplyAlpha;
    var faceIndex = options.faceIndex;
    var img = options.image;

    if (flipY === undefined) {
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    } else {
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
    }

    if (premultiplyAlpha === undefined) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
    }

    if (
      img instanceof HTMLCanvasElement ||
      img instanceof HTMLImageElement ||
      img instanceof HTMLVideoElement
    ) {
      gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, options.level, options.x, options.y, glFmt.format, glFmt.pixelType, img);
    } else {
      if (this._compressed) {
        gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,
          options.level,
          options.x,
          options.y,
          options.width,
          options.height,
          glFmt.format,
          img
        );
      } else {
        gl.texSubImage2D(
          gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,
          options.level,
          options.x,
          options.y,
          options.width,
          options.height,
          glFmt.format,
          glFmt.pixelType,
          img
        );
      }
    }
  };

  TextureCube.prototype._setImage = function _setImage (glFmt, options) {
    var gl = this._device._gl;
    var flipY = options.flipY;
    var premultiplyAlpha = options.premultiplyAlpha;
    var faceIndex = options.faceIndex;
    var img = options.image;

    if (flipY === undefined) {
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    } else {
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
    }

    if (premultiplyAlpha === undefined) {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    } else {
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
    }
    if (
      img instanceof HTMLCanvasElement ||
      img instanceof HTMLImageElement ||
      img instanceof HTMLVideoElement
    ) {
      gl.texImage2D(
        gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,
        options.level,
        glFmt.internalFormat,
        glFmt.format,
        glFmt.pixelType,
        img
      );
    } else {
      if (this._compressed) {
        gl.compressedTexImage2D(
          gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,
          options.level,
          glFmt.internalFormat,
          options.width,
          options.height,
          0,
          img
        );
      } else {
        gl.texImage2D(
          gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,
          options.level,
          glFmt.internalFormat,
          options.width,
          options.height,
          0,
          glFmt.format,
          glFmt.pixelType,
          img
        );
      }
    }
  };

  // levelImages = [imagePosX, imageNegX, imagePosY, imageNegY, imagePosZ, imageNegz]
  // images = [levelImages0, levelImages1, ...]
  TextureCube.prototype._setMipmap = function _setMipmap (images, flipY, premultiplyAlpha) {
    var this$1 = this;

    var glFmt = glTextureFmt(this._format);
    var options = {
      width: this._width,
      height: this._height,
      faceIndex: 0,
      flipY: flipY,
      premultiplyAlpha: premultiplyAlpha,
      level: 0,
      image: null
    };

    for (var i = 0; i < images.length; ++i) {
      var levelImages = images[i];
      options.level = i;
      options.width = this$1._width >> i;
      options.height = this$1._height >> i;

      for (var face = 0; face < 6; ++face) {
        options.faceIndex = face;
        options.image = levelImages[face];
        this$1._setImage(glFmt, options);
      }
    }
  };

  TextureCube.prototype._setTexInfo = function _setTexInfo () {
    var gl = this._device._gl;
    var pot = isPow2(this._width) && isPow2(this._height);

    // WebGL1 doesn't support all wrap modes with NPOT textures
    if (!pot && (this._wrapS !== enums.WRAP_CLAMP || this._wrapT !== enums.WRAP_CLAMP)) {
      console.warn('WebGL1 doesn\'t support all wrap modes with NPOT textures');
      this._wrapS = enums.WRAP_CLAMP;
      this._wrapT = enums.WRAP_CLAMP;
    }

    var mipFilter = this._hasMipmap ? this._mipFilter : -1;
    if (!pot && mipFilter !== -1) {
      console.warn('NPOT textures do not support mipmap filter');
      mipFilter = -1;
    }

    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, glFilter(gl, this._minFilter, mipFilter));
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, glFilter(gl, this._magFilter, -1));
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this._wrapS);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this._wrapT);
    // wrapR available in webgl2
    // gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_R, this._wrapR);

    var ext = this._device.ext('EXT_texture_filter_anisotropic');
    if (ext) {
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, ext.TEXTURE_MAX_ANISOTROPY_EXT, this._anisotropy);
    }
  };

  return TextureCube;
}(Texture));

var RenderBuffer = function RenderBuffer(device, format, width, height) {
  this._device = device;
  this._format = format;
  this._width = width;
  this._height = height;

  var gl = device._gl;
  this._glID = gl.createRenderbuffer();

  gl.bindRenderbuffer(gl.RENDERBUFFER, this._glID);
  gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);
  gl.bindRenderbuffer(gl.RENDERBUFFER, null);
};

/**
 * @method destroy
 */
RenderBuffer.prototype.destroy = function destroy () {
  if (this._glID === null) {
    console.error('The render-buffer already destroyed');
    return;
  }

  var gl = this._device._gl;

  gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  gl.deleteRenderbuffer(this._glID);

  this._glID = null;
};

var FrameBuffer = function FrameBuffer(device, width, height, options) {
  this._device = device;
  this._width = width;
  this._height = height;

  this._colors = options.colors || [];
  this._depth = options.depth || null;
  this._stencil = options.stencil || null;
  this._depthStencil = options.depthStencil || null;

  this._glID = device._gl.createFramebuffer();
};

/**
 * @method destroy
 */
FrameBuffer.prototype.destroy = function destroy () {
  if (this._glID === null) {
    console.error('The frame-buffer already destroyed');
    return;
  }

  var gl = this._device._gl;

  gl.deleteFramebuffer(this._glID);

  this._glID = null;
};

var _default = {
  // blend
  blend: false,
  blendSep: false,
  blendColor: 0xffffffff,
  blendEq: enums.BLEND_FUNC_ADD,
  blendAlphaEq: enums.BLEND_FUNC_ADD,
  blendSrc: enums.BLEND_ONE,
  blendDst: enums.BLEND_ZERO,
  blendSrcAlpha: enums.BLEND_ONE,
  blendDstAlpha: enums.BLEND_ZERO,

  // depth
  depthTest: false,
  depthWrite: false,
  depthFunc: enums.DS_FUNC_LESS,

  // stencil
  stencilTest: false,
  stencilSep: false,
  stencilFuncFront: enums.DS_FUNC_ALWAYS,
  stencilRefFront: 0,
  stencilMaskFront: 0xff,
  stencilFailOpFront: enums.STENCIL_OP_KEEP,
  stencilZFailOpFront: enums.STENCIL_OP_KEEP,
  stencilZPassOpFront: enums.STENCIL_OP_KEEP,
  stencilWriteMaskFront: 0xff,
  stencilFuncBack: enums.DS_FUNC_ALWAYS,
  stencilRefBack: 0,
  stencilMaskBack: 0xff,
  stencilFailOpBack: enums.STENCIL_OP_KEEP,
  stencilZFailOpBack: enums.STENCIL_OP_KEEP,
  stencilZPassOpBack: enums.STENCIL_OP_KEEP,
  stencilWriteMaskBack: 0xff,

  // cull-mode
  cullMode: enums.CULL_BACK,

  // primitive-type
  primitiveType: enums.PT_TRIANGLES,

  // bindings
  maxStream: -1,
  vertexBuffers: [],
  vertexBufferOffsets: [],
  indexBuffer: null,
  maxTextureSlot: -1,
  textureUnits: [],
  program: null,
};

var State = function State(device) {
  // bindings
  this.vertexBuffers = new Array(device._caps.maxVertexStreams);
  this.vertexBufferOffsets = new Array(device._caps.maxVertexStreams);
  this.textureUnits = new Array(device._caps.maxTextureUnits);

  this.set(_default);
};

State.initDefault = function initDefault (device) {
  _default.vertexBuffers = new Array(device._caps.maxVertexStreams);
  _default.vertexBufferOffsets = new Array(device._caps.maxVertexStreams);
  _default.textureUnits = new Array(device._caps.maxTextureUnits);
};

State.prototype.reset = function reset () {
  this.set(_default);
};

State.prototype.set = function set (cpy) {
    var this$1 = this;

  // blending
  this.blend = cpy.blend;
  this.blendSep = cpy.blendSep;
  this.blendColor = cpy.blendColor;
  this.blendEq = cpy.blendEq;
  this.blendAlphaEq = cpy.blendAlphaEq;
  this.blendSrc = cpy.blendSrc;
  this.blendDst = cpy.blendDst;
  this.blendSrcAlpha = cpy.blendSrcAlpha;
  this.blendDstAlpha = cpy.blendDstAlpha;

  // depth
  this.depthTest = cpy.depthTest;
  this.depthWrite = cpy.depthWrite;
  this.depthFunc = cpy.depthFunc;

  // stencil
  this.stencilTest = cpy.stencilTest;
  this.stencilSep = cpy.stencilSep;
  this.stencilFuncFront = cpy.stencilFuncFront;
  this.stencilRefFront = cpy.stencilRefFront;
  this.stencilMaskFront = cpy.stencilMaskFront;
  this.stencilFailOpFront = cpy.stencilFailOpFront;
  this.stencilZFailOpFront = cpy.stencilZFailOpFront;
  this.stencilZPassOpFront = cpy.stencilZPassOpFront;
  this.stencilWriteMaskFront = cpy.stencilWriteMaskFront;
  this.stencilFuncBack = cpy.stencilFuncBack;
  this.stencilRefBack = cpy.stencilRefBack;
  this.stencilMaskBack = cpy.stencilMaskBack;
  this.stencilFailOpBack = cpy.stencilFailOpBack;
  this.stencilZFailOpBack = cpy.stencilZFailOpBack;
  this.stencilZPassOpBack = cpy.stencilZPassOpBack;
  this.stencilWriteMaskBack = cpy.stencilWriteMaskBack;

  // cull-mode
  this.cullMode = cpy.cullMode;

  // primitive-type
  this.primitiveType = cpy.primitiveType;

  // buffer bindings
  this.maxStream = cpy.maxStream;
  for (var i = 0; i < cpy.vertexBuffers.length; ++i) {
    this$1.vertexBuffers[i] = cpy.vertexBuffers[i];
  }
  for (var i$1 = 0; i$1 < cpy.vertexBufferOffsets.length; ++i$1) {
    this$1.vertexBufferOffsets[i$1] = cpy.vertexBufferOffsets[i$1];
  }
  this.indexBuffer = cpy.indexBuffer;

  // texture bindings
  this.maxTextureSlot = cpy.maxTextureSlot;
  for (var i$2 = 0; i$2 < cpy.textureUnits.length; ++i$2) {
    this$1.textureUnits[i$2] = cpy.textureUnits[i$2];
  }

  this.program = cpy.program;
};

var GL_INT = 5124;
var GL_FLOAT$1 = 5126;
var GL_FLOAT_VEC2 = 35664;
var GL_FLOAT_VEC3 = 35665;
var GL_FLOAT_VEC4 = 35666;
var GL_INT_VEC2 = 35667;
var GL_INT_VEC3 = 35668;
var GL_INT_VEC4 = 35669;
var GL_BOOL = 35670;
var GL_BOOL_VEC2 = 35671;
var GL_BOOL_VEC3 = 35672;
var GL_BOOL_VEC4 = 35673;
var GL_FLOAT_MAT2 = 35674;
var GL_FLOAT_MAT3 = 35675;
var GL_FLOAT_MAT4 = 35676;
var GL_SAMPLER_2D = 35678;
var GL_SAMPLER_CUBE = 35680;

/**
 * _type2uniformCommit
 */
var _type2uniformCommit = {};
_type2uniformCommit[GL_INT] = function (gl, id, value) {
    gl.uniform1i(id, value);
  };
_type2uniformCommit[GL_FLOAT$1] = function (gl, id, value) {
    gl.uniform1f(id, value);
  };
_type2uniformCommit[GL_FLOAT_VEC2] = function (gl, id, value) {
    gl.uniform2fv(id, value);
  };
_type2uniformCommit[GL_FLOAT_VEC3] = function (gl, id, value) {
    gl.uniform3fv(id, value);
  };
_type2uniformCommit[GL_FLOAT_VEC4] = function (gl, id, value) {
    gl.uniform4fv(id, value);
  };
_type2uniformCommit[GL_INT_VEC2] = function (gl, id, value) {
    gl.uniform2iv(id, value);
  };
_type2uniformCommit[GL_INT_VEC3] = function (gl, id, value) {
    gl.uniform3iv(id, value);
  };
_type2uniformCommit[GL_INT_VEC4] = function (gl, id, value) {
    gl.uniform4iv(id, value);
  };
_type2uniformCommit[GL_BOOL] = function (gl, id, value) {
    gl.uniform1i(id, value);
  };
_type2uniformCommit[GL_BOOL_VEC2] = function (gl, id, value) {
    gl.uniform2iv(id, value);
  };
_type2uniformCommit[GL_BOOL_VEC3] = function (gl, id, value) {
    gl.uniform3iv(id, value);
  };
_type2uniformCommit[GL_BOOL_VEC4] = function (gl, id, value) {
    gl.uniform4iv(id, value);
  };
_type2uniformCommit[GL_FLOAT_MAT2] = function (gl, id, value) {
    gl.uniformMatrix2fv(id, false, value);
  };
_type2uniformCommit[GL_FLOAT_MAT3] = function (gl, id, value) {
    gl.uniformMatrix3fv(id, false, value);
  };
_type2uniformCommit[GL_FLOAT_MAT4] = function (gl, id, value) {
    gl.uniformMatrix4fv(id, false, value);
  };
_type2uniformCommit[GL_SAMPLER_2D] = function (gl, id, value) {
    gl.uniform1i(id, value);
  };
_type2uniformCommit[GL_SAMPLER_CUBE] = function (gl, id, value) {
    gl.uniform1i(id, value);
  };

/**
 * _type2uniformArrayCommit
 */
var _type2uniformArrayCommit = {};
_type2uniformArrayCommit[GL_INT] = function (gl, id, value) {
    gl.uniform1iv(id, value);
  };
_type2uniformArrayCommit[GL_FLOAT$1] = function (gl, id, value) {
    gl.uniform1fv(id, value);
  };
_type2uniformArrayCommit[GL_FLOAT_VEC2] = function (gl, id, value) {
    gl.uniform2fv(id, value);
  };
_type2uniformArrayCommit[GL_FLOAT_VEC3] = function (gl, id, value) {
    gl.uniform3fv(id, value);
  };
_type2uniformArrayCommit[GL_FLOAT_VEC4] = function (gl, id, value) {
    gl.uniform4fv(id, value);
  };
_type2uniformArrayCommit[GL_INT_VEC2] = function (gl, id, value) {
    gl.uniform2iv(id, value);
  };
_type2uniformArrayCommit[GL_INT_VEC3] = function (gl, id, value) {
    gl.uniform3iv(id, value);
  };
_type2uniformArrayCommit[GL_INT_VEC4] = function (gl, id, value) {
    gl.uniform4iv(id, value);
  };
_type2uniformArrayCommit[GL_BOOL] = function (gl, id, value) {
    gl.uniform1iv(id, value);
  };
_type2uniformArrayCommit[GL_BOOL_VEC2] = function (gl, id, value) {
    gl.uniform2iv(id, value);
  };
_type2uniformArrayCommit[GL_BOOL_VEC3] = function (gl, id, value) {
    gl.uniform3iv(id, value);
  };
_type2uniformArrayCommit[GL_BOOL_VEC4] = function (gl, id, value) {
    gl.uniform4iv(id, value);
  };
_type2uniformArrayCommit[GL_FLOAT_MAT2] = function (gl, id, value) {
    gl.uniformMatrix2fv(id, false, value);
  };
_type2uniformArrayCommit[GL_FLOAT_MAT3] = function (gl, id, value) {
    gl.uniformMatrix3fv(id, false, value);
  };
_type2uniformArrayCommit[GL_FLOAT_MAT4] = function (gl, id, value) {
    gl.uniformMatrix4fv(id, false, value);
  };
_type2uniformArrayCommit[GL_SAMPLER_2D] = function (gl, id, value) {
    gl.uniform1iv(id, value);
  };
_type2uniformArrayCommit[GL_SAMPLER_CUBE] = function (gl, id, value) {
    gl.uniform1iv(id, value);
  };

/**
 * _commitBlendStates
 */
function _commitBlendStates(gl, cur, next) {
  // enable/disable blend
  if (cur.blend !== next.blend) {
    if (!next.blend) {
      gl.disable(gl.BLEND);
      return;
    }

    gl.enable(gl.BLEND);

    if (
      next.blendSrc === enums.BLEND_CONSTANT_COLOR ||
      next.blendSrc === enums.BLEND_ONE_MINUS_CONSTANT_COLOR ||
      next.blendDst === enums.BLEND_CONSTANT_COLOR ||
      next.blendDst === enums.BLEND_ONE_MINUS_CONSTANT_COLOR
    ) {
      gl.blendColor(
        (next.blendColor >> 24) / 255,
        (next.blendColor >> 16 & 0xff) / 255,
        (next.blendColor >> 8 & 0xff) / 255,
        (next.blendColor & 0xff) / 255
      );
    }

    if (next.blendSep) {
      gl.blendFuncSeparate(next.blendSrc, next.blendDst, next.blendSrcAlpha, next.blendDstAlpha);
      gl.blendEquationSeparate(next.blendEq, next.blendAlphaEq);
    } else {
      gl.blendFunc(next.blendSrc, next.blendDst);
      gl.blendEquation(next.blendEq);
    }

    return;
  }

  // nothing to update
  if (next.blend === false) {
    return;
  }

  // blend-color
  if (cur.blendColor !== next.blendColor) {
    gl.blendColor(
      (next.blendColor >> 24) / 255,
      (next.blendColor >> 16 & 0xff) / 255,
      (next.blendColor >> 8 & 0xff) / 255,
      (next.blendColor & 0xff) / 255
    );
  }

  // separate diff, reset all
  if (cur.blendSep !== next.blendSep) {
    if (next.blendSep) {
      gl.blendFuncSeparate(next.blendSrc, next.blendDst, next.blendSrcAlpha, next.blendDstAlpha);
      gl.blendEquationSeparate(next.blendEq, next.blendAlphaEq);
    } else {
      gl.blendFunc(next.blendSrc, next.blendDst);
      gl.blendEquation(next.blendEq);
    }

    return;
  }

  if (next.blendSep) {
    // blend-func-separate
    if (
      cur.blendSrc !== next.blendSrc ||
      cur.blendDst !== next.blendDst ||
      cur.blendSrcAlpha !== next.blendSrcAlpha ||
      cur.blendDstAlpha !== next.blendDstAlpha
    ) {
      gl.blendFuncSeparate(next.blendSrc, next.blendDst, next.blendSrcAlpha, next.blendDstAlpha);
    }

    // blend-equation-separate
    if (
      cur.blendEq !== next.blendEq ||
      cur.blendAlphaEq !== next.blendAlphaEq
    ) {
      gl.blendEquationSeparate(next.blendEq, next.blendAlphaEq);
    }
  } else {
    // blend-func
    if (
      cur.blendSrc !== next.blendSrc ||
      cur.blendDst !== next.blendDst
    ) {
      gl.blendFunc(next.blendSrc, next.blendDst);
    }

    // blend-equation
    if (cur.blendEq !== next.blendEq) {
      gl.blendEquation(next.blendEq);
    }
  }
}

/**
 * _commitDepthStates
 */
function _commitDepthStates(gl, cur, next) {
  // enable/disable depth-test
  if (cur.depthTest !== next.depthTest) {
    if (!next.depthTest) {
      gl.disable(gl.DEPTH_TEST);
      return;
    }

    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(next.depthFunc);
    gl.depthMask(next.depthWrite);

    return;
  }

  // commit depth-write
  if (cur.depthWrite !== next.depthWrite) {
    gl.depthMask(next.depthWrite);
  }

  // check if depth-write enabled
  if (next.depthTest === false) {
    if (next.depthWrite) {
      next.depthTest = true;
      next.depthFunc = enums.DS_FUNC_ALWAYS;

      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(next.depthFunc);
    }

    return;
  }

  // depth-func
  if (cur.depthFunc !== next.depthFunc) {
    gl.depthFunc(next.depthFunc);
  }
}

/**
 * _commitStencilStates
 */
function _commitStencilStates(gl, cur, next) {
  if (next.stencilTest !== cur.stencilTest) {
    if (!next.stencilTest) {
      gl.disable(gl.STENCIL_TEST);
      return;
    }

    gl.enable(gl.STENCIL_TEST);

    if (next.stencilSep) {
      gl.stencilFuncSeparate(gl.FRONT, next.stencilFuncFront, next.stencilRefFront, next.stencilMaskFront);
      gl.stencilMaskSeparate(gl.FRONT, next.stencilWriteMaskFront);
      gl.stencilOpSeparate(gl.FRONT, next.stencilFailOpFront, next.stencilZFailOpFront, next.stencilZPassOpFront);
      gl.stencilFuncSeparate(gl.BACK, next.stencilFuncBack, next.stencilRefBack, next.stencilMaskBack);
      gl.stencilMaskSeparate(gl.BACK, next.stencilWriteMaskBack);
      gl.stencilOpSeparate(gl.BACK, next.stencilFailOpBack, next.stencilZFailOpBack, next.stencilZPassOpBack);
    } else {
      gl.stencilFunc(next.stencilFuncFront, next.stencilRefFront, next.stencilMaskFront);
      gl.stencilMask(next.stencilWriteMaskFront);
      gl.stencilOp(next.stencilFailOpFront, next.stencilZFailOpFront, next.stencilZPassOpFront);
    }

    return;
  }

  // fast return
  if (!next.stencilTest) {
    return;
  }

  if (cur.stencilSep !== next.stencilSep) {
    if (next.stencilSep) {
      gl.stencilFuncSeparate(gl.FRONT, next.stencilFuncFront, next.stencilRefFront, next.stencilMaskFront);
      gl.stencilMaskSeparate(gl.FRONT, next.stencilWriteMaskFront);
      gl.stencilOpSeparate(gl.FRONT, next.stencilFailOpFront, next.stencilZFailOpFront, next.stencilZPassOpFront);
      gl.stencilFuncSeparate(gl.BACK, next.stencilFuncBack, next.stencilRefBack, next.stencilMaskBack);
      gl.stencilMaskSeparate(gl.BACK, next.stencilWriteMaskBack);
      gl.stencilOpSeparate(gl.BACK, next.stencilFailOpBack, next.stencilZFailOpBack, next.stencilZPassOpBack);
    } else {
      gl.stencilFunc(next.stencilFuncFront, next.stencilRefFront, next.stencilMaskFront);
      gl.stencilMask(next.stencilWriteMaskFront);
      gl.stencilOp(next.stencilFailOpFront, next.stencilZFailOpFront, next.stencilZPassOpFront);
    }
    return;
  }

  if (next.stencilSep) {
    // front
    if (
      cur.stencilFuncFront !== next.stencilFuncFront ||
      cur.stencilRefFront !== next.stencilRefFront ||
      cur.stencilMaskFront !== next.stencilMaskFront
    ) {
      gl.stencilFuncSeparate(gl.FRONT, next.stencilFuncFront, next.stencilRefFront, next.stencilMaskFront);
    }
    if (cur.stencilWriteMaskFront !== next.stencilWriteMaskFront) {
      gl.stencilMaskSeparate(gl.FRONT, next.stencilWriteMaskFront);
    }
    if (
      cur.stencilFailOpFront !== next.stencilFailOpFront ||
      cur.stencilZFailOpFront !== next.stencilZFailOpFront ||
      cur.stencilZPassOpFront !== next.stencilZPassOpFront
    ) {
      gl.stencilOpSeparate(gl.FRONT, next.stencilFailOpFront, next.stencilZFailOpFront, next.stencilZPassOpFront);
    }

    // back
    if (
      cur.stencilFuncBack !== next.stencilFuncBack ||
      cur.stencilRefBack !== next.stencilRefBack ||
      cur.stencilMaskBack !== next.stencilMaskBack
    ) {
      gl.stencilFuncSeparate(gl.BACK, next.stencilFuncBack, next.stencilRefBack, next.stencilMaskBack);
    }
    if (cur.stencilWriteMaskBack !== next.stencilWriteMaskBack) {
      gl.stencilMaskSeparate(gl.BACK, next.stencilWriteMaskBack);
    }
    if (
      cur.stencilFailOpBack !== next.stencilFailOpBack ||
      cur.stencilZFailOpBack !== next.stencilZFailOpBack ||
      cur.stencilZPassOpBack !== next.stencilZPassOpBack
    ) {
      gl.stencilOpSeparate(gl.BACK, next.stencilFailOpBack, next.stencilZFailOpBack, next.stencilZPassOpBack);
    }
  } else {
    if (
      cur.stencilFuncFront !== next.stencilFuncFront ||
      cur.stencilRefFront !== next.stencilRefFront ||
      cur.stencilMaskFront !== next.stencilMaskFront
    ) {
      gl.stencilFunc(next.stencilFuncFront, next.stencilRefFront, next.stencilMaskFront);
    }
    if (cur.stencilWriteMaskFront !== next.stencilWriteMaskFront) {
      gl.stencilMask(next.stencilWriteMaskFront);
    }
    if (
      cur.stencilFailOpFront !== next.stencilFailOpFront ||
      cur.stencilZFailOpFront !== next.stencilZFailOpFront ||
      cur.stencilZPassOpFront !== next.stencilZPassOpFront
    ) {
      gl.stencilOp(next.stencilFailOpFront, next.stencilZFailOpFront, next.stencilZPassOpFront);
    }
  }

}

/**
 * _commitCullMode
 */
function _commitCullMode(gl, cur, next) {
  if (cur.cullMode === next.cullMode) {
    return;
  }

  if (next.cullMode === enums.CULL_NONE) {
    gl.disable(gl.CULL_FACE);
    return;
  }

  gl.enable(gl.CULL_FACE);
  gl.cullFace(next.cullMode);
}

/**
 * _commitVertexBuffers
 */
function _commitVertexBuffers(device, gl, cur, next) {
  var attrsDirty = false;

  // nothing changed for vertex buffer
  if (next.maxStream === -1) {
    console.warn('VertexBuffer not assigned, please call setVertexBuffer before every draw.');
    return;
  }

  if (cur.maxStream !== next.maxStream) {
    attrsDirty = true;
  } else if (cur.program !== next.program) {
    attrsDirty = true;
  } else {
    for (var i = 0; i < next.maxStream + 1; ++i) {
      if (
        cur.vertexBuffers[i] !== next.vertexBuffers[i] ||
        cur.vertexBufferOffsets[i] !== next.vertexBufferOffsets[i]
      ) {
        attrsDirty = true;
        break;
      }
    }
  }

  if (attrsDirty) {
    for (var i$1 = 0; i$1 < device._caps.maxVertexAttribs; ++i$1) {
      device._newAttributes[i$1] = 0;
    }

    for (var i$2 = 0; i$2 < next.maxStream + 1; ++i$2) {
      var vb = next.vertexBuffers[i$2];
      var vbOffset = next.vertexBufferOffsets[i$2];
      if (!vb) {
        continue;
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, vb._glID);

      for (var j = 0; j < next.program._attributes.length; ++j) {
        var attr = next.program._attributes[j];

        var el = vb._format.element(attr.name);
        if (!el) {
          console.warn(("Can not find vertex attribute: " + (attr.name)));
          continue;
        }

        if (device._enabledAttributes[attr.location] === 0) {
          gl.enableVertexAttribArray(attr.location);
          device._enabledAttributes[attr.location] = 1;
        }
        device._newAttributes[attr.location] = 1;

        gl.vertexAttribPointer(
          attr.location,
          el.num,
          el.type,
          el.normalize,
          el.stride,
          el.offset + vbOffset * el.stride
        );
      }
    }

    // disable unused attributes
    for (var i$3 = 0; i$3 < device._caps.maxVertexAttribs; ++i$3) {
      if (device._enabledAttributes[i$3] !== device._newAttributes[i$3]) {
        gl.disableVertexAttribArray(i$3);
        device._enabledAttributes[i$3] = 0;
      }
    }
  }
}

/**
 * _commitTextures
 */
function _commitTextures(gl, cur, next) {
  for (var i = 0; i < next.maxTextureSlot + 1; ++i) {
    if (cur.textureUnits[i] !== next.textureUnits[i]) {
      var texture = next.textureUnits[i];
      if (texture !== undefined && texture._glID !== -1) {
        gl.activeTexture(gl.TEXTURE0 + i);
        gl.bindTexture(texture._target, texture._glID);
      }
    }
  }
}

/**
 * _attach
 */
function _attach(gl, location, attachment, face) {
  if ( face === void 0 ) face = 0;

  if (attachment instanceof Texture2D) {
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      location,
      gl.TEXTURE_2D,
      attachment._glID,
      0
    );
  } else if (attachment instanceof TextureCube) {
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      location,
      gl.TEXTURE_CUBE_MAP_POSITIVE_X + face,
      attachment._glID,
      0
    );
  } else {
    gl.framebufferRenderbuffer(
      gl.FRAMEBUFFER,
      location,
      gl.RENDERBUFFER,
      attachment._glID
    );
  }
}

var Device = function Device(canvasEL, opts) {
  var this$1 = this;

  var gl;

  // default options
  opts = opts || {};
  if (opts.alpha === undefined) {
    opts.alpha = false;
  }
  if (opts.stencil === undefined) {
    opts.stencil = true;
  }
  if (opts.depth === undefined) {
    opts.depth = true;
  }
  if (opts.antialias === undefined) {
    opts.antialias = false;
  }
  // NOTE: it is said the performance improved in mobile device with this flag off.
  if (opts.preserveDrawingBuffer === undefined) {
    opts.preserveDrawingBuffer = false;
  }

  try {
    gl = canvasEL.getContext('webgl', opts);
  } catch (err) {
    console.error(err);
    return;
  }

  // statics
  this._gl = gl;
  this._extensions = {};
  this._caps = {}; // capability
  this._stats = {
    texture: 0,
    vb: 0,
    ib: 0,
    drawcalls: 0,
  };

  this._initExtensions([
    'EXT_texture_filter_anisotropic',
    'EXT_shader_texture_lod',
    'OES_standard_derivatives',
    'OES_texture_float',
    'OES_texture_float_linear',
    'OES_texture_half_float',
    'OES_texture_half_float_linear',
    'OES_vertex_array_object',
    'WEBGL_compressed_texture_atc',
    'WEBGL_compressed_texture_etc1',
    'WEBGL_compressed_texture_pvrtc',
    'WEBGL_compressed_texture_s3tc',
    'WEBGL_depth_texture',
    'WEBGL_draw_buffers' ]);
  this._initCaps();
  this._initStates();

  // runtime
  State.initDefault(this);
  this._current = new State(this);
  this._next = new State(this);
  this._uniforms = {}; // name: { value, num, dirty }
  this._vx = this._vy = this._vw = this._vh = 0;
  this._sx = this._sy = this._sw = this._sh = 0;
  this._framebuffer = null;

  //
  this._enabledAttributes = new Array(this._caps.maxVertexAttribs);
  this._newAttributes = new Array(this._caps.maxVertexAttribs);

  for (var i = 0; i < this._caps.maxVertexAttribs; ++i) {
    this$1._enabledAttributes[i] = 0;
    this$1._newAttributes[i] = 0;
  }
};

Device.prototype._initExtensions = function _initExtensions (extensions) {
    var this$1 = this;

  var gl = this._gl;

  for (var i = 0; i < extensions.length; ++i) {
    var name = extensions[i];

    try {
      var ext = gl.getExtension(name);
      if (ext) {
        this$1._extensions[name] = ext;
      }
    } catch (e) {
      console.error(e);
    }
  }
};

Device.prototype._initCaps = function _initCaps () {
  var gl = this._gl;
  var extDrawBuffers = this.ext('WEBGL_draw_buffers');

  this._caps.maxVertexStreams = 4;
  this._caps.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  this._caps.maxFragUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
  this._caps.maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  this._caps.maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

  this._caps.maxDrawBuffers = extDrawBuffers ? gl.getParameter(extDrawBuffers.MAX_DRAW_BUFFERS_WEBGL) : 1;
  this._caps.maxColorAttachments = extDrawBuffers ? gl.getParameter(extDrawBuffers.MAX_COLOR_ATTACHMENTS_WEBGL) : 1;
};

Device.prototype._initStates = function _initStates () {
  var gl = this._gl;

  // gl.frontFace(gl.CCW);
  gl.disable(gl.BLEND);
  gl.blendFunc(gl.ONE, gl.ZERO);
  gl.blendEquation(gl.FUNC_ADD);
  gl.blendColor(1,1,1,1);

  gl.colorMask(true, true, true, true);

  gl.enable(gl.CULL_FACE);
  gl.cullFace(gl.BACK);

  gl.disable(gl.DEPTH_TEST);
  gl.depthFunc(gl.LESS);
  gl.depthMask(false);
  gl.disable(gl.POLYGON_OFFSET_FILL);
  gl.depthRange(0,1);

  gl.disable(gl.STENCIL_TEST);
  gl.stencilFunc(gl.ALWAYS, 0, 0xFF);
  gl.stencilMask(0xFF);
  gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);

  // TODO:
  // this.setAlphaToCoverage(false);
  // this.setTransformFeedbackBuffer(null);
  // this.setRaster(true);
  // this.setDepthBias(false);

  gl.clearDepth(1);
  gl.clearColor(0, 0, 0, 0);
  gl.clearStencil(0);

  gl.disable(gl.SCISSOR_TEST);
};

Device.prototype._restoreTexture = function _restoreTexture (unit) {
  var gl = this._gl;

  var texture = this._current.textureUnits[unit];
  if (texture && texture._glID !== -1) {
    gl.bindTexture(texture._target, texture._glID);
  } else {
    gl.bindTexture(gl.TEXTURE_2D, null);
  }
};

Device.prototype._restoreIndexBuffer = function _restoreIndexBuffer () {
  var gl = this._gl;

  var ib = this._current.indexBuffer;
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib ? ib._glID : null);
};

/**
 * @method ext
 * @param {string} name
 */
Device.prototype.ext = function ext (name) {
  return this._extensions[name];
};

// ===============================
// Immediate Settings
// ===============================

/**
 * @method setFrameBuffer
 * @param {FrameBuffer} fb - null means use the backbuffer
 */
Device.prototype.setFrameBuffer = function setFrameBuffer (fb) {
    var this$1 = this;

  if (this._framebuffer === fb) {
    return;
  }

  this._framebuffer = fb;
  var gl = this._gl;

  if (fb === null) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return;
  }

  gl.bindFramebuffer(gl.FRAMEBUFFER, fb._glID);

  var numColors = this._framebuffer._colors.length;
  for (var i = 0; i < numColors; ++i) {
    var colorBuffer = this$1._framebuffer._colors[i];
    _attach(gl, gl.COLOR_ATTACHMENT0 + i, colorBuffer);

    // TODO: what about cubemap face??? should be the target parameter for colorBuffer
  }
  for (var i$1 = numColors; i$1 < this._caps.maxColorAttachments; ++i$1) {
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0 + i$1,
      gl.TEXTURE_2D,
      null,
      0
    );
  }

  if (this._framebuffer._depth) {
    _attach(gl, gl.DEPTH_ATTACHMENT, this._framebuffer._depth);
  }

  if (this._framebuffer._stencil) {
    _attach(gl, gl.STENCIL_ATTACHMENT, fb._stencil);
  }

  if (this._framebuffer._depthStencil) {
    _attach(gl, gl.DEPTH_STENCIL_ATTACHMENT, fb._depthStencil);
  }
};

/**
 * @method setViewport
 * @param {Number} x
 * @param {Number} y
 * @param {Number} w
 * @param {Number} h
 */
Device.prototype.setViewport = function setViewport (x, y, w, h) {
  if (
    this._vx !== x ||
    this._vy !== y ||
    this._vw !== w ||
    this._vh !== h
  ) {
    this._gl.viewport(x, y, w, h);
    this._vx = x;
    this._vy = y;
    this._vw = w;
    this._vh = h;
  }
};

/**
 * @method setScissor
 * @param {Number} x
 * @param {Number} y
 * @param {Number} w
 * @param {Number} h
 */
Device.prototype.setScissor = function setScissor (x, y, w, h) {
  if (
    this._sx !== x ||
    this._sy !== y ||
    this._sw !== w ||
    this._sh !== h
  ) {
    this._gl.scissor(x, y, w, h);
    this._sx = x;
    this._sy = y;
    this._sw = w;
    this._sh = h;
  }
};

/**
 * @method clear
 * @param {Object} opts
 * @param {Array} opts.color
 * @param {Number} opts.depth
 * @param {Number} opts.stencil
 */
Device.prototype.clear = function clear (opts) {
  var gl = this._gl;
  var flags = 0;

  if (opts.color !== undefined) {
    flags |= gl.COLOR_BUFFER_BIT;
    gl.clearColor(opts.color[0], opts.color[1], opts.color[2], opts.color[3]);
  }

  if (opts.depth !== undefined) {
    flags |= gl.DEPTH_BUFFER_BIT;
    gl.clearDepth(opts.depth);

    gl.enable(gl.DEPTH_TEST);
    gl.depthMask(true);
    gl.depthFunc(gl.ALWAYS);
  }

  if (opts.stencil !== undefined) {
    flags |= gl.STENCIL_BUFFER_BIT;
    gl.clearStencil(opts.stencil);
  }

  gl.clear(flags);

  // restore depth-write
  if (opts.depth !== undefined) {
    if (this._current.depthTest === false) {
      gl.disable(gl.DEPTH_TEST);
    } else {
      if (this._current.depthWrite === false) {
        gl.depthMask(false);
      }
      if (this._current.depthFunc !== enums.DS_FUNC_ALWAYS) {
        gl.depthFunc(this._current.depthFunc);
      }
    }
  }
};

// ===============================
// Deferred States
// ===============================

/**
 * @method enableBlend
 */
Device.prototype.enableBlend = function enableBlend () {
  this._next.blend = true;
};

/**
 * @method enableDepthTest
 */
Device.prototype.enableDepthTest = function enableDepthTest () {
  this._next.depthTest = true;
};

/**
 * @method enableDepthWrite
 */
Device.prototype.enableDepthWrite = function enableDepthWrite () {
  this._next.depthWrite = true;
};

/**
 * @method enableStencilTest
 */
Device.prototype.enableStencilTest = function enableStencilTest () {
  this._next.stencilTest = true;
};

/**
 * @method setStencilFunc
 * @param {DS_FUNC_*} func
 * @param {Number} ref
 * @param {Number} mask
 */
Device.prototype.setStencilFunc = function setStencilFunc (func, ref, mask) {
  this._next.stencilSep = false;
  this._next.stencilFuncFront = this._next.stencilFuncBack = func;
  this._next.stencilRefFront = this._next.stencilRefBack = ref;
  this._next.stencilMaskFront = this._next.stencilMaskBack = mask;
};

/**
 * @method setStencilFuncFront
 * @param {DS_FUNC_*} func
 * @param {Number} ref
 * @param {Number} mask
 */
Device.prototype.setStencilFuncFront = function setStencilFuncFront (func, ref, mask) {
  this._next.stencilSep = true;
  this._next.stencilFuncFront = func;
  this._next.stencilRefFront = ref;
  this._next.stencilMaskFront = mask;
};

/**
 * @method setStencilFuncBack
 * @param {DS_FUNC_*} func
 * @param {Number} ref
 * @param {Number} mask
 */
Device.prototype.setStencilFuncBack = function setStencilFuncBack (func, ref, mask) {
  this._next.stencilSep = true;
  this._next.stencilFuncBack = func;
  this._next.stencilRefBack = ref;
  this._next.stencilMaskBack = mask;
};

/**
 * @method setStencilOp
 * @param {STENCIL_OP_*} failOp
 * @param {STENCIL_OP_*} zFailOp
 * @param {STENCIL_OP_*} zPassOp
 * @param {Number} writeMask
 */
Device.prototype.setStencilOp = function setStencilOp (failOp, zFailOp, zPassOp, writeMask) {
  this._next.stencilFailOpFront = this._next.stencilFailOpBack = failOp;
  this._next.stencilZFailOpFront = this._next.stencilZFailOpBack = zFailOp;
  this._next.stencilZPassOpFront = this._next.stencilZPassOpBack = zPassOp;
  this._next.stencilWriteMaskFront = this._next.stencilWriteMaskBack = writeMask;
};

/**
 * @method setStencilOpFront
 * @param {STENCIL_OP_*} failOp
 * @param {STENCIL_OP_*} zFailOp
 * @param {STENCIL_OP_*} zPassOp
 * @param {Number} writeMask
 */
Device.prototype.setStencilOpFront = function setStencilOpFront (failOp, zFailOp, zPassOp, writeMask) {
  this._next.stencilSep = true;
  this._next.stencilFailOpFront = failOp;
  this._next.stencilZFailOpFront = zFailOp;
  this._next.stencilZPassOpFront = zPassOp;
  this._next.stencilWriteMaskFront = writeMask;
};

/**
 * @method setStencilOpBack
 * @param {STENCIL_OP_*} failOp
 * @param {STENCIL_OP_*} zFailOp
 * @param {STENCIL_OP_*} zPassOp
 * @param {Number} writeMask
 */
Device.prototype.setStencilOpBack = function setStencilOpBack (failOp, zFailOp, zPassOp, writeMask) {
  this._next.stencilSep = true;
  this._next.stencilFailOpBack = failOp;
  this._next.stencilZFailOpBack = zFailOp;
  this._next.stencilZPassOpBack = zPassOp;
  this._next.stencilWriteMaskBack = writeMask;
};

/**
 * @method setDepthFunc
 * @param {DS_FUNC_*} depthFunc
 */
Device.prototype.setDepthFunc = function setDepthFunc (depthFunc) {
  this._next.depthFunc = depthFunc;
};

/**
 * @method setBlendColor32
 * @param {Number} rgba
 */
Device.prototype.setBlendColor32 = function setBlendColor32 (rgba) {
  this._next.blendColor = rgba;
};

/**
 * @method setBlendColor
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b
 * @param {Number} a
 */
Device.prototype.setBlendColor = function setBlendColor (r, g, b, a) {
  this._next.blendColor = ((r * 255) << 24 | (g * 255) << 16 | (b * 255) << 8 | a * 255) >>> 0;
};

/**
 * @method setBlendFunc
 * @param {BELND_*} src
 * @param {BELND_*} dst
 */
Device.prototype.setBlendFunc = function setBlendFunc (src, dst) {
  this._next.blendSep = false;
  this._next.blendSrc = src;
  this._next.blendDst = dst;
};

/**
 * @method setBlendFuncSep
 * @param {BELND_*} src
 * @param {BELND_*} dst
 * @param {BELND_*} srcAlpha
 * @param {BELND_*} dstAlpha
 */
Device.prototype.setBlendFuncSep = function setBlendFuncSep (src, dst, srcAlpha, dstAlpha) {
  this._next.blendSep = true;
  this._next.blendSrc = src;
  this._next.blendDst = dst;
  this._next.blendSrcAlpha = srcAlpha;
  this._next.blendDstAlpha = dstAlpha;
};

/**
 * @method setBlendEq
 * @param {BELND_FUNC_*} eq
 */
Device.prototype.setBlendEq = function setBlendEq (eq) {
  this._next.blendSep = false;
  this._next.blendEq = eq;
};

/**
 * @method setBlendEqSep
 * @param {BELND_FUNC_*} eq
 * @param {BELND_FUNC_*} alphaEq
 */
Device.prototype.setBlendEqSep = function setBlendEqSep (eq, alphaEq) {
  this._next.blendSep = true;
  this._next.blendEq = eq;
  this._next.blendAlphaEq = alphaEq;
};

/**
 * @method setCullMode
 * @param {CULL_*} mode
 */
Device.prototype.setCullMode = function setCullMode (mode) {
  this._next.cullMode = mode;
};

/**
 * @method setVertexBuffer
 * @param {Number} stream
 * @param {VertexBuffer} buffer
 * @param {Number} start - start vertex
 */
Device.prototype.setVertexBuffer = function setVertexBuffer (stream, buffer, start) {
    if ( start === void 0 ) start = 0;

  this._next.vertexBuffers[stream] = buffer;
  this._next.vertexBufferOffsets[stream] = start;
  if (this._next.maxStream < stream) {
    this._next.maxStream = stream;
  }
};

/**
 * @method setIndexBuffer
 * @param {IndexBuffer} buffer
 */
Device.prototype.setIndexBuffer = function setIndexBuffer (buffer) {
  this._next.indexBuffer = buffer;
};

/**
 * @method setProgram
 * @param {Program} program
 */
Device.prototype.setProgram = function setProgram (program) {
  this._next.program = program;
};

/**
 * @method setTexture
 * @param {String} name
 * @param {Texture} texture
 * @param {Number} slot
 */
Device.prototype.setTexture = function setTexture (name, texture, slot) {
  if (slot >= this._caps.maxTextureUnits) {
    console.warn(("Can not set texture " + name + " at stage " + slot + ", max texture exceed: " + (this._caps.maxTextureUnits)));
    return;
  }

  this._next.textureUnits[slot] = texture;
  this.setUniform(name, slot);

  if (this._next.maxTextureSlot < slot) {
    this._next.maxTextureSlot = slot;
  }
};

/**
 * @method setTextureArray
 * @param {String} name
 * @param {Array} textures
 * @param {Int32Array} slots
 */
Device.prototype.setTextureArray = function setTextureArray (name, textures, slots) {
    var this$1 = this;

  var len = textures.length;
  if (len >= this._caps.maxTextureUnits) {
    console.warn(("Can not set " + len + " textures for " + name + ", max texture exceed: " + (this._caps.maxTextureUnits)));
    return;
  }
  for (var i = 0; i < len; ++i) {
    var slot = slots[i];
    this$1._next.textureUnits[slot] = textures[i];
  }
  this.setUniform(name, slots);
};

/**
 * @method setUniform
 * @param {String} name
 * @param {*} value
 */
Device.prototype.setUniform = function setUniform (name, value) {
  var uniform = this._uniforms[name];
  if (!uniform) {
    uniform = {
      dirty: true,
      value: value,
    };
  } else {
    uniform.dirty = true;
    uniform.value = value;
  }
  this._uniforms[name] = uniform;
};

/**
 * @method setPrimitiveType
 * @param {PT_*} type
 */
Device.prototype.setPrimitiveType = function setPrimitiveType (type) {
  this._next.primitiveType = type;
};

/**
 * @method draw
 * @param {Number} base
 * @param {Number} count
 */
Device.prototype.draw = function draw (base, count) {
    var this$1 = this;

  var gl = this._gl;
  var cur = this._current;
  var next = this._next;

  // commit blend
  _commitBlendStates(gl, cur, next);

  // commit depth
  _commitDepthStates(gl, cur, next);

  // commit stencil
  _commitStencilStates(gl, cur, next);

  // commit cull
  _commitCullMode(gl, cur, next);

  // commit vertex-buffer
  _commitVertexBuffers(this, gl, cur, next);

  // commit index-buffer
  if (cur.indexBuffer !== next.indexBuffer) {
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, next.indexBuffer ? next.indexBuffer._glID : null);
  }

  // commit program
  var programDirty = false;
  if (cur.program !== next.program) {
    if (next.program._linked) {
      gl.useProgram(next.program._glID);
    } else {
      console.warn('Failed to use program: has not linked yet.');
    }
    programDirty = true;
  }

  // commit texture/sampler
  _commitTextures(gl, cur, next);

  // commit uniforms
  for (var i = 0; i < next.program._uniforms.length; ++i) {
    var uniformInfo = next.program._uniforms[i];
    var uniform = this$1._uniforms[uniformInfo.name];
    if (!uniform) {
      // console.warn(`Can not find uniform ${uniformInfo.name}`);
      continue;
    }

    if (!programDirty && !uniform.dirty) {
      continue;
    }

    uniform.dirty = false;

    // TODO: please consider array uniform: uniformInfo.size > 0

    var commitFunc = (uniformInfo.size === undefined) ? _type2uniformCommit[uniformInfo.type] : _type2uniformArrayCommit[uniformInfo.type];
    if (!commitFunc) {
      console.warn(("Can not find commit function for uniform " + (uniformInfo.name)));
      continue;
    }

    commitFunc(gl, uniformInfo.location, uniform.value);
  }

  // drawPrimitives
  if (next.indexBuffer) {
    gl.drawElements(
      this._next.primitiveType,
      count,
      next.indexBuffer._format,
      base * next.indexBuffer._bytesPerIndex
    );
  } else {
    gl.drawArrays(
      this._next.primitiveType,
      base,
      count
    );
  }

  // TODO: autogen mipmap for color buffer
  // if (this._framebuffer && this._framebuffer.colors[0].mipmap) {
  // gl.bindTexture(this._framebuffer.colors[i]._target, colors[i]._glID);
  // gl.generateMipmap(this._framebuffer.colors[i]._target);
  // }

  // update stats
  this._stats.drawcalls += 1;

  // reset states
  cur.set(next);
  next.reset();
};

var gfx = {
  // classes
  VertexFormat: VertexFormat,
  IndexBuffer: IndexBuffer,
  VertexBuffer: VertexBuffer,
  Program: Program,
  Texture: Texture,
  Texture2D: Texture2D,
  TextureCube: TextureCube,
  RenderBuffer: RenderBuffer,
  FrameBuffer: FrameBuffer,
  Device: Device,

  // functions
  attrTypeBytes: attrTypeBytes,
  glFilter: glFilter,
  glTextureFmt: glTextureFmt,
};
Object.assign(gfx, enums);

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

var enums$1 = {
  // projection
  PROJ_PERSPECTIVE: 0,
  PROJ_ORTHO: 1,

  // lights
  LIGHT_DIRECTIONAL: 0,
  LIGHT_POINT: 1,
  LIGHT_SPOT: 2,

  // shadows
  SHADOW_NONE: 0,
  SHADOW_HARD: 1,
  SHADOW_SOFT: 2,

  // parameter type
  PARAM_INT:             0,
  PARAM_INT2:            1,
  PARAM_INT3:            2,
  PARAM_INT4:            3,
  PARAM_FLOAT:           4,
  PARAM_FLOAT2:          5,
  PARAM_FLOAT3:          6,
  PARAM_FLOAT4:          7,
  PARAM_COLOR3:          8,
  PARAM_COLOR4:          9,
  PARAM_MAT2:           10,
  PARAM_MAT3:           11,
  PARAM_MAT4:           12,
  PARAM_TEXTURE_2D:     13,
  PARAM_TEXTURE_CUBE:   14,

  // clear flags
  CLEAR_COLOR: 1,
  CLEAR_DEPTH: 2,
  CLEAR_STENCIL: 4,
  CLEAR_SKYBOX: 8,

  //
  BUFFER_VIEW_INT8: 0,
  BUFFER_VIEW_UINT8: 1,
  BUFFER_VIEW_INT16: 2,
  BUFFER_VIEW_UINT16: 3,
  BUFFER_VIEW_INT32: 4,
  BUFFER_VIEW_UINT32: 5,
  BUFFER_VIEW_FLOAT32: 6,
};

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

var InputAssembler = function InputAssembler(vb, ib, pt) {
  if ( pt === void 0 ) pt = gfx.PT_TRIANGLES;

  this._vertexBuffer = vb;
  this._indexBuffer = ib;
  this._primitiveType = pt;
  this._start = 0;
  this._count = -1;

  // TODO: instancing data
  // this._stream = 0;
};

var prototypeAccessors$3 = { count: { configurable: true } };

/**
 * @property {Number} count The number of indices or vertices to dispatch in the draw call.
 */
prototypeAccessors$3.count.get = function () {
  if (this._count !== -1) {
    return this._count;
  }

  if (this._indexBuffer) {
    return this._indexBuffer.count;
  }

  return this._vertexBuffer.count;
};

Object.defineProperties( InputAssembler.prototype, prototypeAccessors$3 );

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

var Pass = function Pass(name) {
  this._programName = name;

  // cullmode
  this._cullMode = gfx.CULL_BACK;

  // blending
  this._blend = false;
  this._blendEq = gfx.BLEND_FUNC_ADD;
  this._blendAlphaEq = gfx.BLEND_FUNC_ADD;
  this._blendSrc = gfx.BLEND_ONE;
  this._blendDst = gfx.BLEND_ZERO;
  this._blendSrcAlpha = gfx.BLEND_ONE;
  this._blendDstAlpha = gfx.BLEND_ZERO;
  this._blendColor = 0xffffffff;

  // depth
  this._depthTest = false;
  this._depthWrite = false;
  this._depthFunc = gfx.DS_FUNC_LESS, this._stencilTest = false;
  // front
  this._stencilFuncFront = gfx.DS_FUNC_ALWAYS;
  this._stencilRefFront = 0;
  this._stencilMaskFront = 0xff;
  this._stencilFailOpFront = gfx.STENCIL_OP_KEEP;
  this._stencilZFailOpFront = gfx.STENCIL_OP_KEEP;
  this._stencilZPassOpFront = gfx.STENCIL_OP_KEEP;
  this._stencilWriteMaskFront = 0xff;
  // back
  this._stencilFuncBack = gfx.DS_FUNC_ALWAYS;
  this._stencilRefBack = 0;
  this._stencilMaskBack = 0xff;
  this._stencilFailOpBack = gfx.STENCIL_OP_KEEP;
  this._stencilZFailOpBack = gfx.STENCIL_OP_KEEP;
  this._stencilZPassOpBack = gfx.STENCIL_OP_KEEP;
  this._stencilWriteMaskBack = 0xff;
};

Pass.prototype.setCullMode = function setCullMode (cullMode) {
  this._cullMode = cullMode;
};

Pass.prototype.setBlend = function setBlend (
  blendEq,
  blendSrc,
  blendDst,
  blendAlphaEq,
  blendSrcAlpha,
  blendDstAlpha,
  blendColor
) {
    if ( blendEq === void 0 ) blendEq = gfx.BLEND_FUNC_ADD;
    if ( blendSrc === void 0 ) blendSrc = gfx.BLEND_ONE;
    if ( blendDst === void 0 ) blendDst = gfx.BLEND_ZERO;
    if ( blendAlphaEq === void 0 ) blendAlphaEq = gfx.BLEND_FUNC_ADD;
    if ( blendSrcAlpha === void 0 ) blendSrcAlpha = gfx.BLEND_ONE;
    if ( blendDstAlpha === void 0 ) blendDstAlpha = gfx.BLEND_ZERO;
    if ( blendColor === void 0 ) blendColor = 0xffffffff;

  this._blend = true;
  this._blendEq = blendEq;
  this._blendSrc = blendSrc;
  this._blendDst = blendDst;
  this._blendAlphaEq = blendAlphaEq;
  this._blendSrcAlpha = blendSrcAlpha;
  this._blendDstAlpha = blendDstAlpha;
  this._blendColor = blendColor;
};

Pass.prototype.setDepth = function setDepth (
  depthTest,
  depthWrite,
  depthFunc
) {
    if ( depthTest === void 0 ) depthTest = false;
    if ( depthWrite === void 0 ) depthWrite = false;
    if ( depthFunc === void 0 ) depthFunc = gfx.DS_FUNC_LESS;

  this._depthTest = depthTest;
  this._depthWrite = depthWrite;
  this._depthFunc = depthFunc;
};

Pass.prototype.setStencilFront = function setStencilFront (
  enabled,
  stencilFunc,
  stencilRef,
  stencilMask,
  stencilFailOp,
  stencilZFailOp,
  stencilZPassOp,
  stencilWriteMask
) {
    if ( enabled === void 0 ) enabled = false;
    if ( stencilFunc === void 0 ) stencilFunc = gfx.DS_FUNC_ALWAYS;
    if ( stencilRef === void 0 ) stencilRef = 0;
    if ( stencilMask === void 0 ) stencilMask = 0xff;
    if ( stencilFailOp === void 0 ) stencilFailOp = gfx.STENCIL_OP_KEEP;
    if ( stencilZFailOp === void 0 ) stencilZFailOp = gfx.STENCIL_OP_KEEP;
    if ( stencilZPassOp === void 0 ) stencilZPassOp = gfx.STENCIL_OP_KEEP;
    if ( stencilWriteMask === void 0 ) stencilWriteMask = 0xff;

  this._stencilTest = enabled;
  this._stencilFuncFront = stencilFunc;
  this._stencilRefFront = stencilRef;
  this._stencilMaskFront = stencilMask;
  this._stencilFailOpFront = stencilFailOp;
  this._stencilZFailOpFront = stencilZFailOp;
  this._stencilZPassOpFront = stencilZPassOp;
  this._stencilWriteMaskFront = stencilWriteMask;
};

Pass.prototype.setStencilBack = function setStencilBack (
  enabled,
  stencilFunc,
  stencilRef,
  stencilMask,
  stencilFailOp,
  stencilZFailOp,
  stencilZPassOp,
  stencilWriteMask
) {
    if ( enabled === void 0 ) enabled = false;
    if ( stencilFunc === void 0 ) stencilFunc = gfx.DS_FUNC_ALWAYS;
    if ( stencilRef === void 0 ) stencilRef = 0;
    if ( stencilMask === void 0 ) stencilMask = 0xff;
    if ( stencilFailOp === void 0 ) stencilFailOp = gfx.STENCIL_OP_KEEP;
    if ( stencilZFailOp === void 0 ) stencilZFailOp = gfx.STENCIL_OP_KEEP;
    if ( stencilZPassOp === void 0 ) stencilZPassOp = gfx.STENCIL_OP_KEEP;
    if ( stencilWriteMask === void 0 ) stencilWriteMask = 0xff;

  this._stencilTest = enabled;
  this._stencilFuncBack = stencilFunc;
  this._stencilRefBack = stencilRef;
  this._stencilMaskBack = stencilMask;
  this._stencilFailOpBack = stencilFailOp;
  this._stencilZFailOpBack = stencilZFailOp;
  this._stencilZPassOpBack = stencilZPassOp;
  this._stencilWriteMaskBack = stencilWriteMask;
};

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

var _stageOffset = 0;
var _name2stageID = {};

var config = {
  addStage: function (name) {
    // already added
    if (_name2stageID[name] !== undefined) {
      return;
    }

    var stageID = 1 << _stageOffset;
    _name2stageID[name] = stageID;

    _stageOffset += 1;
  },

  stageID: function (name) {
    var id = _name2stageID[name];
    if (id === undefined) {
      return -1;
    }
    return id;
  },

  stageIDs: function (nameList) {
    var key = 0;
    for (var i = 0; i < nameList.length; ++i) {
      var id = _name2stageID[nameList[i]];
      if (id !== undefined) {
        key |= id;
      }
    }
    return key;
  }
};

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

var _genID$1 = 0;

var Technique = function Technique(stages, parameters, passes, layer) {
  if ( layer === void 0 ) layer = 0;

  this._id = _genID$1++;
  this._stageIDs = config.stageIDs(stages);
  this._parameters = parameters; // {name, type, size, val}
  this._passes = passes;
  this._layer = layer;
  // TODO: this._version = 'webgl' or 'webgl2' // ????
};

var prototypeAccessors$4 = { passes: { configurable: true },stageIDs: { configurable: true } };

Technique.prototype.setStages = function setStages (stages) {
  this._stageIDs = config.stageIDs(stages);
};

prototypeAccessors$4.passes.get = function () {
  return this._passes;
};

prototypeAccessors$4.stageIDs.get = function () {
  return this._stageIDs;
};

Object.defineProperties( Technique.prototype, prototypeAccessors$4 );

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

var Effect = function Effect(techniques, properties, defines, dependencies) {
  if ( properties === void 0 ) properties = {};
  if ( defines === void 0 ) defines = [];
  if ( dependencies === void 0 ) dependencies = [];

  this._techniques = techniques;
  this._properties = properties;
  this._defines = defines;
  this._dependencies = dependencies;

  // TODO: check if params is valid for current technique???
};

Effect.prototype.clear = function clear () {
  this._techniques.length = 0;
  this._properties = null;
  this._defines.length = 0;
};

Effect.prototype.getTechnique = function getTechnique (stage) {
    var this$1 = this;

  var stageID = config.stageID(stage);
  if (stageID === -1) {
    return null;
  }

  for (var i = 0; i < this._techniques.length; ++i) {
    var tech = this$1._techniques[i];
    if (tech.stageIDs & stageID) {
      return tech;
    }
  }

  return null;
};

Effect.prototype.getProperty = function getProperty (name) {
  return this._properties[name];
};

Effect.prototype.setProperty = function setProperty (name, value) {
  // TODO: check if params is valid for current technique???
  this._properties[name] = value;
};

Effect.prototype.getDefine = function getDefine (name) {
    var this$1 = this;

  for (var i = 0; i < this._defines.length; ++i) {
    var def = this$1._defines[i];
    if ( def.name === name ) {
      return def.value;
    }
  }

  console.warn(("Failed to get define " + name + ", define not found."));
  return null;
};

Effect.prototype.define = function define (name, value) {
    var this$1 = this;

  for (var i = 0; i < this._defines.length; ++i) {
    var def = this$1._defines[i];
    if ( def.name === name ) {
      def.value = value;
      return;
    }
  }

  console.warn(("Failed to set define " + name + ", define not found."));
};

Effect.prototype.extractDefines = function extractDefines (out) {
    var this$1 = this;
    if ( out === void 0 ) out = {};

  for (var i = 0; i < this._defines.length; ++i) {
    var def = this$1._defines[i];
    out[def.name] = def.value;
  }

  return out;
};

Effect.prototype.extractDependencies = function extractDependencies (out) {
    var this$1 = this;
    if ( out === void 0 ) out = {};

  for (var i = 0; i < this._dependencies.length; ++i) {
    var dep = this$1._dependencies[i];
    out[dep.define] = dep.extension;
  }

  return out;
};

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.



/**
 * @param {gfx.Device} device
 * @param {Object} data
 */
function createIA(device, data) {
  if (!data.positions) {
    console.error('The data must have positions field');
    return null;
  }

  var verts = [];
  var vcount = data.positions.length / 3;

  for (var i = 0; i < vcount; ++i) {
    verts.push(data.positions[3 * i], data.positions[3 * i + 1], data.positions[3 * i + 2]);

    if (data.normals) {
      verts.push(data.normals[3 * i], data.normals[3 * i + 1], data.normals[3 * i + 2]);
    }

    if (data.uvs) {
      verts.push(data.uvs[2 * i], data.uvs[2 * i + 1]);
    }
  }

  var vfmt = [];
  vfmt.push({ name: gfx.ATTR_POSITION, type: gfx.ATTR_TYPE_FLOAT32, num: 3 });
  if (data.normals) {
    vfmt.push({ name: gfx.ATTR_NORMAL, type: gfx.ATTR_TYPE_FLOAT32, num: 3 });
  }
  if (data.uvs) {
    vfmt.push({ name: gfx.ATTR_UV0, type: gfx.ATTR_TYPE_FLOAT32, num: 2 });
  }

  var vb = new gfx.VertexBuffer(
    device,
    new gfx.VertexFormat(vfmt),
    gfx.USAGE_STATIC,
    new Float32Array(verts),
    vcount
  );

  var ib = null;
  if (data.indices) {
    ib = new gfx.IndexBuffer(
      device,
      gfx.INDEX_FMT_UINT16,
      gfx.USAGE_STATIC,
      new Uint16Array(data.indices),
      data.indices.length
    );
  }

  return new InputAssembler(vb, ib);
}

/**
 * @ignore
 */
var _d2r = Math.PI / 180.0;
/**
 * @ignore
 */
var _r2d = 180.0 / Math.PI;

/**
 * @property {number} EPSILON
 */
var EPSILON = 0.000001;

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

/**
 * Tests whether or not the arguments have approximately the same value by given maxDiff
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @param {Number} maxDiff Maximum difference.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function approx(a, b, maxDiff) {
  maxDiff = maxDiff || EPSILON;
  return Math.abs(a - b) <= maxDiff;
}

/**
 * Clamps a value between a minimum float and maximum float value.
 *
 * @method clamp
 * @param {number} val
 * @param {number} min
 * @param {number} max
 * @return {number}
 */
function clamp(val, min, max) {
  return val < min ? min : val > max ? max : val;
}

/**
 * Clamps a value between 0 and 1.
 *
 * @method clamp01
 * @param {number} val
 * @return {number}
 */
function clamp01(val) {
  return val < 0 ? 0 : val > 1 ? 1 : val;
}

/**
 * @method lerp
 * @param {number} from
 * @param {number} to
 * @param {number} ratio - the interpolation coefficient
 * @return {number}
 */
function lerp(from, to, ratio) {
  return from + (to - from) * ratio;
}

/**
* Convert Degree To Radian
*
* @param {Number} a Angle in Degrees
*/
function toRadian(a) {
  return a * _d2r;
}

/**
* Convert Radian To Degree
*
* @param {Number} a Angle in Radian
*/
function toDegree(a) {
  return a * _r2d;
}

/**
* @method random
*/
var random = Math.random;

/**
 * Returns a floating-point random number between min (inclusive) and max (exclusive).
 *
 * @method randomRange
 * @param {number} min
 * @param {number} max
 * @return {number} the random number
 */
function randomRange(min, max) {
  return Math.random() * (max - min) + min;
}

/**
 * Returns a random integer between min (inclusive) and max (exclusive).
 *
 * @method randomRangeInt
 * @param {number} min
 * @param {number} max
 * @return {number} the random integer
 */
function randomRangeInt(min, max) {
  return Math.floor(randomRange(min, max));
}

/**
 * Linear congruential generator using Hull-Dobell Theorem.
 *
 * @method pseudoRandom
 * @param {number} seed the random seed
 * @return {number} the pseudo random
 */
function pseudoRandom(seed) {
  seed = (seed * 9301 + 49297) % 233280;
  return seed / 233280.0;
}

/**
 * Returns a floating-point pseudo-random number between min (inclusive) and max (exclusive).
 *
 * @method pseudoRandomRange
 * @param {number} seed
 * @param {number} min
 * @param {number} max
 * @return {number} the random number
 */
function pseudoRandomRange(seed, min, max) {
  return pseudoRandom(seed) * (max - min) + min;
}

/**
 * Returns a pseudo-random integer between min (inclusive) and max (exclusive).
 *
 * @method pseudoRandomRangeInt
 * @param {number} seed
 * @param {number} min
 * @param {number} max
 * @return {number} the random integer
 */
function pseudoRandomRangeInt(seed, min, max) {
  return Math.floor(pseudoRandomRange(seed, min, max));
}

/**
 * Returns the next power of two for the value
 *
 * @method nextPow2
 * @param {number} val
 * @return {number} the the next power of two
 */
function nextPow2(val) {
  --val;
  val = (val >> 1) | val;
  val = (val >> 2) | val;
  val = (val >> 4) | val;
  val = (val >> 8) | val;
  val = (val >> 16) | val;
  ++val;

  return val;
}

/**
 * Returns float remainder for t / length
 *
 * @method repeat
 * @param {number} t time start at 0
 * @param {number} length time of one cycle
 * @return {number} the time wrapped in the first cycle
 */
function repeat(t, length) {
  return t - Math.floor(t / length) * length;
}

/**
 * Returns time wrapped in ping-pong mode
 *
 * @method repeat
 * @param {number} t time start at 0
 * @param {number} length time of one cycle
 * @return {number} the time wrapped in the first cycle
 */
function pingPong(t, length) {
  t = repeat(t, length * 2);
  t = length - Math.abs(t - length);
  return t;
}

/**
 * Returns ratio of a value within a given range
 *
 * @method repeat
 * @param {number} from start value
 * @param {number} to end value
 * @param {number} value given value
 * @return {number} the ratio between [from,to]
 */
function inverseLerp(from, to, value) {
  return (value - from) / (to - from);
}

/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

var INT_BITS = 32;
/**
 * @ignore
 */
var INT_MAX =  0x7fffffff;
/**
 * @ignore
 */
var INT_MIN = -1<<(INT_BITS-1);

/**
 * Returns -1, 0, +1 depending on sign of x
 *
 * @param {number} v
 * @returns {number}
 */
function sign(v) {
  return (v > 0) - (v < 0);
}

/**
 * Computes absolute value of integer
 *
 * @param {number} v
 * @returns {number}
 */
function abs(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

/**
 * Computes minimum of integers x and y
 *
 * @param {number} x
 * @param {number} y
 * @returns {number}
 */
function min(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

/**
 * Computes maximum of integers x and y
 *
 * @param {number} x
 * @param {number} y
 * @returns {number}
 */
function max(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

/**
 * Checks if a number is a power of two
 *
 * @param {number} v
 * @returns {boolean}
 */
function isPow2$1(v) {
  return !(v & (v-1)) && (!!v);
}

/**
 * Computes log base 2 of v
 *
 * @param {number} v
 * @returns {number}
 */
function log2(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

/**
 * Computes log base 10 of v
 *
 * @param {number} v
 * @returns {number}
 */
function log10(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

/**
 * Counts number of bits
 *
 * @param {number} v
 * @returns {number}
 */
function popCount(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

/**
 * Counts number of trailing zeros
 *
 * @param {number} v
 * @returns {number}
 */
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) { c--; }
  if (v & 0x0000FFFF) { c -= 16; }
  if (v & 0x00FF00FF) { c -= 8; }
  if (v & 0x0F0F0F0F) { c -= 4; }
  if (v & 0x33333333) { c -= 2; }
  if (v & 0x55555555) { c -= 1; }
  return c;
}

/**
 * Rounds to next power of 2
 *
 * @param {number} v
 * @returns {number}
 */
function nextPow2$1(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

/**
 * Rounds down to previous power of 2
 *
 * @param {number} v
 * @returns {number}
 */
function prevPow2(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

/**
 * Computes parity of word
 *
 * @param {number} v
 * @returns {number}
 */
function parity(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

/**
 * @ignore
 */
var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

/**
 * Reverse bits in a 32 bit word
 *
 * @param {number} v
 * @returns {number}
 */
function reverse(v) {
  return (REVERSE_TABLE[v & 0xff] << 24) |
         (REVERSE_TABLE[(v >>> 8) & 0xff] << 16) |
         (REVERSE_TABLE[(v >>> 16) & 0xff] << 8) |
         REVERSE_TABLE[(v >>> 24) & 0xff];
}

/**
 * Interleave bits of 2 coordinates with 16 bits. Useful for fast quadtree codes
 *
 * @param {number} x
 * @param {number} y
 * @returns {number}
 */
function interleave2(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

/**
 * Extracts the nth interleaved component
 *
 * @param {number} v
 * @param {number} n
 * @returns {number}
 */
function deinterleave2(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}

/**
 * Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
 *
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @returns {number}
 */
function interleave3(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);

  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;

  return x | (z << 2);
}

/**
 * Extracts nth interleaved component of a 3-tuple
 *
 * @param {number} v
 * @param {number} n
 * @returns {number}
 */
function deinterleave3(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

/**
 * Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
 *
 * @param {number} v
 * @returns {number}
 */
function nextCombination(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}

var bits_ = Object.freeze({
	INT_BITS: INT_BITS,
	INT_MAX: INT_MAX,
	INT_MIN: INT_MIN,
	sign: sign,
	abs: abs,
	min: min,
	max: max,
	isPow2: isPow2$1,
	log2: log2,
	log10: log10,
	popCount: popCount,
	countTrailingZeros: countTrailingZeros,
	nextPow2: nextPow2$1,
	prevPow2: prevPow2,
	parity: parity,
	reverse: reverse,
	interleave2: interleave2,
	deinterleave2: deinterleave2,
	interleave3: interleave3,
	deinterleave3: deinterleave3,
	nextCombination: nextCombination
});

var vec2 = function vec2(x, y) {
  /**
   * The x component.
   * @type {number}
   * */
  this.x = x;

  /**
   * The y component.
   * @type {number}
   * */
  this.y = y;
};

/**
 * Creates a vector, with components specified separately.
 *
 * @param {number} x - Value assigned to x component.
 * @param {number} y - Value assigned to y component.
 * @return {vec2} The newly created vector.
 */
vec2.new = function new$1 (x, y) {
  return new vec2(x, y);
};

/**
 * Creates a zero vector.
 *
 * @return {vec2} The newly created vector.
 */
vec2.zero = function zero () {
  return new vec2(0, 0);
};

/**
 * Clone a vector.
 *
 * @param {vec2} a - Vector to clone.
 * @returns {vec2} The newly created vector.
 */
vec2.clone = function clone (a) {
  return new vec2(a.x, a.y);
};

/**
 * Copy content of a vector into another.
 *
 * @param {vec2} out - The vector to modified.
 * @param {vec2} a - The specified vector.
 * @returns {vec2} out.
 */
vec2.copy = function copy (out, a) {
  out.x = a.x;
  out.y = a.y;
  return out;
};

/**
 * Sets the components of a vector to the given values.
 *
 * @param {vec2} out - The vector to modified.
 * @param {Number} x - Value set to x component.
 * @param {Number} y - Value set to y component.
 * @returns {vec2} out.
 */
vec2.set = function set (out, x, y) {
  out.x = x;
  out.y = y;
  return out;
};

/**
 * Add two vectors.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - The first operand.
 * @param {vec2} b - The second operand.
 * @returns {vec2} out.
 */
vec2.add = function add (out, a, b) {
  out.x = a.x + b.x;
  out.y = a.y + b.y;
  return out;
};

/**
 * Subtract two vectors.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - The first operand.
 * @param {vec2} b - The second operand.
 * @returns {vec2} out.
 */
vec2.subtract = function subtract (out, a, b) {
  out.x = a.x - b.x;
  out.y = a.y - b.y;
  return out;
};

/**
 *Alias of {@link vec2.subtract}.
 */
vec2.sub = function sub (out, a, b) {
  return vec2.subtract(out, a, b);
};

/**
 * Performs multiply on each component of two vectors respectively.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - The first operand.
 * @param {vec2} b - The second operand.
 * @returns {vec2} out.
 */
vec2.multiply = function multiply (out, a, b) {
  out.x = a.x * b.x;
  out.y = a.y * b.y;
  return out;
};

/**
 *Alias of {@link vec2.multiply}.
 */
vec2.mul = function mul (out, a, b) {
  return vec2.multiply(out, a, b);
};

/**
 * Performs division on each component of two vectors respectively.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - The first operand.
 * @param {vec2} b - The second operand.
 * @returns {vec2} out.
 */
vec2.divide = function divide (out, a, b) {
  out.x = a.x / b.x;
  out.y = a.y / b.y;
  return out;
};

/**
 *Alias of {@link vec2.divide}.
 */
vec2.div = function div (out, a, b) {
  return vec2.divide(out, a, b);
};

/**
 * Performs Math.ceil on each component of a vector.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - Vector to perform operation.
 * @returns {vec2} out.
 */
vec2.ceil = function ceil (out, a) {
  out.x = Math.ceil(a.x);
  out.y = Math.ceil(a.y);
  return out;
};

/**
 * Performs Math.floor on each component of a vector.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - Vector to perform operation.
 * @returns {vec2} out.
 */
vec2.floor = function floor (out, a) {
  out.x = Math.floor(a.x);
  out.y = Math.floor(a.y);
  return out;
};

/**
 * Performs Math.min on each component of two vectors respectively.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - The first operand.
 * @param {vec2} b - The second operand.
 * @returns {vec2} out.
 */
vec2.min = function min (out, a, b) {
  out.x = Math.min(a.x, b.x);
  out.y = Math.min(a.y, b.y);
  return out;
};

/**
 * Performs Math.min on each component of two vectors respectively.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - The first operand.
 * @param {vec2} b - The second operand.
 * @returns {vec2} out.
 */
vec2.max = function max (out, a, b) {
  out.x = Math.max(a.x, b.x);
  out.y = Math.max(a.y, b.y);
  return out;
};

/**
 * Performs Math.round on each component of a vector.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - Vector to perform operation.
 * @returns {vec2} out.
 */
vec2.round = function round (out, a) {
  out.x = Math.round(a.x);
  out.y = Math.round(a.y);
  return out;
};

/**
 * Scales a vector with a number.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - Vector to scale.
 * @param {number} b - The scale number.
 * @returns {vec2} out.
 * */
vec2.scale = function scale (out, a, b) {
  out.x = a.x * b;
  out.y = a.y * b;
  return out;
};

/**
 * Add two vectors after scaling the second operand by a number.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - The first operand.
 * @param {vec2} b - The second operand.
 * @param {number} scale - The scale number before adding.
 * @returns {vec2} out.
 */
vec2.scaleAndAdd = function scaleAndAdd (out, a, b, scale) {
  out.x = a.x + (b.x * scale);
  out.y = a.y + (b.y * scale);
  return out;
};

/**
 * Calculates the euclidian distance between two vectors.
 *
 * @param {vec2} a - The first operand.
 * @param {vec2} b - The second operand.
 * @returns {number} Distance between a and b.
 */
vec2.distance = function distance (a, b) {
  var x = b.x - a.x,
    y = b.y - a.y;
  return Math.sqrt(x * x + y * y);
};

/**
 *Alias of {@link vec2.distance}.
 */
vec2.dist = function dist (a, b) {
  return vec2.distance(a, b);
};

/**
 * Calculates the squared euclidian distance between two vectors.
 *
 * @param {vec2} a - The first operand.
 * @param {vec2} b - The second operand.
 * @returns {number} Squared distance between a and b.
 */
vec2.squaredDistance = function squaredDistance (a, b) {
  var x = b.x - a.x,
    y = b.y - a.y;
  return x * x + y * y;
};

/**
 *Alias of {@link vec2.squaredDistance}.
 */
vec2.sqrDist = function sqrDist (a, b) {
  return vec2.squaredDistance(a, b);
};

/**
 * Calculates the length of a vector.
 *
 * @param {vec2} a - The vector.
 * @returns {Number} Length of the vector.
 */
vec2.magnitude = function magnitude (a) {
  var x = a.x,
    y = a.y;
  return Math.sqrt(x * x + y * y);
};

/**
 *Alias of {@link vec2.magnitude}.
 */
vec2.mag = function mag (a) {
  return vec2.magnitude(a);
};

/**
 * Calculates the squared length of a vector.
 *
 * @param {vec2} a - The vector.
 * @returns {Number} Squared length of the vector.
 */
vec2.squaredMagnitude = function squaredMagnitude (a) {
  var x = a.x,
    y = a.y;
  return x * x + y * y;
};

/**
 *Alias of {@link vec2.squaredMagnitude}
 */
vec2.sqrMag = function sqrMag (a) {
  return vec2.squaredMagnitude(a);
};

/**
 * Negates each component of a vector.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - Vector to negate.
 * @returns {vec2} out.
 */
vec2.negate = function negate (out, a) {
  out.x = -a.x;
  out.y = -a.y;
  return out;
};

/**
 * Invert the components of a vector.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - Vector to invert.
 * @returns {vec2} out.
 */
vec2.inverse = function inverse (out, a) {
  out.x = 1.0 / a.x;
  out.y = 1.0 / a.y;
  return out;
};

/**
 * Safely invert the components of a vector.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - Vector to invert.
 * @returns {vec2} out.
 */
vec2.inverseSafe = function inverseSafe (out, a) {
  var x = a.x,
    y = a.y;

  if (Math.abs(x) < EPSILON) {
    out.x = 0;
  } else {
    out.x = 1.0 / x;
  }

  if (Math.abs(y) < EPSILON) {
    out.y = 0;
  } else {
    out.y = 1.0 / a.y;
  }

  return out;
};

/**
 * Normalizes a vector.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - Vector to normalize.
 * @returns {vec2} out.
 */
vec2.normalize = function normalize (out, a) {
  var x = a.x,
    y = a.y;
  var len = x * x + y * y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out.x = a.x * len;
    out.y = a.y * len;
  }
  return out;
};

/**
 * Calculates the dot product of two vectors.
 *
 * @param {vec2} a - The first operand.
 * @param {vec2} b - The second operand.
 * @returns {Number} Dot product of a and b.
 */
vec2.dot = function dot (a, b) {
  return a.x * b.x + a.y * b.y;
};

/**
 * Calculate the cross product of two vectors.
 * Note that the cross product must by definition produce a 3D vector.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - The first operand.
 * @param {vec2} b - The second operand.
 * @returns {vec3} out.
 */
vec2.cross = function cross (out, a, b) {
  var z = a.x * b.y - a.y * b.x;
  out.x = out.y = 0;
  out.z = z;
  return out;
};

/**
 * Performs a linear interpolation between two vectors.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - The first operand.
 * @param {vec2} b - The second operand.
 * @param {Number} t - The interpolation coefficient.
 * @returns {vec2} out.
 */
vec2.lerp = function lerp$$1 (out, a, b, t) {
  var ax = a.x,
    ay = a.y;
  out.x = ax + t * (b.x - ax);
  out.y = ay + t * (b.y - ay);
  return out;
};

/**
 * Generates a random vector with the given scale.
 *
 * @param {vec2} out - Vector to store result.
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned.
 * @returns {vec2} out.
 */
vec2.random = function random$1 (out, scale) {
  scale = scale || 1.0;
  var r = random() * 2.0 * Math.PI;
  out.x = Math.cos(r) * scale;
  out.y = Math.sin(r) * scale;
  return out;
};

/**
 * Transforms a vector with a 2x2 matrix.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - Vector to transform.
 * @param {mat2} m - The matrix.
 * @returns {vec2} out.
 */
vec2.transformMat2 = function transformMat2 (out, a, m) {
  var x = a.x,
    y = a.y;
  out.x = m.m00 * x + m.m02 * y;
  out.y = m.m01 * x + m.m03 * y;
  return out;
};

/**
 * Transforms a vector with a 2x3 matrix.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - Vector to transform.
 * @param {mat23} m - The matrix.
 * @returns {vec2} out.
 */
vec2.transformMat23 = function transformMat23 (out, a, m) {
  var x = a.x,
    y = a.y;
  out.x = m.m00 * x + m.m02 * y + m.m04;
  out.y = m.m01 * x + m.m03 * y + m.m05;
  return out;
};

/**
 * Transforms a vector with a 3x3 matrix.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - Vector to transform.
 * @param {mat3} m - The matrix.
 * @returns {vec2} out.
 */
vec2.transformMat3 = function transformMat3 (out, a, m) {
  var x = a.x,
    y = a.y;
  out.x = m.m00 * x + m.m03 * y + m.m06;
  out.y = m.m01 * x + m.m04 * y + m.m07;
  return out;
};

/**
 * Transforms a vector with a 4x4 matrix.
 * 3rd vector component is implicitly '0'.
 * 4th vector component is implicitly '1'.
 *
 * @param {vec2} out - Vector to store result.
 * @param {vec2} a - Vector to transform.
 * @param {mat4} m - The matrix.
 * @returns {vec2} out.
 */
vec2.transformMat4 = function transformMat4 (out, a, m) {
  var x = a.x,
    y = a.y;
  out.x = m.m00 * x + m.m04 * y + m.m12;
  out.y = m.m01 * x + m.m05 * y + m.m13;
  return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over.
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed.
 * @param {Number} offset Number of elements to skip at the beginning of the array.
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array.
 * @param {Function} fn Function to call for each vector in the array.
 * @param {Object} [arg] additional argument to pass to fn.
 * @returns {Array} a.
 */
vec2.forEach = function forEach (a, stride, offset, count, fn, arg) {
  return vec2._forEach(a, stride, offset, count, fn, arg);
};

/**
 * Returns string representation of a vector.
 *
 * @param {vec2} a - The vector.
 * @returns {String} - String representation of this vector.
 */
vec2.str = function str (a) {
  return ("vec2(" + (a.x) + ", " + (a.y) + ")");
};

/**
 * Store components of a vector into array.
 *
 * @param {Array} out - Array to store result.
 * @param {vec2} v - The vector.
 * @returns {Array} out.
 */
vec2.array = function array (out, v) {
  out[0] = v.x;
  out[1] = v.y;

  return out;
};

/**
 * Returns whether the specified vectors are equal. (Compared using ===)
 *
 * @param {vec2} a - The first vector.
 * @param {vec2} b - The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.exactEquals = function exactEquals (a, b) {
  return a.x === b.x && a.y === b.y;
};

/**
 * Returns whether the specified vectors are approximately equal.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are approximately equal, false otherwise.
 */
vec2.equals = function equals$$1 (a, b) {
  var a0 = a.x, a1 = a.y;
  var b0 = b.x, b1 = b.y;
  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
    Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)));
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over.
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed.
 * @param {Number} offset Number of elements to skip at the beginning of the array.
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array.
 * @param {Function} fn Function to call for each vector in the array.
 * @param {Object} [arg] additional argument to pass to fn.
 * @returns {Array} a.
 * @ignore
 */
vec2._forEach = (function () {
  var vec = vec2.zero();

  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec.x = a[i];
      vec.y = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec.x;
      a[i + 1] = vec.y;
    }

    return a;
  };
})();

var vec3 = function vec3(x, y, z) {
  /**
   * The x component.
   * @type {number}
   * */
  this.x = x;

  /**
   * The y component.
   * @type {number}
   * */
  this.y = y;

  /**
   * The z component.
   * @type {number}
   * */
  this.z = z;
};

/**
 * Creates a vector, with components specified separately.
 *
 * @param {number} x - Value assigned to x component.
 * @param {number} y - Value assigned to y component.
 * @param {number} z - Value assigned to z component.
 * @return {vec3} The newly created vector.
 */
vec3.new = function new$1 (x, y, z) {
  return new vec3(x, y, z);
};

/**
 * Creates a zero vector.
 *
 * @return {vec3} The newly created vector.
 */
vec3.zero = function zero () {
  return vec3.new(0, 0, 0);
};

/**
 * Clone a vector.
 *
 * @param {vec3} a - Vector to clone.
 * @returns {vec3} The newly created vector.
 */
vec3.clone = function clone (a) {
  return new vec3(a.x, a.y, a.z);
};

/**
 * Copy content of a vector into another.
 *
 * @param {vec3} out - The vector to modified.
 * @param {vec3} a - The specified vector.
 * @returns {vec3} out.
 */
vec3.copy = function copy (out, a) {
  out.x = a.x;
  out.y = a.y;
  out.z = a.z;
  return out;
};

/**
 * Sets the components of a vector to the given values.
 *
 * @param {vec3} out - The vector to modified.
 * @param {Number} x - Value set to x component.
 * @param {Number} y - Value set to y component.
 * @param {Number} z - Value set to z component.
 * @returns {vec3} out.
 */
vec3.set = function set (out, x, y, z) {
  out.x = x;
  out.y = y;
  out.z = z;
  return out;
};

/**
 * Add two vectors.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - The first operand.
 * @param {vec3} b - The second operand.
 * @returns {vec3} out.
 */
vec3.add = function add (out, a, b) {
  out.x = a.x + b.x;
  out.y = a.y + b.y;
  out.z = a.z + b.z;
  return out;
};

/**
 * Subtract two vectors.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - The first operand.
 * @param {vec3} b - The second operand.
 * @returns {vec3} out.
 */
vec3.subtract = function subtract (out, a, b) {
  out.x = a.x - b.x;
  out.y = a.y - b.y;
  out.z = a.z - b.z;
  return out;
};

/**
 * Alias of {@link vec3.subtract}.
 */
vec3.sub = function sub (out, a, b) {
  return vec3.subtract(out, a, b);
};

/**
 * Performs multiply on each component of two vectors respectively.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - The first operand.
 * @param {vec3} b - The second operand.
 * @returns {vec3} out.
 */
vec3.multiply = function multiply (out, a, b) {
  out.x = a.x * b.x;
  out.y = a.y * b.y;
  out.z = a.z * b.z;
  return out;
};

/**
 * Alias of {@link vec3.multiply}.
 */
vec3.mul = function mul (out, a, b) {
  return vec3.multiply(out, a, b);
};

/**
 * Performs division on each component of two vectors respectively.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - The first operand.
 * @param {vec3} b - The second operand.
 * @returns {vec3} out.
 */
vec3.divide = function divide (out, a, b) {
  out.x = a.x / b.x;
  out.y = a.y / b.y;
  out.z = a.z / b.z;
  return out;
};

/**
 * Alias of {@link vec3.divide}.
 */
vec3.div = function div (out, a, b) {
  return vec3.divide(out, a, b);
};

/**
 * Performs Math.ceil on each component of a vector.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - Vector to perform operation.
 * @returns {vec3} out.
 */
vec3.ceil = function ceil (out, a) {
  out.x = Math.ceil(a.x);
  out.y = Math.ceil(a.y);
  out.z = Math.ceil(a.z);
  return out;
};

/**
 * Performs Math.floor on each component of a vector.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - Vector to perform operation.
 * @returns {vec3} out.
 */
vec3.floor = function floor (out, a) {
  out.x = Math.floor(a.x);
  out.y = Math.floor(a.y);
  out.z = Math.floor(a.z);
  return out;
};

/**
 * Performs Math.min on each component of two vectors respectively.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - The first operand.
 * @param {vec3} b - The second operand.
 * @returns {vec3} out.
 */
vec3.min = function min (out, a, b) {
  out.x = Math.min(a.x, b.x);
  out.y = Math.min(a.y, b.y);
  out.z = Math.min(a.z, b.z);
  return out;
};

/**
 * Performs Math.min on each component of two vectors respectively.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - The first operand.
 * @param {vec3} b - The second operand.
 * @returns {vec3} out.
 */
vec3.max = function max (out, a, b) {
  out.x = Math.max(a.x, b.x);
  out.y = Math.max(a.y, b.y);
  out.z = Math.max(a.z, b.z);
  return out;
};

/**
 * Performs Math.round on each component of a vector.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - Vector to perform operation.
 * @returns {vec3} out.
 */
vec3.round = function round (out, a) {
  out.x = Math.round(a.x);
  out.y = Math.round(a.y);
  out.z = Math.round(a.z);
  return out;
};

/**
 * Scales a vector with a number.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - Vector to scale.
 * @param {number} b - The scale number.
 * @returns {vec3} out.
 * */
vec3.scale = function scale (out, a, b) {
  out.x = a.x * b;
  out.y = a.y * b;
  out.z = a.z * b;
  return out;
};

/**
 * Add two vectors after scaling the second operand by a number.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - The first operand.
 * @param {vec3} b - The second operand.
 * @param {number} scale - The scale number before adding.
 * @returns {vec3} out.
 */
vec3.scaleAndAdd = function scaleAndAdd (out, a, b, scale) {
  out.x = a.x + (b.x * scale);
  out.y = a.y + (b.y * scale);
  out.z = a.z + (b.z * scale);
  return out;
};

/**
 * Calculates the euclidian distance between two vectors.
 *
 * @param {vec3} a - The first operand.
 * @param {vec3} b - The second operand.
 * @returns {number} Distance between a and b.
 */
vec3.distance = function distance (a, b) {
  var x = b.x - a.x,
    y = b.y - a.y,
    z = b.z - a.z;
  return Math.sqrt(x * x + y * y + z * z);
};

/**
 * Alias of {@link vec3.distance}.
 */
vec3.dist = function dist (a, b) {
  return vec3.distance(a, b);
};

/**
 * Calculates the squared euclidian distance between two vectors.
 *
 * @param {vec3} a - The first operand.
 * @param {vec3} b - The second operand.
 * @returns {number} Squared distance between a and b.
 */
vec3.squaredDistance = function squaredDistance (a, b) {
  var x = b.x - a.x,
    y = b.y - a.y,
    z = b.z - a.z;
  return x * x + y * y + z * z;
};

/**
 * Alias of {@link vec3.squaredDistance}.
 */
vec3.sqrDist = function sqrDist (a, b) {
  return vec3.squaredDistance(a, b);
};

/**
 * Calculates the length of a vector.
 *
 * @param {vec3} a - The vector.
 * @returns {Number} Length of the vector.
 */
vec3.magnitude = function magnitude (a) {
  var x = a.x,
    y = a.y,
    z = a.z;
  return Math.sqrt(x * x + y * y + z * z);
};

/**
 *Alias of {@link vec3.magnitude}.
 */
vec3.mag = function mag (a) {
  return vec3.magnitude(a);
};

/**
 * Calculates the squared length of a vector.
 *
 * @param {vec3} a - The vector.
 * @returns {Number} Squared length of the vector.
 */
vec3.squaredMagnitude = function squaredMagnitude (a) {
  var x = a.x,
    y = a.y,
    z = a.z;
  return x * x + y * y + z * z;
};

/**
 *Alias of {@link vec3.squaredMagnitude}
 */
vec3.sqrMag = function sqrMag (a) {
  return vec3.squaredMagnitude(a);
};

/**
 * Negates each component of a vector.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - Vector to negate.
 * @returns {vec3} out.
 */
vec3.negate = function negate (out, a) {
  out.x = -a.x;
  out.y = -a.y;
  out.z = -a.z;
  return out;
};

/**
 * Inverts the components of a vector.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - Vector to invert.
 * @returns {vec3} out.
 */
vec3.inverse = function inverse (out, a) {
  out.x = 1.0 / a.x;
  out.y = 1.0 / a.y;
  out.z = 1.0 / a.z;
  return out;
};

/**
 * Safely inverts the components of a vector.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - Vector to invert.
 * @returns {vec3} out.
 */
vec3.inverseSafe = function inverseSafe (out, a) {
  var x = a.x,
    y = a.y,
    z = a.z;

  if (Math.abs(x) < EPSILON) {
    out.x = 0;
  } else {
    out.x = 1.0 / x;
  }

  if (Math.abs(y) < EPSILON) {
    out.y = 0;
  } else {
    out.y = 1.0 / y;
  }

  if (Math.abs(z) < EPSILON) {
    out.z = 0;
  } else {
    out.z = 1.0 / z;
  }

  return out;
};

/**
 * Normalizes a vector.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - Vector to normalize.
 * @returns {vec3} out.
 */
vec3.normalize = function normalize (out, a) {
  var x = a.x,
    y = a.y,
    z = a.z;

  var len = x * x + y * y + z * z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out.x = x * len;
    out.y = y * len;
    out.z = z * len;
  }
  return out;
};

/**
 * Calculates the dot product of two vectors.
 *
 * @param {vec3} a - The first operand.
 * @param {vec3} b - The second operand.
 * @returns {Number} Dot product of a and b.
 */
vec3.dot = function dot (a, b) {
  return a.x * b.x + a.y * b.y + a.z * b.z;
};

/**
 * Calculates the cross product of two vectors.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - The first operand.
 * @param {vec3} b - The second operand.
 * @returns {vec3} out.
 */
vec3.cross = function cross (out, a, b) {
  var ax = a.x, ay = a.y, az = a.z,
    bx = b.x, by = b.y, bz = b.z;

  out.x = ay * bz - az * by;
  out.y = az * bx - ax * bz;
  out.z = ax * by - ay * bx;
  return out;
};

/**
 * Performs a linear interpolation between two vectors.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - The first operand.
 * @param {vec3} b - The second operand.
 * @param {Number} t - The interpolation coefficient.
 * @returns {vec3} out.
 */
vec3.lerp = function lerp$$1 (out, a, b, t) {
  var ax = a.x,
    ay = a.y,
    az = a.z;
  out.x = ax + t * (b.x - ax);
  out.y = ay + t * (b.y - ay);
  out.z = az + t * (b.z - az);
  return out;
};

/**
 * Performs a hermite interpolation with two control points.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - The first operand.
 * @param {vec3} b - The second operand.
 * @param {vec3} c - The third operand.
 * @param {vec3} d - The fourth operand.
 * @param {Number} t - The interpolation coefficient.
 * @returns {vec3} out.
 */
vec3.hermite = function hermite (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
    factor1 = factorTimes2 * (2 * t - 3) + 1,
    factor2 = factorTimes2 * (t - 2) + t,
    factor3 = factorTimes2 * (t - 1),
    factor4 = factorTimes2 * (3 - 2 * t);

  out.x = a.x * factor1 + b.x * factor2 + c.x * factor3 + d.x * factor4;
  out.y = a.y * factor1 + b.y * factor2 + c.y * factor3 + d.y * factor4;
  out.z = a.z * factor1 + b.z * factor2 + c.z * factor3 + d.z * factor4;

  return out;
};

/**
 * Performs a bezier interpolation with two control points.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - The first operand.
 * @param {vec3} b - The second operand.
 * @param {vec3} c - The third operand.
 * @param {vec3} d - The fourth operand.
 * @param {Number} t - The interpolation coefficient.
 * @returns {vec3} out.
 */
vec3.bezier = function bezier (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
    inverseFactorTimesTwo = inverseFactor * inverseFactor,
    factorTimes2 = t * t,
    factor1 = inverseFactorTimesTwo * inverseFactor,
    factor2 = 3 * t * inverseFactorTimesTwo,
    factor3 = 3 * factorTimes2 * inverseFactor,
    factor4 = factorTimes2 * t;

  out.x = a.x * factor1 + b.x * factor2 + c.x * factor3 + d.x * factor4;
  out.y = a.y * factor1 + b.y * factor2 + c.y * factor3 + d.y * factor4;
  out.z = a.z * factor1 + b.z * factor2 + c.z * factor3 + d.z * factor4;

  return out;
};

/**
 * Generates a random vector with the given scale.
 *
 * @param {vec3} out - Vector to store result.
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned.
 * @returns {vec3} out.
 */
vec3.random = function random$1 (out, scale) {
  scale = scale || 1.0;

  var r = random() * 2.0 * Math.PI;
  var z = (random() * 2.0) - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;

  out.x = Math.cos(r) * zScale;
  out.y = Math.sin(r) * zScale;
  out.z = z * scale;
  return out;
};

/**
 * Transforms a vector with a 4x4 matrix. 4th vector component is implicitly '1'.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - Vector to transform.
 * @param {mat4} m - The matrix.
 * @returns {vec3} out.
 */
vec3.transformMat4 = function transformMat4 (out, a, m) {
  var x = a.x, y = a.y, z = a.z,
    w = m.m03 * x + m.m07 * y + m.m11 * z + m.m15;
  w = w || 1.0;
  out.x = (m.m00 * x + m.m04 * y + m.m08 * z + m.m12) / w;
  out.y = (m.m01 * x + m.m05 * y + m.m09 * z + m.m13) / w;
  out.z = (m.m02 * x + m.m06 * y + m.m10 * z + m.m14) / w;
  return out;
};

/**
 * Transforms a vector with a 3x3 matrix.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - Vector to transform.
 * @param {mat3} m - The matrix.
 * @returns {vec3} out.
 */
vec3.transformMat3 = function transformMat3 (out, a, m) {
  var x = a.x, y = a.y, z = a.z;
  out.x = x * m.m00 + y * m.m03 + z * m.m06;
  out.y = x * m.m01 + y * m.m04 + z * m.m07;
  out.z = x * m.m02 + y * m.m05 + z * m.m08;
  return out;
};

/**
 * Transforms a vector with a quaternion.
 *
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - Vector to transform.
 * @param {quat} q - The quaternion.
 * @returns {vec3} out.
 */
vec3.transformQuat = function transformQuat (out, a, q) {
  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

  var x = a.x, y = a.y, z = a.z;
  var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

  // calculate quat * vec
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out;
};

/**
 * Rotates a 3D vector around the x-axis.
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - The point to rotate.
 * @param {vec3} b - The origin of the rotation.
 * @param {Number} c - The angle of rotation.
 * @returns {vec3} out.
 */
vec3.rotateX = function rotateX (out, a, b, c) {
  var p = [], r = [];
  // Translate point to the origin
  p.x = a.x - b.x;
  p.y = a.y - b.y;
  p.z = a.z - b.z;

  //perform rotation
  r.x = p.x;
  r.y = p.y * Math.cos(c) - p.z * Math.sin(c);
  r.z = p.y * Math.sin(c) + p.z * Math.cos(c);

  //translate to correct position
  out.x = r.x + b.x;
  out.y = r.y + b.y;
  out.z = r.z + b.z;

  return out;
};

/**
 * Rotates a 3D vector around the y-axis.
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - The point to rotate.
 * @param {vec3} b - The origin of the rotation.
 * @param {Number} c - The angle of rotation.
 * @returns {vec3} out.
 */
vec3.rotateY = function rotateY (out, a, b, c) {
  var p = [], r = [];
  //Translate point to the origin
  p.x = a.x - b.x;
  p.y = a.y - b.y;
  p.z = a.z - b.z;

  //perform rotation
  r.x = p.z * Math.sin(c) + p.x * Math.cos(c);
  r.y = p.y;
  r.z = p.z * Math.cos(c) - p.x * Math.sin(c);

  //translate to correct position
  out.x = r.x + b.x;
  out.y = r.y + b.y;
  out.z = r.z + b.z;

  return out;
};

/**
 * Rotates a 3D vector around the z-axis.
 * @param {vec3} out - Vector to store result.
 * @param {vec3} a - The point to rotate.
 * @param {vec3} b - The origin of the rotation.
 * @param {Number} c - The angle of rotation.
 * @returns {vec3} out.
 */
vec3.rotateZ = function rotateZ (out, a, b, c) {
  var p = [], r = [];
  //Translate point to the origin
  p.x = a.x - b.x;
  p.y = a.y - b.y;
  p.z = a.z - b.z;

  //perform rotation
  r.x = p.x * Math.cos(c) - p.y * Math.sin(c);
  r.y = p.x * Math.sin(c) + p.y * Math.cos(c);
  r.z = p.z;

  //translate to correct position
  out.x = r.x + b.x;
  out.y = r.y + b.y;
  out.z = r.z + b.z;

  return out;
};

/**
 * Returns string representation of a vector.
 *
 * @param {vec3} a - The vector.
 * @returns {String} - String representation of this vector.
 */
vec3.str = function str (a) {
  return ("vec3(" + (a.x) + ", " + (a.y) + ", " + (a.z) + ")");
};

/**
 * Store components of a vector into array.
 *
 * @param {Array} out - Array to store result.
 * @param {vec3} v - The vector.
 * @returns {Array} out.
 */
vec3.array = function array (out, v) {
  out[0] = v.x;
  out[1] = v.y;
  out[2] = v.z;

  return out;
};

/**
 * Returns whether the specified vectors are equal. (Compared using ===)
 *
 * @param {vec3} a - The first vector.
 * @param {vec3} b - The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.exactEquals = function exactEquals (a, b) {
  return a.x === b.x && a.y === b.y && a.z === b.z;
};

/**
 * Returns whether the specified vectors are approximately equal.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are approximately equal, false otherwise.
 */
vec3.equals = function equals$$1 (a, b) {
  var a0 = a.x, a1 = a.y, a2 = a.z;
  var b0 = b.x, b1 = b.y, b2 = b.z;
  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
    Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
    Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)));
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over.
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed.
 * @param {Number} offset Number of elements to skip at the beginning of the array.
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array.
 * @param {Function} fn Function to call for each vector in the array.
 * @param {Object} [arg] additional argument to pass to fn.
 * @returns {Array} a.
 */
vec3.forEach = function forEach (a, stride, offset, count, fn, arg) {
  return vec3._forEach(a, stride, offset, count, fn, arg);
};

/**
 * Gets the angle between two 3D vectors.
 * @param {vec3} a - The first operand.
 * @param {vec3} b - The second operand.
 * @returns {Number} - The angle in radians.
 */
vec3.angle = function angle (a, b) {
  return vec3._angle(a, b);
};

/**
* Perform some operation over an array of vec3s.
*
* @param {Array} a the array of vectors to iterate over.
* @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed.
* @param {Number} offset Number of elements to skip at the beginning of the array.
* @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array.
* @param {Function} fn Function to call for each vector in the array.
* @param {Object} [arg] additional argument to pass to fn.
* @returns {Array} a.
* @ignore.
*/
vec3._forEach = (function () {
  var vec = vec3.zero();

  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec.x = a[i];
      vec.y = a[i + 1];
      vec.z = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec.x;
      a[i + 1] = vec.y;
      a[i + 2] = vec.z;
    }

    return a;
  };
})();

  /**
   * Get the angle between two 3D vectors.
   * @param {vec3} a The first operand.
   * @param {vec3} b The second operand.
   * @returns {Number} The angle in radians.
   * @ignore
   */
vec3._angle = (function () {
  var tempA = vec3.zero();
  var tempB = vec3.zero();

  return function (a, b) {
    vec3.copy(tempA, a);
    vec3.copy(tempB, b);

    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);

    var cosine = vec3.dot(tempA, tempB);

    if (cosine > 1.0) {
      return 0;
    }

    if (cosine < -1.0) {
      return Math.PI;
    }

    return Math.acos(cosine);
  };
})();

var vec4 = function vec4(x, y, z, w) {
  /**
   * The x component.
   * @type {number}
   * */
  this.x = x;

  /**
   * The y component.
   * @type {number}
   * */
  this.y = y;

  /**
   * The z component.
   * @type {number}
   * */
  this.z = z;

  /**
   * The w component.
   * @type {number}
   * */
  this.w = w;
};

/**
 * Create a vector, with components specified separately.
 *
 * @param {number} x - Value assigned to x component.
 * @param {number} y - Value assigned to y component.
 * @param {number} z - Value assigned to z component.
 * @param {number} w - Value assigned to w component.
 * @return {vec4} The newly created vector.
 */
vec4.new = function new$1 (x, y, z, w) {
  return new vec4(x, y, z, w);
};

/**
 * Creates a zero vector.
 *
 * @return {vec4} The newly created vector.
 */
vec4.zero = function zero () {
  return vec4.new(0, 0, 0, 0);
};

/**
 * Clone a vector.
 *
 * @param {vec4} a - Vector to clone.
 * @returns {vec4} The newly created vector.
 */
vec4.clone = function clone (a) {
  return new vec4(a.x, a.y, a.z, a.w);
};

/**
 * Copy content of a vector into another.
 *
 * @param {vec4} out - The vector to modified.
 * @param {vec4} a - The specified vector.
 * @returns {vec4} out.
 */
vec4.copy = function copy (out, a) {
  out.x = a.x;
  out.y = a.y;
  out.z = a.z;
  out.w = a.w;
  return out;
};

/**
 * Sets the components of a vector to the given values.
 *
 * @param {vec4} out - The vector to modified.
 * @param {Number} x - Value set to x component.
 * @param {Number} y - Value set to y component.
 * @param {Number} z - Value set to z component.
 * @param {Number} w - Value set to w component.
 * @returns {vec4} out.
 */
vec4.set = function set (out, x, y, z, w) {
  out.x = x;
  out.y = y;
  out.z = z;
  out.w = w;
  return out;
};

/**
 * Add two vectors.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec4} out - Vector to store result.
 * @param {vec4} a - The first operand.
 * @param {vec4} b - The second operand.
 * @returns {vec4} out.
 */
vec4.add = function add (out, a, b) {
  out.x = a.x + b.x;
  out.y = a.y + b.y;
  out.z = a.z + b.z;
  out.w = a.w + b.w;
  return out;
};

/**
 * Subtract two vectors.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec4} out - Vector to store result.
 * @param {vec4} a - The first operand.
 * @param {vec4} b - The second operand.
 * @returns {vec4} out.
 */
vec4.subtract = function subtract (out, a, b) {
  out.x = a.x - b.x;
  out.y = a.y - b.y;
  out.z = a.z - b.z;
  out.w = a.w - b.w;
  return out;
};

/**
 * Alias of {@link vec4.subtract}.
 */
vec4.sub = function sub (out, a, b) {
  return vec4.subtract(out, a, b);
};

/**
 * Performs multiply on each component of two vectors respectively.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec4} out - Vector to store result.
 * @param {vec4} a - The first operand.
 * @param {vec4} b - The second operand.
 * @returns {vec4} out.
 */
vec4.multiply = function multiply (out, a, b) {
  out.x = a.x * b.x;
  out.y = a.y * b.y;
  out.z = a.z * b.z;
  out.w = a.w * b.w;
  return out;
};

/**
 * Alias of {@link vec4.multiply}.
 */
vec4.mul = function mul (out, a, b) {
  return vec4.multiply(out, a, b);
};

/**
 * Performs division on each component of two vectors respectively.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec4} out - Vector to store result.
 * @param {vec4} a - The first operand.
 * @param {vec4} b - The second operand.
 * @returns {vec4} out.
 */
vec4.divide = function divide (out, a, b) {
  out.x = a.x / b.x;
  out.y = a.y / b.y;
  out.z = a.z / b.z;
  out.w = a.w / b.w;
  return out;
};

/**
 * Alias of {@link vec4.divide}.
 */
vec4.div = function div (out, a, b) {
  return vec4.divide(out, a, b);
};

/**
 * Performs Math.ceil on each component of a vector.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec4} out - Vector to store result.
 * @param {vec4} a - Vector to perform operation.
 * @returns {vec4} out.
 */
vec4.ceil = function ceil (out, a) {
  out.x = Math.ceil(a.x);
  out.y = Math.ceil(a.y);
  out.z = Math.ceil(a.z);
  out.w = Math.ceil(a.w);
  return out;
};

/**
 * Performs Math.floor on each component of a vector.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec4} out - Vector to store result.
 * @param {vec4} a - Vector to perform operation.
 * @returns {vec4} out.
 */
vec4.floor = function floor (out, a) {
  out.x = Math.floor(a.x);
  out.y = Math.floor(a.y);
  out.z = Math.floor(a.z);
  out.w = Math.floor(a.w);
  return out;
};

/**
 * Performs Math.min on each component of two vectors respectively.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec4} out - Vector to store result.
 * @param {vec4} a - The first operand.
 * @param {vec4} b - The second operand.
 * @returns {vec4} out.
 */
vec4.min = function min (out, a, b) {
  out.x = Math.min(a.x, b.x);
  out.y = Math.min(a.y, b.y);
  out.z = Math.min(a.z, b.z);
  out.w = Math.min(a.w, b.w);
  return out;
};

/**
 * Performs Math.min on each component of two vectors respectively.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec4} out - Vector to store result.
 * @param {vec4} a - The first operand.
 * @param {vec4} b - The second operand.
 * @returns {vec4} out.
 */
vec4.max = function max (out, a, b) {
  out.x = Math.max(a.x, b.x);
  out.y = Math.max(a.y, b.y);
  out.z = Math.max(a.z, b.z);
  out.w = Math.max(a.w, b.w);
  return out;
};

/**
 * Performs Math.round on each component of a vector.
 *
 * It doesn't matter that any amount of these parameters refer to same vector.
 *
 * @param {vec4} out - Vector to store result.
 * @param {vec4} a - Vector to perform operation.
 * @returns {vec4} out.
 */
vec4.round = function round (out, a) {
  out.x = Math.round(a.x);
  out.y = Math.round(a.y);
  out.z = Math.round(a.z);
  out.w = Math.round(a.w);
  return out;
};

/**
 * Scales a vector with a number.
 *
 * @param {vec4} out - Vector to store result.
 * @param {vec4} a - Vector to scale.
 * @param {number} b - The scale number.
 * @returns {vec4} out.
 * */
vec4.scale = function scale (out, a, b) {
  out.x = a.x * b;
  out.y = a.y * b;
  out.z = a.z * b;
  out.w = a.w * b;
  return out;
};

/**
 * Add two vectors after scaling the second operand by a number.
 *
 * @param {vec4} out - Vector to store result.
 * @param {vec4} a - The first operand.
 * @param {vec4} b - The second operand.
 * @param {number} scale - The scale number before adding.
 * @returns {vec4} out.
 */
vec4.scaleAndAdd = function scaleAndAdd (out, a, b, scale) {
  out.x = a.x + (b.x * scale);
  out.y = a.y + (b.y * scale);
  out.z = a.z + (b.z * scale);
  out.w = a.w + (b.w * scale);
  return out;
};

/**
 * Calculates the euclidian distance between two vectors.
 *
 * @param {vec4} a - The first operand.
 * @param {vec4} b - The second operand.
 * @returns {number} Distance between a and b.
 */
vec4.distance = function distance (a, b) {
  var x = b.x - a.x,
    y = b.y - a.y,
    z = b.z - a.z,
    w = b.w - a.w;
  return Math.sqrt(x * x + y * y + z * z + w * w);
};

/**
 * Alias of {@link vec4.distance}.
 */
vec4.dist = function dist (a, b) {
  return vec4.distance(a, b);
};

/**
 * Calculates the squared euclidian distance between two vectors.
 *
 * @param {vec4} a - The first operand.
 * @param {vec4} b - The second operand.
 * @returns {number} Squared distance between a and b.
 */
vec4.squaredDistance = function squaredDistance (a, b) {
  var x = b.x - a.x,
    y = b.y - a.y,
    z = b.z - a.z,
    w = b.w - a.w;
  return x * x + y * y + z * z + w * w;
};

/**
 * Alias of {@link vec4.squaredDistance}.
 */
vec4.sqrDist = function sqrDist (a, b) {
  return vec4.squaredDistance(a, b);
};

/**
 * Calculates the length of a vector.
 *
 * @param {vec4} a - The vector.
 * @returns {Number} Length of the vector.
 */
vec4.magnitude = function magnitude (a) {
  var x = a.x,
    y = a.y,
    z = a.z,
    w = a.w;
  return Math.sqrt(x * x + y * y + z * z + w * w);
};

/**
 *Alias of {@link vec4.magnitude}.
 */
vec4.mag = function mag (a) {
  return vec4.magnitude(a);
};

/**
 * Calculates the squared length of a vector.
 *
 * @param {vec4} a - The vector.
 * @returns {Number} Squared length of the vector.
 */
vec4.squaredMagnitude = function squaredMagnitude (a) {
  var x = a.x,
    y = a.y,
    z = a.z,
    w = a.w;
  return x * x + y * y + z * z + w * w;
};

/**
 *Alias of {@link vec4.squaredMagnitude}
 */
vec4.sqrMag = function sqrMag (a) {
  return vec4.squaredMagnitude(a);
};

/**
 * Negates each component of a vector.
 *
 * @param {vec4} out - Vector to store result.
 * @param {vec4} a - Vector to negate.
 * @returns {vec4} out.
 */
vec4.negate = function negate (out, a) {
  out.x = -a.x;
  out.y = -a.y;
  out.z = -a.z;
  out.w = -a.w;
  return out;
};

/**
 * Inverts the components of a vector.
 *
 * @param {vec4} out - Vector to store result.
 * @param {vec4} a - Vector to invert.
 * @returns {vec4} out.
 */
vec4.inverse = function inverse (out, a) {
  out.x = 1.0 / a.x;
  out.y = 1.0 / a.y;
  out.z = 1.0 / a.z;
  out.w = 1.0 / a.w;
  return out;
};

/**
 * Safely inverts the components of a vector.
 *
 * @param {vec4} out - Vector to store result.
 * @param {vec4} a - Vector to invert.
 * @returns {vec4} out.
 */
vec4.inverseSafe = function inverseSafe (out, a) {
  var x = a.x,
    y = a.y,
    z = a.z,
    w = a.w;

  if (Math.abs(x) < EPSILON) {
    out.x = 0;
  } else {
    out.x = 1.0 / x;
  }

  if (Math.abs(y) < EPSILON) {
    out.y = 0;
  } else {
    out.y = 1.0 / y;
  }

  if (Math.abs(z) < EPSILON) {
    out.z = 0;
  } else {
    out.z = 1.0 / z;
  }

  if (Math.abs(w) < EPSILON) {
    out.w = 0;
  } else {
    out.w = 1.0 / w;
  }

  return out;
};

/**
 * Normalizes a vector.
 *
 * @param {vec4} out - Vector to store result.
 * @param {vec4} a - Vector to normalize.
 * @returns {vec4} out.
 */
vec4.normalize = function normalize (out, a)
{
  var x = a.x,
    y = a.y,
    z = a.z,
    w = a.w;
  var len = x * x + y * y + z * z + w * w;
  if (len > 0)
  {
    len = 1 / Math.sqrt(len);
    out.x = x * len;
    out.y = y * len;
    out.z = z * len;
    out.w = w * len;
  }
  return out;
};

/**
 * Calculates the dot product of two vectors.
 *
 * @param {vec4} a - The first operand.
 * @param {vec4} b - The second operand.
 * @returns {Number} Dot product of a and b.
 */
vec4.dot = function dot (a, b) {
  return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
};

/**
 * Performs a linear interpolation between two vectors.
 *
 * @param {vec4} out - Vector to store result.
 * @param {vec4} a - The first operand.
 * @param {vec4} b - The second operand.
 * @param {Number} t - The interpolation coefficient.
 * @returns {vec4} out.
 */
vec4.lerp = function lerp$$1 (out, a, b, t) {
  var ax = a.x,
    ay = a.y,
    az = a.z,
    aw = a.w;
  out.x = ax + t * (b.x - ax);
  out.y = ay + t * (b.y - ay);
  out.z = az + t * (b.z - az);
  out.w = aw + t * (b.w - aw);
  return out;
};

/**
 * Generates a random vector with the given scale.
 *
 * @param {vec4} out - Vector to store result.
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned.
 * @returns {vec4} out.
 */
vec4.random = function random$1 (out, scale) {
  scale = scale || 1.0;

  //TODO: This is a pretty awful way of doing this. Find something better.
  out.x = random();
  out.y = random();
  out.z = random();
  out.w = random();
  vec4.normalize(out, out);
  vec4.scale(out, out, scale);
  return out;
};

/**
 * Transforms a vector with a 4x4 matrix.
 *
 * @param {vec4} out - Vector to store result.
 * @param {vec4} a - Vector to transform.
 * @param {mat4} m - The matrix.
 * @returns {vec4} out.
 */
vec4.transformMat4 = function transformMat4 (out, a, m) {
  var x = a.x, y = a.y, z = a.z, w = a.w;
  out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12 * w;
  out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13 * w;
  out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14 * w;
  out.w = m.m03 * x + m.m07 * y + m.m11 * z + m.m15 * w;
  return out;
};

/**
 * Transforms a vector with a quaternion.
 *
 * @param {vec4} out - Vector to store result.
 * @param {vec4} a - Vector to transform.
 * @param {quat} q - The quaternion.
 * @returns {vec4} out.
 */
vec4.transformQuat = function transformQuat (out, a, q) {
  var x = a.x, y = a.y, z = a.z;
  var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

  // calculate quat * vec
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out.w = a.w;
  return out;
};

/**
 * Returns string representation of a vector.
 *
 * @param {vec4} a - The vector.
 * @returns {String} - String representation of this vector.
 */
vec4.str = function str (a) {
  return ("vec4(" + (a.x) + ", " + (a.y) + ", " + (a.z) + ", " + (a.w) + ")");
};

/**
 * Store components of a vector into array.
 *
 * @param {Array} out - Array to store result.
 * @param {vec4} v - The vector.
 * @returns {Array} out.
 */
vec4.array = function array (out, v) {
  out[0] = v.x;
  out[1] = v.y;
  out[2] = v.z;
  out[3] = v.w;

  return out;
};

/**
 * Returns whether the specified vectors are equal. (Compared using ===)
 *
 * @param {vec4} a - The first vector.
 * @param {vec4} b - The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.exactEquals = function exactEquals (a, b) {
  return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
};

/**
 * Returns whether the specified vectors are approximately equal.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are approximately equal, false otherwise.
 */
vec4.equals = function equals$$1 (a, b) {
  var a0 = a.x, a1 = a.y, a2 = a.z, a3 = a.w;
  var b0 = b.x, b1 = b.y, b2 = b.z, b3 = b.w;
  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
    Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
    Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
    Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

/**
 * Performs some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over.
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed.
 * @param {Number} offset Number of elements to skip at the beginning of the array.
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array.
 * @param {Function} fn Function to call for each vector in the array.
 * @param {Object} [arg] additional argument to pass to fn.
 * @returns {Array} a.
 */
vec4.forEach = function forEach (a, stride, offset, count, fn, arg) {
  return vec4._forEach(a, stride, offset, count, fn, arg);
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over.
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed.
 * @param {Number} offset Number of elements to skip at the beginning of the array.
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array.
 * @param {Function} fn Function to call for each vector in the array.
 * @param {Object} [arg] additional argument to pass to fn.
 * @returns {Array} a.
 * @ignore
 */
vec4._forEach = (function () {
  var vec = vec4.zero();

  return function (a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec.x = a[i];
      vec.y = a[i + 1];
      vec.z = a[i + 2];
      vec.w = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec.x;
      a[i + 1] = vec.y;
      a[i + 2] = vec.z;
      a[i + 3] = vec.w;
    }

    return a;
  };
})();

var mat3 = function mat3(
  m00, m01, m02, m03,
  m04, m05, m06, m07,
  m08
) {
  /**
   * The element at column 0 row 0.
   * @type {number}
   * */
  this.m00 = m00;

  /**
   * The element at column 0 row 1.
   * @type {number}
   * */
  this.m01 = m01;

  /**
   * The element at column 0 row 2.
   * @type {number}
   * */
  this.m02 = m02;

  /**
   * The element at column 1 row 0.
   * @type {number}
   * */
  this.m03 = m03;

  /**
   * The element at column 1 row 1.
   * @type {number}
   * */
  this.m04 = m04;

  /**
   * The element at column 1 row 2.
   * @type {number}
   * */
  this.m05 = m05;

  /**
   * The element at column 2 row 0.
   * @type {number}
   * */
  this.m06 = m06;

  /**
   * The element at column 2 row 1.
   * @type {number}
   * */
  this.m07 = m07;

  /**
   * The element at column 2 row 2.
   * @type {number}
   * */
  this.m08 = m08;
};

/**
 * Creates a new identity matrix.
 *
 * @returns {mat3} The newly created matrix.
 */
mat3.create = function create () {
  return new mat3(
    1, 0, 0,
    0, 1, 0,
    0, 0, 1
  );
};

/**
 * Creates a matrix, with elements specified separately.
 *
 * @param {Number} m00 - Value assigned to element at column 0 row 0.
 * @param {Number} m01 - Value assigned to element at column 0 row 1.
 * @param {Number} m02 - Value assigned to element at column 0 row 2.
 * @param {Number} m03 - Value assigned to element at column 1 row 0.
 * @param {Number} m04 - Value assigned to element at column 1 row 1.
 * @param {Number} m05 - Value assigned to element at column 1 row 2.
 * @param {Number} m06 - Value assigned to element at column 2 row 0.
 * @param {Number} m07 - Value assigned to element at column 2 row 1.
 * @param {Number} m08 - Value assigned to element at column 2 row 2.
 * @returns {mat3} The newly created matrix.
 */
mat3.new = function new$1 (m00, m01, m02, m03, m04, m05, m06, m07, m08) {
  return new mat3(m00, m01, m02, m03, m04, m05, m06, m07, m08);
};

/**
 * Clone a matrix.
 *
 * @param {mat3} a - Matrix to clone.
 * @returns {mat3} The newly created matrix.
 */
mat3.clone = function clone (a) {
  return new mat3(
    a.m00, a.m01, a.m02,
    a.m03, a.m04, a.m05,
    a.m06, a.m07, a.m08
  );
};

/**
 * Copy content of a matrix into another.
 *
 * @param {mat3} out - Matrix to modified.
 * @param {mat3} a - The specified matrix.
 * @returns {mat3} out.
 */
mat3.copy = function copy (out, a) {
  out.m00 = a.m00;
  out.m01 = a.m01;
  out.m02 = a.m02;
  out.m03 = a.m03;
  out.m04 = a.m04;
  out.m05 = a.m05;
  out.m06 = a.m06;
  out.m07 = a.m07;
  out.m08 = a.m08;
  return out;
};

/**
 * Sets the elements of a matrix to the given values.
 *
 * @param {mat3} out - The matrix to modified.
 * @param {Number} m00 - Value assigned to element at column 0 row 0.
 * @param {Number} m01 - Value assigned to element at column 0 row 1.
 * @param {Number} m02 - Value assigned to element at column 0 row 2.
 * @param {Number} m10 - Value assigned to element at column 1 row 0.
 * @param {Number} m11 - Value assigned to element at column 1 row 1.
 * @param {Number} m12 - Value assigned to element at column 1 row 2.
 * @param {Number} m20 - Value assigned to element at column 2 row 0.
 * @param {Number} m21 - Value assigned to element at column 2 row 1.
 * @param {Number} m22 - Value assigned to element at column 2 row 2.
 * @returns {mat3} out.
 */
mat3.set = function set (out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out.m00 = m00;
  out.m01 = m01;
  out.m02 = m02;
  out.m03 = m10;
  out.m04 = m11;
  out.m05 = m12;
  out.m06 = m20;
  out.m07 = m21;
  out.m08 = m22;
  return out;
};

/**
 * Sets a matrix as identity matrix.
 *
 * @param {mat3} out - Matrix to modified.
 * @returns {mat3} out.
 */
mat3.identity = function identity (out) {
  out.m00 = 1;
  out.m01 = 0;
  out.m02 = 0;
  out.m03 = 0;
  out.m04 = 1;
  out.m05 = 0;
  out.m06 = 0;
  out.m07 = 0;
  out.m08 = 1;
  return out;
};

/**
 * Transposes a matrix.
 *
 * @param {mat3} out - Matrix to store result.
 * @param {mat3} a - Matrix to transpose.
 * @returns {mat3} out.
 */
mat3.transpose = function transpose (out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a.m01, a02 = a.m02, a12 = a.m05;
    out.m01 = a.m03;
    out.m02 = a.m06;
    out.m03 = a01;
    out.m05 = a.m07;
    out.m06 = a02;
    out.m07 = a12;
  } else {
    out.m00 = a.m00;
    out.m01 = a.m03;
    out.m02 = a.m06;
    out.m03 = a.m01;
    out.m04 = a.m04;
    out.m05 = a.m07;
    out.m06 = a.m02;
    out.m07 = a.m05;
    out.m08 = a.m08;
  }

  return out;
};

/**
 * Inverts a matrix.
 *
 * @param {mat3} out - Matrix to store result.
 * @param {mat3} a - Matrix to invert.
 * @returns {mat3} out.
 */
mat3.invert = function invert (out, a) {
  var a00 = a.m00, a01 = a.m01, a02 = a.m02,
    a10 = a.m03, a11 = a.m04, a12 = a.m05,
    a20 = a.m06, a21 = a.m07, a22 = a.m08;

  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;

  // Calculate the determinant
  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out.m00 = b01 * det;
  out.m01 = (-a22 * a01 + a02 * a21) * det;
  out.m02 = (a12 * a01 - a02 * a11) * det;
  out.m03 = b11 * det;
  out.m04 = (a22 * a00 - a02 * a20) * det;
  out.m05 = (-a12 * a00 + a02 * a10) * det;
  out.m06 = b21 * det;
  out.m07 = (-a21 * a00 + a01 * a20) * det;
  out.m08 = (a11 * a00 - a01 * a10) * det;
  return out;
};

/**
 * Calculates the adjugate of a matrix.
 *
 * @param {mat3} out - Matrix to store result.
 * @param {mat3} a - Matrix to calculate.
 * @returns {mat3} out.
 */
mat3.adjoint = function adjoint (out, a) {
  var a00 = a.m00, a01 = a.m01, a02 = a.m02,
    a10 = a.m03, a11 = a.m04, a12 = a.m05,
    a20 = a.m06, a21 = a.m07, a22 = a.m08;

  out.m00 = (a11 * a22 - a12 * a21);
  out.m01 = (a02 * a21 - a01 * a22);
  out.m02 = (a01 * a12 - a02 * a11);
  out.m03 = (a12 * a20 - a10 * a22);
  out.m04 = (a00 * a22 - a02 * a20);
  out.m05 = (a02 * a10 - a00 * a12);
  out.m06 = (a10 * a21 - a11 * a20);
  out.m07 = (a01 * a20 - a00 * a21);
  out.m08 = (a00 * a11 - a01 * a10);
  return out;
};

/**
 * Calculates the determinant of a matrix.
 *
 * @param {mat3} a - Matrix to calculate.
 * @returns {Number} Determinant of a.
 */
mat3.determinant = function determinant (a) {
  var a00 = a.m00, a01 = a.m01, a02 = a.m02,
    a10 = a.m03, a11 = a.m04, a12 = a.m05,
    a20 = a.m06, a21 = a.m07, a22 = a.m08;

  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiply two matrices explicitly.
 *
 * @param {mat3} out - Matrix to store result.
 * @param {mat3} a - The first operand.
 * @param {mat3} b - The second operand.
 * @returns {mat3} out.
 */
mat3.multiply = function multiply (out, a, b) {
  var a00 = a.m00, a01 = a.m01, a02 = a.m02,
    a10 = a.m03, a11 = a.m04, a12 = a.m05,
    a20 = a.m06, a21 = a.m07, a22 = a.m08;

  var b00 = b.m00, b01 = b.m01, b02 = b.m02;
  var b10 = b.m03, b11 = b.m04, b12 = b.m05;
  var b20 = b.m06, b21 = b.m07, b22 = b.m08;

  out.m00 = b00 * a00 + b01 * a10 + b02 * a20;
  out.m01 = b00 * a01 + b01 * a11 + b02 * a21;
  out.m02 = b00 * a02 + b01 * a12 + b02 * a22;

  out.m03 = b10 * a00 + b11 * a10 + b12 * a20;
  out.m04 = b10 * a01 + b11 * a11 + b12 * a21;
  out.m05 = b10 * a02 + b11 * a12 + b12 * a22;

  out.m06 = b20 * a00 + b21 * a10 + b22 * a20;
  out.m07 = b20 * a01 + b21 * a11 + b22 * a21;
  out.m08 = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
};

/**
 * Alias of {@link mat3.multiply}.
 */
mat3.mul = function mul (out, a, b) {
  return mat3.multiply(out, a, b);
};

/**
 * Multiply a matrix with a translation matrix given by a translation offset.
 *
 * @param {mat3} out - Matrix to store result.
 * @param {mat3} a - Matrix to multiply.
 * @param {vec2} v - The translation offset.
 * @returns {mat3} out.
 */
mat3.translate = function translate (out, a, v) {
  var a00 = a.m00, a01 = a.m01, a02 = a.m02,
    a10 = a.m03, a11 = a.m04, a12 = a.m05,
    a20 = a.m06, a21 = a.m07, a22 = a.m08;
  var x = v.x, y = v.y;

  out.m00 = a00;
  out.m01 = a01;
  out.m02 = a02;

  out.m03 = a10;
  out.m04 = a11;
  out.m05 = a12;

  out.m06 = x * a00 + y * a10 + a20;
  out.m07 = x * a01 + y * a11 + a21;
  out.m08 = x * a02 + y * a12 + a22;
  return out;
};

/**
 * Rotates a matrix by the given angle.
 *
 * @param {mat3} out - Matrix to store result.
 * @param {mat3} a - Matrix to rotate.
 * @param {Number} rad - The rotation angle.
 * @returns {mat3} out
 */
mat3.rotate = function rotate (out, a, rad) {
  var a00 = a.m00, a01 = a.m01, a02 = a.m02,
    a10 = a.m03, a11 = a.m04, a12 = a.m05,
    a20 = a.m06, a21 = a.m07, a22 = a.m08;

  var s = Math.sin(rad);
  var c = Math.cos(rad);

  out.m00 = c * a00 + s * a10;
  out.m01 = c * a01 + s * a11;
  out.m02 = c * a02 + s * a12;

  out.m03 = c * a10 - s * a00;
  out.m04 = c * a11 - s * a01;
  out.m05 = c * a12 - s * a02;

  out.m06 = a20;
  out.m07 = a21;
  out.m08 = a22;
  return out;
};

/**
 * Multiply a matrix with a scale matrix given by a scale vector.
 *
 * @param {mat3} out - Matrix to store result.
 * @param {mat3} a - Matrix to multiply.
 * @param {vec2} v - The scale vector.
 * @returns {mat3} out
 **/
mat3.scale = function scale (out, a, v) {
  var x = v.x, y = v.y;

  out.m00 = x * a.m00;
  out.m01 = x * a.m01;
  out.m02 = x * a.m02;

  out.m03 = y * a.m03;
  out.m04 = y * a.m04;
  out.m05 = y * a.m05;

  out.m06 = a.m06;
  out.m07 = a.m07;
  out.m08 = a.m08;
  return out;
};

/**
 * Copies the upper-left 3x3 values of a 4x4 matrix into a 3x3 matrix.
 *
 * @param {mat3} out - Matrix to store result.
 * @param {mat4} a - The 4x4 matrix.
 * @returns {mat3} out.
 */
mat3.fromMat4 = function fromMat4 (out, a) {
  out.m00 = a.m00;
  out.m01 = a.m01;
  out.m02 = a.m02;
  out.m03 = a.m04;
  out.m04 = a.m05;
  out.m05 = a.m06;
  out.m06 = a.m08;
  out.m07 = a.m09;
  out.m08 = a.m10;
  return out;
};

/**
 * Creates a matrix from a translation offset.
 * This is equivalent to (but much faster than):
 *
 *   mat3.identity(dest);
 *   mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out - Matrix to store result.
 * @param {vec2} v - The translation offset.
 * @returns {mat3} out.
 */
mat3.fromTranslation = function fromTranslation (out, v) {
  out.m00 = 1;
  out.m01 = 0;
  out.m02 = 0;
  out.m03 = 0;
  out.m04 = 1;
  out.m05 = 0;
  out.m06 = v.x;
  out.m07 = v.y;
  out.m08 = 1;
  return out;
};

/**
 * Creates a matrix from a given angle.
 * This is equivalent to (but much faster than):
 *
 *   mat3.identity(dest);
 *   mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out - Matrix to store result.
 * @param {Number} rad - The rotation angle.
 * @returns {mat3} out.
 */
mat3.fromRotation = function fromRotation (out, rad) {
  var s = Math.sin(rad), c = Math.cos(rad);

  out.m00 = c;
  out.m01 = s;
  out.m02 = 0;

  out.m03 = -s;
  out.m04 = c;
  out.m05 = 0;

  out.m06 = 0;
  out.m07 = 0;
  out.m08 = 1;
  return out;
};

/**
 * Creates a matrix from a scale vector.
 * This is equivalent to (but much faster than):
 *
 *   mat3.identity(dest);
 *   mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out - Matrix to store result.
 * @param {vec2} v - Scale vector.
 * @returns {mat3} out.
 */
mat3.fromScaling = function fromScaling (out, v) {
  out.m00 = v.x;
  out.m01 = 0;
  out.m02 = 0;

  out.m03 = 0;
  out.m04 = v.y;
  out.m05 = 0;

  out.m06 = 0;
  out.m07 = 0;
  out.m08 = 1;
  return out;
};

/**
 * Copies the values from a 2x3 matrix into a 3x3 matrix.
 *
 * @param {mat3} out - Matrix to store result.
 * @param {mat23} a - The 2x3 matrix.
 * @returns {mat3} out.
 **/
mat3.fromMat2d = function fromMat2d (out, a) {
  out.m00 = a.m00;
  out.m01 = a.m01;
  out.m02 = 0;

  out.m03 = a.m02;
  out.m04 = a.m03;
  out.m05 = 0;

  out.m06 = a.m04;
  out.m07 = a.m05;
  out.m08 = 1;
  return out;
};

/**
 * Calculates a 3x3 matrix from the given quaternion.
 *
 * @param {mat3} out - Matrix to store result.
 * @param {quat} q - The quaternion.
 *
 * @returns {mat3} out.
 */
mat3.fromQuat = function fromQuat (out, q) {
  var x = q.x, y = q.y, z = q.z, w = q.w;
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  out.m00 = 1 - yy - zz;
  out.m03 = yx - wz;
  out.m06 = zx + wy;

  out.m01 = yx + wz;
  out.m04 = 1 - xx - zz;
  out.m07 = zy - wx;

  out.m02 = zx - wy;
  out.m05 = zy + wx;
  out.m08 = 1 - xx - yy;

  return out;
};

/**
 * Calculates a 3x3 matrix from view direction and up direction.
 *
 * @param {mat3} out - Matrix to store result.
 * @param {vec3} view - View direction (must be normalized).
 * @param {vec3} [up] - Up direction, default is (0,1,0) (must be normalized).
 *
 * @returns {mat3} out
 */
mat3.fromViewUp = function fromViewUp (out, view, up) {
  return mat3._fromViewUp(out, view, up);
};

/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix.
 *
 * @param {mat3} out - Matrix to store result.
 * @param {mat4} a - A 4x4 matrix to derive the normal matrix from.
 *
 * @returns {mat3} out.
 */
mat3.normalFromMat4 = function normalFromMat4 (out, a) {
  var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03,
    a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07,
    a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11,
    a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15;

  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det;

  out.m03 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out.m04 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out.m05 = (a01 * b08 - a00 * b10 - a03 * b06) * det;

  out.m06 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out.m07 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out.m08 = (a30 * b04 - a31 * b02 + a33 * b00) * det;

  return out;
};

/**
 * Returns a string representation of a matrix.
 *
 * @param {mat3} a - The matrix.
 * @returns {String} String representation of this matrix.
 */
mat3.str = function str (a) {
  return ("mat3(" + (a.m00) + ", " + (a.m01) + ", " + (a.m02) + ", " + (a.m03) + ", " + (a.m04) + ", " + (a.m05) + ", " + (a.m06) + ", " + (a.m07) + ", " + (a.m08) + ")");
};

/**
 * Store elements of a matrix into array.
 *
 * @param {array} out - Array to store result.
 * @param {mat3} m - The matrix.
 * @returns {Array} out.
 */
mat3.array = function array (out, m) {
  out[0] = m.m00;
  out[1] = m.m01;
  out[2] = m.m02;
  out[3] = m.m03;
  out[4] = m.m04;
  out[5] = m.m05;
  out[6] = m.m06;
  out[7] = m.m07;
  out[8] = m.m08;

  return out;
};

/**
 * Returns Frobenius norm of a matrix.
 *
 * @param {mat3} a - Matrix to calculate Frobenius norm of.
 * @returns {Number} - The frobenius norm.
 */
mat3.frob = function frob (a) {
  return (Math.sqrt(Math.pow(a.m00, 2) + Math.pow(a.m01, 2) + Math.pow(a.m02, 2) + Math.pow(a.m03, 2) + Math.pow(a.m04, 2) + Math.pow(a.m05, 2) + Math.pow(a.m06, 2) + Math.pow(a.m07, 2) + Math.pow(a.m08, 2)));
};

/**
 * Adds two matrices.
 *
 * @param {mat3} out - Matrix to store result.
 * @param {mat3} a - The first operand.
 * @param {mat3} b - The second operand.
 * @returns {mat3} out.
 */
mat3.add = function add (out, a, b) {
  out.m00 = a.m00 + b.m00;
  out.m01 = a.m01 + b.m01;
  out.m02 = a.m02 + b.m02;
  out.m03 = a.m03 + b.m03;
  out.m04 = a.m04 + b.m04;
  out.m05 = a.m05 + b.m05;
  out.m06 = a.m06 + b.m06;
  out.m07 = a.m07 + b.m07;
  out.m08 = a.m08 + b.m08;
  return out;
};

/**
 * Subtracts matrix b from matrix a.
 *
 * @param {mat3} out - Matrix to store result.
 * @param {mat3} a - The first operand.
 * @param {mat3} b - The second operand.
 * @returns {mat3} out.
 */
mat3.subtract = function subtract (out, a, b) {
  out.m00 = a.m00 - b.m00;
  out.m01 = a.m01 - b.m01;
  out.m02 = a.m02 - b.m02;
  out.m03 = a.m03 - b.m03;
  out.m04 = a.m04 - b.m04;
  out.m05 = a.m05 - b.m05;
  out.m06 = a.m06 - b.m06;
  out.m07 = a.m07 - b.m07;
  out.m08 = a.m08 - b.m08;
  return out;
};

/**
 * Alias of {@link mat3.subtract}.
 */
mat3.sub = function sub (out, a, b) {
  return mat3.subtract(out, a, b);
};

/**
 * Multiply each element of a matrix by a scalar number.
 *
 * @param {mat3} out - Matrix to store result.
 * @param {mat3} a - Matrix to scale
 * @param {Number} b - The scale number.
 * @returns {mat3} out.
 */
mat3.multiplyScalar = function multiplyScalar (out, a, b) {
  out.m00 = a.m00 * b;
  out.m01 = a.m01 * b;
  out.m02 = a.m02 * b;
  out.m03 = a.m03 * b;
  out.m04 = a.m04 * b;
  out.m05 = a.m05 * b;
  out.m06 = a.m06 * b;
  out.m07 = a.m07 * b;
  out.m08 = a.m08 * b;
  return out;
};

/**
 * Adds two matrices after multiplying each element of the second operand by a scalar number.
 *
 * @param {mat3} out - Matrix to store result.
 * @param {mat3} a - The first operand.
 * @param {mat3} b - The second operand.
 * @param {Number} scale - The scale number.
 * @returns {mat3} out.
 */
mat3.multiplyScalarAndAdd = function multiplyScalarAndAdd (out, a, b, scale) {
  out.m00 = a.m00 + (b.m00 * scale);
  out.m01 = a.m01 + (b.m01 * scale);
  out.m02 = a.m02 + (b.m02 * scale);
  out.m03 = a.m03 + (b.m03 * scale);
  out.m04 = a.m04 + (b.m04 * scale);
  out.m05 = a.m05 + (b.m05 * scale);
  out.m06 = a.m06 + (b.m06 * scale);
  out.m07 = a.m07 + (b.m07 * scale);
  out.m08 = a.m08 + (b.m08 * scale);
  return out;
};

/**
 * Returns whether the specified matrices are equal. (Compared using ===)
 *
 * @param {mat3} a - The first matrix.
 * @param {mat3} b - The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.exactEquals = function exactEquals (a, b) {
  return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 &&
    a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 &&
    a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08;
};

/**
 * Returns whether the specified matrices are approximately equal.
 *
 * @param {mat3} a - The first matrix.
 * @param {mat3} b - The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.equals = function equals$$1 (a, b) {
  var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05, a6 = a.m06, a7 = a.m07, a8 = a.m08;
  var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03, b4 = b.m04, b5 = b.m05, b6 = b.m06, b7 = b.m07, b8 = b.m08;
  return (
    Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
    Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
    Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
    Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
    Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
    Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
    Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
    Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
    Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8))
  );
};

mat3._fromViewUp = (function () {
  var default_up = vec3.new(0, 1, 0);
  var x = vec3.zero();
  var y = vec3.zero();

  return function (out, view, up) {
    if (vec3.sqrMag(view) < EPSILON * EPSILON) {
      mat3.identity(out);
      return out;
    }

    up = up || default_up;
    vec3.normalize(x, vec3.cross(x, up, view));

    if (vec3.sqrMag(x) < EPSILON * EPSILON) {
      mat3.identity(out);
      return out;
    }

    vec3.cross(y, view, x);
    mat3.set(
      out,
      x.x, x.y, x.z,
      y.x, y.y, y.z,
      view.x, view.y, view.z
    );

    return out;
  };
})();

var quat = function quat(x, y, z, w) {
  /**
   * The x component.
   * @type {number}
   * */
  this.x = x;

  /**
   * The y component.
   * @type {number}
   * */
  this.y = y;

  /**
   * The z component.
   * @type {number}
   * */
  this.z = z;

  /**
   * The w component.
   * @type {number}
   * */
  this.w = w;
};

/**
 * Creates a quaternion, with components specified separately.
 *
 * @param {number} x - Value assigned to x component.
 * @param {number} y - Value assigned to y component.
 * @param {number} z - Value assigned to z component.
 * @param {number} w - Value assigned to w component.
 * @return {quat} The newly created quaternion.
 */
quat.new = function new$1 (x, y, z, w) {
  return new quat(x, y, z, w);
};

/**
 * Creates an identity quaternion.
 *
 * @returns {quat} The newly created quaternion.
 */
quat.create = function create () {
  return new quat(0, 0, 0, 1);
};

/**
 * Clone a quaternion.
 *
 * @param {quat} a - Quaternion to clone.
 * @returns {quat} The newly created quaternion.
 */
quat.clone = function clone (a) {
  return new quat(a.x, a.y, a.z, a.w);
};

/**
 * Copy content of a quaternion into another.
 *
 * @param {quat} out - Quaternion to modified.
 * @param {quat} a - The specified quaternion.
 * @returns {quat} out.
 */
quat.copy = function copy (out, a) {
  return vec4.copy(out, a);
};

/**
 * Sets the components of a quaternion to the given values.
 *
 * @param {quat} out - The quaternion to modified.
 * @param {Number} x - Value set to x component.
 * @param {Number} y - Value set to y component.
 * @param {Number} z - Value set to z component.
 * @param {Number} w - Value set to w component.
 * @returns {quat} out.
 */
quat.set = function set (out, x, y, z, w) {
  out.x = x;
  out.y = y;
  out.z = z;
  out.w = w;
  return out;
};

/**
 * Sets a quaternion as identity quaternion.
 *
 * @param {quat} out - Quaternion to set.
 * @returns {quat} out.
 */
quat.identity = function identity (out) {
  out.x = 0;
  out.y = 0;
  out.z = 0;
  out.w = 1;
  return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out - Quaternion to set.
 * @param {vec3} a - The initial vector.
 * @param {vec3} b - The destination vector.
 * @returns {quat} out.
 */
quat.rotationTo = function rotationTo (out, a, b) {
  return quat._rotationTo(out, a, b);
};

/**
 * Gets the rotation axis and angle for a given
 *quaternion. If a quaternion is created with
 *fromAxisAngle, this method will return the same
 *values as provided in the original parameter list
 *OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *angle -90 is the same as the quaternion formed by
 *[0, 0, 1] and 270. This method favors the latter.
 * @param{vec3} out_axis - Vector to store the rotation axis.
 * @param{quat} q - Quaternion to be decomposed.
 * @return {Number} - Angle, in radians, of the rotation.
 */
quat.getAxisAngle = function getAxisAngle (out_axis, q) {
  var rad = Math.acos(q.w) * 2.0;
  var s = Math.sin(rad / 2.0);
  if (s != 0.0) {
    out_axis.x = q.x / s;
    out_axis.y = q.y / s;
    out_axis.z = q.z / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis.x = 1;
    out_axis.y = 0;
    out_axis.z = 0;
  }
  return rad;
};

/**
 * Multiply two quaternions.
 *
 * @param {quat} out - Quaternion to store result.
 * @param {quat} a - The first operand.
 * @param {quat} b - The second operand.
 * @returns {quat} out.
 */
quat.multiply = function multiply (out, a, b) {
  var ax = a.x, ay = a.y, az = a.z, aw = a.w,
    bx = b.x, by = b.y, bz = b.z, bw = b.w;

  out.x = ax * bw + aw * bx + ay * bz - az * by;
  out.y = ay * bw + aw * by + az * bx - ax * bz;
  out.z = az * bw + aw * bz + ax * by - ay * bx;
  out.w = aw * bw - ax * bx - ay * by - az * bz;
  return out;
};

/**
 * Alias of {@link quat.multiply}.
 */
quat.mul = function mul (out, a, b) {
  return quat.multiply(out, a, b);
};

/**
 * Scales a quaternion with a number.
 *
 * @param {quat} out - Quaternion to store result.
 * @param {quat} a - Quaternion to scale.
 * @param {quat} b - The scale number.
 * @returns {quat} out.
 * */
quat.scale = function scale (out, a, b) {
  out.x = a.x * b;
  out.y = a.y * b;
  out.z = a.z * b;
  out.w = a.w * b;
  return out;
};

/**
 * Rotates a quaternion by the given angle about the X axis.
 *
 * @param {quat} out - Quaternion to store result.
 * @param {quat} a - Quaternion to rotate.
 * @param {number} rad - Angle (in radians) to rotate.
 * @returns {quat} out.
 */
quat.rotateX = function rotateX (out, a, rad) {
  rad *= 0.5;

  var ax = a.x, ay = a.y, az = a.z, aw = a.w,
    bx = Math.sin(rad), bw = Math.cos(rad);

  out.x = ax * bw + aw * bx;
  out.y = ay * bw + az * bx;
  out.z = az * bw - ay * bx;
  out.w = aw * bw - ax * bx;
  return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis.
 *
 * @param {quat} out - Quaternion to store result.
 * @param {quat} a - Quaternion to rotate.
 * @param {number} rad - Angle (in radians) to rotate.
 * @returns {quat} out.
 */
quat.rotateY = function rotateY (out, a, rad) {
  rad *= 0.5;

  var ax = a.x, ay = a.y, az = a.z, aw = a.w,
    by = Math.sin(rad), bw = Math.cos(rad);

  out.x = ax * bw - az * by;
  out.y = ay * bw + aw * by;
  out.z = az * bw + ax * by;
  out.w = aw * bw - ay * by;
  return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis.
 *
 * @param {quat} out - Quaternion to store result.
 * @param {quat} a - Quaternion to rotate.
 * @param {number} rad - Angle (in radians) to rotate.
 * @returns {quat} out.
 */
quat.rotateZ = function rotateZ (out, a, rad) {
  rad *= 0.5;

  var ax = a.x, ay = a.y, az = a.z, aw = a.w,
    bz = Math.sin(rad), bw = Math.cos(rad);

  out.x = ax * bw + ay * bz;
  out.y = ay * bw - ax * bz;
  out.z = az * bw + aw * bz;
  out.w = aw * bw - az * bz;
  return out;
};

/**
 * Rotates a quaternion by the given angle about a world space axis.
 *
 * @param {quat} out - Quaternion to store result.
 * @param {quat} rot - Quaternion to rotate.
 * @param {vec3} axis - The axis around which to rotate in world space.
 * @param {number} rad - Angle (in radians) to rotate.
 * @returns {quat} out.
 */
quat.rotateAround = function rotateAround (out, rot, axis, rad) {
  return quat._rotateAround(out, rot, axis, rad);
};

/**
 * Rotates a quaternion by the given angle about a local space axis.
 *
 * @param {quat} out - Quaternion to store result.
 * @param {quat} rot - Quaternion to rotate.
 * @param {vec3} axis - The axis around which to rotate in local space.
 * @param {number} rad - Angle (in radians) to rotate.
 * @returns {quat} out.
 */
quat.rotateAroundLocal = function rotateAroundLocal (out, rot, axis, rad) {
  return quat._rotateAroundLocal(out, rot, axis, rad);
};

/**
 * Calculates the W component of a quaternion from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out - Quaternion to store result.
 * @param {quat} a - Quaternion to calculate W.
 * @returns {quat} out.
 */
quat.calculateW = function calculateW (out, a) {
  var x = a.x, y = a.y, z = a.z;

  out.x = x;
  out.y = y;
  out.z = z;
  out.w = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
};

/**
 * Calculates the dot product of two quaternions.
 *
 * @param {quat} a - The first operand.
 * @param {quat} b - The second operand.
 * @returns {Number} - The dot product of a and b.
 */
quat.dot = function dot (a, b) {
  return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
};

/**
 * Performs a linear interpolation between two quaternions.
 *
 * @param {quat} out - Quaternion to store result.
 * @param {quat} a - The first operand.
 * @param {quat} b - The second operand.
 * @param {Number} t - The interpolation coefficient.
 * @returns {quat} out.
 */
quat.lerp = function lerp (out, a, b, t) {
  var ax = a.x,
    ay = a.y,
    az = a.z,
    aw = a.w;
  out.x = ax + t * (b.x - ax);
  out.y = ay + t * (b.y - ay);
  out.z = az + t * (b.z - az);
  out.w = aw + t * (b.w - aw);
  return out;
};

/**
 * Performs a spherical linear interpolation between two quaternions.
 *
 * @param {quat} out - Quaternion to store result.
 * @param {quat} a - The first operand.
 * @param {quat} b - The second operand.
 * @param {Number} t - The interpolation coefficient.
 * @returns {quat} out.
 */
quat.slerp = function slerp (out, a, b, t) {
  // benchmarks:
  //  http://jsperf.com/quaternion-slerp-implementations

  var ax = a.x, ay = a.y, az = a.z, aw = a.w,
    bx = b.x, by = b.y, bz = b.z, bw = b.w;

  var omega, cosom, sinom, scale0, scale1;

  // calc cosine
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  // adjust signs (if necessary)
  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  // calculate coefficients
  if ((1.0 - cosom) > 0.000001) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  }
  // calculate final values
  out.x = scale0 * ax + scale1 * bx;
  out.y = scale0 * ay + scale1 * by;
  out.z = scale0 * az + scale1 * bz;
  out.w = scale0 * aw + scale1 * bw;

  return out;
};

/**
 * Performs a spherical linear interpolation with two control points.
 *
 * @param {quat} out - Quaternion to store result.
 * @param {quat} a - The first operand.
 * @param {quat} b - The second operand.
 * @param {quat} c - The third operand.
 * @param {quat} d - The fourth operand.
 * @param {Number} t - The interpolation coefficient.
 * @returns {quat} out
 */
quat.sqlerp = function sqlerp (out, a, b, c, d, t) {
  return quat._sqlerp(out, a, b, c, d, t);
};

/**
 * Calculates the inverse of a quaternion.
 *
 * @param {quat} out - Quaternion to store result.
 * @param {quat} a - Quaternion to calculate inverse of.
 * @returns {quat} out.
 */
quat.invert = function invert (out, a) {
  var a0 = a.x, a1 = a.y, a2 = a.z, a3 = a.w;
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0;

  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out.x = -a0 * invDot;
  out.y = -a1 * invDot;
  out.z = -a2 * invDot;
  out.w = a3 * invDot;
  return out;
};

/**
 * Calculates the conjugate of a quaternion.
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out - Quaternion to store result.
 * @param {quat} a - Quaternion to calculate conjugate of.
 * @returns {quat} out.
 */
quat.conjugate = function conjugate (out, a) {
  out.x = -a.x;
  out.y = -a.y;
  out.z = -a.z;
  out.w = a.w;
  return out;
};

/**
 * Calculates the length of a quaternion.
 *
 * @param {quat} a - The quaternion.
 * @returns {Number} Length of the quaternion.
 */
quat.magnitude = function magnitude (a) {
  var x = a.x,
    y = a.y,
    z = a.z,
    w = a.w;
  return Math.sqrt(x * x + y * y + z * z + w * w);
};

/**
 *Alias of {@link quat.magnitude}.
 */
quat.mag = function mag (a) {
  return quat.magnitude(a);
};

/**
 * Calculates the squared length of a quaternion.
 *
 * @param {quat} a - The quaternion.
 * @returns {Number} Squared length of the quaternion.
 */
quat.squaredMagnitude = function squaredMagnitude (a) {
  var x = a.x,
    y = a.y,
    z = a.z,
    w = a.w;
  return x * x + y * y + z * z + w * w;
};

/**
 *Alias of {@link quat.squaredMagnitude}
 */
quat.sqrMag = function sqrMag (a) {
  return quat.squaredMagnitude(a);
};

/**
 * Normalizes a quaternion.
 *
 * @param {quat} out - Quaternion to store result.
 * @param {quat} a - Quaternion to normalize.
 * @returns {quat} out.
 * @function
 */
quat.normalize = function normalize (out, a) {
  var x = a.x,
    y = a.y,
    z = a.z,
    w = a.w;
  var len = x * x + y * y + z * z + w * w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    out.x = x * len;
    out.y = y * len;
    out.z = z * len;
    out.w = w * len;
  }
  return out;
};

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {quat} out - Quaternion to store result.
 * @param {vec3} xAxis - Vector representing the local "right" direction.
 * @param {vec3} yAxis - Vector representing the local "up" direction.
 * @param {vec3} zAxis - Vector representing the viewing direction.
 * @returns {quat} out.
 */
quat.fromAxes = function fromAxes (out, xAxis, yAxis, zAxis) {
  return quat._fromAxes(out, xAxis, yAxis, zAxis);
};

/**
 * Calculates a quaternion from view direction and up direction
 *
 * @param {quat} out - Quaternion to store result.
 * @param {vec3} view - View direction (must be normalized).
 * @param {vec3} [up] - Up direction, default is (0,1,0) (must be normalized).
 *
 * @returns {quat} out.
 */
quat.fromViewUp = function fromViewUp (out, view, up) {
  return quat._fromViewUp(out, view, up);
};

/**
 * Sets a quaternion from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out - Quaternion to store result.
 * @param {vec3} axis - The axis around which to rotate.
 * @param {Number} rad - The angle in radians.
 * @returns {quat} out.
 **/
quat.fromAxisAngle = function fromAxisAngle (out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out.x = s * axis.x;
  out.y = s * axis.y;
  out.z = s * axis.z;
  out.w = Math.cos(rad);
  return out;
};

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to re-normalize the quaternion yourself where necessary.
 *
 * @param {quat} out - Quaternion to store result.
 * @param {mat3} m - The rotation matrix.
 * @returns {quat} out.
 * @function
 */
quat.fromMat3 = function fromMat3 (out, m) {
  // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

  var m00 = m.m00, m01 = m.m03, m02 = m.m06,
    m10 = m.m01, m11 = m.m04, m12 = m.m07,
    m20 = m.m02, m21 = m.m05, m22 = m.m08;

  var trace = m00 + m11 + m22;

  if (trace > 0) {
    var s = 0.5 / Math.sqrt(trace + 1.0);

    out.w = 0.25 / s;
    out.x = (m21 - m12) * s;
    out.y = (m02 - m20) * s;
    out.z = (m10 - m01) * s;

  } else if ((m00 > m11) && (m00 > m22)) {
    var s$1 = 2.0 * Math.sqrt(1.0 + m00 - m11 - m22);

    out.w = (m21 - m12) / s$1;
    out.x = 0.25 * s$1;
    out.y = (m01 + m10) / s$1;
    out.z = (m02 + m20) / s$1;

  } else if (m11 > m22) {
    var s$2 = 2.0 * Math.sqrt(1.0 + m11 - m00 - m22);

    out.w = (m02 - m20) / s$2;
    out.x = (m01 + m10) / s$2;
    out.y = 0.25 * s$2;
    out.z = (m12 + m21) / s$2;

  } else {
    var s$3 = 2.0 * Math.sqrt(1.0 + m22 - m00 - m11);

    out.w = (m10 - m01) / s$3;
    out.x = (m02 + m20) / s$3;
    out.y = (m12 + m21) / s$3;
    out.z = 0.25 * s$3;
  }

  return out;
};

/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out - Quaternion to store result.
 * @param {number} x - Angle to rotate around X axis in degrees.
 * @param {number} y - Angle to rotate around Y axis in degrees.
 * @param {number} z - Angle to rotate around Z axis in degrees.
 * @returns {quat} out.
 * @function
 */
quat.fromEuler = function fromEuler (out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;

  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);

  out.x = sx * cy * cz - cx * sy * sz;
  out.y = cx * sy * cz + sx * cy * sz;
  out.z = cx * cy * sz - sx * sy * cz;
  out.w = cx * cy * cz + sx * sy * sz;

  return out;
};

/**
 * Returns string representation of a quaternion.
 *
 * @param {quat} a - The quaternion.
 * @returns {String} - String representation of this quaternion.
 */
quat.str = function str (a) {
  return ("quat(" + (a.x) + ", " + (a.y) + ", " + (a.z) + ", " + (a.w) + ")");
};

/**
 * Store components of a quaternion into array.
 *
 * @param {Array} out - Array to store result.
 * @param {quat} q - The quaternion.
 * @returns {Array} out.
 */
quat.array = function array (out, q) {
  out[0] = q.x;
  out[1] = q.y;
  out[2] = q.z;
  out[3] = q.w;

  return out;
};

/**
 * Returns whether the specified quaternions are equal. (Compared using ===)
 *
 * @param {quat} a - The first quaternion.
 * @param {quat} b - The second quaternion.
 * @returns {Boolean} True if the quaternions are equal, false otherwise.
 */
quat.exactEquals = function exactEquals (a, b) {
  return vec4.exactEquals(a, b);
};

/**
 * Returns whether the specified quaternions are approximately equal.
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the quaternions are approximately equal, false otherwise.
 */
quat.equals = function equals (a, b) {
  return vec4.equals(a, b);
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 * @ignore
 */
quat._rotationTo = (function ()
{
  var tmpvec3 = vec3.zero();
  var xUnitVec3 = vec3.new(1, 0, 0);
  var yUnitVec3 = vec3.new(0, 1, 0);

  return function (out, a, b)
  {
    var dot = vec3.dot(a, b);
    if (dot < -0.999999)
    {
      vec3.cross(tmpvec3, xUnitVec3, a);
      if (vec3.magnitude(tmpvec3) < 0.000001)
      {
        vec3.cross(tmpvec3, yUnitVec3, a);
      }
      vec3.normalize(tmpvec3, tmpvec3);
      quat.fromAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999)
    {
      out.x = 0;
      out.y = 0;
      out.z = 0;
      out.w = 1;
      return out;
    } else
    {
      vec3.cross(tmpvec3, a, b);
      out.x = tmpvec3.x;
      out.y = tmpvec3.y;
      out.z = tmpvec3.z;
      out.w = 1 + dot;
      return quat.normalize(out, out);
    }
  };
})();

/**
 * Rotates a quaternion by the given angle about the axis in world space
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} rot quat to rotate
 * @param {vec3} axis the axis around which to rotate in world space
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 * @ignore
 */
quat._rotateAround = (function () {
  var v3_tmp = vec3.zero();
  var q_tmp = quat.create();

  return function (out, rot, axis, rad) {
    // get inv-axis (local to rot)
    quat.invert(q_tmp, rot);
    vec3.transformQuat(v3_tmp, axis, q_tmp);
    // rotate by inv-axis
    quat.fromAxisAngle(q_tmp, v3_tmp, rad);
    quat.mul(out, rot, q_tmp);

    return out;
  };
})();

/**
 * Rotates a quaternion by the given angle about the axis in local space
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} rot quat to rotate
 * @param {vec3} axis the axis around which to rotate in local space
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 * @ignore
 */
quat._rotateAroundLocal = (function () {
  var q_tmp = quat.create();

  return function (out, rot, axis, rad) {
    quat.fromAxisAngle(q_tmp, axis, rad);
    quat.mul(out, rot, q_tmp);

    return out;
  };
})();

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 * @ignore
 */
quat._sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();

  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));

    return out;
  };
}());

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} xAxis the vector representing the local "right" direction
 * @param {vec3} yAxis the vector representing the local "up" direction
 * @param {vec3} zAxis the vector representing the viewing direction
 * @returns {quat} out
 * @ignore
 */
quat._fromAxes = (function () {
  var matr = mat3.create();

  return function (out, xAxis, yAxis, zAxis) {
    mat3.set(matr,
      xAxis.x, xAxis.y, xAxis.z,
      yAxis.x, yAxis.y, yAxis.z,
      zAxis.x, zAxis.y, zAxis.z
    );
    return quat.normalize(out, quat.fromMat3(out, matr));
  };
})();

/**
 * Calculates a quaternion from view direction and up direction
 *
 * @param {quat} out mat3 receiving operation result
 * @param {vec3} view view direction (must be normalized)
 * @param {vec3} [up] up direction, default is (0,1,0) (must be normalized)
 *
 * @returns {quat} out
 * @ignore
 */
quat._fromViewUp = (function () {
  var matr = mat3.create();

  return function (out, view, up) {
    mat3.fromViewUp(matr, view, up);
    if (!matr) {
      return null;
    }

    return quat.normalize(out, quat.fromMat3(out, matr));
  };
})();

var mat2 = function mat2(m00, m01, m02, m03) {
  /**
   * The element at column 0 row 0.
   * @type {number}
   * */
  this.m00 = m00;

  /**
   * The element at column 0 row 1.
   * @type {number}
   * */
  this.m01 = m01;

  /**
   * The element at column 1 row 0.
   * @type {number}
   * */
  this.m02 = m02;

  /**
   * The element at column 1 row 1.
   * @type {number}
   * */
  this.m03 = m03;
};

/**
 * Creates a new identity matrix.
 *
 * @returns {mat2} The newly created matrix.
 */
mat2.create = function create () {
  return new mat2(1, 0, 0, 1);
};

/**
 * Creates a matrix, with elements specified separately.
 *
 * @param {Number} m00 - Value assigned to element at column 0 row 0.
 * @param {Number} m01 - Value assigned to element at column 0 row 1.
 * @param {Number} m02 - Value assigned to element at column 1 row 0.
 * @param {Number} m03 - Value assigned to element at column 1 row 1.
 * @returns {mat2} The newly created matrix.
 */
mat2.new = function new$1 (m00, m01, m02, m03) {
  return new mat2(m00, m01, m02, m03);
};

/**
 * Clone a matrix.
 *
 * @param {mat2} a - Matrix to clone.
 * @returns {mat2} The newly created matrix.
 */
mat2.clone = function clone (a) {
  return new mat2(a.m00, a.m01, a.m02, a.m03);
};

/**
 * Copy content of a matrix into another.
 *
 * @param {mat2} out - Matrix to modified.
 * @param {mat2} a - The specified matrix.
 * @returns {mat2} out.
 */
mat2.copy = function copy (out, a) {
  out.m00 = a.m00;
  out.m01 = a.m01;
  out.m02 = a.m02;
  out.m03 = a.m03;
  return out;
};

/**
 * Sets a matrix as identity matrix.
 *
 * @param {mat2} out - Matrix to modified.
 * @returns {mat2} out.
 */
mat2.identity = function identity (out) {
  out.m00 = 1;
  out.m01 = 0;
  out.m02 = 0;
  out.m03 = 1;
  return out;
};

/**
 * Sets the elements of a matrix to the given values.
 *
 * @param {mat2} out - The matrix to modified.
 * @param {Number} m00 - Value assigned to element at column 0 row 0.
 * @param {Number} m01 - Value assigned to element at column 0 row 1.
 * @param {Number} m10 - Value assigned to element at column 1 row 0.
 * @param {Number} m11 - Value assigned to element at column 1 row 1.
 * @returns {mat2} out.
 */
mat2.set = function set (out, m00, m01, m10, m11) {
  out.m00 = m00;
  out.m01 = m01;
  out.m02 = m10;
  out.m03 = m11;
  return out;
};


/**
 * Transposes a matrix.
 *
 * @param {mat2} out - Matrix to store result.
 * @param {mat2} a - Matrix to transpose.
 * @returns {mat2} out.
 */
mat2.transpose = function transpose (out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a1 = a.m01;
    out.m01 = a.m02;
    out.m02 = a1;
  } else {
    out.m00 = a.m00;
    out.m01 = a.m02;
    out.m02 = a.m01;
    out.m03 = a.m03;
  }

  return out;
};

/**
 * Inverts a matrix.
 *
 * @param {mat2} out - Matrix to store result.
 * @param {mat2} a - Matrix to invert.
 * @returns {mat2} out.
 */
mat2.invert = function invert (out, a) {
  var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03;

  // Calculate the determinant
  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out.m00 = a3 * det;
  out.m01 = -a1 * det;
  out.m02 = -a2 * det;
  out.m03 = a0 * det;

  return out;
};

/**
 * Calculates the adjugate of a matrix.
 *
 * @param {mat2} out - Matrix to store result.
 * @param {mat2} a - Matrix to calculate.
 * @returns {mat2} out.
 */
mat2.adjoint = function adjoint (out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a.m00;
  out.m00 = a.m03;
  out.m01 = -a.m01;
  out.m02 = -a.m02;
  out.m03 = a0;

  return out;
};

/**
 * Calculates the determinant of a matrix.
 *
 * @param {mat2} a - Matrix to calculate.
 * @returns {Number} Determinant of a.
 */
mat2.determinant = function determinant (a) {
  return a.m00 * a.m03 - a.m02 * a.m01;
};

/**
 * Multiply two matrices explicitly.
 *
 * @param {mat2} out - Matrix to store result.
 * @param {mat2} a - The first operand.
 * @param {mat2} b - The second operand.
 * @returns {mat2} out.
 */
mat2.multiply = function multiply (out, a, b) {
  var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03;
  var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03;
  out.m00 = a0 * b0 + a2 * b1;
  out.m01 = a1 * b0 + a3 * b1;
  out.m02 = a0 * b2 + a2 * b3;
  out.m03 = a1 * b2 + a3 * b3;
  return out;
};

/**
 * Alias of {@link mat2.multiply}.
 */
mat2.mul = function mul (out, a, b) {
  return mat2.multiply(out, a, b);
};

/**
 * Rotates a matrix by the given angle.
 *
 * @param {mat2} out - Matrix to store result.
 * @param {mat2} a - Matrix to rotate.
 * @param {Number} rad - The rotation angle.
 * @returns {mat2} out
 */
mat2.rotate = function rotate (out, a, rad) {
  var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03,
    s = Math.sin(rad),
    c = Math.cos(rad);
  out.m00 = a0 * c + a2 * s;
  out.m01 = a1 * c + a3 * s;
  out.m02 = a0 * -s + a2 * c;
  out.m03 = a1 * -s + a3 * c;
  return out;
};

/**
 * Scales the matrix given by a scale vector.
 *
 * @param {mat2} out - Matrix to store result.
 * @param {mat2} a - Matrix to scale.
 * @param {vec2} v - The scale vector.
 * @returns {mat2} out
 **/
mat2.scale = function scale (out, a, v) {
  var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03,
    v0 = v.x, v1 = v.y;
  out.m00 = a0 * v0;
  out.m01 = a1 * v0;
  out.m02 = a2 * v1;
  out.m03 = a3 * v1;
  return out;
};

/**
 * Creates a matrix from a given angle.
 * This is equivalent to (but much faster than):
 *
 *   mat2.identity(dest);
 *   mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out - Matrix to store result.
 * @param {Number} rad - The rotation angle.
 * @returns {mat2} out.
 */
mat2.fromRotation = function fromRotation (out, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad);
  out.m00 = c;
  out.m01 = s;
  out.m02 = -s;
  out.m03 = c;
  return out;
};

/**
 * Creates a matrix from a scale vector.
 * This is equivalent to (but much faster than):
 *
 *   mat2.identity(dest);
 *   mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out - Matrix to store result.
 * @param {vec2} v - Scale vector.
 * @returns {mat2} out.
 */
mat2.fromScaling = function fromScaling (out, v) {
  out.m00 = v.x;
  out.m01 = 0;
  out.m02 = 0;
  out.m03 = v.y;
  return out;
};

/**
 * Returns a string representation of a matrix.
 *
 * @param {mat2} a - The matrix.
 * @returns {String} String representation of this matrix.
 */
mat2.str = function str (a) {
  return ("mat2(" + (a.m00) + ", " + (a.m01) + ", " + (a.m02) + ", " + (a.m03) + ")");
};

/**
 * Store elements of a matrix into array.
 *
 * @param {array} out - Array to store result.
 * @param {mat2} m - The matrix.
 * @returns {Array} out.
 */
mat2.array = function array (out, m) {
  out[0] = m.m00;
  out[1] = m.m01;
  out[2] = m.m02;
  out[3] = m.m03;

  return out;
};

/**
 * Returns Frobenius norm of a matrix.
 *
 * @param {mat2} a - Matrix to calculate Frobenius norm of.
 * @returns {Number} - The frobenius norm.
 */
mat2.frob = function frob (a) {
  return (Math.sqrt(Math.pow(a.m00, 2) + Math.pow(a.m01, 2) + Math.pow(a.m02, 2) + Math.pow(a.m03, 2)));
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix.
 * @param {mat2} L - The lower triangular matrix.
 * @param {mat2} D - The diagonal matrix.
 * @param {mat2} U - The upper triangular matrix.
 * @param {mat2} a - The input matrix to factorize.
 */
mat2.LDU = function LDU (L, D, U, a) {
  L.m02 = a.m02 / a.m00;
  U.m00 = a.m00;
  U.m01 = a.m01;
  U.m03 = a.m03 - L.m02 * U.m01;
};

/**
 * Adds two matrices.
 *
 * @param {mat2} out - Matrix to store result.
 * @param {mat2} a - The first operand.
 * @param {mat2} b - The second operand.
 * @returns {mat2} out.
 */
mat2.add = function add (out, a, b) {
  out.m00 = a.m00 + b.m00;
  out.m01 = a.m01 + b.m01;
  out.m02 = a.m02 + b.m02;
  out.m03 = a.m03 + b.m03;
  return out;
};

/**
 * Subtracts matrix b from matrix a.
 *
 * @param {mat2} out - Matrix to store result.
 * @param {mat2} a - The first operand.
 * @param {mat2} b - The second operand.
 * @returns {mat2} out.
 */
mat2.subtract = function subtract (out, a, b) {
  out.m00 = a.m00 - b.m00;
  out.m01 = a.m01 - b.m01;
  out.m02 = a.m02 - b.m02;
  out.m03 = a.m03 - b.m03;
  return out;
};

/**
 * Alias of {@link mat2.subtract}.
 */
mat2.sub = function sub (out, a, b) {
  return mat2.subtract(out, a, b);
};

/**
 * Returns whether the specified matrices are equal. (Compared using ===)
 *
 * @param {mat2} a - The first matrix.
 * @param {mat2} b - The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.exactEquals = function exactEquals (a, b) {
  return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03;
};

/**
 * Returns whether the specified matrices are approximately equal.
 *
 * @param {mat2} a - The first matrix.
 * @param {mat2} b - The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.equals = function equals$$1 (a, b) {
  var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03;
  var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03;
  return (
    Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
    Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
    Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
    Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3))
  );
};

/**
 * Multiply each element of a matrix by a scalar number.
 *
 * @param {mat2} out - Matrix to store result.
 * @param {mat2} a - Matrix to scale
 * @param {Number} b - The scale number.
 * @returns {mat2} out.
 */
mat2.multiplyScalar = function multiplyScalar (out, a, b) {
  out.m00 = a.m00 * b;
  out.m01 = a.m01 * b;
  out.m02 = a.m02 * b;
  out.m03 = a.m03 * b;
  return out;
};

/**
 * Adds two matrices after multiplying each element of the second operand by a scalar number.
 *
 * @param {mat2} out - Matrix to store result.
 * @param {mat2} a - The first operand.
 * @param {mat2} b - The second operand.
 * @param {Number} scale - The scale number.
 * @returns {mat2} out.
 */
mat2.multiplyScalarAndAdd = function multiplyScalarAndAdd (out, a, b, scale) {
  out.m00 = a.m00 + (b.m00 * scale);
  out.m01 = a.m01 + (b.m01 * scale);
  out.m02 = a.m02 + (b.m02 * scale);
  out.m03 = a.m03 + (b.m03 * scale);
  return out;
};

var mat23 = function mat23(m00, m01, m02, m03, m04, m05) {
  /**
   * The element a.
   * @type {number}
   * */
  this.m00 = m00;

  /**
   * The element b.
   * @type {number}
   * */
  this.m01 = m01;

  /**
   * The element c.
   * @type {number}
   * */
  this.m02 = m02;

  /**
   * The element d.
   * @type {number}
   * */
  this.m03 = m03;

  /**
   * The element tx.
   * @type {number}
   * */
  this.m04 = m04;

  /**
   * The element ty.
   * @type {number}
   * */
  this.m05 = m05;
};

/**
 * Creates a new identity matrix.
 *
 * @returns {mat23} The newly created matrix.
 */
mat23.create = function create () {
  return new mat23(
    1, 0,
    0, 1,
    0, 0
  );
};

/**
 * Creates a matrix, with elements specified separately.
 *
 * @param {Number} m00 -Value assigned to element a.
 * @param {Number} m01 -Value assigned to element b.
 * @param {Number} m02 -Value assigned to element c.
 * @param {Number} m03 -Value assigned to element d.
 * @param {Number} m04 -Value assigned to element tx.
 * @param {Number} m05 -Value assigned to element ty.
 * @returns {mat23} The newly created matrix.
 */
mat23.new = function new$1 (m00, m01, m02, m03, m04, m05) {
  return new mat23(m00, m01, m02, m03, m04, m05);
};

/**
 * Clone a matrix.
 *
 * @param {mat23} a - Matrix to clone.
 * @returns {mat23} The newly created matrix.
 */
mat23.clone = function clone (a) {
  return new mat23(
    a.m00, a.m01,
    a.m02, a.m03,
    a.m04, a.m05
  );
};

/**
 * Copy content of a matrix into another.
 *
 * @param {mat23} out - Matrix to modified.
 * @param {mat23} a - The specified matrix.
 * @returns {mat23} out.
 */
mat23.copy = function copy (out, a) {
  out.m00 = a.m00;
  out.m01 = a.m01;
  out.m02 = a.m02;
  out.m03 = a.m03;
  out.m04 = a.m04;
  out.m05 = a.m05;
  return out;
};

/**
 * Sets a matrix as identity matrix.
 *
 * @param {mat23} out - Matrix to modified.
 * @returns {mat23} out.
 */
mat23.identity = function identity (out) {
  out.m00 = 1;
  out.m01 = 0;
  out.m02 = 0;
  out.m03 = 1;
  out.m04 = 0;
  out.m05 = 0;
  return out;
};

/**
 * Sets the elements of a matrix to the given values.
 *
 * @param {mat23} out - The matrix to modified.
 * @param {Number} a - Value assigned to element a.
 * @param {Number} b - Value assigned to element b.
 * @param {Number} c - Value assigned to element c.
 * @param {Number} d - Value assigned to element d.
 * @param {Number} tx - Value assigned to element tx.
 * @param {Number} ty - Value assigned to element ty.
 * @returns {mat23} out.
 */
mat23.set = function set (out, a, b, c, d, tx, ty) {
  out.m00 = a;
  out.m01 = b;
  out.m02 = c;
  out.m03 = d;
  out.m04 = tx;
  out.m05 = ty;
  return out;
};

/**
 * Inverts a matrix.
 *
 * @param {mat23} out - Matrix to store result.
 * @param {mat23} a - Matrix to invert.
 * @returns {mat23} out.
 */
mat23.invert = function invert (out, a) {
  var aa = a.m00, ab = a.m01, ac = a.m02, ad = a.m03,
    atx = a.m04, aty = a.m05;

  var det = aa * ad - ab * ac;
  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out.m00 = ad * det;
  out.m01 = -ab * det;
  out.m02 = -ac * det;
  out.m03 = aa * det;
  out.m04 = (ac * aty - ad * atx) * det;
  out.m05 = (ab * atx - aa * aty) * det;
  return out;
};

/**
 * Calculates the determinant of a matrix.
 *
 * @param {mat23} a - Matrix to calculate.
 * @returns {Number} Determinant of a.
 */
mat23.determinant = function determinant (a) {
  return a.m00 * a.m03 - a.m01 * a.m02;
};

/**
 * Multiply two matrices explicitly.
 *
 * @param {mat23} out - Matrix to store result.
 * @param {mat23} a - The first operand.
 * @param {mat23} b - The second operand.
 * @returns {mat23} out.
 */
mat23.multiply = function multiply (out, a, b) {
  var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05,
    b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03, b4 = b.m04, b5 = b.m05;
  out.m00 = a0 * b0 + a2 * b1;
  out.m01 = a1 * b0 + a3 * b1;
  out.m02 = a0 * b2 + a2 * b3;
  out.m03 = a1 * b2 + a3 * b3;
  out.m04 = a0 * b4 + a2 * b5 + a4;
  out.m05 = a1 * b4 + a3 * b5 + a5;
  return out;
};

/**
 * Alias of {@link mat23.multiply}.
 */
mat23.mul = function mul (out, a, b) {
  return mat23.multiply(out, a, b);
};

/**
 * Rotates a matrix by the given angle.
 *
 * @param {mat23} out - Matrix to store result.
 * @param {mat23} a - Matrix to rotate.
 * @param {Number} rad - The rotation angle.
 * @returns {mat23} out
 */
mat23.rotate = function rotate (out, a, rad) {
  var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05,
    s = Math.sin(rad),
    c = Math.cos(rad);
  out.m00 = a0 * c + a2 * s;
  out.m01 = a1 * c + a3 * s;
  out.m02 = a0 * -s + a2 * c;
  out.m03 = a1 * -s + a3 * c;
  out.m04 = a4;
  out.m05 = a5;
  return out;
};

/**
 * Multiply a matrix with a scale matrix given by a scale vector.
 *
 * @param {mat23} out - Matrix to store result.
 * @param {mat23} a - Matrix to multiply.
 * @param {vec2} v - The scale vector.
 * @returns {mat23} out
 **/
mat23.scale = function scale (out, a, v) {
  var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05,
    v0 = v.x, v1 = v.y;
  out.m00 = a0 * v0;
  out.m01 = a1 * v0;
  out.m02 = a2 * v1;
  out.m03 = a3 * v1;
  out.m04 = a4;
  out.m05 = a5;
  return out;
};

/**
 * Multiply a matrix with a translation matrix given by a translation offset.
 *
 * @param {mat23} out - Matrix to store result.
 * @param {mat23} a - Matrix to multiply.
 * @param {vec2} v - The translation offset.
 * @returns {mat23} out.
 */
mat23.translate = function translate (out, a, v) {
  var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05,
    v0 = v.x, v1 = v.y;
  out.m00 = a0;
  out.m01 = a1;
  out.m02 = a2;
  out.m03 = a3;
  out.m04 = a0 * v0 + a2 * v1 + a4;
  out.m05 = a1 * v0 + a3 * v1 + a5;
  return out;
};

/**
 * Creates a matrix from a given angle.
 * This is equivalent to (but much faster than):
 *
 *   mat23.identity(dest);
 *   mat23.rotate(dest, dest, rad);
 *
 * @param {mat23} out - Matrix to store result.
 * @param {Number} rad - The rotation angle.
 * @returns {mat23} out.
 */
mat23.fromRotation = function fromRotation (out, rad) {
  var s = Math.sin(rad), c = Math.cos(rad);
  out.m00 = c;
  out.m01 = s;
  out.m02 = -s;
  out.m03 = c;
  out.m04 = 0;
  out.m05 = 0;
  return out;
};

/**
 * Creates a matrix from a scale vector.
 * This is equivalent to (but much faster than):
 *
 *   mat23.identity(dest);
 *   mat23.scale(dest, dest, vec);
 *
 * @param {mat23} out - Matrix to store result.
 * @param {vec2} v - Scale vector.
 * @returns {mat23} out.
 */
mat23.fromScaling = function fromScaling (out, v) {
  out.m00 = v.m00;
  out.m01 = 0;
  out.m02 = 0;
  out.m03 = v.m01;
  out.m04 = 0;
  out.m05 = 0;
  return out;
};

/**
 * Creates a matrix from a translation offset.
 * This is equivalent to (but much faster than):
 *
 *   mat23.identity(dest);
 *   mat23.translate(dest, dest, vec);
 *
 * @param {mat23} out - Matrix to store result.
 * @param {vec2} v - The translation offset.
 * @returns {mat23} out.
 */
mat23.fromTranslation = function fromTranslation (out, v) {
  out.m00 = 1;
  out.m01 = 0;
  out.m02 = 0;
  out.m03 = 1;
  out.m04 = v.x;
  out.m05 = v.y;
  return out;
};

/**
 * Creates a matrix from a rotation, translation offset and scale vector.
 * This is equivalent to (but faster than):
 *
 *   mat23.identity(dest);
 *   mat23.translate(dest, vec);
 *   let tmp = mat23.create();
 *   mat23.fromRotation(tmp, rot);
 *   mat23.multiply(dest, dest, tmp);
 *   mat23.fromScaling(tmp, scale);
 *   mat23.multiply(dest, dest, tmp);
 *
 * @param {mat23} out - Matrix to store result.
 * @param {number} r - Rotation radian.
 * @param {vec2} t - Translation offset.
 * @param {vec2} s - Scale vector.
 * @returns {mat23} out.
 */
mat23.fromRTS = function fromRTS (out, r, t, s) {
  var sr = Math.sin(r), cr = Math.cos(r);
  out.m00 = cr * s.x;
  out.m01 = sr * s.x;
  out.m02 = -sr * s.y;
  out.m03 = cr * s.y;
  out.m04 = t.x;
  out.m05 = t.y;
  return out;
};

/**
 * Returns a string representation of a matrix.
 *
 * @param {mat23} a - The matrix.
 * @returns {String} String representation of this matrix.
 */
mat23.str = function str (a) {
  return ("mat23(" + (a.m00) + ", " + (a.m01) + ", " + (a.m02) + ", " + (a.m03) + ", " + (a.m04) + ", " + (a.m05) + ")");
};

/**
 * Store elements of a matrix into array.
 *
 * @param {array} out - Array to store result.
 * @param {mat23} m - The matrix.
 * @returns {Array} out.
 */
mat23.array = function array (out, m) {
  out[0] = m.m00;
  out[1] = m.m01;
  out[2] = m.m02;
  out[3] = m.m03;
  out[4] = m.m04;
  out[5] = m.m05;

  return out;
};

/**
 * Store elements of a matrix into 16 floats array.
 *
 * @param {array} out
 * @param {mat23} m
 * @returns {array}
 */
mat23.array4x4 = function array4x4 (out, m) {
  out[0] = m.m00;
  out[1] = m.m01;
  out[2] = 0;
  out[3] = 0;
  out[4] = m.m02;
  out[5] = m.m03;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = m.m04;
  out[13] = m.m05;
  out[14] = 0;
  out[15] = 1;

  return out;
};

/**
 * Returns Frobenius norm of a matrix.
 *
 * @param {mat23} a - Matrix to calculate Frobenius norm of.
 * @returns {Number} - The frobenius norm.
 */
mat23.frob = function frob (a) {
  return (Math.sqrt(Math.pow(a.m00, 2) + Math.pow(a.m01, 2) + Math.pow(a.m02, 2) + Math.pow(a.m03, 2) + Math.pow(a.m04, 2) + Math.pow(a.m05, 2) + 1));
};

/**
 * Adds two matrices.
 *
 * @param {mat23} out - Matrix to store result.
 * @param {mat23} a - The first operand.
 * @param {mat23} b - The second operand.
 * @returns {mat23} out.
 */
mat23.add = function add (out, a, b) {
  out.m00 = a.m00 + b.m00;
  out.m01 = a.m01 + b.m01;
  out.m02 = a.m02 + b.m02;
  out.m03 = a.m03 + b.m03;
  out.m04 = a.m04 + b.m04;
  out.m05 = a.m05 + b.m05;
  return out;
};

/**
 * Subtracts matrix b from matrix a.
 *
 * @param {mat23} out - Matrix to store result.
 * @param {mat23} a - The first operand.
 * @param {mat23} b - The second operand.
 * @returns {mat23} out.
 */
mat23.subtract = function subtract (out, a, b) {
  out.m00 = a.m00 - b.m00;
  out.m01 = a.m01 - b.m01;
  out.m02 = a.m02 - b.m02;
  out.m03 = a.m03 - b.m03;
  out.m04 = a.m04 - b.m04;
  out.m05 = a.m05 - b.m05;
  return out;
};

/**
 * Alias of {@link mat23.subtract}.
 */
mat23.sub = function sub (out, a, b) {
  return mat23.subtract(out, a, b);
};

/**
 * Multiply each element of a matrix by a scalar number.
 *
 * @param {mat23} out - Matrix to store result.
 * @param {mat23} a - Matrix to scale
 * @param {Number} b - The scale number.
 * @returns {mat23} out.
 */
mat23.multiplyScalar = function multiplyScalar (out, a, b) {
  out.m00 = a.m00 * b;
  out.m01 = a.m01 * b;
  out.m02 = a.m02 * b;
  out.m03 = a.m03 * b;
  out.m04 = a.m04 * b;
  out.m05 = a.m05 * b;
  return out;
};

/**
 * Adds two matrices after multiplying each element of the second operand by a scalar number.
 *
 * @param {mat23} out - Matrix to store result.
 * @param {mat23} a - The first operand.
 * @param {mat23} b - The second operand.
 * @param {Number} scale - The scale number.
 * @returns {mat23} out.
 */
mat23.multiplyScalarAndAdd = function multiplyScalarAndAdd (out, a, b, scale) {
  out.m00 = a.m00 + (b.m00 * scale);
  out.m01 = a.m01 + (b.m01 * scale);
  out.m02 = a.m02 + (b.m02 * scale);
  out.m03 = a.m03 + (b.m03 * scale);
  out.m04 = a.m04 + (b.m04 * scale);
  out.m05 = a.m05 + (b.m05 * scale);
  return out;
};

/**
 * Returns whether the specified matrices are equal. (Compared using ===)
 *
 * @param {mat23} a - The first matrix.
 * @param {mat23} b - The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat23.exactEquals = function exactEquals (a, b) {
  return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05;
};

/**
 * Returns whether the specified matrices are approximately equal.
 *
 * @param {mat23} a - The first matrix.
 * @param {mat23} b - The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat23.equals = function equals$$1 (a, b) {
  var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05;
  var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03, b4 = b.m04, b5 = b.m05;
  return (
    Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
    Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
    Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
    Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
    Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
    Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5))
  );
};

var mat4 = function mat4(
  m00, m01, m02, m03,
  m04, m05, m06, m07,
  m08, m09, m10, m11,
  m12, m13, m14, m15
) {
  /**
   * The element at column 0 row 0.
   * @type {number}
   * */
  this.m00 = m00;

  /**
   * The element at column 0 row 1.
   * @type {number}
   * */
  this.m01 = m01;

  /**
   * The element at column 0 row 2.
   * @type {number}
   * */
  this.m02 = m02;

  /**
   * The element at column 0 row 3.
   * @type {number}
   * */
  this.m03 = m03;

  /**
   * The element at column 1 row 0.
   * @type {number}
   * */
  this.m04 = m04;

  /**
   * The element at column 1 row 1.
   * @type {number}
   * */
  this.m05 = m05;

  /**
   * The element at column 1 row 2.
   * @type {number}
   * */
  this.m06 = m06;

  /**
   * The element at column 1 row 3.
   * @type {number}
   * */
  this.m07 = m07;

  /**
   * The element at column 2 row 0.
   * @type {number}
   * */
  this.m08 = m08;

  /**
   * The element at column 2 row 1.
   * @type {number}
   * */
  this.m09 = m09;

  /**
   * The element at column 2 row 2.
   * @type {number}
   * */
  this.m10 = m10;

  /**
   * The element at column 2 row 3.
   * @type {number}
   * */
  this.m11 = m11;

  /**
   * The element at column 3 row 0.
   * @type {number}
   * */
  this.m12 = m12;

  /**
   * The element at column 3 row 1.
   * @type {number}
   * */
  this.m13 = m13;

  /**
   * The element at column 3 row 2.
   * @type {number}
   * */
  this.m14 = m14;

  /**
   * The element at column 3 row 3.
   * @type {number}
   * */
  this.m15 = m15;
};

/**
 * Creates a matrix, with elements specified separately.
 *
 * @param {Number} m00 - Value assigned to element at column 0 row 0.
 * @param {Number} m01 - Value assigned to element at column 0 row 1.
 * @param {Number} m02 - Value assigned to element at column 0 row 2.
 * @param {Number} m03 - Value assigned to element at column 0 row 3.
 * @param {Number} m04 - Value assigned to element at column 1 row 0.
 * @param {Number} m05 - Value assigned to element at column 1 row 1.
 * @param {Number} m06 - Value assigned to element at column 1 row 2.
 * @param {Number} m07 - Value assigned to element at column 1 row 3.
 * @param {Number} m08 - Value assigned to element at column 2 row 0.
 * @param {Number} m09 - Value assigned to element at column 2 row 1.
 * @param {Number} m10 - Value assigned to element at column 2 row 2.
 * @param {Number} m11 - Value assigned to element at column 2 row 3.
 * @param {Number} m12 - Value assigned to element at column 3 row 0.
 * @param {Number} m13 - Value assigned to element at column 3 row 1.
 * @param {Number} m14 - Value assigned to element at column 3 row 2.
 * @param {Number} m15 - Value assigned to element at column 3 row 3.
 * @returns {mat4} The newly created matrix.
 */
mat4.new = function new$1 (
  m00, m01, m02, m03,
  m04, m05, m06, m07,
  m08, m09, m10, m11,
  m12, m13, m14, m15
) {
  return new mat4(
    m00, m01, m02, m03,
    m04, m05, m06, m07,
    m08, m09, m10, m11,
    m12, m13, m14, m15);
};

/**
 * Creates a new identity matrix.
 *
 * @returns {mat4} The newly created matrix.
 */
mat4.create = function create () {
  return new mat4(
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
  );
};

/**
 * Clone a matrix.
 *
 * @param {mat4} a - Matrix to clone.
 * @returns {mat4} The newly created matrix.
 */
mat4.clone = function clone (a) {
  return new mat4(
    a.m00, a.m01, a.m02, a.m03,
    a.m04, a.m05, a.m06, a.m07,
    a.m08, a.m09, a.m10, a.m11,
    a.m12, a.m13, a.m14, a.m15
  );
};

/**
 * Copy content of a matrix into another.
 *
 * @param {mat4} out - Matrix to modified.
 * @param {mat4} a - The specified matrix.
 * @returns {mat4} out.
 */
mat4.copy = function copy (out, a) {
  out.m00 = a.m00;
  out.m01 = a.m01;
  out.m02 = a.m02;
  out.m03 = a.m03;
  out.m04 = a.m04;
  out.m05 = a.m05;
  out.m06 = a.m06;
  out.m07 = a.m07;
  out.m08 = a.m08;
  out.m09 = a.m09;
  out.m10 = a.m10;
  out.m11 = a.m11;
  out.m12 = a.m12;
  out.m13 = a.m13;
  out.m14 = a.m14;
  out.m15 = a.m15;
  return out;
};

/**
 * Sets the elements of a matrix to the given values.
 *
 * @param {mat4} out - The matrix to modified.
 * @param {Number} m00 - Value assigned to element at column 0 row 0.
 * @param {Number} m01 - Value assigned to element at column 0 row 1.
 * @param {Number} m02 - Value assigned to element at column 0 row 2.
 * @param {Number} m03 - Value assigned to element at column 0 row 3.
 * @param {Number} m10 - Value assigned to element at column 1 row 0.
 * @param {Number} m11 - Value assigned to element at column 1 row 1.
 * @param {Number} m12 - Value assigned to element at column 1 row 2.
 * @param {Number} m13 - Value assigned to element at column 1 row 3.
 * @param {Number} m20 - Value assigned to element at column 2 row 0.
 * @param {Number} m21 - Value assigned to element at column 2 row 1.
 * @param {Number} m22 - Value assigned to element at column 2 row 2.
 * @param {Number} m23 - Value assigned to element at column 2 row 3.
 * @param {Number} m30 - Value assigned to element at column 3 row 0.
 * @param {Number} m31 - Value assigned to element at column 3 row 1.
 * @param {Number} m32 - Value assigned to element at column 3 row 2.
 * @param {Number} m33 - Value assigned to element at column 3 row 3.
 * @returns {mat4} out.
 */
mat4.set = function set (out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out.m00 = m00;
  out.m01 = m01;
  out.m02 = m02;
  out.m03 = m03;
  out.m04 = m10;
  out.m05 = m11;
  out.m06 = m12;
  out.m07 = m13;
  out.m08 = m20;
  out.m09 = m21;
  out.m10 = m22;
  out.m11 = m23;
  out.m12 = m30;
  out.m13 = m31;
  out.m14 = m32;
  out.m15 = m33;
  return out;
};


/**
 * Sets a matrix as identity matrix.
 *
 * @param {mat4} out - Matrix to modified.
 * @returns {mat4} out.
 */
mat4.identity = function identity (out) {
  out.m00 = 1;
  out.m01 = 0;
  out.m02 = 0;
  out.m03 = 0;
  out.m04 = 0;
  out.m05 = 1;
  out.m06 = 0;
  out.m07 = 0;
  out.m08 = 0;
  out.m09 = 0;
  out.m10 = 1;
  out.m11 = 0;
  out.m12 = 0;
  out.m13 = 0;
  out.m14 = 0;
  out.m15 = 1;
  return out;
};

/**
 * Transposes a matrix.
 *
 * @param {mat4} out - Matrix to store result.
 * @param {mat4} a - Matrix to transpose.
 * @returns {mat4} out.
 */
mat4.transpose = function transpose (out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a.m01, a02 = a.m02, a03 = a.m03,
      a12 = a.m06, a13 = a.m07,
      a23 = a.m11;

    out.m01 = a.m04;
    out.m02 = a.m08;
    out.m03 = a.m12;
    out.m04 = a01;
    out.m06 = a.m09;
    out.m07 = a.m13;
    out.m08 = a02;
    out.m09 = a12;
    out.m11 = a.m14;
    out.m12 = a03;
    out.m13 = a13;
    out.m14 = a23;
  } else {
    out.m00 = a.m00;
    out.m01 = a.m04;
    out.m02 = a.m08;
    out.m03 = a.m12;
    out.m04 = a.m01;
    out.m05 = a.m05;
    out.m06 = a.m09;
    out.m07 = a.m13;
    out.m08 = a.m02;
    out.m09 = a.m06;
    out.m10 = a.m10;
    out.m11 = a.m14;
    out.m12 = a.m03;
    out.m13 = a.m07;
    out.m14 = a.m11;
    out.m15 = a.m15;
  }

  return out;
};

/**
 * Inverts a matrix.
 *
 * @param {mat4} out - Matrix to store result.
 * @param {mat4} a - Matrix to invert.
 * @returns {mat4} out.
 */
mat4.invert = function invert (out, a) {
  var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03,
    a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07,
    a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11,
    a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15;

  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out.m01 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out.m02 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out.m03 = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out.m04 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out.m06 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out.m07 = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out.m08 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out.m09 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out.m11 = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out.m12 = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out.m13 = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out.m14 = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out.m15 = (a20 * b03 - a21 * b01 + a22 * b00) * det;

  return out;
};

/**
 * Calculates the adjugate of a matrix.
 *
 * @param {mat4} out - Matrix to store result.
 * @param {mat4} a - Matrix to calculate.
 * @returns {mat4} out.
 */
mat4.adjoint = function adjoint (out, a) {
  var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03,
    a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07,
    a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11,
    a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15;

  out.m00 = (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
  out.m01 = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out.m02 = (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
  out.m03 = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out.m04 = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out.m05 = (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
  out.m06 = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out.m07 = (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
  out.m08 = (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
  out.m09 = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out.m10 = (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
  out.m11 = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out.m12 = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out.m13 = (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
  out.m14 = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out.m15 = (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
  return out;
};

/**
 * Calculates the determinant of a matrix.
 *
 * @param {mat4} a - Matrix to calculate.
 * @returns {Number} Determinant of a.
 */
mat4.determinant = function determinant (a) {
  var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03,
    a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07,
    a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11,
    a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15;

  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiply two matrices explicitly.
 *
 * @param {mat4} out - Matrix to store result.
 * @param {mat4} a - The first operand.
 * @param {mat4} b - The second operand.
 * @returns {mat4} out.
 */
mat4.multiply = function multiply (out, a, b) {
  var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03,
    a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07,
    a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11,
    a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15;

  // Cache only the current line of the second matrix
  var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03;
  out.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

  b0 = b.m04; b1 = b.m05; b2 = b.m06; b3 = b.m07;
  out.m04 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out.m05 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out.m06 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out.m07 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

  b0 = b.m08; b1 = b.m09; b2 = b.m10; b3 = b.m11;
  out.m08 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out.m09 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out.m10 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out.m11 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

  b0 = b.m12; b1 = b.m13; b2 = b.m14; b3 = b.m15;
  out.m12 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out.m13 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out.m14 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out.m15 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
};

/**
 * Alias of {@link mat4.multiply}.
 */
mat4.mul = function mul (out, a, b) {
  return mat4.multiply(out, a, b);
};

/**
 * Multiply a matrix with a translation matrix given by a translation offset.
 *
 * @param {mat4} out - Matrix to store result.
 * @param {mat4} a - Matrix to multiply.
 * @param {vec3} v - The translation offset.
 * @returns {mat4} out.
 */
mat4.translate = function translate (out, a, v) {
  var x = v.x, y = v.y, z = v.z,
    a00, a01, a02, a03,
    a10, a11, a12, a13,
    a20, a21, a22, a23;

  if (a === out) {
    out.m12 = a.m00 * x + a.m04 * y + a.m08 * z + a.m12;
    out.m13 = a.m01 * x + a.m05 * y + a.m09 * z + a.m13;
    out.m14 = a.m02 * x + a.m06 * y + a.m10 * z + a.m14;
    out.m15 = a.m03 * x + a.m07 * y + a.m11 * z + a.m15;
  } else {
    a00 = a.m00; a01 = a.m01; a02 = a.m02; a03 = a.m03;
    a10 = a.m04; a11 = a.m05; a12 = a.m06; a13 = a.m07;
    a20 = a.m08; a21 = a.m09; a22 = a.m10; a23 = a.m11;

    out.m00 = a00; out.m01 = a01; out.m02 = a02; out.m03 = a03;
    out.m04 = a10; out.m05 = a11; out.m06 = a12; out.m07 = a13;
    out.m08 = a20; out.m09 = a21; out.m10 = a22; out.m11 = a23;

    out.m12 = a00 * x + a10 * y + a20 * z + a.m12;
    out.m13 = a01 * x + a11 * y + a21 * z + a.m13;
    out.m14 = a02 * x + a12 * y + a22 * z + a.m14;
    out.m15 = a03 * x + a13 * y + a23 * z + a.m15;
  }

  return out;
};

/**
 * Multiply a matrix with a scale matrix given by a scale vector.
 *
 * @param {mat4} out - Matrix to store result.
 * @param {mat4} a - Matrix to multiply.
 * @param {vec3} v - The scale vector.
 * @returns {mat4} out
 **/
mat4.scale = function scale (out, a, v) {
  var x = v.x, y = v.y, z = v.z;

  out.m00 = a.m00 * x;
  out.m01 = a.m01 * x;
  out.m02 = a.m02 * x;
  out.m03 = a.m03 * x;
  out.m04 = a.m04 * y;
  out.m05 = a.m05 * y;
  out.m06 = a.m06 * y;
  out.m07 = a.m07 * y;
  out.m08 = a.m08 * z;
  out.m09 = a.m09 * z;
  out.m10 = a.m10 * z;
  out.m11 = a.m11 * z;
  out.m12 = a.m12;
  out.m13 = a.m13;
  out.m14 = a.m14;
  out.m15 = a.m15;
  return out;
};

/**
 * Multiply a matrix with a rotation matrix denotes by the rotation around arbitrary axis.
 *
 * @param {mat4} out - Matrix to store result.
 * @param {mat4} a - Matrix to multiply.
 * @param {Number} rad - The rotation angle.
 * @param {vec3} axis - The rotation axis.
 * @returns {mat4} out.
 */
mat4.rotate = function rotate (out, a, rad, axis) {
  var x = axis.x, y = axis.y, z = axis.z;
  var s, c, t,
    a00, a01, a02, a03,
    a10, a11, a12, a13,
    a20, a21, a22, a23,
    b00, b01, b02,
    b10, b11, b12,
    b20, b21, b22;

  var len = Math.sqrt(x * x + y * y + z * z);

  if (Math.abs(len) < EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  a00 = a.m00; a01 = a.m01; a02 = a.m02; a03 = a.m03;
  a10 = a.m04; a11 = a.m05; a12 = a.m06; a13 = a.m07;
  a20 = a.m08; a21 = a.m09; a22 = a.m10; a23 = a.m11;

  // Construct the elements of the rotation matrix
  b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
  b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
  b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

  // Perform rotation-specific matrix multiplication
  out.m00 = a00 * b00 + a10 * b01 + a20 * b02;
  out.m01 = a01 * b00 + a11 * b01 + a21 * b02;
  out.m02 = a02 * b00 + a12 * b01 + a22 * b02;
  out.m03 = a03 * b00 + a13 * b01 + a23 * b02;
  out.m04 = a00 * b10 + a10 * b11 + a20 * b12;
  out.m05 = a01 * b10 + a11 * b11 + a21 * b12;
  out.m06 = a02 * b10 + a12 * b11 + a22 * b12;
  out.m07 = a03 * b10 + a13 * b11 + a23 * b12;
  out.m08 = a00 * b20 + a10 * b21 + a20 * b22;
  out.m09 = a01 * b20 + a11 * b21 + a21 * b22;
  out.m10 = a02 * b20 + a12 * b21 + a22 * b22;
  out.m11 = a03 * b20 + a13 * b21 + a23 * b22;

  // If the source and destination differ, copy the unchanged last row
  if (a !== out) {
    out.m12 = a.m12;
    out.m13 = a.m13;
    out.m14 = a.m14;
    out.m15 = a.m15;
  }

  return out;
};

/**
 * Multiply a matrix with a rotation matrix denotes by the rotation around x-axis.
 *
 * @param {mat4} out - Matrix to store result.
 * @param {mat4} a - Matrix to multiply.
 * @param {Number} rad - The rotation angle.
 * @returns {mat4} out.
 */
mat4.rotateX = function rotateX (out, a, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad),
    a10 = a.m04,
    a11 = a.m05,
    a12 = a.m06,
    a13 = a.m07,
    a20 = a.m08,
    a21 = a.m09,
    a22 = a.m10,
    a23 = a.m11;

  if (a !== out) { // If the source and destination differ, copy the unchanged rows
    out.m00 = a.m00;
    out.m01 = a.m01;
    out.m02 = a.m02;
    out.m03 = a.m03;
    out.m12 = a.m12;
    out.m13 = a.m13;
    out.m14 = a.m14;
    out.m15 = a.m15;
  }

  // Perform axis-specific matrix multiplication
  out.m04 = a10 * c + a20 * s;
  out.m05 = a11 * c + a21 * s;
  out.m06 = a12 * c + a22 * s;
  out.m07 = a13 * c + a23 * s;
  out.m08 = a20 * c - a10 * s;
  out.m09 = a21 * c - a11 * s;
  out.m10 = a22 * c - a12 * s;
  out.m11 = a23 * c - a13 * s;

  return out;
};

/**
 * Multiply a matrix with a rotation matrix denotes by the rotation around y-axis.
 *
 * @param {mat4} out - Matrix to store result.
 * @param {mat4} a - Matrix to multiply.
 * @param {Number} rad - The rotation angle.
 * @returns {mat4} out.
 */
mat4.rotateY = function rotateY (out, a, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad),
    a00 = a.m00,
    a01 = a.m01,
    a02 = a.m02,
    a03 = a.m03,
    a20 = a.m08,
    a21 = a.m09,
    a22 = a.m10,
    a23 = a.m11;

  if (a !== out) { // If the source and destination differ, copy the unchanged rows
    out.m04 = a.m04;
    out.m05 = a.m05;
    out.m06 = a.m06;
    out.m07 = a.m07;
    out.m12 = a.m12;
    out.m13 = a.m13;
    out.m14 = a.m14;
    out.m15 = a.m15;
  }

  // Perform axis-specific matrix multiplication
  out.m00 = a00 * c - a20 * s;
  out.m01 = a01 * c - a21 * s;
  out.m02 = a02 * c - a22 * s;
  out.m03 = a03 * c - a23 * s;
  out.m08 = a00 * s + a20 * c;
  out.m09 = a01 * s + a21 * c;
  out.m10 = a02 * s + a22 * c;
  out.m11 = a03 * s + a23 * c;

  return out;
};

/**
 * Multiply a matrix with a rotation matrix denotes by the rotation around z-axis.
 *
 * @param {mat4} out - Matrix to store result.
 * @param {mat4} a - Matrix to multiply.
 * @param {Number} rad - The rotation angle.
 * @returns {mat4} out.
 */
mat4.rotateZ = function rotateZ (out, a, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad),
    a00 = a.m00,
    a01 = a.m01,
    a02 = a.m02,
    a03 = a.m03,
    a10 = a.m04,
    a11 = a.m05,
    a12 = a.m06,
    a13 = a.m07;

  // If the source and destination differ, copy the unchanged last row
  if (a !== out) {
    out.m08 = a.m08;
    out.m09 = a.m09;
    out.m10 = a.m10;
    out.m11 = a.m11;
    out.m12 = a.m12;
    out.m13 = a.m13;
    out.m14 = a.m14;
    out.m15 = a.m15;
  }

  // Perform axis-specific matrix multiplication
  out.m00 = a00 * c + a10 * s;
  out.m01 = a01 * c + a11 * s;
  out.m02 = a02 * c + a12 * s;
  out.m03 = a03 * c + a13 * s;
  out.m04 = a10 * c - a00 * s;
  out.m05 = a11 * c - a01 * s;
  out.m06 = a12 * c - a02 * s;
  out.m07 = a13 * c - a03 * s;

  return out;
};

/**
 * Create a translation matrix from a translation offset.
 * This is equivalent to (but much faster than):
 *
 *   mat4.identity(dest);
 *   mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out - Matrix to store result.
 * @param {vec3} v - The translation offset.
 * @returns {mat4} out.
 */
mat4.fromTranslation = function fromTranslation (out, v) {
  out.m00 = 1;
  out.m01 = 0;
  out.m02 = 0;
  out.m03 = 0;
  out.m04 = 0;
  out.m05 = 1;
  out.m06 = 0;
  out.m07 = 0;
  out.m08 = 0;
  out.m09 = 0;
  out.m10 = 1;
  out.m11 = 0;
  out.m12 = v.x;
  out.m13 = v.y;
  out.m14 = v.z;
  out.m15 = 1;
  return out;
};

/**
 * Creates a scale matrix from a scale vector.
 * This is equivalent to (but much faster than):
 *
 *   mat4.identity(dest);
 *   mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out - Matrix to store result.
 * @param {vec3} v - The scale vector.
 * @returns {mat4} out.
 */
mat4.fromScaling = function fromScaling (out, v) {
  out.m00 = v.x;
  out.m01 = 0;
  out.m02 = 0;
  out.m03 = 0;
  out.m04 = 0;
  out.m05 = v.y;
  out.m06 = 0;
  out.m07 = 0;
  out.m08 = 0;
  out.m09 = 0;
  out.m10 = v.z;
  out.m11 = 0;
  out.m12 = 0;
  out.m13 = 0;
  out.m14 = 0;
  out.m15 = 1;
  return out;
};

/**
 * Creates a rotation matrix from the rotation around arbitrary axis.
 * This is equivalent to (but much faster than):
 *
 *   mat4.identity(dest);
 *   mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out - Matrix to store result.
 * @param {Number} rad - The rotation angle.
 * @param {vec3} axis - The rotation axis.
 * @returns {mat4} out.
 */
mat4.fromRotation = function fromRotation (out, rad, axis) {
  var x = axis.x, y = axis.y, z = axis.z;
  var len = Math.sqrt(x * x + y * y + z * z);
  var s, c, t;

  if (Math.abs(len) < EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  // Perform rotation-specific matrix multiplication
  out.m00 = x * x * t + c;
  out.m01 = y * x * t + z * s;
  out.m02 = z * x * t - y * s;
  out.m03 = 0;
  out.m04 = x * y * t - z * s;
  out.m05 = y * y * t + c;
  out.m06 = z * y * t + x * s;
  out.m07 = 0;
  out.m08 = x * z * t + y * s;
  out.m09 = y * z * t - x * s;
  out.m10 = z * z * t + c;
  out.m11 = 0;
  out.m12 = 0;
  out.m13 = 0;
  out.m14 = 0;
  out.m15 = 1;
  return out;
};

/**
 * Creates a rotation matrix from the rotation around x-axis.
 * This is equivalent to (but much faster than):
 *
 *   mat4.identity(dest);
 *   mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out - Matrix to store result.
 * @param {Number} rad - The rotation angle.
 * @returns {mat4} out.
 */
mat4.fromXRotation = function fromXRotation (out, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out.m00 = 1;
  out.m01 = 0;
  out.m02 = 0;
  out.m03 = 0;
  out.m04 = 0;
  out.m05 = c;
  out.m06 = s;
  out.m07 = 0;
  out.m08 = 0;
  out.m09 = -s;
  out.m10 = c;
  out.m11 = 0;
  out.m12 = 0;
  out.m13 = 0;
  out.m14 = 0;
  out.m15 = 1;
  return out;
};

/**
 * Creates a rotation matrix from the rotation around y-axis.
 * This is equivalent to (but much faster than):
 *
 *   mat4.identity(dest);
 *   mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out - Matrix to store result.
 * @param {Number} rad - The rotation angle.
 * @returns {mat4} out.
 */
mat4.fromYRotation = function fromYRotation (out, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out.m00 = c;
  out.m01 = 0;
  out.m02 = -s;
  out.m03 = 0;
  out.m04 = 0;
  out.m05 = 1;
  out.m06 = 0;
  out.m07 = 0;
  out.m08 = s;
  out.m09 = 0;
  out.m10 = c;
  out.m11 = 0;
  out.m12 = 0;
  out.m13 = 0;
  out.m14 = 0;
  out.m15 = 1;
  return out;
};

/**
 * Creates a rotation matrix from the rotation around z-axis.
 * This is equivalent to (but much faster than):
 *
 *   mat4.identity(dest);
 *   mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out - Matrix to store result.
 * @param {Number} rad - The rotation angle.
 * @returns {mat4} out.
 */
mat4.fromZRotation = function fromZRotation (out, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out.m00 = c;
  out.m01 = s;
  out.m02 = 0;
  out.m03 = 0;
  out.m04 = -s;
  out.m05 = c;
  out.m06 = 0;
  out.m07 = 0;
  out.m08 = 0;
  out.m09 = 0;
  out.m10 = 1;
  out.m11 = 0;
  out.m12 = 0;
  out.m13 = 0;
  out.m14 = 0;
  out.m15 = 1;
  return out;
};

/**
 * Creates a matrix from a quaternion rotation and a translation offset.
 * This is equivalent to (but much faster than):
 *
 *   mat4.identity(dest);
 *   mat4.translate(dest, vec);
 *   let quatMat = mat4.create();
 *   quat.toMat4(quat, quatMat);
 *   mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out - Matrix to store result.
 * @param {quat} q - Rotation quaternion.
 * @param {vec3} v - Translation vector.
 * @returns {mat4} out.
 */
mat4.fromRT = function fromRT (out, q, v) {
  // Quaternion math
  var x = q.x, y = q.y, z = q.z, w = q.w;
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  out.m00 = 1 - (yy + zz);
  out.m01 = xy + wz;
  out.m02 = xz - wy;
  out.m03 = 0;
  out.m04 = xy - wz;
  out.m05 = 1 - (xx + zz);
  out.m06 = yz + wx;
  out.m07 = 0;
  out.m08 = xz + wy;
  out.m09 = yz - wx;
  out.m10 = 1 - (xx + yy);
  out.m11 = 0;
  out.m12 = v.x;
  out.m13 = v.y;
  out.m14 = v.z;
  out.m15 = 1;

  return out;
};

/**
 * Returns the translation vector component of a transformation
 *matrix. If a matrix is built with fromRT,
 *the returned vector will be the same as the translation offset
 *originally supplied.
 * @param{vec3} out - Vector to store result.
 * @param{mat4} mat - Matrix to be decomposed.
 * @return {vec3} out.
 */
mat4.getTranslation = function getTranslation (out, mat) {
  out.x = mat.m12;
  out.y = mat.m13;
  out.z = mat.m14;

  return out;
};

/**
 * Returns the scale component of a transformation
 *matrix. If a matrix is built with fromRTS
 *with a normalized Quaternion parameter, the returned vector will be
 *the same as the scale vector
 *originally supplied.
 * @param{vec3} out - Vector to store result.
 * @param{mat4} mat - Matrix to be decomposed.
 * @return {vec3} out.
 */
mat4.getScaling = function getScaling (out, mat) {
  var m11 = mat.m00,
    m12 = mat.m01,
    m13 = mat.m02,
    m21 = mat.m04,
    m22 = mat.m05,
    m23 = mat.m06,
    m31 = mat.m08,
    m32 = mat.m09,
    m33 = mat.m10;

  out.x = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out.y = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out.z = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);

  return out;
};

/**
 * Returns a quaternion representing the rotational component
 *of a transformation matrix. If a matrix is built with
 *fromRT, the returned quaternion will be the
 *same as the quaternion originally supplied.
 * @param {quat} out - Quaternion to store result.
 * @param {mat4} mat - Matrix to be decomposed.
 * @return {quat} out.
 */
mat4.getRotation = function getRotation (out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat.m00 + mat.m05 + mat.m10;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out.w = 0.25 * S;
    out.x = (mat.m06 - mat.m09) / S;
    out.y = (mat.m08 - mat.m02) / S;
    out.z = (mat.m01 - mat.m04) / S;
  } else if ((mat.m00 > mat.m05) & (mat.m00 > mat.m10)) {
    S = Math.sqrt(1.0 + mat.m00 - mat.m05 - mat.m10) * 2;
    out.w = (mat.m06 - mat.m09) / S;
    out.x = 0.25 * S;
    out.y = (mat.m01 + mat.m04) / S;
    out.z = (mat.m08 + mat.m02) / S;
  } else if (mat.m05 > mat.m10) {
    S = Math.sqrt(1.0 + mat.m05 - mat.m00 - mat.m10) * 2;
    out.w = (mat.m08 - mat.m02) / S;
    out.x = (mat.m01 + mat.m04) / S;
    out.y = 0.25 * S;
    out.z = (mat.m06 + mat.m09) / S;
  } else {
    S = Math.sqrt(1.0 + mat.m10 - mat.m00 - mat.m05) * 2;
    out.w = (mat.m01 - mat.m04) / S;
    out.x = (mat.m08 + mat.m02) / S;
    out.y = (mat.m06 + mat.m09) / S;
    out.z = 0.25 * S;
  }

  return out;
};

/**
 * Creates a matrix from a quaternion rotation, translation offset and scale vector.
 * This is equivalent to (but much faster than):
 *
 *   mat4.identity(dest);
 *   mat4.translate(dest, vec);
 *   let quatMat = mat4.create();
 *   quat.toMat4(quat, quatMat);
 *   mat4.multiply(dest, quatMat);
 *   mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 - Matrix to store result.
 * @param {quat} q - Rotation quaternion.
 * @param {vec3} v - Translation offset.
 * @param {vec3} s - Scale vector.
 * @returns {mat4} out.
 */
mat4.fromRTS = function fromRTS (out, q, v, s) {
  // Quaternion math
  var x = q.x, y = q.y, z = q.z, w = q.w;
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s.x;
  var sy = s.y;
  var sz = s.z;

  out.m00 = (1 - (yy + zz)) * sx;
  out.m01 = (xy + wz) * sx;
  out.m02 = (xz - wy) * sx;
  out.m03 = 0;
  out.m04 = (xy - wz) * sy;
  out.m05 = (1 - (xx + zz)) * sy;
  out.m06 = (yz + wx) * sy;
  out.m07 = 0;
  out.m08 = (xz + wy) * sz;
  out.m09 = (yz - wx) * sz;
  out.m10 = (1 - (xx + yy)) * sz;
  out.m11 = 0;
  out.m12 = v.x;
  out.m13 = v.y;
  out.m14 = v.z;
  out.m15 = 1;

  return out;
};

/**
 * Creates a matrix from a quaternion rotation, translation offset and scale vector, rotating and scaling around the given origin.
 * This is equivalent to (but much faster than):
 *
 *   mat4.identity(dest);
 *   mat4.translate(dest, vec);
 *   mat4.translate(dest, origin);
 *   let quatMat = mat4.create();
 *   quat.toMat4(quat, quatMat);
 *   mat4.multiply(dest, quatMat);
 *   mat4.scale(dest, scale)
 *   mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 - Matrix to store result.
 * @param {quat} q - Rotation quaternion.
 * @param {vec3} v - Translation offset.
 * @param {vec3} s - Scale vector.
 * @param {vec3} o The origin vector around which to scale and rotate.
 * @returns {mat4} out.
 */
mat4.fromRTSOrigin = function fromRTSOrigin (out, q, v, s, o) {
  // Quaternion math
  var x = q.x, y = q.y, z = q.z, w = q.w;
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  var sx = s.x;
  var sy = s.y;
  var sz = s.z;

  var ox = o.x;
  var oy = o.y;
  var oz = o.z;

  out.m00 = (1 - (yy + zz)) * sx;
  out.m01 = (xy + wz) * sx;
  out.m02 = (xz - wy) * sx;
  out.m03 = 0;
  out.m04 = (xy - wz) * sy;
  out.m05 = (1 - (xx + zz)) * sy;
  out.m06 = (yz + wx) * sy;
  out.m07 = 0;
  out.m08 = (xz + wy) * sz;
  out.m09 = (yz - wx) * sz;
  out.m10 = (1 - (xx + yy)) * sz;
  out.m11 = 0;
  out.m12 = v.x + ox - (out.m00 * ox + out.m04 * oy + out.m08 * oz);
  out.m13 = v.y + oy - (out.m01 * ox + out.m05 * oy + out.m09 * oz);
  out.m14 = v.z + oz - (out.m02 * ox + out.m06 * oy + out.m10 * oz);
  out.m15 = 1;

  return out;
};

/**
 * Calculates a 4x4 matrix from the given quaternion.
 *
 * @param {mat4} out mat4 - Matrix to store result.
 * @param {quat} q - Quaternion to create matrix from.
 *
 * @returns {mat4} out.
 */
mat4.fromQuat = function fromQuat (out, q) {
  var x = q.x, y = q.y, z = q.z, w = q.w;
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  out.m00 = 1 - yy - zz;
  out.m01 = yx + wz;
  out.m02 = zx - wy;
  out.m03 = 0;

  out.m04 = yx - wz;
  out.m05 = 1 - xx - zz;
  out.m06 = zy + wx;
  out.m07 = 0;

  out.m08 = zx + wy;
  out.m09 = zy - wx;
  out.m10 = 1 - xx - yy;
  out.m11 = 0;

  out.m12 = 0;
  out.m13 = 0;
  out.m14 = 0;
  out.m15 = 1;

  return out;
};

/**
 * Generates a frustum matrix with the given bounds.
 *
 * @param {mat4} out mat4 - Matrix to store result.
 * @param {Number} left - Left bound of the frustum.
 * @param {Number} right - Right bound of the frustum.
 * @param {Number} bottom - Bottom bound of the frustum.
 * @param {Number} top - Top bound of the frustum.
 * @param {Number} near - Near bound of the frustum.
 * @param {Number} far - Far bound of the frustum.
 * @returns {mat4} out.
 */
mat4.frustum = function frustum (out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);

  out.m00 = (near * 2) * rl;
  out.m01 = 0;
  out.m02 = 0;
  out.m03 = 0;
  out.m04 = 0;
  out.m05 = (near * 2) * tb;
  out.m06 = 0;
  out.m07 = 0;
  out.m08 = (right + left) * rl;
  out.m09 = (top + bottom) * tb;
  out.m10 = (far + near) * nf;
  out.m11 = -1;
  out.m12 = 0;
  out.m13 = 0;
  out.m14 = (far * near * 2) * nf;
  out.m15 = 0;
  return out;
};

/**
 * Generates a perspective projection matrix with the given bounds.
 *
 * @param {mat4} out - Matrix to store result.
 * @param {number} fovy - Vertical field of view in radians.
 * @param {number} aspect - Aspect ratio. typically viewport width/height.
 * @param {number} near - Near bound of the frustum.
 * @param {number} far - Far bound of the frustum.
 * @returns {mat4} out.
 */
mat4.perspective = function perspective (out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2);
  var nf = 1 / (near - far);

  out.m00 = f / aspect;
  out.m01 = 0;
  out.m02 = 0;
  out.m03 = 0;
  out.m04 = 0;
  out.m05 = f;
  out.m06 = 0;
  out.m07 = 0;
  out.m08 = 0;
  out.m09 = 0;
  out.m10 = (far + near) * nf;
  out.m11 = -1;
  out.m12 = 0;
  out.m13 = 0;
  out.m14 = (2 * far * near) * nf;
  out.m15 = 0;
  return out;
};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out - Matrix to store result.
 * @param {Object} fov - Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees.
 * @param {number} near - Near bound of the frustum.
 * @param {number} far - Far bound of the frustum.
 * @returns {mat4} out.
 */
mat4.perspectiveFromFieldOfView = function perspectiveFromFieldOfView (out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);

  out.m00 = xScale;
  out.m01 = 0.0;
  out.m02 = 0.0;
  out.m03 = 0.0;
  out.m04 = 0.0;
  out.m05 = yScale;
  out.m06 = 0.0;
  out.m07 = 0.0;
  out.m08 = -((leftTan - rightTan) * xScale * 0.5);
  out.m09 = ((upTan - downTan) * yScale * 0.5);
  out.m10 = far / (near - far);
  out.m11 = -1.0;
  out.m12 = 0.0;
  out.m13 = 0.0;
  out.m14 = (far * near) / (near - far);
  out.m15 = 0.0;
  return out;
};

/**
 * Generates a orthogonal projection matrix with the given bounds.
 *
 * @param {mat4} out - Matrix to store result.
 * @param {number} left - Left bound of the frustum.
 * @param {number} right - Right bound of the frustum.
 * @param {number} bottom - Bottom bound of the frustum.
 * @param {number} top - Top bound of the frustum.
 * @param {number} near - Near bound of the frustum.
 * @param {number} far - Far bound of the frustum.
 * @returns {mat4} out.
 */
mat4.ortho = function ortho (out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out.m00 = -2 * lr;
  out.m01 = 0;
  out.m02 = 0;
  out.m03 = 0;
  out.m04 = 0;
  out.m05 = -2 * bt;
  out.m06 = 0;
  out.m07 = 0;
  out.m08 = 0;
  out.m09 = 0;
  out.m10 = 2 * nf;
  out.m11 = 0;
  out.m12 = (left + right) * lr;
  out.m13 = (top + bottom) * bt;
  out.m14 = (far + near) * nf;
  out.m15 = 1;
  return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * `eye - center` mustn't be zero vector or parallel to `up`
 *
 * @param {mat4} out - Matrix to store result.
 * @param {vec3} eye - Position of the viewer.
 * @param {vec3} center - Point the viewer is looking at.
 * @param {vec3} up - Vector pointing up.
 * @returns {mat4} out
 */
mat4.lookAt = function lookAt (out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye.x;
  var eyey = eye.y;
  var eyez = eye.z;
  var upx = up.x;
  var upy = up.y;
  var upz = up.z;
  var centerx = center.x;
  var centery = center.y;
  var centerz = center.z;

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;

  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;

  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = 1 / Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  x0 *= len;
  x1 *= len;
  x2 *= len;

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;

  out.m00 = x0;
  out.m01 = y0;
  out.m02 = z0;
  out.m03 = 0;
  out.m04 = x1;
  out.m05 = y1;
  out.m06 = z1;
  out.m07 = 0;
  out.m08 = x2;
  out.m09 = y2;
  out.m10 = z2;
  out.m11 = 0;
  out.m12 = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out.m13 = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out.m14 = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out.m15 = 1;

  return out;
};

/**
 * Returns a string representation of a matrix.
 *
 * @param {mat4} a - The matrix.
 * @returns {String} String representation of this matrix.
 */
mat4.str = function str (a) {
  return ("mat4(" + (a.m00) + ", " + (a.m01) + ", " + (a.m02) + ", " + (a.m03) + ", " + (a.m04) + ", " + (a.m05) + ", " + (a.m06) + ", " + (a.m07) + ", " + (a.m08) + ", " + (a.m09) + ", " + (a.m10) + ", " + (a.m11) + ", " + (a.m12) + ", " + (a.m13) + ", " + (a.m14) + ", " + (a.m15) + ")");
};

/**
 * Store elements of a matrix into array.
 *
 * @param {array} out - Array to store result.
 * @param {mat4} m - The matrix.
 * @returns {Array} out.
 */
mat4.array = function array (out, m) {
  out[0] = m.m00;
  out[1] = m.m01;
  out[2] = m.m02;
  out[3] = m.m03;
  out[4] = m.m04;
  out[5] = m.m05;
  out[6] = m.m06;
  out[7] = m.m07;
  out[8] = m.m08;
  out[9] = m.m09;
  out[10] = m.m10;
  out[11] = m.m11;
  out[12] = m.m12;
  out[13] = m.m13;
  out[14] = m.m14;
  out[15] = m.m15;

  return out;
};

/**
 * Returns Frobenius norm of a matrix.
 *
 * @param {mat4} a - Matrix to calculate Frobenius norm of.
 * @returns {Number} - The frobenius norm.
 */
mat4.frob = function frob (a) {
  return (Math.sqrt(Math.pow(a.m00, 2) + Math.pow(a.m01, 2) + Math.pow(a.m02, 2) + Math.pow(a.m03, 2) + Math.pow(a.m04, 2) + Math.pow(a.m05, 2) + Math.pow(a.m06, 2) + Math.pow(a.m07, 2) + Math.pow(a.m08, 2) + Math.pow(a.m09, 2) + Math.pow(a.m10, 2) + Math.pow(a.m11, 2) + Math.pow(a.m12, 2) + Math.pow(a.m13, 2) + Math.pow(a.m14, 2) + Math.pow(a.m15, 2)))
};

/**
 * Adds two matrices.
 *
 * @param {mat4} out - Matrix to store result.
 * @param {mat4} a - The first operand.
 * @param {mat4} b - The second operand.
 * @returns {mat4} out.
 */
mat4.add = function add (out, a, b) {
  out.m00 = a.m00 + b.m00;
  out.m01 = a.m01 + b.m01;
  out.m02 = a.m02 + b.m02;
  out.m03 = a.m03 + b.m03;
  out.m04 = a.m04 + b.m04;
  out.m05 = a.m05 + b.m05;
  out.m06 = a.m06 + b.m06;
  out.m07 = a.m07 + b.m07;
  out.m08 = a.m08 + b.m08;
  out.m09 = a.m09 + b.m09;
  out.m10 = a.m10 + b.m10;
  out.m11 = a.m11 + b.m11;
  out.m12 = a.m12 + b.m12;
  out.m13 = a.m13 + b.m13;
  out.m14 = a.m14 + b.m14;
  out.m15 = a.m15 + b.m15;
  return out;
};

/**
 * Subtracts matrix b from matrix a.
 *
 * @param {mat4} out - Matrix to store result.
 * @param {mat4} a - The first operand.
 * @param {mat4} b - The second operand.
 * @returns {mat4} out.
 */
mat4.subtract = function subtract (out, a, b) {
  out.m00 = a.m00 - b.m00;
  out.m01 = a.m01 - b.m01;
  out.m02 = a.m02 - b.m02;
  out.m03 = a.m03 - b.m03;
  out.m04 = a.m04 - b.m04;
  out.m05 = a.m05 - b.m05;
  out.m06 = a.m06 - b.m06;
  out.m07 = a.m07 - b.m07;
  out.m08 = a.m08 - b.m08;
  out.m09 = a.m09 - b.m09;
  out.m10 = a.m10 - b.m10;
  out.m11 = a.m11 - b.m11;
  out.m12 = a.m12 - b.m12;
  out.m13 = a.m13 - b.m13;
  out.m14 = a.m14 - b.m14;
  out.m15 = a.m15 - b.m15;
  return out;
};

/**
 * Alias of {@link mat4.subtract}.
 */
mat4.sub = function sub (out, a, b) {
  return mat4.subtract(out, a, b);
};

/**
 * Multiply each element of a matrix by a scalar number.
 *
 * @param {mat4} out - Matrix to store result.
 * @param {mat4} a - Matrix to scale
 * @param {Number} b - The scale number.
 * @returns {mat4} out.
 */
mat4.multiplyScalar = function multiplyScalar (out, a, b) {
  out.m00 = a.m00 * b;
  out.m01 = a.m01 * b;
  out.m02 = a.m02 * b;
  out.m03 = a.m03 * b;
  out.m04 = a.m04 * b;
  out.m05 = a.m05 * b;
  out.m06 = a.m06 * b;
  out.m07 = a.m07 * b;
  out.m08 = a.m08 * b;
  out.m09 = a.m09 * b;
  out.m10 = a.m10 * b;
  out.m11 = a.m11 * b;
  out.m12 = a.m12 * b;
  out.m13 = a.m13 * b;
  out.m14 = a.m14 * b;
  out.m15 = a.m15 * b;
  return out;
};

/**
 * Adds two matrices after multiplying each element of the second operand by a scalar number.
 *
 * @param {mat4} out - Matrix to store result.
 * @param {mat4} a - The first operand.
 * @param {mat4} b - The second operand.
 * @param {Number} scale - The scale number.
 * @returns {mat4} out.
 */
mat4.multiplyScalarAndAdd = function multiplyScalarAndAdd (out, a, b, scale) {
  out.m00 = a.m00 + (b.m00 * scale);
  out.m01 = a.m01 + (b.m01 * scale);
  out.m02 = a.m02 + (b.m02 * scale);
  out.m03 = a.m03 + (b.m03 * scale);
  out.m04 = a.m04 + (b.m04 * scale);
  out.m05 = a.m05 + (b.m05 * scale);
  out.m06 = a.m06 + (b.m06 * scale);
  out.m07 = a.m07 + (b.m07 * scale);
  out.m08 = a.m08 + (b.m08 * scale);
  out.m09 = a.m09 + (b.m09 * scale);
  out.m10 = a.m10 + (b.m10 * scale);
  out.m11 = a.m11 + (b.m11 * scale);
  out.m12 = a.m12 + (b.m12 * scale);
  out.m13 = a.m13 + (b.m13 * scale);
  out.m14 = a.m14 + (b.m14 * scale);
  out.m15 = a.m15 + (b.m15 * scale);
  return out;
};

/**
 * Returns whether the specified matrices are equal. (Compared using ===)
 *
 * @param {mat4} a - The first matrix.
 * @param {mat4} b - The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.exactEquals = function exactEquals (a, b) {
  return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 &&
    a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 &&
    a.m08 === b.m08 && a.m09 === b.m09 && a.m10 === b.m10 && a.m11 === b.m11 &&
    a.m12 === b.m12 && a.m13 === b.m13 && a.m14 === b.m14 && a.m15 === b.m15;
};

/**
 * Returns whether the specified matrices are approximately equal.
 *
 * @param {mat4} a - The first matrix.
 * @param {mat4} b - The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.equals = function equals$$1 (a, b) {
  var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03,
    a4 = a.m04, a5 = a.m05, a6 = a.m06, a7 = a.m07,
    a8 = a.m08, a9 = a.m09, a10 = a.m10, a11 = a.m11,
    a12 = a.m12, a13 = a.m13, a14 = a.m14, a15 = a.m15;

  var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03,
    b4 = b.m04, b5 = b.m05, b6 = b.m06, b7 = b.m07,
    b8 = b.m08, b9 = b.m09, b10 = b.m10, b11 = b.m11,
    b12 = b.m12, b13 = b.m13, b14 = b.m14, b15 = b.m15;

  return (
    Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
    Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
    Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
    Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
    Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
    Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
    Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
    Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
    Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
    Math.abs(a9 - b9) <= EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
    Math.abs(a10 - b10) <= EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
    Math.abs(a11 - b11) <= EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
    Math.abs(a12 - b12) <= EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
    Math.abs(a13 - b13) <= EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
    Math.abs(a14 - b14) <= EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
    Math.abs(a15 - b15) <= EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15))
  );
};

var color3 = function color3(r, g, b) {
  /**
   * The r component.
   * @type {number}
   * */
  this.r = r;

  /**
   * The g component.
   * @type {number}
   * */
  this.g = g;

  /**
   * The b component.
   * @type {number}
   * */
  this.b = b;
};

/**
 * Creates a color, with components specified separately.
 *
 * @param {number} r - Value assigned to r component.
 * @param {number} g - Value assigned to g component.
 * @param {number} b - Value assigned to b component.
 * @return {color3} The newly created color.
 */
color3.new = function new$1 (r, g, b) {
  return new color3(r, g, b);
};

/**
 * Creates a color representing white color.
 *
 * @return {color3} The newly created color.
 */
color3.create = function create () {
  return new color3(1, 1, 1);
};

/**
 * Clone a color.
 *
 * @param {color3} a - Color to clone.
 * @returns {color3} The newly created color.
 */
color3.clone = function clone (a) {
  return new color3(a.r, a.g, a.b);
};

/**
 * Copy content of a color into another.
 *
 * @param {color3} out - The color to modified.
 * @param {color3} a - The specified color.
 * @returns {color3} out.
 */
color3.copy = function copy (out, a) {
  out.r = a.r;
  out.g = a.g;
  out.b = a.b;
  return out;
};

/**
 * Set the components of a color to the given values.
 *
 * @param {color3} out - The color to modified.
 * @param {number} r - Value assigned to r component.
 * @param {number} g - Value assigned to g component.
 * @param {number} b - Value assigned to b component.
 * @returns {color3} out.
 */
color3.set = function set (out, r, g, b) {
  out.r = r;
  out.g = g;
  out.b = b;
  return out;
};

/**
 * Converts the hexadecimal formal color into rgb formal.
 *
 * @param {color3} out - Color to store result.
 * @param {Number} hex - The color's hexadecimal formal.
 * @returns {color3} out.
 * @function
 */
color3.fromHex = function fromHex (out, hex) {
  var r = ((hex >> 16)) / 255.0;
  var g = ((hex >> 8) & 0xff) / 255.0;
  var b = ((hex) & 0xff) / 255.0;

  out.r = r;
  out.g = g;
  out.b = b;
  return out;
};

/**
 * Add components of two colors, respectively.
 *
 * @param {color3} out - Color to store result.
 * @param {color3} a - The first operand.
 * @param {color3} b - The second operand.
 * @returns {color3} out.
 */
color3.add = function add (out, a, b) {
  out.r = a.r + b.r;
  out.g = a.g + b.g;
  out.b = a.b + b.b;
  return out;
};

/**
 * Subtract components of color b from components of color a, respectively.
 *
 * @param {color3} out - Color to store result.
 * @param {color3} a - The a.
 * @param {color3} b - The b.
 * @returns {color3} out.
 */
color3.subtract = function subtract (out, a, b) {
  out.r = a.r - b.r;
  out.g = a.g - b.g;
  out.b = a.b - b.b;
  return out;
};

/**
 * Alias of {@link color3.subtract}.
 */
color3.sub = function sub (out, a, b) {
  return color3.subtract(out, a, b);
};

/**
 * Multiply components of two colors, respectively.
 *
 * @param {color3} out - Color to store result.
 * @param {color3} a - The first operand.
 * @param {color3} b - The second operand.
 * @returns {color3} out.
 */
color3.multiply = function multiply (out, a, b) {
  out.r = a.r * b.r;
  out.g = a.g * b.g;
  out.b = a.b * b.b;
  return out;
};

/**
 * Alias of {@link color3.multiply}.
 */
color3.mul = function mul (out, a, b) {
  return color3.multiply(out, a, b);
};

/**
 * Divide components of color a by components of color b, respectively.
 *
 * @param {color3} out - Color to store result.
 * @param {color3} a - The first operand.
 * @param {color3} b - The second operand.
 * @returns {color3} out.
 */
color3.divide = function divide (out, a, b) {
  out.r = a.r / b.r;
  out.g = a.g / b.g;
  out.b = a.b / b.b;
  return out;
};

/**
 * Alias of {@link color3.divide}.
 */
color3.div = function div (out, a, b) {
  return color3.divide(out, a, b);
};

/**
 * Scales a color by a number.
 *
 * @param {color3} out - Color to store result.
 * @param {color3} a - Color to scale.
 * @param {number} b - The scale number.
 * @returns {color3} out.
 */
color3.scale = function scale (out, a, b) {
  out.r = a.r * b;
  out.g = a.g * b;
  out.b = a.b * b;
  return out;
};

/**
 * Performs a linear interpolation between two colors.
 *
 * @param {color3} out - Color to store result.
 * @param {color3} a - The first operand.
 * @param {color3} b - The second operand.
 * @param {Number} t - The interpolation coefficient.
 * @returns {color3} out.
 */
color3.lerp = function lerp$$1 (out, a, b, t) {
  var ar = a.r,
    ag = a.g,
    ab = a.b;
  out.r = ar + t * (b.r - ar);
  out.g = ag + t * (b.g - ag);
  out.b = ab + t * (b.b - ab);
  return out;
};

/**
 * Returns string representation of a color.
 *
 * @param {color3} a - The color.
 * @returns {String} - String representation of this color.
 */
color3.str = function str (a) {
  return ("color3(" + (a.r) + ", " + (a.g) + ", " + (a.b) + ")");
};

/**
 * Store components of a color into array.
 *
 * @param {Array} out - Array to store result.
 * @param {color3} a - The color.
 * @returns {Array} out.
 */
color3.array = function array (out, a) {
  out[0] = a.r;
  out[1] = a.g;
  out[2] = a.b;

  return out;
};

/**
 * Returns whether the specified colors are equal. (Compared using ===)
 *
 * @param {color3} a - The first color.
 * @param {color3} b - The second color.
 * @returns {Boolean} True if the colors are equal, false otherwise.
 */
color3.exactEquals = function exactEquals (a, b) {
  return a.r === b.r && a.g === b.g && a.b === b.b;
};

/**
 * Returns whether the specified colors are approximately equal.
 *
 * @param {color3} a - The first color.
 * @param {color3} b - The second color.
 * @returns {Boolean} True if the colors are approximately equal, false otherwise.
 */
color3.equals = function equals$$1 (a, b) {
  var a0 = a.r, a1 = a.g, a2 = a.b;
  var b0 = b.r, b1 = b.g, b2 = b.b;
  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
    Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
    Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)));
};

/**
 * Converts a color's rgb formal into the hexadecimal one.
 *
 * @param {color3} a - The color.
 * @returns {Number} - The color's hexadecimal formal.
 */
color3.hex = function hex (a) {
  return (a.r * 255) << 16 | (a.g * 255) << 8 | (a.b * 255);
};

var color4 = function color4(r, g, b, a) {
  /**
   * The r component.
   * @type {number}
   * */
  this.r = r;

  /**
   * The g component.
   * @type {number}
   * */
  this.g = g;

  /**
   * The b component.
   * @type {number}
   * */
  this.b = b;

  /**
   * The a component.
   * @type {number}
   * */
  this.a = a;
};

/**
 * Creates a color, with components specified separately.
 *
 * @param {number} r - Value assigned to r component.
 * @param {number} g - Value assigned to g component.
 * @param {number} b - Value assigned to b component.
 * @param {number} a - Value assigned to a component.
 * @return {color4} The newly created color.
 */
color4.new = function new$1 (r, g, b, a) {
  return new color4(r, g, b, a);
};

/**
 * Creates a color representing white color.
 *
 * @return {color4} The newly created color.
 */
color4.create = function create () {
  return new color4(1, 1, 1, 1);
};

/**
 * Clone a color.
 *
 * @param {color4} a - Color to clone.
 * @returns {color4} The newly created color.
 */
color4.clone = function clone (a) {
  return new color4(a.r, a.g, a.b, a.a);
};

/**
 * Copy content of a color into another.
 *
 * @param {color4} out - The color to modified.
 * @param {color4} a - The specified color.
 * @returns {color4} out.
 */
color4.copy = function copy (out, a) {
  out.r = a.r;
  out.g = a.g;
  out.b = a.b;
  out.a = a.a;
  return out;
};

/**
 * Set the components of a color to the given values.
 *
 * @param {color4} out - The color to modified.
 * @param {number} r - Value assigned to r component.
 * @param {number} g - Value assigned to g component.
 * @param {number} b - Value assigned to b component.
 * @param {number} a - Value assigned to a component.
 * @returns {color4} out.
 */
color4.set = function set (out, r, g, b, a) {
  out.r = r;
  out.g = g;
  out.b = b;
  out.a = a;
  return out;
};

/**
 * Converts the hexadecimal formal color into rgb formal.
 *
 * @param {color4} out - Color to store result.
 * @param {Number} hex - The color's hexadecimal formal.
 * @returns {color4} out.
 * @function
 */
color4.fromHex = function fromHex (out, hex) {
  var r = ((hex >> 24)) / 255.0;
  var g = ((hex >> 16) & 0xff) / 255.0;
  var b = ((hex >> 8) & 0xff) / 255.0;
  var a = ((hex) & 0xff) / 255.0;

  out.r = r;
  out.g = g;
  out.b = b;
  out.a = a;
  return out;
};

/**
 * Add components of two colors, respectively.
 *
 * @param {color4} out - Color to store result.
 * @param {color4} a - The first operand.
 * @param {color4} b - The second operand.
 * @returns {color4} out.
 */
color4.add = function add (out, a, b) {
  out.r = a.r + b.r;
  out.g = a.g + b.g;
  out.b = a.b + b.b;
  out.a = a.a + b.a;
  return out;
};

/**
 * Subtract components of color b from components of color a, respectively.
 *
 * @param {color4} out - Color to store result.
 * @param {color4} a - The a.
 * @param {color4} b - The b.
 * @returns {color4} out.
 */
color4.subtract = function subtract (out, a, b) {
  out.r = a.r - b.r;
  out.g = a.g - b.g;
  out.b = a.b - b.b;
  out.a = a.a - b.a;
  return out;
};

/**
 * Alias of {@link color4.subtract}.
 */
color4.sub = function sub (out, a, b) {
  return color4.subtract(out, a, b);
};

/**
 * Multiply components of two colors, respectively.
 *
 * @param {color4} out - Color to store result.
 * @param {color4} a - The first operand.
 * @param {color4} b - The second operand.
 * @returns {color4} out.
 */
color4.multiply = function multiply (out, a, b) {
  out.r = a.r * b.r;
  out.g = a.g * b.g;
  out.b = a.b * b.b;
  out.a = a.a * b.a;
  return out;
};

/**
 * Alias of {@link color4.multiply}.
 */
color4.mul = function mul (out, a, b) {
  return color4.multiply(out, a, b);
};

/**
 * Divide components of color a by components of color b, respectively.
 *
 * @param {color4} out - Color to store result.
 * @param {color4} a - The first operand.
 * @param {color4} b - The second operand.
 * @returns {color4} out.
 */
color4.divide = function divide (out, a, b) {
  out.r = a.r / b.r;
  out.g = a.g / b.g;
  out.b = a.b / b.b;
  out.a = a.a / b.a;
  return out;
};

/**
 * Alias of {@link color4.divide}.
 */
color4.div = function div (out, a, b) {
  return color4.divide(out, a, b);
};

/**
 * Scales a color by a number.
 *
 * @param {color4} out - Color to store result.
 * @param {color4} a - Color to scale.
 * @param {number} b - The scale number.
 * @returns {color4} out.
 */
color4.scale = function scale (out, a, b) {
  out.r = a.r * b;
  out.g = a.g * b;
  out.b = a.b * b;
  out.a = a.a * b;
  return out;
};

/**
 * Performs a linear interpolation between two colors.
 *
 * @param {color4} out - Color to store result.
 * @param {color4} a - The first operand.
 * @param {color4} b - The second operand.
 * @param {Number} t - The interpolation coefficient.
 * @returns {color4} out.
 */
color4.lerp = function lerp$$1 (out, a, b, t) {
  var ar = a.r,
    ag = a.g,
    ab = a.b,
    aa = a.a;
  out.r = ar + t * (b.r - ar);
  out.g = ag + t * (b.g - ag);
  out.b = ab + t * (b.b - ab);
  out.a = aa + t * (b.a - aa);
  return out;
};

/**
 * Returns string representation of a color.
 *
 * @param {color4} a - The color.
 * @returns {String} - String representation of this color.
 */
color4.str = function str (a) {
  return ("color4(" + (a.r) + ", " + (a.g) + ", " + (a.b) + ", " + (a.a) + ")");
};

/**
 * Store components of a color into array.
 *
 * @param {Array} out - Array to store result.
 * @param {color4} a - The color.
 * @returns {Array} out.
 */
color4.array = function array (out, a) {
  out[0] = a.r;
  out[1] = a.g;
  out[2] = a.b;
  out[3] = a.a;

  return out;
};

/**
 * Returns whether the specified colors are equal. (Compared using ===)
 *
 * @param {color4} a - The first color.
 * @param {color4} b - The second color.
 * @returns {Boolean} True if the colors are equal, false otherwise.
 */
color4.exactEquals = function exactEquals (a, b) {
  return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
};

/**
 * Returns whether the specified colors are approximately equal.
 *
 * @param {color4} a - The first color.
 * @param {color4} b - The second color.
 * @returns {Boolean} True if the colors are approximately equal, false otherwise.
 */
color4.equals = function equals$$1 (a, b) {
  var a0 = a.r, a1 = a.g, a2 = a.b, a3 = a.a;
  var b0 = b.r, b1 = b.g, b2 = b.b, b3 = b.a;
  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
    Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
    Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
    Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

/**
 * Converts a color's rgb formal into the hexadecimal one.
 *
 * @param {color4} a - The color.
 * @returns {Number} - The color's hexadecimal formal.
 */
color4.hex = function hex (a) {
  return ((a.r * 255) << 24 | (a.g * 255) << 16 | (a.b * 255) << 8 | a.a * 255) >>> 0;
};

var bits = bits_;



var math = Object.freeze({
	bits: bits,
	vec2: vec2,
	vec3: vec3,
	vec4: vec4,
	quat: quat,
	mat2: mat2,
	mat23: mat23,
	mat3: mat3,
	mat4: mat4,
	color3: color3,
	color4: color4,
	EPSILON: EPSILON,
	equals: equals,
	approx: approx,
	clamp: clamp,
	clamp01: clamp01,
	lerp: lerp,
	toRadian: toRadian,
	toDegree: toDegree,
	random: random,
	randomRange: randomRange,
	randomRangeInt: randomRangeInt,
	pseudoRandom: pseudoRandom,
	pseudoRandomRange: pseudoRandomRange,
	pseudoRandomRangeInt: pseudoRandomRangeInt,
	nextPow2: nextPow2,
	repeat: repeat,
	pingPong: pingPong,
	inverseLerp: inverseLerp
});

function point_plane(point, plane) {
  return vec3.dot(plane.n, point) - plane.d;
}

/**
 * the closest point of the point to plane
 *
 * @param {vec3} out the result point
 * @param {vec3} point
 * @param {plane} plane
 */
function pt_point_plane (out, point, plane) {
  var t = point_plane(point, plane);

  return vec3.sub(out, point, vec3.scale(out, plane.n, t));
}


/**
 * @name distance
 */
var distance = {
  point_plane: point_plane,
  pt_point_plane: pt_point_plane,
};

var ray_plane = (function () {
  var pt = vec3.zero();

  return function (ray, plane, outPt) {
    distance.pt_point_plane(pt, ray.o, plane);
    var t = vec3.dot(pt, plane.n) / vec3.dot(ray.d, plane.n);
    var intersects = t >= 0;

    if (outPt && intersects) {
      vec3.scale(outPt, ray.d, t);
      vec3.add(outPt, outPt, ray.o);
    }

    return intersects;
  };
})();

/**
 * line-plane intersect
 *
 * @param {line} line
 * @param {plane} plane
 * @param {vec3} outPt the intersect point if provide
 * @return {boolean}
 */
var line_plane = (function () {
  var ab = vec3.zero();

  return function (line, plane, outPt) {
    vec3.sub(ab, line.e, line.s);
    var t = (plane.d - vec3.dot(line.s, plane.n)) / vec3.dot(ab, plane.n);
    var intersects = t >= 0 && t <= 1.0;

    if (outPt && intersects) {
      vec3.scale(outPt, ab, t);
      vec3.add(outPt, outPt, line.s);
    }

    return intersects;
  };
})();

/**
 * ray-triangle intersect
 *
 * @param {ray} ray
 * @param {triangle} triangle
 * @param {vec3} outPt the intersect point if provide
 * @return {boolean}
 */
var ray_triangle = (function () {
  var ab = vec3.zero();
  var ac = vec3.zero();
  var pvec = vec3.zero();
  var tvec = vec3.zero();
  var qvec = vec3.zero();

  return function (ray, triangle, outPt) {
    vec3.sub(ab, triangle.b, triangle.a);
    vec3.sub(ac, triangle.c, triangle.a);

    vec3.cross(pvec, ray.d, ac);
    var det = vec3.dot(ab, pvec);

    if (det <= 0) {
      return false;
    }

    vec3.sub(tvec, ray.o, triangle.a);
    var u = vec3.dot(tvec, pvec);
    if (u < 0 || u > det) {
      return false;
    }

    vec3.cross(qvec, tvec, ab);
    var v = vec3.dot(ray.d, qvec);
    if (v < 0 || u + v > det) {
      return false;
    }

    if (outPt) {
      var t = vec3.dot(ac, qvec) / det;
      vec3.scaleAndAdd(outPt, ray.o, ray.d, t);
    }

    return true;
  };
})();

/**
 * line-triangle intersect
 *
 * @param {line} line
 * @param {triangle} triangle
 * @param {vec3} outPt the intersect point if provide
 * @return {boolean}
 */
var line_triangle = (function () {
  var ab = vec3.zero();
  var ac = vec3.zero();
  var qp = vec3.zero();
  var ap = vec3.zero();
  var n = vec3.zero();
  var e = vec3.zero();

  return function (line, triangle, outPt) {
    vec3.sub(ab, triangle.b, triangle.a);
    vec3.sub(ac, triangle.c, triangle.a);
    vec3.sub(qp, line.s, line.e);

    vec3.cross(n, ab, ac);
    var det = vec3.dot(qp, n);

    if (det <= 0.0) {
      return false;
    }

    vec3.sub(ap, line.s, triangle.a);
    var t = vec3.dot(ap, n);
    if (t < 0 || t > det) {
      return false;
    }

    vec3.cross(e, qp, ap);
    var v = vec3.dot(ac, e);
    if (v < 0 || v > det) {
      return false;
    }

    var w = -vec3.dot(ab, e);
    if (w < 0.0 || v + w > det) {
      return false;
    }

    if (outPt) {
      var invDet = 1.0 / det;
      v *= invDet;
      w *= invDet;
      var u = 1.0 - v - w;

      // outPt = u*a + v*d + w*c;
      vec3.set(outPt,
        triangle.a.x * u + triangle.b.x * v + triangle.c.x * w,
        triangle.a.y * u + triangle.b.y * v + triangle.c.y * w,
        triangle.a.z * u + triangle.b.z * v + triangle.c.z * w
      );
    }

    return true;
  };
})();

/**
 * ray-quad intersect
 *
 * @param {vec3} p
 * @param {vec3} q
 * @param {vec3} a
 * @param {vec3} b
 * @param {vec3} c
 * @param {vec3} d
 * @param {vec3} outPt the intersect point if provide
 * @return {boolean}
 */
var line_quad = (function () {
  var pq = vec3.zero();
  var pa = vec3.zero();
  var pb = vec3.zero();
  var pc = vec3.zero();
  var pd = vec3.zero();
  var m = vec3.zero();
  var tmp = vec3.zero();

  return function (p, q, a, b, c, d, outPt) {
    vec3.sub(pq, q, p);
    vec3.sub(pa, a, p);
    vec3.sub(pb, b, p);
    vec3.sub(pc, c, p);

    // Determine which triangle to test against by testing against diagonal first
    vec3.cross(m, pc, pq);
    var v = vec3.dot(pa, m);

    if (v >= 0) {
      // Test intersection against triangle abc
      var u = -vec3.dot(pb, m);
      if (u < 0) {
        return false;
      }

      var w = vec3.dot(vec3.cross(tmp, pq, pb), pa);
      if (w < 0) {
        return false;
      }

      // outPt = u*a + v*b + w*c;
      if (outPt) {
        var denom = 1.0 / (u + v + w);
        u *= denom;
        v *= denom;
        w *= denom;

        vec3.set(outPt,
          a.x * u + b.x * v + c.x * w,
          a.y * u + b.y * v + c.y * w,
          a.z * u + b.z * v + c.z * w
        );
      }
    } else {
      // Test intersection against triangle dac
      vec3.sub(pd, d, p);

      var u$1 = vec3.dot(pd, m);
      if (u$1 < 0) {
        return false;
      }

      var w$1 = vec3.dot(vec3.cross(tmp, pq, pa), pd);
      if (w$1 < 0) {
        return false;
      }

      // outPt = u*a + v*d + w*c;
      if (outPt) {
        v = -v;

        var denom$1 = 1.0 / (u$1 + v + w$1);
        u$1 *= denom$1;
        v *= denom$1;
        w$1 *= denom$1;

        vec3.set(outPt,
          a.x * u$1 + d.x * v + c.x * w$1,
          a.y * u$1 + d.y * v + c.y * w$1,
          a.z * u$1 + d.z * v + c.z * w$1
        );
      }
    }

    return true;
  };
})();

/**
 * ray-sphere intersect
 *
 * @param {ray} ray
 * @param {sphere} sphere
 * @param {vec3} outPt the intersect point if provide
 * @return {boolean}
 */
var ray_sphere = (function () {
  var e = vec3.zero();
  var c = vec3.zero();
  var o = vec3.zero();
  var d = vec3.zero();

  return function (ray, sphere, outPt) {
    var r = sphere.r;
    c = sphere.c;
    o = ray.o;
    d = ray.d;
    vec3.sub(e, c, o);
    var eLength = vec3.magnitude(e);

    //Projection formula: dot(a, b) / |b|
    var aLength = vec3.dot(e, d) / vec3.magnitude(d);
    var f = Math.sqrt(sphere.r * sphere.r - (eLength * eLength - aLength * aLength));
    var t = aLength - f;

    if (f < 0 || t < 0 || eLength < sphere.r) {
      return false;
    }

    vec3.scale(outPt, e, (eLength - r) / eLength);

    return true;
  };
})();

/**
 * ray-box intersect
 *
 * @param {ray} ray
 * @param {box} box
 * @param {vec3} outPt the intersect point if provide
 * @return {boolean}
 */
var ray_box = (function () {
  var center = vec3.zero();
  var o = vec3.zero();
  var d = vec3.zero();
  var X = vec3.zero();
  var Y = vec3.zero();
  var Z = vec3.zero();
  var p = vec3.zero();
  var out = vec3.zero();
  var size = new Array(3);
  var f = new Array(3);
  var e = new Array(3);
  var t = new Array(6);

  return function (ray, box, outPt) {
    size[0] = box.size.x;
    size[1] = box.size.y;
    size[2] = box.size.z;
    center = box.center;
    o = ray.o;
    d = ray.d;

    vec3.set(X, box.orientation.m00, box.orientation.m01, box.orientation.m02);
    vec3.set(Y, box.orientation.m03, box.orientation.m04, box.orientation.m05);
    vec3.set(Z, box.orientation.m06, box.orientation.m07, box.orientation.m08);
    vec3.sub(p, center, o);

    //The cos values of the ray on the X, Y, Z
    f[0] = vec3.dot(X, d);
    f[1] = vec3.dot(Y, d);
    f[2] = vec3.dot(Z, d);

    //The projection length of P on X, Y, Z
    e[0] = vec3.dot(X, p);
    e[1] = vec3.dot(Y, p);
    e[2] = vec3.dot(Z, p);

    for (var i = 0; i < 3; ++i) {
      if (f[i] === 0) {
        if (-e[i] - size[i] > 0 || -e[i] + size[i] < 0) {
          return false;
        }
        // Avoid div by 0!
        f[i] = 0.0000001;
      }
      // min
      t[i * 2 + 0] = (e[i] + size[i]) / f[i];
      // max
      t[i * 2 + 1] = (e[i] - size[i]) / f[i];
    }
    var tmin = Math.max(
      Math.max(
        Math.min(t[0], t[1]),
        Math.min(t[2], t[3])),
      Math.min(t[4], t[5])
    );
    var tmax = Math.min(
      Math.min(
        Math.max(t[0], t[1]),
        Math.max(t[2], t[3])),
      Math.max(t[4], t[5])
    );
    if (tmax < 0 || tmin > tmax || tmin < 0) {
      return false;
    }

    vec3.set(out, tmin * f[0] + o.x, tmin * f[1] + o.y, tmin * f[2] + o.z);
    vec3.transformMat3(outPt, out, box.orientation);

    return true;
  };
})();

var box_point = (function () {
  var tmp = vec3.zero(), m3 = mat3.create();
  var lessThan = function(a, b) { return Math.abs(a.x) < b.x && Math.abs(a.y) < b.y && Math.abs(a.z) < b.z; };
  return function(box, point) {
    vec3.sub(tmp, point, box.center);
    vec3.transformMat3(tmp, tmp, mat3.transpose(m3, box.orientation));
    return lessThan(tmp, box.size);
  };
})();


/**
 * box-plane intersect
 *
 * @param {box} box
 * @param {plane} plane
 * @return {number} outside(front) = 0, intersect = -1, inside(back) = 1
 */
var box_plane = (function () {
  var absDot = function(n, x, y, z) {
    return Math.abs(n.x * x + n.y * y + n.z * z);
  };
  return function (box, plane) {
    // Real-Time Collision Detection, Christer Ericson, p. 163.
    var r = box.size.x * absDot(plane.n, box.orientation.m00, box.orientation.m01, box.orientation.m02) +
      box.size.y * absDot(plane.n, box.orientation.m03, box.orientation.m04, box.orientation.m05) +
      box.size.z * absDot(plane.n, box.orientation.m06, box.orientation.m07, box.orientation.m08);

    var dot = vec3.dot(plane.n, box.center);
    if (dot + r < plane.d) { return 1; }
    else if (dot - r > plane.d) { return 0; }
    return -1;
  };
})();

/**
 * box-frustum intersect, faster but has
 * false positive corner cases, read more here:
 * https://cesium.com/blog/2017/02/02/tighter-frustum-culling-and-why-you-may-want-to-disregard-it/
 *
 * @param {box} box
 * @param {planes: plane[], vertices: vec3[]} frustum
 * @return {boolean}
 */
var box_frustum = function (box, frustum) {
  for (var i = 0; i < frustum.planes.length; i++)
    // frustum plane normal points to the inside
    { if (box_plane(box, frustum.planes[i]) == 1)
      { return false; } } // completely outside
  return true;
};

/**
 * box-frustum intersect, handles most of the false positives correctly
 *
 * @param {box} box
 * @param {planes: plane[], vertices: vec3[]} frustum
 * @return {boolean}
 */
var box_frustum_accurate = (function () {
  var tmp = new Array(8), dist = 0, out1 = 0, out2 = 0;
  for (var i = 0; i < tmp.length; i++) { tmp[i] = vec3.zero(); }
  var dot = function(n, x, y, z) {
    return n.x * x + n.y * y + n.z * z;
  };
  return function (cbox, frustum) {
    var result = 0, intersects = false;
    // 1. box inside/outside frustum test
    for (var i = 0; i < frustum.planes.length; i++) {
      result = box_plane(cbox, frustum.planes[i]);
      // frustum plane normal points to the inside
      if (result == 1) { return false; } // completely outside
      else if (result == -1) { intersects = true; }
    }
    if (!intersects) { return true; } // completely inside
    // in case of false positives
    // 2. frustum inside/outside box test
    for (var i$1 = 0; i$1 < frustum.vertices.length; i$1++)
      { vec3.sub(tmp[i$1], frustum.vertices[i$1], cbox.center); }
    out1 = 0, out2 = 0;
    for (var i$2 = 0; i$2 < frustum.vertices.length; i$2++) {
      dist = dot(tmp[i$2], cbox.orientation.m00, cbox.orientation.m01, cbox.orientation.m02);
      if (dist > cbox.size.x) { out1++; }
      else if (dist < -cbox.size.x) { out2++; }
    }
    if (out1 == frustum.vertices.length || out2 == frustum.vertices.length) { return false; }
    out1 = 0; out2 = 0;
    for (var i$3 = 0; i$3 < frustum.vertices.length; i$3++) {
      dist = dot(tmp[i$3], cbox.orientation.m03, cbox.orientation.m04, cbox.orientation.m05);
      if (dist > cbox.size.y) { out1++; }
      else if (dist < -cbox.size.y) { out2++; }
    }
    if (out1 == frustum.vertices.length || out2 == frustum.vertices.length) { return false; }
    out1 = 0; out2 = 0;
    for (var i$4 = 0; i$4 < frustum.vertices.length; i$4++) {
      dist = dot(tmp[i$4], cbox.orientation.m06, cbox.orientation.m07, cbox.orientation.m08);
      if (dist > cbox.size.z) { out1++; }
      else if (dist < -cbox.size.z) { out2++; }
    }
    if (out1 == frustum.vertices.length || out2 == frustum.vertices.length) { return false; }
    return true;
  };
})();

/**
 * box-box intersect
 *
 * @param {box} box
 * @return {boolean}
 */
var box_box = (function () {
  var test = new Array(15);
  for (var i$1 = 0; i$1 < 15; i$1++) {
    test[i$1] = vec3.zero();
  }

  var vertex = new Array(8);
  for (var i$2 = 0; i$2 < 8; i$2++) {
    vertex[i$2] = vec3.zero();
  }

  var i = vec3.zero();
  var a = vec3.zero();
  var p1 = vec3.zero();
  var p2 = vec3.zero();

  return function (box0, box1) {
    vec3.set(test[0], box0.orientation.m00, box0.orientation.m01, box0.orientation.m02);
    vec3.set(test[1], box0.orientation.m03, box0.orientation.m04, box0.orientation.m05);
    vec3.set(test[2], box0.orientation.m06, box0.orientation.m07, box0.orientation.m08);
    vec3.set(test[3], box1.orientation.m00, box1.orientation.m01, box1.orientation.m02);
    vec3.set(test[4], box1.orientation.m03, box1.orientation.m04, box1.orientation.m05);
    vec3.set(test[5], box1.orientation.m06, box1.orientation.m07, box1.orientation.m08);

    // Fill out rest of axis
    for (var i$1 = 0; i$1 < 3; ++i$1) {
      vec3.cross(test[6 + i$1 * 3 + 0], test[i$1], test[0]);
      vec3.cross(test[6 + i$1 * 3 + 1], test[i$1], test[1]);
      vec3.cross(test[6 + i$1 * 3 + 1], test[i$1], test[2]);
    }

    // Seperating axis found
    for (var i$2 = 0; i$2 < 15; ++i$2) {

      if (!overlapOnAxis(box0, box1, test[i$2])) {
        return false;
      }
    }

    return true;

    function overlapOnAxis(box0, box1, axis) {

      var MIN = 0;
      var MAX = 1;
      var interval_0 = getInterval(box0, axis);
      var interval_1 = getInterval(box1, axis);

      return ((interval_1[MIN] <= interval_0[MAX]) && (interval_0[MIN] <= interval_1[MAX]));
    }

    function getInterval(box, axis) {

      vec3.add(p1, box.center, box.size);
      vec3.sub(p2, box.center, box.size);

      //Get min
      vec3.set(i, Math.min(p1.x, p2.x), Math.min(p1.y, p2.y), Math.min(p1.z, p2.z));

      //Get max
      vec3.set(a, Math.max(p1.x, p2.x), Math.max(p1.y, p2.y), Math.max(p1.z, p2.z));

      vec3.set(vertex[0], i.x, a.y, a.z);
      vec3.set(vertex[1], i.x, a.y, i.z);
      vec3.set(vertex[2], i.x, i.y, a.z);
      vec3.set(vertex[3], i.x, i.y, i.z);
      vec3.set(vertex[4], a.x, a.y, a.z);
      vec3.set(vertex[5], a.x, a.y, i.z);
      vec3.set(vertex[6], a.x, i.y, a.z);
      vec3.set(vertex[7], a.x, i.y, i.z);

      var min = 0;
      var max = 0;
      min = max = vec3.dot(axis, vertex[0]);

      for (var i$1 = 1; i$1 < 8; ++i$1) {
        var projection = vec3.dot(axis, vertex[i$1]);
        min = (projection < min) ?
          projection : min;
        max = (projection > max) ?
          projection : max;
      }
      var result = [min, max];

      return result;
    }
  };
})();

/**
 * sphere-plane intersect, not necessarily faster than box-plane
 * due to the length calculation of the plane normal to factor out
 * the unnomalized plane distance
 *
 * @param {sphere} sphere
 * @param {plane} plane
 * @return {number} outside(front) = 0, intersect = -1, inside(back) = 1
 */
var sphere_plane = function (sphere, plane) {
  var dot = vec3.dot(plane.n, sphere.c);
  var r = sphere.r * vec3.magnitude(plane.n);
  if (dot + r < plane.d) { return 1; }
  else if (dot - r > plane.d) { return 0; }
  return -1;
};

/**
 * sphere-frustum intersect, faster but has 
 * false positive corner cases, read more here:
 * https://stackoverflow.com/questions/20912692/view-frustum-culling-corner-cases
 *
 * @param {sphere} sphere
 * @param {planes: plane[], vertices: vec3[]} frustum
 * @return {boolean}
 */
var sphere_frustum = function (sphere, frustum) {
  for (var i = 0; i < frustum.planes.length; i++)
    // frustum plane normal points to the inside
    { if (sphere_plane(sphere, frustum.planes[i]) == 1)
      { return false; } } // completely outside
  return true;
};

/**
 * sphere-frustum intersect, handles the false positives correctly
 *
 * @param {sphere} sphere
 * @param {planes: plane[], vertices: vec3[]} frustum
 * @return {boolean}
 */
var sphere_frustum_accurate = (function () {
  var pt = vec3.zero(), map = [1, -1, 1, -1, 1, -1];
  var p = [], d = [];
  return function (sphere, frustum) {
    var intersects = false; p.length = 0; d.length = 0;
    for (var i = 0; i < frustum.planes.length; i++) {
      var dot = vec3.dot(frustum.planes[i].n, sphere.c);
      var dist = vec3.magnitude(frustum.planes[i].n);
      var r = sphere.r * dist; d.push(1 / dist);
      // frustum plane normal points to the inside
      if (dot + r < frustum.planes[i].d) { return false; } // completely outside
      else if (dot - r < frustum.planes[i].d) { intersects = true; p.push(i); }
    }
    if (!intersects) { return true; } // completely inside
    // in case of false positives
    for (var j = 0; j < p.length; j++) {
      // the most accurate solution would be to calculate 
      // the farthest intersection point away from each testing plane,
      // but the trade-off here is acceptable
      // for the corner cases are rare and generally negligible
      vec3.scale(pt, frustum.planes[p[j]].n, sphere.r * d[p[j]]);
      vec3.add(pt, sphere.c, pt);
      for (var i$1 = 0; i$1 < frustum.planes.length; i$1++) {
        if (i$1 == p[j] || i$1 == p[j] + map[i$1]) { continue; }
        if (vec3.dot(frustum.planes[i$1].n, pt) < frustum.planes[i$1].d) 
          { return false; }
      }
    }
    return true;
  };
})();

/**
 * sphere-sphere intersect
 *
 * @param {sphere} sphere0
 * @param {sphere} sphere1
 * @return {boolean}
 */
var sphere_sphere = (function () {
  var c0 = vec3.zero();
  var c1 = vec3.zero();

  return function (sphere0, sphere1) {
    var r0 = sphere0.r;
    var r1 = sphere1.r;
    c0 = sphere0.c;
    c1 = sphere1.c;
    var distance$$1 = vec3.distance(c0, c1);

    if (distance$$1 > (r0 + r1)) {
      return false;
    }
    else { return true; }
  };
})();

/**
 * box-sphere intersect
 *
 * @param {sphere} sphere
 * @param {box} box
 * @return {boolean}
 */

var sphere_box = (function () {
  var X = vec3.zero();
  var Y = vec3.zero();
  var Z = vec3.zero();
  var d = vec3.zero();
  var closestPoint = vec3.zero();
  var u = new Array(3);
  var e = new Array(3);

  return function (sphere, box) {
    vec3.set(X, box.orientation.m00, box.orientation.m01, box.orientation.m02);
    vec3.set(Y, box.orientation.m03, box.orientation.m04, box.orientation.m05);
    vec3.set(Z, box.orientation.m06, box.orientation.m07, box.orientation.m08);

    u[0] = X;
    u[1] = Y;
    u[2] = Z;
    e[0] = box.size.x;
    e[1] = box.size.y;
    e[2] = box.size.z;

    vec3.sub(d, sphere.c, box.center);

    //Start result at center of box; make steps from there
    vec3.set(closestPoint, box.center.x, box.center.y, box.center.z);

    //For each OBB axis...
    for (var i = 0; i < 3; i++) {

      //...project d onto that axis to get the distance
      //along the axis of d from the box center
      var dist$1 = vec3.dot(d, u[i]);

      //if distance farther than the box extents, clamp to the box
      if (dist$1 > e[i]) {
        dist$1 = e[i];
      }
      if (dist$1 < -e[i]) {
        dist$1 = -e[i];
      }

      //Step that distance along the axis to get world coordinate
      closestPoint.x += dist$1 * u[i].x;
      closestPoint.y += dist$1 * u[i].y;
      closestPoint.z += dist$1 * u[i].z;
    }

    var dist = vec3.distance(closestPoint, sphere.c);

    return dist < sphere.r;
  };
})();

/**
 * @name intersect
 */
var intersect = {
  ray_plane: ray_plane,
  line_plane: line_plane,
  ray_triangle: ray_triangle,
  line_triangle: line_triangle,
  line_quad: line_quad,
  ray_sphere: ray_sphere,
  ray_box: ray_box,
  box_point: box_point,
  box_plane: box_plane,
  box_frustum: box_frustum,
  box_frustum_accurate: box_frustum_accurate,
  box_box: box_box,
  sphere_plane: sphere_plane,
  sphere_frustum: sphere_frustum,
  sphere_frustum_accurate: sphere_frustum_accurate,
  sphere_sphere: sphere_sphere,
  sphere_box: sphere_box,
};

var line = function line(sx, sy, sz, ex, ey, ez) {
  this.s = vec3.new(sx, sy, sz);
  this.e = vec3.new(ex, ey, ez);
};
/**
 * create a new line
 *
 * @return {line}
 */
line.create = function create () {
  return new line(0, 0, 0, 0, 0, -1);
};

/**
 * create a new line
 *
 * @param {Number} sx start X component
 * @param {Number} sy start Y component
 * @param {Number} sz start Z component
 * @param {Number} ex end X component
 * @param {Number} ey end Y component
 * @param {Number} ez end Z component
 * @return {line}
 */
line.new = function new$1 (sx, sy, sz, ex, ey, ez) {
  return new line(sx, sy, sz, ex, ey, ez);
};

/**
 * Creates a new line initialized with values from an existing line
 *
 * @param {line} a line to clone
 * @returns {line} a new line
 */
line.clone = function clone (a) {
  return new line(
    a.s.x, a.s.y, a.s.z,
    a.e.x, a.e.y, a.e.z
  );
};

/**
 * Copy the values from one line to another
 *
 * @param {line} out the receiving line
 * @param {line} a the source line
 * @returns {line} out
 */
line.copy = function copy (out, a) {
  out.s.x = a.s.x;
  out.s.y = a.s.y;
  out.s.z = a.s.z;
  out.e.x = a.e.x;
  out.e.y = a.e.y;
  out.e.z = a.e.z;

  return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} sx start X component
 * @param {Number} sy start Y component
 * @param {Number} sz start Z component
 * @param {Number} ex end X component
 * @param {Number} ey end Y component
 * @param {Number} ez end Z component
 * @returns {vec3} out
 */
line.set = function set (out, sx, sy, sz, ex, ey, ez) {
  out.s.x = sx;
  out.s.y = sy;
  out.s.z = sz;
  out.e.x = ex;
  out.e.y = ey;
  out.e.z = ez;

  return out;
};

/**
 * create line from 2 points
 *
 * @param {line} line
 * @returns {number}
 */
line.magnitude = function magnitude (line) {
  return vec3.distance(line.s, line.e);
};

/**
 *Alias of {@link line.magnitude}.
 */
line.mag = function mag (line) {
  return line.magnitude(line);
};

var plane = function plane(nx, ny, nz, d) {
  this.n = vec3.new(nx, ny, nz);
  this.d = d;
};

/**
 * create a new plane
 *
 * @return {plane}
 */
plane.create = function create () {
  return new plane(0, 1, 0, 0);
};

/**
 * create a new plane
 *
 * @param {Number} nx normal X component
 * @param {Number} ny normal Y component
 * @param {Number} nz normal Z component
 * @param {Number} d the constant d
 * @return {plane}
 */
plane.new = function new$1 (nx, ny, nz, d) {
  return new plane(nx, ny, nz, d);
};

/**
 * clone a new plane
 *
 * @param {plane} p a the source plane
 * @return {plane}
 */
plane.clone = function clone (p) {
  return new plane(p.n.x, p.n.y, p.n.z, p.d);
};

/**
 * copy the values from one plane to another
 *
 * @param {plane} out the receiving plane
 * @param {plane} p the source plane
 * @return {plane}
 */
plane.copy = function copy (out, p) {
  out.n.x = p.n.x;
  out.n.y = p.n.y;
  out.n.z = p.n.z;
  out.d = p.d;

  return out;
};

/**
 * Set the components of a plane to the given values
 *
 * @param {plane} out the receiving plane
 * @param {Number} nx X component of n
 * @param {Number} ny Y component of n
 * @param {Number} nz Z component of n
 * @param {Number} d
 * @returns {plane} out
 * @function
 */
plane.set = function set (out, nx, ny, nz, d) {
  out.n.x = nx;
  out.n.y = ny;
  out.n.z = nz;
  out.d = d;

  return out;
};

/**
 * create plane from normal and point
 *
 * @param {plane} out the receiving plane
 * @param {vec3} normal
 * @param {vec3} point
 * @returns {plane} out
 * @function
 */
plane.fromNormalAndPoint = function fromNormalAndPoint (out, normal, point) {
  vec3.copy(out.n, normal);
  out.d = vec3.dot(normal, point);

  return out;
};

/**
 * normalize a plane
 *
 * @param {plane} out the receiving plane
 * @param {plane} a plane to normalize
 * @returns {plane} out
 */
plane.normalize = function normalize (out, a) {
  var len = vec3.magnitude(a.n);
  vec3.normalize(out.n, a.n);
  if (len > 0) {
    out.d = a.d / len;
  }
  return out;
};

/**
 * create plane from 3 points
 *
 * @param {plane} out the receiving plane
 * @param {vec3} a
 * @param {vec3} b
 * @param {vec3} c
 * @returns {plane} out
 * @function
 */
plane.fromPoints = (function () {
  var v1 = vec3.zero();
  var v2 = vec3.zero();

  return function (out, a, b, c) {
    vec3.sub(v1, b, a);
    vec3.sub(v2, c, a);

    vec3.normalize(out.n, vec3.cross(out.n, v1, v2));
    out.d = vec3.dot(out.n, a);

    return out;
  };
})();

var ray = function ray(ox, oy, oz, dx, dy, dz) {
  this.o = vec3.new(ox, oy, oz);
  this.d = vec3.new(dx, dy, dz);
};

/**
 * create a new ray
 *
 * @return {ray}
 */
ray.create = function create () {
  return new ray(0, 0, 0, 0, 0, -1);
};

/**
 * create a new ray
 *
 * @param {Number} ox origin X component
 * @param {Number} oy origin Y component
 * @param {Number} oz origin Z component
 * @param {Number} dx dir X component
 * @param {Number} dy dir Y component
 * @param {Number} dz dir Z component
 * @return {ray}
 */
ray.new = function new$1 (ox, oy, oz, dx, dy, dz) {
  return new ray(ox, oy, oz, dx, dy, dz);
};

/**
 * Creates a new ray initialized with values from an existing ray
 *
 * @param {ray} a ray to clone
 * @returns {ray} a new ray
 */
ray.clone = function clone (a) {
  return new ray(
    a.o.x, a.o.y, a.o.z,
    a.d.x, a.d.y, a.d.z
  );
};

/**
 * Copy the values from one ray to another
 *
 * @param {ray} out the receiving ray
 * @param {ray} a the source ray
 * @returns {ray} out
 */
ray.copy = function copy (out, a) {
  out.o.x = a.o.x;
  out.o.y = a.o.y;
  out.o.z = a.o.z;
  out.d.x = a.d.x;
  out.d.y = a.d.y;
  out.d.z = a.d.z;

  return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} ox origin X component
 * @param {Number} oy origin Y component
 * @param {Number} oz origin Z component
 * @param {Number} dx dir X component
 * @param {Number} dy dir Y component
 * @param {Number} dz dir Z component
 * @returns {vec3} out
 */
ray.set = function set (out, ox, oy, oz, dx, dy, dz) {
  out.o.x = ox;
  out.o.y = oy;
  out.o.z = oz;
  out.d.x = dx;
  out.d.y = dy;
  out.d.z = dz;

  return out;
};

/**
 * create ray from 2 points
 *
 * @param {ray} out the receiving plane
 * @param {vec3} origin
 * @param {vec3} lookAt
 * @returns {ray} out
 * @function
 */
ray.fromPoints = function fromPoints (out, origin, lookAt) {
  vec3.copy(out.o, origin);
  vec3.normalize(out.d, vec3.sub(out.d, lookAt, origin));

  return out;
};

var triangle = function triangle(ax, ay, az, bx, by, bz, cx, cy, cz) {
  this.a = vec3.new(ax, ay, az);
  this.b = vec3.new(bx, by, bz);
  this.c = vec3.new(cx, cy, cz);
};

/**
 * create a new triangle
 *
 * @return {triangle}
 */
triangle.create = function create () {
  return new triangle(
    0, 0, 0,
    1, 0, 0,
    0, 1, 0
  );
};

/**
 * create a new triangle
 *
 * @param {Number} ax
 * @param {Number} ay
 * @param {Number} az
 * @param {Number} bx
 * @param {Number} by
 * @param {Number} bz
 * @param {Number} cx
 * @param {Number} cy
 * @param {Number} cz
 * @return {triangle}
 */
triangle.new = function new$1 (ax, ay, az, bx, by, bz, cx, cy, cz) {
  return new triangle(
    ax, ay, az,
    bx, by, bz,
    cx, cy, cz
  );
};

/**
 * clone a new triangle
 *
 * @param {triangle} t the source plane
 * @return {triangle}
 */
triangle.clone = function clone (t) {
  return new triangle(
    t.a.x, t.a.y, t.a.z,
    t.b.x, t.b.y, t.b.z,
    t.c.x, t.c.y, t.c.z
  );
};

/**
 * copy the values from one triangle to another
 *
 * @param {triangle} out the receiving triangle
 * @param {triangle} t the source triangle
 * @return {triangle}
 */
triangle.copy = function copy (out, t) {
  out.a.x = t.a.x;
  out.a.y = t.a.y;
  out.a.z = t.a.z;

  out.b.x = t.b.x;
  out.b.y = t.b.y;
  out.b.z = t.b.z;

  out.c.x = t.c.x;
  out.c.y = t.c.y;
  out.c.z = t.c.z;

  return out;
};

/**
 * Set the components of a triangle to the given values
 *
 * @param {triangle} out the receiving plane
 * @param {Number} ax X component of a
 * @param {Number} ay Y component of a
 * @param {Number} az Z component of a
 * @param {Number} bx X component of b
 * @param {Number} by Y component of b
 * @param {Number} bz Z component of b
 * @param {Number} cx X component of c
 * @param {Number} cy Y component of c
 * @param {Number} cz Z component of c
 * @returns {plane} out
 * @function
 */
triangle.set = function set (out, ax, ay, az, bx, by, bz, cx, cy, cz) {
  out.a.x = ax;
  out.a.y = ay;
  out.a.z = az;

  out.b.x = bx;
  out.b.y = by;
  out.b.z = bz;

  out.c.x = cx;
  out.c.y = cy;
  out.c.z = cz;

  return out;
};

var sphere = function sphere(cx, cy, cz, r) {
  this.c = vec3.new(cx, cy, cz);
  this.r = r;
};

/**
 * create a new sphere
 *
 * @return {plane}
 */
sphere.create = function create () {
  return new sphere(0, 0, 0, 1);
};

/**
 * create a new sphere
 *
 * @param {Number} cx normal X component
 * @param {Number} cy normal Y component
 * @param {Number} cz normal Z component
 * @param {Number} r the radius r
 * @return {sphere}
 */
sphere.new = function new$1 (cx, cy, cz, r) {
  return new sphere(cx, cy, cz, r);
};

/**
 * clone a new sphere
 *
 * @param {sphere} p the source sphere
 * @return {sphere}
 */
sphere.clone = function clone (p) {
  return new sphere(p.c.x, p.c.y, p.c.z, p.r);
};

/**
 * copy the values from one sphere to another
 *
 * @param {sphere} out the receiving sphere
 * @param {sphere} p the source sphere
 * @return {sphere}
 */
sphere.copy = function copy (out, p) {
  out.c.x = p.c.x;
  out.c.y = p.c.y;
  out.c.z = p.c.z;
  out.r = p.r;

  return out;
};

/**
 * Set the components of a sphere to the given values
 *
 * @param {sphere} out the receiving sphere
 * @param {Number} cx X component of c
 * @param {Number} cy Y component of c
 * @param {Number} cz Z component of c
 * @param {Number} r
 * @returns {sphere} out
 * @function
 */
sphere.set = function set (out, cx, cy, cz, r) {
  out.c.x = cx;
  out.c.y = cy;
  out.c.z = cz;
  out.r = r;

  return out;
};

var box = function box(px, py, pz, w, h, l, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
  this.center = vec3.new(px, py, pz);
  this.size = vec3.new(w, h, l);
  this.orientation = mat3.new(ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
};

/**
 * create a new box
 *
 * @return {plane}
 */
box.create = function create () {
  return new box(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1);
};

/**
 * create a new box
 *
 * @param {Number} px X coordinates for box's original point
 * @param {Number} py Y coordinates for box's original point
 * @param {Number} pz Z coordinates for box's original point
 * @param {Number} w the half of box width
 * @param {Number} h the half of box height
 * @param {Number} l the half of box length
 * @param {Number} ox_1 the orientation vector coordinates
 * @param {Number} ox_2 the orientation vector coordinates
 * @param {Number} ox_3 the orientation vector coordinates
 * @param {Number} oy_1 the orientation vector coordinates
 * @param {Number} oy_2 the orientation vector coordinates
 * @param {Number} oy_3 the orientation vector coordinates
 * @param {Number} oz_1 the orientation vector coordinates
 * @param {Number} oz_2 the orientation vector coordinates
 * @param {Number} oz_3 the orientation vector coordinates
 * @return {box}
 */
box.new = function new$1 (px, py, pz, w, h, l, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
  return new box(px, py, pz, w, h, l, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
};

/**
 * Set the transform information of the box
 *
 * @param {box} out the receiving box
 * @param {vec3} pos the surrounding object world coordinates
 * @param {vec3} rot the surrounding object world spins
 * @param {vec3} scale the surrounding object world zooms
 * @param {box} parent parent box transform to apply
 * @return {box}
 */
box.setTransform = function setTransform (out, pos, rot, scale, parent) {
    if ( parent === void 0 ) parent = null;

  vec3.copy(out.center, pos);
  mat3.fromQuat(out.orientation, rot);
  vec3.copy(out.size, scale);
  if (parent) {
    vec3.add(out.center, out.center, parent.center);
    mat3.mul(out.orientation, out.orientation, parent.orientation);
    vec3.mul(out.size, out.size, parent.size);
  }
  return out;
};

/**
 * clone a new box
 *
 * @param {box} a the source box
 * @return {box}
 */
box.clone = function clone (a) {
  return new box(a.center.x, a.center.y, a.center.z,
    a.size.x, a.size.y, a.size.z,
    a.orientation.m00, a.orientation.m01, a.orientation.m02,
    a.orientation.m03, a.orientation.m04, a.orientation.m05,
    a.orientation.m06, a.orientation.m07, a.orientation.m08);
};

/**
 * copy the values from one box to another
 *
 * @param {box} out the receiving box
 * @param {box} a the source box
 * @return {box}
 */
box.copy = function copy (out, a) {
  out.center = a.center;
  out.size = a.size;
  out.orientation = a.orientation;

  return out;
};

/**
 * Set the components of a box to the given values
 *
 * @param {box} out the receiving box
 * @param {Number} px X coordinates for box's original point
 * @param {Number} py Y coordinates for box's original point
 * @param {Number} pz Z coordinates for box's original point
 * @param {Number} w the half of box width
 * @param {Number} h the half of box height
 * @param {Number} l the half of box length
 * @param {Number} ox_1 the orientation vector coordinates
 * @param {Number} ox_2 the orientation vector coordinates
 * @param {Number} ox_3 the orientation vector coordinates
 * @param {Number} oy_1 the orientation vector coordinates
 * @param {Number} oy_2 the orientation vector coordinates
 * @param {Number} oy_3 the orientation vector coordinates
 * @param {Number} oz_1 the orientation vector coordinates
 * @param {Number} oz_2 the orientation vector coordinates
 * @param {Number} oz_3 the orientation vector coordinates
 * @returns {box} out
 * @function
 */
box.set = function set (out, px, py, pz, w, h, l, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
  vec3.set(out.center, px, py, pz);
  vec3.set(out.size, w, h, l);
  mat3.set(out.orientation, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
  return out;
};

/**
 * create a new axis-aligned box from two corner points
 *
 * @param {vec3} minPos lower corner position of the box
 * @param {vec3} maxPos upper corner position of the box
 * @return {box}
 */
box.fromPoints = (function () {
  var center = vec3.zero();
  var halfSize = vec3.zero();
  return function (minPos, maxPos) {
    vec3.scale(center, vec3.add(center, minPos, maxPos), 0.5);
    vec3.scale(halfSize, vec3.sub(halfSize, maxPos, minPos), 0.5);
    return new box(center.x, center.y, center.z,
      halfSize.x, halfSize.y, halfSize.z,
      1, 0, 0, 0, 1, 0, 0, 0, 1);
  };
})();

var Keyframe = function Keyframe () {};

Keyframe.schema = {
  time: {
    type: 'number',
    default: 0,
  },
  value: {
    type: 'number',
    default: 0,
  },
  inTangent: {
    type: 'number',
    default: 0,
  },
  outTangent: {
    type: 'number',
    default: 0,
  }
};

var AnimationCurve = function AnimationCurve(keyFrames) {
  this._keyFrames = keyFrames;
};

AnimationCurve.prototype.addKey = function addKey (keyFrame) {
  if (this._keyFrames === null)
    { this._keyFrames = []; }
  this._keyFrames.push(keyFrame);
};

//cubic Hermite spline
AnimationCurve.prototype.evaluate = function evaluate (time) {
    var this$1 = this;

  var wrappedTime = time;
  var wrapMode = time < 0 ? this._preWrapMode : this._postWrapMode;
  var startTime = this._keyFrames[0].time;
  var endTime = this._keyFrames[this._keyFrames.length - 1].time;
  switch (wrapMode) {
    case 'loop':
      wrappedTime = repeat(time - startTime, endTime - startTime) + startTime;
      break;
    case 'pingPong':
      wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
      break;
    case 'clampForever':
      wrappedTime = clamp(time, startTime, endTime);
      break;
  }
  var preKFIndex = 0;
  if (wrappedTime > this._keyFrames[0].time) {
    if (wrappedTime >= this._keyFrames[this._keyFrames.length - 1].time)
      { preKFIndex = this._keyFrames.length - 2; }
    else {
      for (var i = 0; i < this._keyFrames.length - 1; i++) {
        if (wrappedTime >= this$1._keyFrames[0].time && wrappedTime <= this$1._keyFrames[i + 1].time) {
          preKFIndex = i;
          break;
        }
      }
    }
  }
  var keyframe0 = this._keyFrames[preKFIndex];
  var keyframe1 = this._keyFrames[preKFIndex + 1];

  var t = inverseLerp(keyframe0.time, keyframe1.time, wrappedTime);
  var dt = keyframe1.time - keyframe0.time;

  var m0 = keyframe0.outTangent * dt;
  var m1 = keyframe1.inTangent * dt;

  var t2 = t * t;
  var t3 = t2 * t;

  var a = 2 * t3 - 3 * t2 + 1;
  var b = t3 - 2 * t2 + t;
  var c = t3 - t2;
  var d = -2 * t3 + 3 * t2;

  return a * keyframe0.value + b * m0 + c * m1 + d * keyframe1.value;
};

AnimationCurve.schema = {
  keyFrames: {
    type: 'Keyframe',
    default: null,
    array: true,
  },
  preWrapMode: {
    type: 'enums',
    default: 'default',
    options: [
      'default',
      'once',
      'loop',
      'pingPong',
      'clampForever'
    ],
  },
  postWrapMode: {
    type: 'enums',
    default: 'default',
    options: [
      'default',
      'once',
      'loop',
      'pingPong',
      'clampForever'
    ],
  }
};



var geometry = Object.freeze({
	distance: distance,
	intersect: intersect,
	line: line,
	plane: plane,
	ray: ray,
	triangle: triangle,
	sphere: sphere,
	box: box,
	Keyframe: Keyframe,
	AnimationCurve: AnimationCurve
});

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

var _m4_tmp = mat4.create();
var _v3 = vec3.zero();
var _genID$2 = 0;

/**
 * A representation of a single camera view
 */
var View = function View() {
  var this$1 = this;

  this._id = _genID$2++;

  // priority. the smaller one will be rendered first
  this._priority = 0;

  // viewport
  this._rect = {
    x: 0, y: 0, w: 1, h: 1
  };

  // TODO:
  // this._scissor = {
  // x: 0, y: 0, w: 1, h: 1
  // };

  // clear options
  this._color = color4.new(0.3, 0.3, 0.3, 1);
  this._depth = 1;
  this._stencil = 0;
  this._clearFlags = enums$1.CLEAR_COLOR | enums$1.CLEAR_DEPTH;
  this._clearModel = null;

  // matrix
  this._matView = mat4.create();
  this._matProj = mat4.create();
  this._matViewProj = mat4.create();
  this._matInvViewProj = mat4.create();

  // stages & framebuffer
  this._stages = [];
  this._cullingByID = false;
  this._framebuffer = null;

  this._shadowLight = null; // TODO: should not refer light in view.

  this._frustum = {};
  this._frustum.fullUpdate = false;
  this._frustum.planes = new Array(6); // 0: left, 1: right, 2: bottom, 3: top, 4: near, 5: far
  for (var i = 0; i < 6; ++i) {
    this$1._frustum.planes[i] = plane.create();
  }
  this._frustum.vertices = new Array(8);
  for (var i$1 = 0; i$1 < 8; ++i$1) {
    this$1._frustum.vertices[i$1] = vec3.zero();
  }
};

var prototypeAccessors$5 = { fullUpdate: { configurable: true } };

/**
 * Set whether to update extra information in this view,
 * including only frustum vertex positions for now
 * @param {boolean} b need update or not
 */
prototypeAccessors$5.fullUpdate.set = function (b) {
  this._frustum.fullUpdate = b;
};

/**
 * Get the view's forward direction
 * @param {vec3} out the receiving vector
 * @returns {vec3} the receiving vector
 */
View.prototype.getForward = function getForward (out) {
  return vec3.set(
    out,
    -this._matView.m02,
    -this._matView.m06,
    -this._matView.m10
  );
};

/**
 * Get the view's observing location
 * @param {vec3} out the receiving vector
 * @returns {vec3} the receiving vector
 */
View.prototype.getPosition = function getPosition (out) {
  mat4.invert(_m4_tmp, this._matView);
  return mat4.getTranslation(out, _m4_tmp);
};

/**
 * Update the view's frustum information according to the stored transform matrix.
 * Note that the resulting planes are not normalized.
 */
View.prototype.updateFrustum = function updateFrustum () {
  // RTR3, ch. 16.14.1, p. 774
  // extract frustum planes from view-proj matrix.
  var m = this._matViewProj;

  // left plane
  vec3.set(this._frustum.planes[0].n, m.m03 + m.m00, m.m07 + m.m04, m.m11 + m.m08);
  this._frustum.planes[0].d = -(m.m15 + m.m12);
  // right plane
  vec3.set(this._frustum.planes[1].n, m.m03 - m.m00, m.m07 - m.m04, m.m11 - m.m08);
  this._frustum.planes[1].d = -(m.m15 - m.m12);
  // bottom plane
  vec3.set(this._frustum.planes[2].n, m.m03 + m.m01, m.m07 + m.m05, m.m11 + m.m09);
  this._frustum.planes[2].d = -(m.m15 + m.m13);
  // top plane
  vec3.set(this._frustum.planes[3].n, m.m03 - m.m01, m.m07 - m.m05, m.m11 - m.m09);
  this._frustum.planes[3].d = -(m.m15 - m.m13);
  // near plane
  vec3.set(this._frustum.planes[4].n, m.m03 + m.m02, m.m07 + m.m06, m.m11 + m.m10);
  this._frustum.planes[4].d = -(m.m15 + m.m14);
  // far plane
  vec3.set(this._frustum.planes[5].n, m.m03 - m.m02, m.m07 - m.m06, m.m11 - m.m10);
  this._frustum.planes[5].d = -(m.m15 - m.m14);

  // the actual distance of the plane can be retrieved by:
  // plane.d / vec3.magnitude(plane.n)

  if (!this._frustum.fullUpdate) { return; }
  // update frustum vertices
  vec3.set(_v3, 1,1,1); vec3.transformMat4(this._frustum.vertices[0], _v3, this._matInvViewProj);
  vec3.set(_v3, -1,1,1); vec3.transformMat4(this._frustum.vertices[1], _v3, this._matInvViewProj);
  vec3.set(_v3, -1, -1,1); vec3.transformMat4(this._frustum.vertices[2], _v3, this._matInvViewProj);
  vec3.set(_v3, 1, -1,1); vec3.transformMat4(this._frustum.vertices[3], _v3, this._matInvViewProj);
  vec3.set(_v3, 1,1, -1); vec3.transformMat4(this._frustum.vertices[4], _v3, this._matInvViewProj);
  vec3.set(_v3, -1,1, -1); vec3.transformMat4(this._frustum.vertices[5], _v3, this._matInvViewProj);
  vec3.set(_v3, -1, -1, -1); vec3.transformMat4(this._frustum.vertices[6], _v3, this._matInvViewProj);
  vec3.set(_v3, 1, -1, -1); vec3.transformMat4(this._frustum.vertices[7], _v3, this._matInvViewProj);
};

Object.defineProperties( View.prototype, prototypeAccessors$5 );

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

var _forward = vec3.new(0, 0, -1);

var _m4_tmp$1 = mat4.create();
var _m3_tmp = mat3.create();
var _transformedLightDirection = vec3.zero();

// compute light viewProjMat for shadow.
function _computeSpotLightViewProjMatrix(light, outView, outProj) {
  // view matrix
  light._node.getWorldRT(outView);
  mat4.invert(outView, outView);

  // proj matrix
  mat4.perspective(outProj, light._spotAngle * light._spotAngleScale, 1, light._shadowMinDepth, light._shadowMaxDepth);
}

function _computeDirectionalLightViewProjMatrix(light, outView, outProj) {
  // view matrix
  light._node.getWorldRT(outView);
  mat4.invert(outView, outView);

  // TODO: should compute directional light frustum based on rendered meshes in scene.
  // proj matrix
  var halfSize = light._shadowFrustumSize / 2;
  mat4.ortho(outProj, -halfSize, halfSize, -halfSize, halfSize, light._shadowMinDepth, light._shadowMaxDepth);
}

function _computePointLightViewProjMatrix(light, outView, outProj) {
  // view matrix
  light._node.getWorldRT(outView);
  mat4.invert(outView, outView);

  // The transformation from Cartesian to polar coordinates is not a linear function, 
  // so it cannot be achieved by means of a fixed matrix multiplication.
  // Here we just use a nearly 180 degree perspective matrix instead.
  mat4.perspective(outProj, toRadian(179), 1, light._shadowMinDepth, light._shadowMaxDepth);
}

/**
 * A representation of a light source.
 * Could be a point light, a spot light or a directional light.
 */
var Light = function Light() {
  this._poolID = -1;
  this._node = null;

  this._type = enums$1.LIGHT_DIRECTIONAL;

  this._color = color3.new(1, 1, 1);
  this._intensity = 1;

  // used for spot and point light
  this._range = 1;
  // used for spot light, default to 60 degrees
  this._spotAngle = toRadian(60);
  this._spotExp = 1;
  // cached for uniform
  this._directionUniform = new Float32Array(3);
  this._positionUniform = new Float32Array(3);
  this._colorUniform = new Float32Array([this._color.r * this._intensity, this._color.g * this._intensity, this._color.b * this._intensity]);
  this._spotUniform = new Float32Array([Math.cos(this._spotAngle * 0.5), this._spotExp]);

  // shadow params
  this._shadowType = enums$1.SHADOW_NONE;
  this._shadowFrameBuffer = null;
  this._shadowMap = null;
  this._shadowMapDirty = false;
  this._shadowDepthBuffer = null;
  this._shadowResolution = 1024;
  this._shadowBias = 0.0005;
  this._shadowDarkness = 1;
  this._shadowMinDepth = 1;
  this._shadowMaxDepth = 1000;
  this._shadowDepthScale = 50; // maybe need to change it if the distance between shadowMaxDepth and shadowMinDepth is small.
  this._frustumEdgeFalloff = 0; // used by directional and spot light.
  this._viewProjMatrix = mat4.create();
  this._spotAngleScale = 1; // used for spot light.
  this._shadowFrustumSize = 50; // used for directional light.
};

var prototypeAccessors$6 = { color: { configurable: true },intensity: { configurable: true },type: { configurable: true },spotAngle: { configurable: true },spotExp: { configurable: true },range: { configurable: true },shadowType: { configurable: true },shadowMap: { configurable: true },viewProjMatrix: { configurable: true },shadowResolution: { configurable: true },shadowBias: { configurable: true },shadowDarkness: { configurable: true },shadowMinDepth: { configurable: true },shadowMaxDepth: { configurable: true },shadowDepthScale: { configurable: true },frustumEdgeFalloff: { configurable: true },shadowFrustumSize: { configurable: true } };

/**
 * set the hosting node of this light
 * @param {Node} node the hosting node
 */
Light.prototype.setNode = function setNode (node) {
  this._node = node;
};

/**
 * set the color of the light source
 * @param {number} r red channel of the light color
 * @param {number} g green channel of the light color
 * @param {number} b blue channel of the light color
 */
Light.prototype.setColor = function setColor (r, g, b) {
  color3.set(this._color, r, g, b);
  this._colorUniform[0] = r * this._intensity;
  this._colorUniform[1] = g * this._intensity;
  this._colorUniform[2] = b * this._intensity;
};

/**
 * get the color of the light source
 * @returns {color3} the light color
 */
prototypeAccessors$6.color.get = function () {
  return this._color;
};

/**
 * set the intensity of the light source
 * @param {number} val the light intensity
 */
Light.prototype.setIntensity = function setIntensity (val) {
  this._intensity = val;
  this._colorUniform[0] = val * this._color.r;
  this._colorUniform[1] = val * this._color.g;
  this._colorUniform[2] = val * this._color.b;
};

/**
 * get the intensity of the light source
 * @returns {number} the light intensity
 */
prototypeAccessors$6.intensity.get = function () {
  return this._intensity;
};

/**
 * set the type of the light source
 * @param {number} type light source type
 */
Light.prototype.setType = function setType (type) {
  this._type = type;
};

/**
 * get the type of the light source
 * @returns {number} light source type
 */
prototypeAccessors$6.type.get = function () {
  return this._type;
};

/**
 * set the spot light angle
 * @param {number} val spot light angle
 */
Light.prototype.setSpotAngle = function setSpotAngle (val) {
  this._spotAngle = val;
  this._spotUniform[0] = Math.cos(this._spotAngle * 0.5);
};

/**
 * get the spot light angle
 * @returns {number} spot light angle
 */
prototypeAccessors$6.spotAngle.get = function () {
  return this._spotAngle;
};

/**
 * set the spot light exponential
 * @param {number} val spot light exponential
 */
Light.prototype.setSpotExp = function setSpotExp (val) {
  this._spotExp = val;
  this._spotUniform[1] = val;
};

/**
 * get the spot light exponential
 * @returns {number} spot light exponential
 */
prototypeAccessors$6.spotExp.get = function () {
  return this._spotExp;
};

/**
 * set the range of the light source
 * @param {number} val light source range
 */
Light.prototype.setRange = function setRange (val) {
  this._range = val;
};

/**
 * get the range of the light source
 * @returns {number} range of the light source
 */
prototypeAccessors$6.range.get = function () {
  return this._range;
};

/**
 * set the shadow type of the light source
 * @param {number} type light source shadow type
 */
Light.prototype.setShadowType = function setShadowType (type) {
  if (this._shadowType === enums$1.SHADOW_NONE && type !== enums$1.SHADOW_NONE) {
    this._shadowMapDirty = true;
  }
  this._shadowType = type;
};

/**
 * get the shadow type of the light source
 * @returns {number} light source shadow type
 */
prototypeAccessors$6.shadowType.get = function () {
  return this._shadowType;
};

/**
 * get the shadowmap of the light source
 * @returns {Texture2D} light source shadowmap
 */
prototypeAccessors$6.shadowMap.get = function () {
  return this._shadowMap;
};

/**
 * get the view-projection matrix of the light source
 * @returns {mat4} light source view-projection matrix
 */
prototypeAccessors$6.viewProjMatrix.get = function () {
  return this._viewProjMatrix;
};

/**
 * set the shadow resolution of the light source
 * @param {number} val light source shadow resolution
 */
Light.prototype.setShadowResolution = function setShadowResolution (val) {
  if (this._shadowResolution !== val) {
    this._shadowMapDirty = true;
  }
  this._shadowResolution = val;
};

/**
 * get the shadow resolution of the light source
 * @returns {number} light source shadow resolution
 */
prototypeAccessors$6.shadowResolution.get = function () {
  return this._shadowResolution;
};

/**
 * set the shadow bias of the light source
 * @param {number} val light source shadow bias
 */
Light.prototype.setShadowBias = function setShadowBias (val) {
  this._shadowBias = val;
};

/**
 * get the shadow bias of the light source
 * @returns {number} light source shadow bias
 */
prototypeAccessors$6.shadowBias.get = function () {
  return this._shadowBias;
};

/**
 * set the shadow darkness of the light source
 * @param {number} val light source shadow darkness
 */
Light.prototype.setShadowDarkness = function setShadowDarkness (val) {
  this._shadowDarkness = val;
};

/**
 * get the shadow darkness of the light source
 * @returns {number} light source shadow darkness
 */
prototypeAccessors$6.shadowDarkness.get = function () {
  return this._shadowDarkness;
};

/**
 * set the shadow min depth of the light source
 * @param {number} val light source shadow min depth
 */
Light.prototype.setShadowMinDepth = function setShadowMinDepth (val) {
  this._shadowMinDepth = val;
};

/**
 * get the shadow min depth of the light source
 * @returns {number} light source shadow min depth
 */
prototypeAccessors$6.shadowMinDepth.get = function () {
  if (this._type === enums$1.LIGHT_DIRECTIONAL) {
    return 1.0;
  }
  return this._shadowMinDepth;
};

/**
 * set the shadow max depth of the light source
 * @param {number} val light source shadow max depth
 */
Light.prototype.setShadowMaxDepth = function setShadowMaxDepth (val) {
  this._shadowMaxDepth = val;
};

/**
 * get the shadow max depth of the light source
 * @returns {number} light source shadow max depth
 */
prototypeAccessors$6.shadowMaxDepth.get = function () {
  if (this._type === enums$1.LIGHT_DIRECTIONAL) {
    return 1.0;
  }
  return this._shadowMaxDepth;
};

/**
 * set the shadow depth scale of the light source
 * @param {number} val light source shadow depth scale
 */
Light.prototype.setShadowDepthScale = function setShadowDepthScale (val) {
  this._shadowDepthScale = val;
};

/**
 * get the shadow depth scale of the light source
 * @returns {number} light source shadow depth scale
 */
prototypeAccessors$6.shadowDepthScale.get = function () {
  return this._shadowDepthScale;
};

/**
 * set the frustum edge falloff of the light source
 * @param {number} val light source frustum edge falloff
 */
Light.prototype.setFrustumEdgeFalloff = function setFrustumEdgeFalloff (val) {
  this._frustumEdgeFalloff = val;
};

/**
 * get the frustum edge falloff of the light source
 * @returns {number} light source frustum edge falloff
 */
prototypeAccessors$6.frustumEdgeFalloff.get = function () {
  return this._frustumEdgeFalloff;
};

/**
 * set the shadow frustum size of the light source
 * @param {number} val light source shadow frustum size
 */
Light.prototype.setShadowFrustumSize = function setShadowFrustumSize (val) {
  this._shadowFrustumSize = val;
};

/**
 * get the shadow frustum size of the light source
 * @returns {number} light source shadow frustum size
 */
prototypeAccessors$6.shadowFrustumSize.get = function () {
  return this._shadowFrustumSize;
};

/**
 * extract a view of this light source
 * @param {View} out the receiving view
 * @param {string[]} stages the stages using the view
 */
Light.prototype.extractView = function extractView (out, stages) {
  // TODO: view should not handle light.
  out._shadowLight = this;

  // priority. TODO: use varying value for shadow view?
  out._priority = -1;

  // rect
  out._rect.x = 0;
  out._rect.y = 0;
  out._rect.w = this._shadowResolution;
  out._rect.h = this._shadowResolution;

  // clear opts
  color4.set(out._color, 1, 1, 1, 1);
  out._depth = 1;
  out._stencil = 1;
  out._clearFlags = enums$1.CLEAR_COLOR | enums$1.CLEAR_DEPTH;

  // stages & framebuffer
  out._stages = stages;
  out._framebuffer = this._shadowFrameBuffer;

  // view projection matrix
  switch(this._type) {
    case enums$1.LIGHT_SPOT:
      _computeSpotLightViewProjMatrix(this, out._matView, out._matProj);
      break;

    case enums$1.LIGHT_DIRECTIONAL:
      _computeDirectionalLightViewProjMatrix(this, out._matView, out._matProj);
      break;

    case enums$1.LIGHT_POINT:
      _computePointLightViewProjMatrix(this, out._matView, out._matProj);
      break;

    default:
      console.warn('shadow of this light type is not supported');
  }

  // view-projection
  mat4.mul(out._matViewProj, out._matProj, out._matView);
  this._viewProjMatrix = out._matViewProj;
  mat4.invert(out._matInvViewProj, out._matViewProj);

  // update view's frustum
  out.updateFrustum();
};

Light.prototype._updateLightPositionAndDirection = function _updateLightPositionAndDirection () {
  this._node.getWorldMatrix(_m4_tmp$1);
  mat3.fromMat4(_m3_tmp, _m4_tmp$1);
  vec3.transformMat3(_transformedLightDirection, _forward, _m3_tmp);
  vec3.array(this._directionUniform, _transformedLightDirection);
  var pos = this._positionUniform;
  pos[0] = _m4_tmp$1.m12;
  pos[1] = _m4_tmp$1.m13;
  pos[2] = _m4_tmp$1.m14;
};

Light.prototype._generateShadowMap = function _generateShadowMap (device) {
  this._shadowMap = new gfx.Texture2D(device, {
    width: this._shadowResolution,
    height: this._shadowResolution,
    format: gfx.TEXTURE_FMT_RGBA8,
    wrapS: gfx.WRAP_CLAMP,
    wrapT: gfx.WRAP_CLAMP,
  });
  this._shadowDepthBuffer = new gfx.RenderBuffer(device,
    gfx.RB_FMT_D16,
    this._shadowResolution,
    this._shadowResolution
  );
  this._shadowFrameBuffer = new gfx.FrameBuffer(device, this._shadowResolution, this._shadowResolution, {
    colors: [this._shadowMap],
    depth: this._shadowDepthBuffer,
  });
};

Light.prototype._destroyShadowMap = function _destroyShadowMap () {
  if (this._shadowMap) {
    this._shadowMap.destroy();
    this._shadowDepthBuffer.destroy();
    this._shadowFrameBuffer.destroy();
    this._shadowMap = null;
    this._shadowDepthBuffer = null;
    this._shadowFrameBuffer = null;
  }
};

/**
 * update the light source
 * @param {Device} device the rendering device
 */
Light.prototype.update = function update (device) {
  this._updateLightPositionAndDirection();

  if (this._shadowType === enums$1.SHADOW_NONE) {
    this._destroyShadowMap();
  } else if (this._shadowMapDirty) {
    this._destroyShadowMap();
    this._generateShadowMap(device);
    this._shadowMapDirty = false;
  }

};

Object.defineProperties( Light.prototype, prototypeAccessors$6 );

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

var _matView = mat4.create();
var _matProj = mat4.create();
var _matViewProj = mat4.create();
var _matInvViewProj = mat4.create();
var _tmp_v3 = vec3.zero();
var _tmp2_v3 = vec3.zero();
var _tmp3_v3 = vec3.zero();

/**
 * A representation of a camera instance
 */
var Camera = function Camera() {
  this._poolID = -1;
  this._node = null;

  //
  this._projection = enums$1.PROJ_PERSPECTIVE;

  // priority. the smaller one will be rendered first
  this._priority = 0;

  // clear options
  this._color = color4.new(0.2, 0.3, 0.47, 1);
  this._depth = 1;
  this._stencil = 0;
  this._clearFlags = enums$1.CLEAR_COLOR | enums$1.CLEAR_DEPTH;
  this._clearModel = null;

  // stages & framebuffer
  this._stages = [];
  this._framebuffer = null;

  // projection properties
  this._near = 0.01;
  this._far = 1000.0;
  this._fov = Math.PI/4.0; // vertical fov
  this._rect = {
    x: 0, y: 0, w: 1, h: 1
  };

  // ortho properties
  this._orthoHeight = 10;
};

/**
 * Get the hosting node of this camera
 * @returns {Node} the hosting node
 */
Camera.prototype.getNode = function getNode () {
  return this._node;
};

/**
 * Set the hosting node of this camera
 * @param {Node} node the hosting node
 */
Camera.prototype.setNode = function setNode (node) {
  this._node = node;
};

/**
 * Get the projection type of the camera
 * @returns {number} camera projection type
 */
Camera.prototype.getType = function getType () {
  return this._projection;
};

/**
 * Set the projection type of the camera
 * @param {number} type camera projection type
 */
Camera.prototype.setType = function setType (type) {
  this._projection = type;
};

/**
 * Get the priority of the camera
 * @returns {number} camera priority
 */
Camera.prototype.getPriority = function getPriority () {
  return this._priority;
};

/**
 * Set the priority of the camera
 * @param {number} priority camera priority
 */
Camera.prototype.setPriority = function setPriority (priority) {
  this._priority = priority;
};

/**
 * Get the orthogonal height of the camera
 * @returns {number} camera height
 */
Camera.prototype.getOrthoHeight = function getOrthoHeight () {
  return this._orthoHeight;
};

/**
 * Set the orthogonal height of the camera
 * @param {number} val camera height
 */
Camera.prototype.setOrthoHeight = function setOrthoHeight (val) {
  this._orthoHeight = val;
};

/**
 * Get the field of view of the camera
 * @returns {number} camera field of view
 */
Camera.prototype.getFov = function getFov () {
  return this._fov;
};

/**
 * Set the field of view of the camera
 * @param {number} fov camera field of view
 */
Camera.prototype.setFov = function setFov (fov) {
  this._fov = fov;
};

/**
 * Get the near clipping distance of the camera
 * @returns {number} camera near clipping distance
 */
Camera.prototype.getNear = function getNear () {
  return this._near;
};

/**
 * Set the near clipping distance of the camera
 * @param {number} near camera near clipping distance
 */
Camera.prototype.setNear = function setNear (near) {
  this._near = near;
};

/**
 * Get the far clipping distance of the camera
 * @returns {number} camera far clipping distance
 */
Camera.prototype.getFar = function getFar () {
  return this._far;
};

/**
 * Set the far clipping distance of the camera
 * @param {number} far camera far clipping distance
 */
Camera.prototype.setFar = function setFar (far) {
  this._far = far;
};

/**
 * Get the clear color of the camera
 * @returns {color4} out the receiving color vector
 */
Camera.prototype.getColor = function getColor (out) {
  return color4.copy(out, this._color);
};

/**
 * Set the clear color of the camera
 * @param {number} r red channel of camera clear color
 * @param {number} g green channel of camera clear color
 * @param {number} b blue channel of camera clear color
 * @param {number} a alpha channel of camera clear color
 */
Camera.prototype.setColor = function setColor (r, g, b, a) {
  color4.set(this._color, r, g, b, a);
};

/**
 * Get the clear depth of the camera
 * @returns {number} camera clear depth
 */
Camera.prototype.getDepth = function getDepth () {
  return this._depth;
};

/**
 * Set the clear depth of the camera
 * @param {number} depth camera clear depth
 */
Camera.prototype.setDepth = function setDepth (depth) {
  this._depth = depth;
};

/**
 * Get the clearing stencil value of the camera
 * @returns {number} camera clearing stencil value
 */
Camera.prototype.getStencil = function getStencil () {
  return this._stencil;
};

/**
 * Set the clearing stencil value of the camera
 * @param {number} stencil camera clearing stencil value
 */
Camera.prototype.setStencil = function setStencil (stencil) {
  this._stencil = stencil;
};

/**
 * Get the clearing flags of the camera
 * @returns {number} camera clearing flags
 */
Camera.prototype.getClearFlags = function getClearFlags () {
  return this._clearFlags;
};

/**
 * Set the clearing flags of the camera
 * @param {number} flags camera clearing flags
 */
Camera.prototype.setClearFlags = function setClearFlags (flags) {
  this._clearFlags = flags;
};

/**
 * Get the rect of the camera
 * @param {Object} out the receiving object
 * @returns {Object} camera rect
 */
Camera.prototype.getRect = function getRect (out) {
  out.x = this._rect.x;
  out.y = this._rect.y;
  out.w = this._rect.w;
  out.h = this._rect.h;

  return out;
};

/**
 * Set the rect of the camera
 * @param {Number} x - [0,1]
 * @param {Number} y - [0,1]
 * @param {Number} w - [0,1]
 * @param {Number} h - [0,1]
 */
Camera.prototype.setRect = function setRect (x, y, w, h) {
  this._rect.x = x;
  this._rect.y = y;
  this._rect.w = w;
  this._rect.h = h;
};

/**
 * Get the stages of the camera
 * @returns {string[]} camera stages
 */
Camera.prototype.getStages = function getStages () {
  return this._stages;
};

/**
 * Set the stages of the camera
 * @param {string[]} stages camera stages
 */
Camera.prototype.setStages = function setStages (stages) {
  this._stages = stages;
};

/**
 * Get the framebuffer of the camera
 * @returns {FrameBuffer} camera framebuffer
 */
Camera.prototype.getFramebuffer = function getFramebuffer () {
  return this._framebuffer;
};

/**
 * Set the framebuffer of the camera
 * @param {FrameBuffer} framebuffer camera framebuffer
 */
Camera.prototype.setFramebuffer = function setFramebuffer (framebuffer) {
  this._framebuffer = framebuffer;
};

/**
 * extract a view of this camera
 * @param {View} out the receiving view
 * @param {number} width framebuffer width
 * @param {number} height framebuffer height
 */
Camera.prototype.extractView = function extractView (out, width, height) {
  // priority
  out._priority = this._priority;

  // rect
  out._rect.x = this._rect.x * width;
  out._rect.y = this._rect.y * height;
  out._rect.w = this._rect.w * width;
  out._rect.h = this._rect.h * height;

  // clear opts
  out._color = this._color;
  out._depth = this._depth;
  out._stencil = this._stencil;
  out._clearFlags = this._clearFlags;
  out._clearModel = this._clearModel;

  // stages & framebuffer
  out._stages = this._stages;
  out._framebuffer = this._framebuffer;

  // view matrix
  this._node.getWorldRT(out._matView);
  mat4.invert(out._matView, out._matView);

  // projection matrix
  // TODO: if this._projDirty
  var aspect = width / height;
  if (this._projection === enums$1.PROJ_PERSPECTIVE) {
    mat4.perspective(out._matProj,
      this._fov,
      aspect,
      this._near,
      this._far
    );
  } else {
    var x = this._orthoHeight * aspect;
    var y = this._orthoHeight;
    mat4.ortho(out._matProj,
      -x, x, -y, y, this._near, this._far
    );
  }

  // view-projection
  mat4.mul(out._matViewProj, out._matProj, out._matView);
  mat4.invert(out._matInvViewProj, out._matViewProj);

  // update view's frustum
  out.updateFrustum();
};

/**
 * transform a screen position to world space
 * @param {vec3} out the resulting vector
 * @param {vec3} screenPos the screen position to be transformed
 * @param {number} width framebuffer width
 * @param {number} height framebuffer height
 * @returns {vec3} the resulting vector
 */
Camera.prototype.screenToWorld = function screenToWorld (out, screenPos, width, height) {
  var aspect = width / height;
  var cx = this._rect.x * width;
  var cy = this._rect.y * height;
  var cw = this._rect.w * width;
  var ch = this._rect.h * height;

  // view matrix
  this._node.getWorldRT(_matView);
  mat4.invert(_matView, _matView);

  // projection matrix
  if (this._projection === enums$1.PROJ_PERSPECTIVE) {
    mat4.perspective(_matProj,
      this._fov,
      aspect,
      this._near,
      this._far
    );
  } else {
    var x = this._orthoHeight * aspect;
    var y = this._orthoHeight;
    mat4.ortho(_matProj,
      -x, x, -y, y, this._near, this._far
    );
  }

  // view-projection
  mat4.mul(_matViewProj, _matProj, _matView);

  // inv view-projection
  mat4.invert(_matInvViewProj, _matViewProj);

  //
  if (this._projection === enums$1.PROJ_PERSPECTIVE) {
    // calculate screen pos in far clip plane
    vec3.set(out,
      (screenPos.x - cx) * 2.0 / cw - 1.0,
      (screenPos.y - cy) * 2.0 / ch - 1.0, // DISABLE: (ch - (screenPos.y - cy)) * 2.0 / ch - 1.0,
      1.0
    );

    // transform to world
    vec3.transformMat4(out, out, _matInvViewProj);

    //
    this._node.getWorldPos(_tmp_v3);
    vec3.lerp(out, _tmp_v3, out, screenPos.z / this._far);
  } else {
    var range = this._farClip - this._nearClip;
    vec3.set(out,
      (screenPos.x - cx) * 2.0 / cw - 1.0,
      (screenPos.y - cy) * 2.0 / ch - 1.0, // DISABLE: (ch - (screenPos.y - cy)) * 2.0 / ch - 1.0,
      (this._far - screenPos.z) / range * 2.0 - 1.0
    );

    // transform to world
    vec3.transformMat4(out, out, _matInvViewProj);
  }

  return out;
};

/**
 * transform a screen position to a world space ray
 * @param {vec3} screenPos the screen position to be transformed
 * @param {number} width framebuffer width
 * @param {number} height framebuffer height
 * @returns {Ray} the resulting ray
 */
Camera.prototype.screenPointToRay = function screenPointToRay (screenPos, width, height) {
  this._node.getWorldPos(_tmp3_v3);
  this.screenToWorld(_tmp2_v3, screenPos, width, height);
  vec3.sub(_tmp2_v3, _tmp2_v3, _tmp3_v3);
  return ray.new(_tmp3_v3.x, _tmp3_v3.y, _tmp3_v3.z, _tmp2_v3.x, _tmp2_v3.y, _tmp2_v3.z);
};

/**
 * transform a world space position to screen space
 * @param {vec3} out the resulting vector
 * @param {vec3} worldPos the world space position to be transformed
 * @param {number} width framebuffer width
 * @param {number} height framebuffer height
 * @returns {vec3} the resulting vector
 */
Camera.prototype.worldToScreen = function worldToScreen (out, worldPos, width, height) {
  var aspect = width / height;
  var cx = this._rect.x * width;
  var cy = this._rect.y * height;
  var cw = this._rect.w * width;
  var ch = this._rect.h * height;

  // view matrix
  this._node.getWorldRT(_matView);
  mat4.invert(_matView, _matView);

  // projection matrix
  if (this._projection === enums$1.PROJ_PERSPECTIVE) {
    mat4.perspective(_matProj,
      this._fov,
      aspect,
      this._near,
      this._far
    );
  } else {
    var x = this._orthoHeight * aspect;
    var y = this._orthoHeight;
    mat4.ortho(_matProj,
      -x, x, -y, y, this._near, this._far
    );
  }

  // view-projection
  mat4.mul(_matViewProj, _matProj, _matView);

  // calculate w
  var w =
    worldPos.x * _matViewProj.m03 +
    worldPos.y * _matViewProj.m07 +
    worldPos.z * _matViewProj.m11 +
    _matViewProj.m15;

  vec3.transformMat4(out, worldPos, _matViewProj);
  out.x = cx + (out.x / w + 1) * 0.5 * cw;
  out.y = cy + (out.y / w + 1) * 0.5 * ch;

  return out;
};

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
var Model = function Model() {
  this._type = 'default';
  this._poolID = -1;
  this._node = null;
  this._inputAssembler = null;
  this._effect = null;
  this._defines = {};
  this._dependencies = {};
  this._viewID = -1;
  this._cameraID = -1;
  this._userKey = -1;
  this._castShadow = false;

  // TODO: we calculate aabb based on vertices
  // this._aabb
  this._boundingBox = null;
};

/**
 * Set the hosting node of this model
 * @param {Node} node the hosting node
 */
Model.prototype.setNode = function setNode (node) {
  this._node = node;
};

/**
 * Set the input assembler
 * @param {InputAssembler} ia
 */
Model.prototype.setInputAssembler = function setInputAssembler (ia) {
  this._inputAssembler = ia;
};

/**
 * Set the model effect
 * @param {?Effect} effect the effect to use
 */
Model.prototype.setEffect = function setEffect (effect) {
  if (effect) {
    this._effect = effect;
    this._defines = effect.extractDefines(Object.create(null));
    this._dependencies = effect.extractDependencies(Object.create(null));
  } else {
    this._effect = null;
    this._defines = Object.create(null);
    this._dependencies = Object.create(null);
  }
};

/**
 * Set the user key
 * @param {number} key
 */
Model.prototype.setUserKey = function setUserKey (key) {
  this._userKey = key;
};

/**
 * Extract a drawing item
 * @param {Object} out the receiving item
 */
Model.prototype.extractDrawItem = function extractDrawItem (out) {
  out.model = this;
  out.node = this._node;
  out.ia = this._inputAssembler;
  out.effect = this._effect;
  out.defines = this._effect.extractDefines(this._defines);
  out.dependencies = this._effect.extractDependencies(this._dependencies);
};

/**
 * Create the bounding box of this model
 * @param {number} minPos the min position of the model
 * @param {number} maxPos the max position of the model
 */
Model.prototype.createBoundingBox = function createBoundingBox (minPos, maxPos) {
  if (minPos === null || minPos === undefined || maxPos === null || maxPos === undefined) {
    // console.warn('can not create boundingBox for mesh without min,max position');
    return;
  }

  this._bbModelSpace = box.fromPoints(minPos, maxPos);
  this._boundingBox = box.clone(this._bbModelSpace);
};

var CircularPool = function CircularPool(fn, size) {
  var this$1 = this;

  this._cursor = 0;
  this._data = new Array(size);

  for (var i = 0; i < size; ++i) {
    this$1._data[i] = fn();
  }
};

CircularPool.prototype.request = function request () {
  var item = this._data[this._cursor];
  this._cursor = (this._cursor + 1) % this._data.length;

  return item;
};

// reference: https://github.com/mziccard/node-timsort

/**
 * Default minimum size of a run.
 */
var DEFAULT_MIN_MERGE = 32;

/**
 * Minimum ordered subsequece required to do galloping.
 */
var DEFAULT_MIN_GALLOPING = 7;

/**
 * Default tmp storage length. Can increase depending on the size of the
 * smallest run to merge.
 */
var DEFAULT_TMP_STORAGE_LENGTH = 256;

/**
 * Pre-computed powers of 10 for efficient lexicographic comparison of
 * small integers.
 */
var POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];

/**
 * Estimate the logarithm base 10 of a small integer.
 *
 * @param {number} x - The integer to estimate the logarithm of.
 * @return {number} - The estimated logarithm of the integer.
 */
function log10$1(x) {
  if (x < 1e5) {
    if (x < 1e2) {
      return x < 1e1 ? 0 : 1;
    }

    if (x < 1e4) {
      return x < 1e3 ? 2 : 3;
    }

    return 4;
  }

  if (x < 1e7) {
    return x < 1e6 ? 5 : 6;
  }

  if (x < 1e9) {
    return x < 1e8 ? 7 : 8;
  }

  return 9;
}

/**
 * Default alphabetical comparison of items.
 *
 * @param {string|object|number} a - First element to compare.
 * @param {string|object|number} b - Second element to compare.
 * @return {number} - A positive number if a.toString() > b.toString(), a
 * negative number if .toString() < b.toString(), 0 otherwise.
 */
function alphabeticalCompare(a, b) {
  if (a === b) {
    return 0;
  }

  if (~~a === a && ~~b === b) {
    if (a === 0 || b === 0) {
      return a < b ? -1 : 1;
    }

    if (a < 0 || b < 0) {
      if (b >= 0) {
        return -1;
      }

      if (a >= 0) {
        return 1;
      }

      a = -a;
      b = -b;
    }

    var al = log10$1(a);
    var bl = log10$1(b);

    var t = 0;

    if (al < bl) {
      a *= POWERS_OF_TEN[bl - al - 1];
      b /= 10;
      t = -1;
    } else if (al > bl) {
      b *= POWERS_OF_TEN[al - bl - 1];
      a /= 10;
      t = 1;
    }

    if (a === b) {
      return t;
    }

    return a < b ? -1 : 1;
  }

  var aStr = String(a);
  var bStr = String(b);

  if (aStr === bStr) {
    return 0;
  }

  return aStr < bStr ? -1 : 1;
}

/**
 * Compute minimum run length for TimSort
 *
 * @param {number} n - The size of the array to sort.
 */
function minRunLength(n) {
  var r = 0;

  while (n >= DEFAULT_MIN_MERGE) {
    r |= (n & 1);
    n >>= 1;
  }

  return n + r;
}

/**
 * Counts the length of a monotonically ascending or strictly monotonically
 * descending sequence (run) starting at array[lo] in the range [lo, hi). If
 * the run is descending it is made ascending.
 *
 * @param {array} array - The array to reverse.
 * @param {number} lo - First element in the range (inclusive).
 * @param {number} hi - Last element in the range.
 * @param {function} compare - Item comparison function.
 * @return {number} - The length of the run.
 */
function makeAscendingRun(array, lo, hi, compare) {
  var runHi = lo + 1;

  if (runHi === hi) {
    return 1;
  }

  // Descending
  if (compare(array[runHi++], array[lo]) < 0) {
    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
      runHi++;
    }

    reverseRun(array, lo, runHi);
    // Ascending
  } else {
    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
      runHi++;
    }
  }

  return runHi - lo;
}

/**
 * Reverse an array in the range [lo, hi).
 *
 * @param {array} array - The array to reverse.
 * @param {number} lo - First element in the range (inclusive).
 * @param {number} hi - Last element in the range.
 */
function reverseRun(array, lo, hi) {
  hi--;

  while (lo < hi) {
    var t = array[lo];
    array[lo++] = array[hi];
    array[hi--] = t;
  }
}

/**
 * Perform the binary sort of the array in the range [lo, hi) where start is
 * the first element possibly out of order.
 *
 * @param {array} array - The array to sort.
 * @param {number} lo - First element in the range (inclusive).
 * @param {number} hi - Last element in the range.
 * @param {number} start - First element possibly out of order.
 * @param {function} compare - Item comparison function.
 */
function binaryInsertionSort(array, lo, hi, start, compare) {
  if (start === lo) {
    start++;
  }

  for (; start < hi; start++) {
    var pivot = array[start];

    // Ranges of the array where pivot belongs
    var left = lo;
    var right = start;

    /*
     *   pivot >= array[i] for i in [lo, left)
     *   pivot <  array[i] for i in  in [right, start)
     */
    while (left < right) {
      var mid = (left + right) >>> 1;

      if (compare(pivot, array[mid]) < 0) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }

    /*
     * Move elements right to make room for the pivot. If there are elements
     * equal to pivot, left points to the first slot after them: this is also
     * a reason for which TimSort is stable
     */
    var n = start - left;
    // Switch is just an optimization for small arrays
    switch (n) {
      case 3:
        array[left + 3] = array[left + 2];
      /* falls through */
      case 2:
        array[left + 2] = array[left + 1];
      /* falls through */
      case 1:
        array[left + 1] = array[left];
        break;
      default:
        while (n > 0) {
          array[left + n] = array[left + n - 1];
          n--;
        }
    }

    array[left] = pivot;
  }
}

/**
 * Find the position at which to insert a value in a sorted range. If the range
 * contains elements equal to the value the leftmost element index is returned
 * (for stability).
 *
 * @param {number} value - Value to insert.
 * @param {array} array - The array in which to insert value.
 * @param {number} start - First element in the range.
 * @param {number} length - Length of the range.
 * @param {number} hint - The index at which to begin the search.
 * @param {function} compare - Item comparison function.
 * @return {number} - The index where to insert value.
 */
function gallopLeft(value, array, start, length, hint, compare) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;

  if (compare(value, array[start + hint]) > 0) {
    maxOffset = length - hint;

    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    // Make offsets relative to start
    lastOffset += hint;
    offset += hint;

    // value <= array[start + hint]
  } else {
    maxOffset = hint + 1;
    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }

    // Make offsets relative to start
    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  }

  /*
   * Now array[start+lastOffset] < value <= array[start+offset], so value
   * belongs somewhere in the range (start + lastOffset, start + offset]. Do a
   * binary search, with invariant array[start + lastOffset - 1] < value <=
   * array[start + offset].
   */
  lastOffset++;
  while (lastOffset < offset) {
    var m = lastOffset + ((offset - lastOffset) >>> 1);

    if (compare(value, array[start + m]) > 0) {
      lastOffset = m + 1;

    } else {
      offset = m;
    }
  }
  return offset;
}

/**
 * Find the position at which to insert a value in a sorted range. If the range
 * contains elements equal to the value the rightmost element index is returned
 * (for stability).
 *
 * @param {number} value - Value to insert.
 * @param {array} array - The array in which to insert value.
 * @param {number} start - First element in the range.
 * @param {number} length - Length of the range.
 * @param {number} hint - The index at which to begin the search.
 * @param {function} compare - Item comparison function.
 * @return {number} - The index where to insert value.
 */
function gallopRight(value, array, start, length, hint, compare) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;

  if (compare(value, array[start + hint]) < 0) {
    maxOffset = hint + 1;

    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    // Make offsets relative to start
    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;

    // value >= array[start + hint]
  } else {
    maxOffset = length - hint;

    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;

      if (offset <= 0) {
        offset = maxOffset;
      }
    }

    if (offset > maxOffset) {
      offset = maxOffset;
    }

    // Make offsets relative to start
    lastOffset += hint;
    offset += hint;
  }

  /*
   * Now array[start+lastOffset] < value <= array[start+offset], so value
   * belongs somewhere in the range (start + lastOffset, start + offset]. Do a
   * binary search, with invariant array[start + lastOffset - 1] < value <=
   * array[start + offset].
   */
  lastOffset++;

  while (lastOffset < offset) {
    var m = lastOffset + ((offset - lastOffset) >>> 1);

    if (compare(value, array[start + m]) < 0) {
      offset = m;

    } else {
      lastOffset = m + 1;
    }
  }

  return offset;
}

var TimSort = function TimSort(array, compare) {
  this.array = array;
  this.compare = compare;
  this.minGallop = DEFAULT_MIN_GALLOPING;
  this.length = array.length;

  this.tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
  if (this.length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
    this.tmpStorageLength = this.length >>> 1;
  }

  this.tmp = new Array(this.tmpStorageLength);

  this.stackLength =
    (this.length < 120 ? 5 :
      this.length < 1542 ? 10 :
        this.length < 119151 ? 19 : 40);

  this.runStart = new Array(this.stackLength);
  this.runLength = new Array(this.stackLength);
  this.stackSize = 0;
};

/**
 * Push a new run on TimSort's stack.
 *
 * @param {number} runStart - Start index of the run in the original array.
 * @param {number} runLength - Length of the run;
 */
TimSort.prototype.pushRun = function pushRun (runStart, runLength) {
  this.runStart[this.stackSize] = runStart;
  this.runLength[this.stackSize] = runLength;
  this.stackSize += 1;
};

/**
 * Merge runs on TimSort's stack so that the following holds for all i:
 * 1) runLength[i - 3] > runLength[i - 2] + runLength[i - 1]
 * 2) runLength[i - 2] > runLength[i - 1]
 */
TimSort.prototype.mergeRuns = function mergeRuns () {
    var this$1 = this;

  while (this.stackSize > 1) {
    var n = this$1.stackSize - 2;

    if ((n >= 1 &&
      this$1.runLength[n - 1] <= this$1.runLength[n] + this$1.runLength[n + 1]) ||
      (n >= 2 &&
      this$1.runLength[n - 2] <= this$1.runLength[n] + this$1.runLength[n - 1])) {

      if (this$1.runLength[n - 1] < this$1.runLength[n + 1]) {
        n--;
      }

    } else if (this$1.runLength[n] > this$1.runLength[n + 1]) {
      break;
    }
    this$1.mergeAt(n);
  }
};

/**
 * Merge all runs on TimSort's stack until only one remains.
 */
TimSort.prototype.forceMergeRuns = function forceMergeRuns () {
    var this$1 = this;

  while (this.stackSize > 1) {
    var n = this$1.stackSize - 2;

    if (n > 0 && this$1.runLength[n - 1] < this$1.runLength[n + 1]) {
      n--;
    }

    this$1.mergeAt(n);
  }
};

/**
 * Merge the runs on the stack at positions i and i+1. Must be always be called
 * with i=stackSize-2 or i=stackSize-3 (that is, we merge on top of the stack).
 *
 * @param {number} i - Index of the run to merge in TimSort's stack.
 */
TimSort.prototype.mergeAt = function mergeAt (i) {
  var compare = this.compare;
  var array = this.array;

  var start1 = this.runStart[i];
  var length1 = this.runLength[i];
  var start2 = this.runStart[i + 1];
  var length2 = this.runLength[i + 1];

  this.runLength[i] = length1 + length2;

  if (i === this.stackSize - 3) {
    this.runStart[i + 1] = this.runStart[i + 2];
    this.runLength[i + 1] = this.runLength[i + 2];
  }

  this.stackSize--;

  /*
   * Find where the first element in the second run goes in run1. Previous
   * elements in run1 are already in place
   */
  var k = gallopRight(array[start2], array, start1, length1, 0, compare);
  start1 += k;
  length1 -= k;

  if (length1 === 0) {
    return;
  }

  /*
   * Find where the last element in the first run goes in run2. Next elements
   * in run2 are already in place
   */
  length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);

  if (length2 === 0) {
    return;
  }

  /*
   * Merge remaining runs. A tmp array with length = min(length1, length2) is
   * used
   */
  if (length1 <= length2) {
    this.mergeLow(start1, length1, start2, length2);

  } else {
    this.mergeHigh(start1, length1, start2, length2);
  }
};

/**
 * Merge two adjacent runs in a stable way. The runs must be such that the
 * first element of run1 is bigger than the first element in run2 and the
 * last element of run1 is greater than all the elements in run2.
 * The method should be called when run1.length <= run2.length as it uses
 * TimSort temporary array to store run1. Use mergeHigh if run1.length >
 * run2.length.
 *
 * @param {number} start1 - First element in run1.
 * @param {number} length1 - Length of run1.
 * @param {number} start2 - First element in run2.
 * @param {number} length2 - Length of run2.
 */
TimSort.prototype.mergeLow = function mergeLow (start1, length1, start2, length2) {

  var compare = this.compare;
  var array = this.array;
  var tmp = this.tmp;
  var i = 0;

  for (i = 0; i < length1; i++) {
    tmp[i] = array[start1 + i];
  }

  var cursor1 = 0;
  var cursor2 = start2;
  var dest = start1;

  array[dest++] = array[cursor2++];

  if (--length2 === 0) {
    for (i = 0; i < length1; i++) {
      array[dest + i] = tmp[cursor1 + i];
    }
    return;
  }

  if (length1 === 1) {
    for (i = 0; i < length2; i++) {
      array[dest + i] = array[cursor2 + i];
    }
    array[dest + length2] = tmp[cursor1];
    return;
  }

  var minGallop = this.minGallop;

  while (true) {
    var count1 = 0;
    var count2 = 0;
    var exit = false;

    do {
      if (compare(array[cursor2], tmp[cursor1]) < 0) {
        array[dest++] = array[cursor2++];
        count2++;
        count1 = 0;

        if (--length2 === 0) {
          exit = true;
          break;
        }

      } else {
        array[dest++] = tmp[cursor1++];
        count1++;
        count2 = 0;
        if (--length1 === 1) {
          exit = true;
          break;
        }
      }
    } while ((count1 | count2) < minGallop);

    if (exit) {
      break;
    }

    do {
      count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);

      if (count1 !== 0) {
        for (i = 0; i < count1; i++) {
          array[dest + i] = tmp[cursor1 + i];
        }

        dest += count1;
        cursor1 += count1;
        length1 -= count1;
        if (length1 <= 1) {
          exit = true;
          break;
        }
      }

      array[dest++] = array[cursor2++];

      if (--length2 === 0) {
        exit = true;
        break;
      }

      count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);

      if (count2 !== 0) {
        for (i = 0; i < count2; i++) {
          array[dest + i] = array[cursor2 + i];
        }

        dest += count2;
        cursor2 += count2;
        length2 -= count2;

        if (length2 === 0) {
          exit = true;
          break;
        }
      }
      array[dest++] = tmp[cursor1++];

      if (--length1 === 1) {
        exit = true;
        break;
      }

      minGallop--;

    } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

    if (exit) {
      break;
    }

    if (minGallop < 0) {
      minGallop = 0;
    }

    minGallop += 2;
  }

  this.minGallop = minGallop;

  if (minGallop < 1) {
    this.minGallop = 1;
  }

  if (length1 === 1) {
    for (i = 0; i < length2; i++) {
      array[dest + i] = array[cursor2 + i];
    }
    array[dest + length2] = tmp[cursor1];

  } else if (length1 === 0) {
    throw new Error('mergeLow preconditions were not respected');

  } else {
    for (i = 0; i < length1; i++) {
      array[dest + i] = tmp[cursor1 + i];
    }
  }
};

/**
 * Merge two adjacent runs in a stable way. The runs must be such that the
 * first element of run1 is bigger than the first element in run2 and the
 * last element of run1 is greater than all the elements in run2.
 * The method should be called when run1.length > run2.length as it uses
 * TimSort temporary array to store run2. Use mergeLow if run1.length <=
 * run2.length.
 *
 * @param {number} start1 - First element in run1.
 * @param {number} length1 - Length of run1.
 * @param {number} start2 - First element in run2.
 * @param {number} length2 - Length of run2.
 */
TimSort.prototype.mergeHigh = function mergeHigh (start1, length1, start2, length2) {
  var compare = this.compare;
  var array = this.array;
  var tmp = this.tmp;
  var i = 0;

  for (i = 0; i < length2; i++) {
    tmp[i] = array[start2 + i];
  }

  var cursor1 = start1 + length1 - 1;
  var cursor2 = length2 - 1;
  var dest = start2 + length2 - 1;
  var customCursor = 0;
  var customDest = 0;

  array[dest--] = array[cursor1--];

  if (--length1 === 0) {
    customCursor = dest - (length2 - 1);

    for (i = 0; i < length2; i++) {
      array[customCursor + i] = tmp[i];
    }

    return;
  }

  if (length2 === 1) {
    dest -= length1;
    cursor1 -= length1;
    customDest = dest + 1;
    customCursor = cursor1 + 1;

    for (i = length1 - 1; i >= 0; i--) {
      array[customDest + i] = array[customCursor + i];
    }

    array[dest] = tmp[cursor2];
    return;
  }

  var minGallop = this.minGallop;

  while (true) {
    var count1 = 0;
    var count2 = 0;
    var exit = false;

    do {
      if (compare(tmp[cursor2], array[cursor1]) < 0) {
        array[dest--] = array[cursor1--];
        count1++;
        count2 = 0;
        if (--length1 === 0) {
          exit = true;
          break;
        }

      } else {
        array[dest--] = tmp[cursor2--];
        count2++;
        count1 = 0;
        if (--length2 === 1) {
          exit = true;
          break;
        }
      }

    } while ((count1 | count2) < minGallop);

    if (exit) {
      break;
    }

    do {
      count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);

      if (count1 !== 0) {
        dest -= count1;
        cursor1 -= count1;
        length1 -= count1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;

        for (i = count1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
        }

        if (length1 === 0) {
          exit = true;
          break;
        }
      }

      array[dest--] = tmp[cursor2--];

      if (--length2 === 1) {
        exit = true;
        break;
      }

      count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);

      if (count2 !== 0) {
        dest -= count2;
        cursor2 -= count2;
        length2 -= count2;
        customDest = dest + 1;
        customCursor = cursor2 + 1;

        for (i = 0; i < count2; i++) {
          array[customDest + i] = tmp[customCursor + i];
        }

        if (length2 <= 1) {
          exit = true;
          break;
        }
      }

      array[dest--] = array[cursor1--];

      if (--length1 === 0) {
        exit = true;
        break;
      }

      minGallop--;

    } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

    if (exit) {
      break;
    }

    if (minGallop < 0) {
      minGallop = 0;
    }

    minGallop += 2;
  }

  this.minGallop = minGallop;

  if (minGallop < 1) {
    this.minGallop = 1;
  }

  if (length2 === 1) {
    dest -= length1;
    cursor1 -= length1;
    customDest = dest + 1;
    customCursor = cursor1 + 1;

    for (i = length1 - 1; i >= 0; i--) {
      array[customDest + i] = array[customCursor + i];
    }

    array[dest] = tmp[cursor2];

  } else if (length2 === 0) {
    throw new Error('mergeHigh preconditions were not respected');

  } else {
    customCursor = dest - (length2 - 1);
    for (i = 0; i < length2; i++) {
      array[customCursor + i] = tmp[i];
    }
  }
};

/**
 * Sort an array in the range [lo, hi) using TimSort.
 *
 * @param {array} array - The array to sort.
 * @param {number} lo - First element in the range (inclusive).
 * @param {number} hi - Last element in the range.
 * @param {function=} compare - Item comparison function. Default is alphabetical.
 */
function sort (array, lo, hi, compare) {
  if (!Array.isArray(array)) {
    throw new TypeError('Can only sort arrays');
  }

  /*
   * Handle the case where a comparison function is not provided. We do
   * lexicographic sorting
   */

  if (lo === undefined) {
    lo = 0;
  }

  if (hi === undefined) {
    hi = array.length;
  }

  if (compare === undefined) {
    compare = alphabeticalCompare;
  }

  var remaining = hi - lo;

  // The array is already sorted
  if (remaining < 2) {
    return;
  }

  var runLength = 0;
  // On small arrays binary sort can be used directly
  if (remaining < DEFAULT_MIN_MERGE) {
    runLength = makeAscendingRun(array, lo, hi, compare);
    binaryInsertionSort(array, lo, hi, lo + runLength, compare);
    return;
  }

  var ts = new TimSort(array, compare);

  var minRun = minRunLength(remaining);

  do {
    runLength = makeAscendingRun(array, lo, hi, compare);
    if (runLength < minRun) {
      var force = remaining;
      if (force > minRun) {
        force = minRun;
      }

      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
      runLength = force;
    }
    // Push new run and merge if necessary
    ts.pushRun(lo, runLength);
    ts.mergeRuns();

    // Go find next run
    remaining -= runLength;
    lo += runLength;

  } while (remaining !== 0);

  // Force merging of remaining runs
  ts.forceMergeRuns();
}

var FixedArray = function FixedArray(size) {
  this._count = 0;
  this._data = new Array(size);
};

var prototypeAccessors$7 = { length: { configurable: true },data: { configurable: true } };

FixedArray.prototype._resize = function _resize (size) {
    var this$1 = this;

  if (size > this._data.length) {
    for (var i = this._data.length; i < size; ++i) {
      this$1._data[i] = undefined;
    }
  }
};

prototypeAccessors$7.length.get = function () {
  return this._count;
};

prototypeAccessors$7.data.get = function () {
  return this._data;
};

FixedArray.prototype.reset = function reset () {
    var this$1 = this;

  for (var i = 0; i < this._count; ++i) {
    this$1._data[i] = undefined;
  }

  this._count = 0;
};

FixedArray.prototype.push = function push (val) {
  if (this._count >= this._data.length) {
    this._resize(this._data.length * 2);
  }

  this._data[this._count] = val;
  ++this._count;
};

FixedArray.prototype.pop = function pop () {
  --this._count;

  if (this._count < 0) {
    this._count = 0;
  }

  var ret = this._data[this._count];
  this._data[this._count] = undefined;

  return ret;
};

FixedArray.prototype.fastRemove = function fastRemove (idx) {
  if (idx >= this._count) {
    return;
  }

  var last = this._count - 1;
  this._data[idx] = this._data[last];
  this._data[last] = undefined;
  this._count -= 1;
};

FixedArray.prototype.indexOf = function indexOf (val) {
  var idx = this._data.indexOf(val);
  if (idx >= this._count) {
    return -1;
  }

  return idx;
};

FixedArray.prototype.sort = function sort$1 (cmp) {
  return sort(this._data, 0, this._count, cmp);
};

Object.defineProperties( FixedArray.prototype, prototypeAccessors$7 );

var Pool = function Pool(fn, size) {
  var this$1 = this;

  this._fn = fn;
  this._idx = size - 1;
  this._frees = new Array(size);

  for (var i = 0; i < size; ++i) {
    this$1._frees[i] = fn();
  }
};

Pool.prototype._expand = function _expand (size) {
    var this$1 = this;

  var old = this._frees;
  this._frees = new Array(size);

  var len = size - old.length;
  for (var i = 0; i < len; ++i) {
    this$1._frees[i] = this$1._fn();
  }

  for (var i$1 = len, j = 0; i$1 < size; ++i$1, ++j) {
    this$1._frees[i$1] = old[j];
  }

  this._idx += len;
};

Pool.prototype.alloc = function alloc () {
  // create some more space (expand by 20%, minimum 1)
  if (this._idx < 0) {
    this._expand(Math.round(this._frees.length * 1.2) + 1);
  }

  var ret = this._frees[this._idx];
  this._frees[this._idx] = null;
  --this._idx;

  return ret;
};

Pool.prototype.free = function free (obj) {
  ++this._idx;
  this._frees[this._idx] = obj;
};

var LinkedArray = function LinkedArray(fn, size) {
  this._fn = fn;
  this._count = 0;
  this._head = null;
  this._tail = null;

  this._pool = new Pool(fn, size);
};

var prototypeAccessors$8 = { head: { configurable: true },tail: { configurable: true },length: { configurable: true } };

prototypeAccessors$8.head.get = function () {
  return this._head;
};

prototypeAccessors$8.tail.get = function () {
  return this._tail;
};

prototypeAccessors$8.length.get = function () {
  return this._count;
};

LinkedArray.prototype.add = function add () {
  var node = this._pool.alloc();

  if (!this._tail) {
    this._head = node;
  } else {
    this._tail._next = node;
    node._prev = this._tail;
  }
  this._tail = node;
  this._count += 1;

  return node;
};

LinkedArray.prototype.remove = function remove (node) {
  if (node._prev) {
    node._prev._next = node._next;
  } else {
    this._head = node._next;
  }

  if (node._next) {
    node._next._prev = node._prev;
  } else {
    this._tail = node._prev;
  }

  node._next = null;
  node._prev = null;
  this._pool.free(node);
  this._count -= 1;
};

LinkedArray.prototype.forEach = function forEach (fn, binder) {
    var this$1 = this;

  var cursor = this._head;
  if (!cursor) {
    return;
  }

  if (binder) {
    fn = fn.bind(binder);
  }

  var idx = 0;
  var next = cursor;

  while (cursor) {
    next = cursor._next;
    fn(cursor, idx, this$1);

    cursor = next;
    ++idx;
  }
};

Object.defineProperties( LinkedArray.prototype, prototypeAccessors$8 );

var RecyclePool = function RecyclePool(fn, size) {
  var this$1 = this;

  this._fn = fn;
  this._count = 0;
  this._data = new Array(size);

  for (var i = 0; i < size; ++i) {
    this$1._data[i] = fn();
  }
};

var prototypeAccessors$9 = { length: { configurable: true },data: { configurable: true } };

prototypeAccessors$9.length.get = function () {
  return this._count;
};

prototypeAccessors$9.data.get = function () {
  return this._data;
};

RecyclePool.prototype.reset = function reset () {
  this._count = 0;
};

RecyclePool.prototype.resize = function resize (size) {
    var this$1 = this;

  if (size > this._data.length) {
    for (var i = this._data.length; i < size; ++i) {
      this$1._data[i] = this$1._fn();
    }
  }
};

RecyclePool.prototype.add = function add () {
  if (this._count >= this._data.length) {
    this.resize(this._data.length * 2);
  }

  return this._data[this._count++];
};

RecyclePool.prototype.remove = function remove (idx) {
  if (idx >= this._count) {
    return;
  }

  var last = this._count - 1;
  var tmp = this._data[idx];
  this._data[idx] = this._data[last];
  this._data[last] = tmp;
  this._count -= 1;
};

RecyclePool.prototype.sort = function sort$1 (cmp) {
  return sort(this._data, 0, this._count, cmp);
};

Object.defineProperties( RecyclePool.prototype, prototypeAccessors$9 );

var _bufferPools = Array(8);
for (var i = 0; i < 8; ++i) {
  _bufferPools[i] = [];
}

function _nextPow16(v) {
  for (var i = 16; i <= (1 << 28); i *= 16) {
    if (v <= i) {
      return i;
    }
  }
  return 0;
}

function _log2(v) {
  var r, shift;
  r = (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

function _alloc(n) {
  var sz = _nextPow16(n);
  var bin = _bufferPools[_log2(sz) >> 2];
  if (bin.length > 0) {
    return bin.pop();
  }
  return new ArrayBuffer(sz);
}

function _free(buf) {
  _bufferPools[_log2(buf.byteLength) >> 2].push(buf);
}

var typedArrayPool = {
  alloc_int8: function alloc_int8(n) {
    var result = new Int8Array(_alloc(n), 0, n);
    if (result.length !== n) {
      return result.subarray(0, n);
    }

    return result;
  },

  alloc_uint8: function alloc_uint8(n) {
    var result = new Uint8Array(_alloc(n), 0, n);
    if (result.length !== n) {
      return result.subarray(0, n);
    }

    return result;
  },

  alloc_int16: function alloc_int16(n) {
    var result = new Int16Array(_alloc(2 * n), 0, n);
    if (result.length !== n) {
      return result.subarray(0, n);
    }

    return result;
  },

  alloc_uint16: function alloc_uint16(n) {
    var result = new Uint16Array(_alloc(2 * n), 0, n);
    if (result.length !== n) {
      return result.subarray(0, n);
    }

    return result;
  },

  alloc_int32: function alloc_int32(n) {
    var result = new Int32Array(_alloc(4 * n), 0, n);
    if (result.length !== n) {
      return result.subarray(0, n);
    }

    return result;
  },

  alloc_uint32: function alloc_uint32(n) {
    var result = new Uint32Array(_alloc(4 * n), 0, n);
    if (result.length !== n) {
      return result.subarray(0, n);
    }

    return result;
  },

  alloc_float32: function alloc_float32(n) {
    var result = new Float32Array(_alloc(4 * n), 0, n);
    if (result.length !== n) {
      return result.subarray(0, n);
    }

    return result;
  },

  alloc_float64: function alloc_float64(n) {
    var result = new Float64Array(_alloc(8 * n), 0, n);
    if (result.length !== n) {
      return result.subarray(0, n);
    }

    return result;
  },

  alloc_dataview: function alloc_dataview(n) {
    var result = new DataView(_alloc(n), 0, n);
    if (result.length !== n) {
      return result.subarray(0, n);
    }

    return result;
  },

  free: function free(array) {
    _free(array.buffer);
  },

  reset: function reset() {
    var _bufferPools = Array(8);
    for (var i = 0; i < 8; ++i) {
      _bufferPools[i] = [];
    }
  },
};



var memop = Object.freeze({
	CircularPool: CircularPool,
	FixedArray: FixedArray,
	LinkedArray: LinkedArray,
	Pool: Pool,
	RecyclePool: RecyclePool,
	TypedArrayPool: typedArrayPool
});

/**
 * Returns a random v4 UUID of the form xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx, 
 * where each x is replaced with a random hexadecimal digit from 0 to f, 
 * and y is replaced with a random hexadecimal digit from 8 to b.
 * @param {?number} a the placeholder
 * @returns {number} resulting UUID
 * @see https://gist.github.com/jed/982883
 */
function uuid(a) {
  return a           // if the placeholder was passed, return
    ? (              // a random number from 0 to 15
      a ^            // unless b is 8,
      Math.random()  // in which case
      * 16           // a random number from
      >> a / 4       // 8 to 11
    ).toString(16)   // in hexadecimal
    : (              // or otherwise a concatenated string:
      [1e7] +        // 10000000 +
      -1e3 +         // -1000 +
      -4e3 +         // -4000 +
      -8e3 +         // -80000000 +
      -1e11          // -100000000000,
    ).replace(       // replacing
      /[018]/g,      // zeroes, ones, and eights with
      uuid           // random hex digits
    );
}

/**
 * Entity layer system
 */
var Layers = function Layers () {};

Layers.addLayer = function addLayer (name) {
  if (Layers._nextAvailable > 31) 
    { return new Error('maximum layers reached.'); }
  Layers[name] = (1 << Layers._nextAvailable++);
  return Layers[name];
};

/**
 * Make a layer mask accepting nothing but the listed layers
 * @param {number[]} includes layers accepted by the mask
 * @return {number} the specified layer mask
 */
Layers.makeInclusiveMask = function makeInclusiveMask (includes) {
  var mask = 0;
  for (var i = 0; i < includes.length; i++)
    { mask |= includes[i]; }
  return mask;
};

/**
 * Make a layer mask accepting everything but the listed layers
 * @param {number[]} excludes layers rejected by the mask
 * @return {number} the specified layer mask
 */
Layers.makeExclusiveMask = function makeExclusiveMask (excludes) {
  return ~Layers.makeInclusiveMask(excludes);
};

/**
 * Check a layer is accepted by the mask or not
 * @param {number} layer the layer number to be tested
 * @param {number} mask the testing layer mask
 * @return {boolean} true if accepted
 */
Layers.check = function check (layer, mask) {
  return (layer & mask) == layer;
};

Layers._nextAvailable = 8;

// built-in layers, reserved up to (1 << 7)
Layers.Default =  (1 << 0);
Layers.IgnoreRaycast =  (1 << 1);

// masks
Layers.RaycastMask = Layers.makeExclusiveMask([Layers.IgnoreRaycast]);

var v3_a = vec3.zero();
var q_a = quat.create();
var m3_a = mat3.create();
var m3_b = mat3.create();
var m4_a = mat4.create();

var Node = function Node(name) {
  this._id = uuid();
  this._parent = null;
  this._children = [];

  this.name = name || '';
  this.lpos = vec3.new(0, 0, 0);
  this.lscale = vec3.new(1, 1, 1);
  this.lrot = quat.new(0, 0, 0, 1);
  this.layer = Layers.Default;
};

var prototypeAccessors$10 = { id: { configurable: true },parent: { configurable: true },children: { configurable: true } };

/**
 * @property {number} id
 * @readonly
 */
Node.mixin = function mixin (cls) {
  Object.getOwnPropertyNames(Node.prototype).forEach(function (name) {
    if (cls.prototype.hasOwnProperty(name) === false) {
      Object.defineProperty(
        cls.prototype,
        name,
        Object.getOwnPropertyDescriptor(Node.prototype, name)
      );
    }
  });
  cls.prototype.__initNode = function () {
    this._id = uuid();
    this._parent = null;
    this._children = [];

    this.name = '';
    this.lpos = vec3.new(0, 0, 0);
    this.lscale = vec3.new(1, 1, 1);
    this.lrot = quat.new(0, 0, 0, 1);
    this.layer = Layers.Default;
  };
};

prototypeAccessors$10.id.get = function () {
  return this._id;
};

/**
 * @property parent
 * @readonly
 *
 * get parent
 */
prototypeAccessors$10.parent.get = function () {
  return this._parent;
};

/**
 * @property children
 *
 * get children
 */
prototypeAccessors$10.children.get = function () {
  return this._children;
};

// ===============================
// hierarchy
// ===============================

/**
 * @method setParent
 * @param {Node} newParent
 * @return {boolean}
 *
 * NOTE: This function will invoke `_onParentChanged` if it exists.
 */
Node.prototype.setParent = function setParent (newParent) {
    var this$1 = this;

  var oldParent = this._parent;

  // newParent is the current parent of this
  if (oldParent === newParent) {
    return false;
  }

  // make sure the newParent is not a child of this
  var cur = newParent;
  while (cur) {
    if (cur === this$1) {
      // console.warn(`Failed to set parent for ${this.name}: the new parent ${newParent.name} is its child.`);
      return false;
    }

    cur = cur._parent;
  }

  // remove this from its old parent (if it has)
  if (oldParent) {
    var len = oldParent._children.length;
    for (var i = 0; i < len; ++i) {
      if (oldParent._children[i] === this$1) {
        oldParent._children.splice(i, 1);
        break;
      }
    }
  }

  // append it to the new parent
  this._parent = newParent;
  if (newParent) {
    newParent._children.push(this);
  }

  // invoke _onParentChanged
  if (this._onParentChanged) {
    this._onParentChanged(oldParent, newParent);
  }

  return true;
};

/**
 * @method insertAt
 * @param {number} idx
 * @param {Node} node
 *
 * Insert `node` before the `idx` of children.
 * NOTE: This function will invoke `_onParentChanged` if it exists.
 */
Node.prototype.insertAt = function insertAt (idx, node) {
    var this$1 = this;

  if (!node) {
    return false;
  }

  // make sure the node is not the parent of this
  var cur = this;
  while (cur) {
    if (cur === node) {
      // console.warn(`Failed to append ${node.name}: it is the ancient of current node.`);
      return false;
    }

    cur = cur._parent;
  }

  var oldParent = node._parent;

  // 0 <= idx <= len
  var len = this._children.length;
  idx = idx < 0 ? 0 : idx > len ? len : idx;

  // remove node from its current parent
  if (oldParent) {
    len = oldParent._children.length;
    for (var i = 0; i < len; ++i) {
      if (oldParent._children[i] === node) {
        // if we already have the child
        if (oldParent === this$1) {
          // if its insert position didn't changed, don't do anything.
          if (i === idx || i === idx - 1) {
            return false;
          }

          if (i < idx - 1) {
            idx = idx - 1;
          }
        }

        oldParent._children.splice(i, 1);
        break;
      }
    }
  }

  // append the new node
  node._parent = this;
  this._children.splice(idx, 0, node);

  // invoke _onParentChanged
  if (node._onParentChanged && node._parent !== this) {
    node._onParentChanged(oldParent, this);
  }

  return true;
};

/**
 * @method append
 * @param {Node} node
 * @return {boolean}
 *
 * Append `node` at the end of children.
 * NOTE: This function will invoke `_onParentChanged` if it exists.
 */
Node.prototype.append = function append (node) {
    var this$1 = this;

  if (!node) {
    return false;
  }

  // make sure the node is not the parent of this
  var cur = this;
  while (cur) {
    if (cur === node) {
      // console.warn(`Failed to append ${node.name}: it is the ancient of current node.`);
      return false;
    }

    cur = cur._parent;
  }

  var oldParent = node._parent;

  // remove node from its current parent
  if (oldParent) {
    var len = oldParent._children.length;
    for (var i = 0; i < len; ++i) {
      if (oldParent._children[i] === node) {
        // if we already have the child and its insert position didn't changed, don't do anything.
        if (oldParent === this$1 && i === len - 1) {
          return false;
        }

        oldParent._children.splice(i, 1);
        break;
      }
    }
  }

  // append the new node
  node._parent = this;
  this._children.push(node);

  // invoke _onParentChanged
  if (node._onParentChanged && node._parent !== this) {
    node._onParentChanged(oldParent, this);
  }

  return true;
};

/**
 * @method remove
 *
 * Remove self from parent
 * NOTE: This function will invoke `_onParentChanged` if it exists.
 */
Node.prototype.remove = function remove () {
  if (this._parent) {
    this._parent.removeChild(this);
  }
};

/**
 * @method removeChild
 * @param {Node} node
 *
 * Remove child
 * NOTE: This function will invoke `_onParentChanged` if it exists.
 */
Node.prototype.removeChild = function removeChild (node) {
    var this$1 = this;

  var len = this._children.length;

  for (var i = 0; i < len; ++i) {
    if (this$1._children[i] === node) {
      this$1._children.splice(i, 1);
      node._parent = null;

      // invoke _onParentChanged
      if (node._onParentChanged) {
        node._onParentChanged(this$1, null);
      }

      return true;
    }
  }

  // console.warn(`Failed to remove node ${node.name}, can not find it.`);
  return false;
};

// ===============================
// transform helper
// ===============================

/**
 * @method getWorldPos
 * @param {vec3} pos
 * @param {vec3} [up] - default is (0,1,0)
 * @return {vec3}
 *
 * Set rotation by lookAt target point
 */
Node.prototype.lookAt = function lookAt (pos, up) {
  this.getWorldPos(v3_a);
  vec3.sub(v3_a, v3_a, pos); // NOTE: we use -z for view-dir
  vec3.normalize(v3_a, v3_a);
  quat.fromViewUp(q_a, v3_a, up);

  this.setWorldRot(q_a);
};

// ===============================
// transform
// ===============================

/**
 * @method getWorldPos
 * @param {vec3} out
 * @return {vec3}
 *
 * Calculate and return world position
 */
Node.prototype.getWorldPos = function getWorldPos (out) {
  vec3.copy(out, this.lpos);

  var cur = this._parent;
  while (cur) {
    // out = parent_lscale * lpos
    vec3.mul(out, out, cur.lscale);

    // out = parent_lrot * out
    vec3.transformQuat(out, out, cur.lrot);

    // out = out + lpos
    vec3.add(out, out, cur.lpos);

    cur = cur._parent;
  }

  return out;
};

/**
 * @method setWorldPos
 * @param {vec3} pos
 *
 * Set world position
 */
Node.prototype.setWorldPos = function setWorldPos (pos) {
  // NOTE: this is faster than invert world matrix and transform the point

  if (this._parent) {
    this._parent.invTransformPoint(this.lpos, pos);
    return;
  }

  vec3.copy(this.lpos, pos);
};

/**
 * @method getWorldRot
 * @param {quat} out
 * @return {quat}
 *
 * Calculate and return world rotation
 */
Node.prototype.getWorldRot = function getWorldRot (out) {
  quat.copy(out, this.lrot);

  // result = ... * parent.parent.lrot * parent.lrot * lrot
  var cur = this._parent;
  while (cur) {
    quat.mul(out, cur.lrot, out);

    cur = cur._parent;
  }

  return out;
};

/**
 * @method setWorldRot
 * @param {quat} rot
 *
 * Set world position
 */
Node.prototype.setWorldRot = function setWorldRot (rot) {
  // lrot = rot * inv(prarent.wrot);
  if (this._parent) {
    this._parent.getWorldRot(this.lrot);
    quat.conjugate(this.lrot, this.lrot);
    quat.mul(this.lrot, this.lrot, rot);

    return;
  }

  quat.copy(this.lrot, rot);
};

/**
 * @method getWorldScale
 * @param {quat} out
 * @return {quat}
 *
 * Calculate and return world rotation
 */
Node.prototype.getWorldScale = function getWorldScale (out) {
  vec3.copy(out, this.lscale);

  var cur = this._parent;
  while (cur) {
    vec3.mul(out, cur.lscale, out);
    cur = cur._parent;
  }

  return out;
};

/**
 * @method invTransformPoint
 * @param {vec3} out
 * @param {vec3} pos
 *
 * Transforms position from world space to local space.
 */
Node.prototype.invTransformPoint = function invTransformPoint (out, pos) {
  if (this._parent) {
    this._parent.invTransformPoint(out, pos);
  } else {
    vec3.copy(out, pos);
  }

  // out = parent_inv_pos - lpos
  vec3.sub(out, out, this.lpos);

  // out = inv(lrot) * out
  quat.conjugate(q_a, this.lrot);
  vec3.transformQuat(out, out, q_a);

  // out = (1/scale) * out
  vec3.inverseSafe(v3_a, this.lscale);
  vec3.mul(out, out, v3_a);

  return out;
};

/**
 * @method getLocalMatrix
 * @param {mat4} out
 * @return {mat4}
 *
 * Calculate and return local transform
 */
Node.prototype.getLocalMatrix = function getLocalMatrix (out) {
  mat4.fromRTS(out, this.lrot, this.lpos, this.lscale);
  return out;
};

/**
 * @method getWorldMatrix
 * @param {mat4} out
 * @return {mat4}
 *
 * Calculate and return world transform
 */
Node.prototype.getWorldMatrix = function getWorldMatrix (out) {
  // out = ... * parent.parent.local * parent.local * local;
  this.getLocalMatrix(out);

  var cur = this._parent;
  while (cur) {
    cur.getLocalMatrix(m4_a);
    mat4.mul(out, m4_a, out);

    cur = cur._parent;
  }

  return out;
};

/**
 * @method getWorldRT
 * @param {mat4} out
 * @return {mat4}
 *
 * Calculate and return world transform without scale
 */
Node.prototype.getWorldRT = function getWorldRT (out) {
  this._getWorldPosAndRot(v3_a, q_a);
  mat4.fromRT(out, q_a, v3_a);

  return out;
};

/**
 * @method getWorldRS
 * @param {mat3} out
 *
 * Calculate and return world rotation and scale matrix
 */
Node.prototype.getWorldRS = function getWorldRS (out) {
  mat3.set(m3_a,
    this.lscale.x, 0, 0,
    0, this.lscale.y, 0,
    0, 0, this.lscale.z
  );
  mat3.fromQuat(m3_b, this.lrot);

  if (this._parent) {
    // parent_RS * rot * scale
    this._parent.getWorldRS(out);
    mat3.mul(out, out, m3_b);
    mat3.mul(out, out, m3_a);
  } else {
    // rot * scale
    mat3.mul(out, m3_b, m3_a);
  }

  return out;
};

/**
 * @method _getWorldPosAndRot
 * @param {vec3} opos
 * @param {quat} orot
 *
 * Calculate and return world position and rotation
 */
Node.prototype._getWorldPosAndRot = function _getWorldPosAndRot (opos, orot) {
  vec3.copy(opos, this.lpos);
  quat.copy(orot, this.lrot);

  var cur = this._parent;
  while (cur) {
    // opos = parent_lscale * lpos
    vec3.mul(opos, opos, cur.lscale);

    // opos = parent_lrot * opos
    vec3.transformQuat(opos, opos, cur.lrot);

    // opos = opos + lpos
    vec3.add(opos, opos, cur.lpos);

    // orot = lrot * orot
    quat.mul(orot, cur.lrot, orot);

    cur = cur._parent;
  }
};

/**
 * Calculate and return world position, rotation and scale
 * @param {vec3} opos
 * @param {quat} orot
 * @param {vec3} osca
 */
Node.prototype._getWorldPRS = function _getWorldPRS (opos, orot, osca) {
  vec3.copy(opos, this.lpos);
  quat.copy(orot, this.lrot);
  vec3.copy(osca, this.lscale);

  var cur = this._parent;
  while (cur) {
    // opos = parent_lscale * lpos
    vec3.mul(opos, opos, cur.lscale);

    // opos = parent_lrot * opos
    vec3.transformQuat(opos, opos, cur.lrot);

    // opos = opos + lpos
    vec3.add(opos, opos, cur.lpos);

    // orot = lrot * orot
    quat.mul(orot, cur.lrot, orot);

    // osca = lsca * osca
    vec3.mul(osca, cur.lscale, osca);

    cur = cur._parent;
  }
};

Object.defineProperties( Node.prototype, prototypeAccessors$10 );

function walk(node, fn, level) {
  if ( level === void 0 ) level = 0;

  level += 1;
  var len = node.children.length;

  for (var i = 0; i < len; ++i) {
    var child = node.children[i];
    var continueWalk = fn(child, node, level);

    if (continueWalk === false) {
      break;
    }

    walk(child, fn, level);
  }
}

/**
 * fn1 is used when entering the node, fn2 is used when leaving the node
 * @param {Node} node
 * @param {function(node: Node, parent: Node, level: number): boolean} fn1
 * @param {function(node: Node, parent: Node, level: number)} fn2
 * @param {number} level
 */
function walk2(node, fn1, fn2, level) {
  if ( level === void 0 ) level = 0;

  level += 1;
  var len = node.children.length;

  for (var i = 0; i < len; ++i) {
    var child = node.children[i];
    var continueWalk = fn1(child, node, level);

    if (continueWalk === false) {
      fn2(child, node, level);
      break;
    }

    walk2(child, fn1, fn2, level);
    fn2(child, node, level);
  }
}

/**
 * walkSibling is almost same as walk except when the fn return false,
 * it just break walk in children but not break walk in sibiling
 *
 * @method walkSibling
 * @param {Node} node
 * @param {function(node: Node, parent: Node, level: number): boolean} fn
 * @param {number} level
 */
function walkSibling(node, fn, level) {
  if ( level === void 0 ) level = 0;

  level += 1;
  var len = node.children.length;

  for (var i = 0; i < len; ++i) {
    var child = node.children[i];
    var continueWalk = fn(child, node, level);

    if (continueWalk !== false) {
      walkSibling(child, fn, level);
    }
  }
}

/**
 * @method flat
 * @param {Node} node
 */
function flat(node) {
  var out = [];

  out.push(node);
  walk(node, function (iter) {
    out.push(iter);
  });

  return out;
}

/**
 * @method replace
 * @param {Node} oldNode
 * @param {Node} newNode
 */
function replace(oldNode, newNode) {
  newNode.remove();

  var parent = oldNode._parent;
  if (!parent) {
    return;
  }

  oldNode._parent = null;
  newNode._parent = parent;

  var len = parent._children.length;
  for (var i = 0; i < len; ++i) {
    if (parent._children[i] === oldNode) {
      parent._children[i] = newNode;
      return;
    }
  }
}

/**
 * @method clone
 * @param {Node} node
 * @param {function} ctor
 * @param {function} fn
 * @return {Node}
 */
function clone(node, ctor, fn) {
  if ( ctor === void 0 ) ctor = Node;
  if ( fn === void 0 ) fn = null;

  var newNode = new ctor();
  newNode.name = node.name;
  vec3.copy(newNode.lpos, node.lpos);
  vec3.copy(newNode.lscale, node.lscale);
  quat.copy(newNode.lrot, node.lrot);

  // do user custom clone function
  if (fn) {
    fn(newNode, node);
  }

  return newNode;
}

/**
 * @method deepClone
 * @param {Node} node
 * @param {function} ctor
 * @param {function} fn
 * @return {Node}
 */
function deepClone(node, ctor, fn) {
  if ( ctor === void 0 ) ctor = Node;
  if ( fn === void 0 ) fn = null;

  var newNode = clone(node, ctor, fn);

  newNode._children = new Array(node._children.length);
  for (var i = 0; i < node._children.length; ++i) {
    var child = node._children[i];
    var newChild = deepClone(child, ctor, fn);
    newNode._children[i] = newChild;
    newChild._parent = newNode;
  }

  return newNode;
}

/**
 * @method find
 * @param {Node} root
 * @param {string} path
 */
function find(root, path) {
  var names = path.split('/');

  function _recurse(node, level) {
    var len = node.children.length;
    var name = names[level];

    for (var i = 0; i < len; ++i) {
      var child = node.children[i];

      if (child.name !== name) {
        continue;
      }

      if (level === names.length - 1) {
        return child;
      } else {
        return _recurse(child, level + 1);
      }
    }

    return null;
  }

  return _recurse(root, 0);
}

var utils = {
  walk: walk,
  walk2: walk2,
  walkSibling: walkSibling,
  flat: flat,
  replace: replace,
  clone: clone,
  deepClone: deepClone,
  find: find,
};

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

var Scene = function Scene() {
  this._lights = new FixedArray(16);
  this._models = new FixedArray(16);
  this._cameras = new FixedArray(16);
  this._debugCamera = null;

  // NOTE: we don't use pool for views (because it's less changed and it doesn't have poolID)
  this._views = [];
};

Scene.prototype._add = function _add (pool, item) {
  if (item._poolID !== -1) {
    return;
  }

  pool.push(item);
  item._poolID = pool.length - 1;
};

Scene.prototype._remove = function _remove (pool, item) {
  if (item._poolID === -1) {
    return;
  }

  pool.data[pool.length-1]._poolID = item._poolID;
  pool.fastRemove(item._poolID);
  item._poolID = -1;
};

/**
 * reset the model viewIDs
 */
Scene.prototype.reset = function reset () {
    var this$1 = this;

  for (var i = 0; i < this._models.length; ++i) {
    var model = this$1._models.data[i];
    model._viewID = -1;
  }
};

/**
 * Set the debug camera
 * @param {Camera} cam the debug camera
 */
Scene.prototype.setDebugCamera = function setDebugCamera (cam) {
  this._debugCamera = cam;
};

/**
 * Get the count of registered cameras
 * @returns {number} camera count
 */
Scene.prototype.getCameraCount = function getCameraCount () {
  return this._cameras.length;
};

/**
 * Get the specified camera
 * @param {number} idx camera index
 * @returns {Camera} the specified camera
 */
Scene.prototype.getCamera = function getCamera (idx) {
  return this._cameras.data[idx];
};

/**
 * register a camera
 * @param {Camera} camera the new camera
 */
Scene.prototype.addCamera = function addCamera (camera) {
  this._add(this._cameras, camera);
};

/**
 * remove a camera
 * @param {Camera} camera the camera to be removed
 */
Scene.prototype.removeCamera = function removeCamera (camera) {
  this._remove(this._cameras, camera);
};

/**
 * Get the count of registered model
 * @returns {number} model count
 */
Scene.prototype.getModelCount = function getModelCount () {
  return this._models.length;
};

/**
 * Get the specified model
 * @param {number} idx model index
 * @returns {Model} the specified model
 */
Scene.prototype.getModel = function getModel (idx) {
  return this._models.data[idx];
};

/**
 * register a model
 * @param {Model} model the new model
 */
Scene.prototype.addModel = function addModel (model) {
  this._add(this._models, model);
};

/**
 * remove a model
 * @param {Model} model the model to be removed
 */
Scene.prototype.removeModel = function removeModel (model) {
  this._remove(this._models, model);
};

/**
 * cast a ray in the scene, find the nearest intersection
 * @param {Object} hitInfo the output intersection information
 * @param {Ray} ray the testing ray
 * @param {number} maxDistance max intersection distance
 * @returns {boolean} is there any intersection?
 */
Scene.prototype.raycast = function raycast (hitInfo, ray, maxDistance) {
    var this$1 = this;
    if ( maxDistance === void 0 ) maxDistance = Infinity;

  var dist = Infinity, cur = dist;
  // fixme: brute-force traversal
  var its = vec3.zero();
  for (var i = 0; i < this.getModelCount(); i++) {
    var model = this$1.getModel(i);
    if (!Layers.check(model._node.layer, Layers.RaycastMask)) { continue; }
    if (!intersect.ray_box(ray, model._boundingBox, its)) { continue; }
    cur = vec3.sqrDist(its, ray.o);
    if (cur > maxDistance * maxDistance || cur > dist) { continue; }
    dist = cur;
    hitInfo.entity = model._node;
  }
  return dist < Infinity;
};

/**
 * Get the count of registered light
 * @returns {number} light count
 */
Scene.prototype.getLightCount = function getLightCount () {
  return this._lights.length;
};

/**
 * Get the specified light
 * @param {number} idx light index
 * @returns {Light} the specified light
 */
Scene.prototype.getLight = function getLight (idx) {
  return this._lights.data[idx];
};

/**
 * register a light
 * @param {Light} light the new light
 */
Scene.prototype.addLight = function addLight (light) {
  this._add(this._lights, light);
};

/**
 * remove a light
 * @param {Light} light the light to be removed
 */
Scene.prototype.removeLight = function removeLight (light) {
  this._remove(this._lights, light);
};

/**
 * register a view
 * @param {View} view the new view
 */
Scene.prototype.addView = function addView (view) {
  if (this._views.indexOf(view) === -1) {
    this._views.push(view);
  }
};

/**
 * remove a view
 * @param {View} view the view to be removed
 */
Scene.prototype.removeView = function removeView (view) {
  var idx = this._views.indexOf(view);
  if (idx !== -1) {
    this._views.splice(idx, 1);
  }
};

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

var LineBatchModel = (function (Model$$1) {
  function LineBatchModel() {
    Model$$1.call(this);

    this._type = 'line-batch';
    this._lines = new RecyclePool(function () {
      return {
        start: vec3.zero(),
        end: vec3.zero(),
        color: color3.create(),
        normal: vec3.zero(),
      };
    }, 2000);
  }

  if ( Model$$1 ) LineBatchModel.__proto__ = Model$$1;
  LineBatchModel.prototype = Object.create( Model$$1 && Model$$1.prototype );
  LineBatchModel.prototype.constructor = LineBatchModel;

  var prototypeAccessors = { vertCount: { configurable: true },lineCount: { configurable: true } };

  prototypeAccessors.vertCount.get = function () {
    return this._lines.length * 2;
  };

  prototypeAccessors.lineCount.get = function () {
    return this._lines.length;
  };

  LineBatchModel.prototype.getLine = function getLine (idx) {
    return this._lines.data[idx];
  };

  LineBatchModel.prototype.addLine = function addLine (start, end, color, normal) {
    var line = this._lines.add();

    vec3.copy(line.start, start);
    vec3.copy(line.end, end);

    if (color) {
      color3.copy(line.color, color);
    }

    if (normal) {
      vec3.copy(line.normal, normal);
    }

    return line;
  };

  LineBatchModel.prototype.clear = function clear () {
    this._lines.reset();
  };

  Object.defineProperties( LineBatchModel.prototype, prototypeAccessors );

  return LineBatchModel;
}(Model));

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

var SpriteBatchModel = (function (Model$$1) {
  function SpriteBatchModel() {
    Model$$1.call(this);

    this._type = 'sprite-batch';
    this._sprites = new RecyclePool(function () {
      return {
        refPositions: null,
        refUVs: null,
        refColor: null,
        refIndices: null,
      };
    }, 2000);

    this._vertCount = 0;
    this._indexCount = 0;
  }

  if ( Model$$1 ) SpriteBatchModel.__proto__ = Model$$1;
  SpriteBatchModel.prototype = Object.create( Model$$1 && Model$$1.prototype );
  SpriteBatchModel.prototype.constructor = SpriteBatchModel;

  var prototypeAccessors = { vertCount: { configurable: true },indexCount: { configurable: true },spriteCount: { configurable: true } };

  prototypeAccessors.vertCount.get = function () {
    return this._vertCount;
  };

  prototypeAccessors.indexCount.get = function () {
    return this._indexCount;
  };

  prototypeAccessors.spriteCount.get = function () {
    return this._sprites.length;
  };

  SpriteBatchModel.prototype.getSprite = function getSprite (idx) {
    return this._sprites.data[idx];
  };

  SpriteBatchModel.prototype.addSprite = function addSprite (positions, uvs, color, indices) {
    var sprite = this._sprites.add();

    sprite.refPositions = positions;
    sprite.refUVs = uvs;
    sprite.refColor = color;
    sprite.refIndices = indices;

    this._vertCount += positions.length;
    this._indexCount += indices.length;

    return sprite;
  };

  SpriteBatchModel.prototype.clear = function clear () {
    this._sprites.reset();

    this._vertCount = 0;
    this._indexCount = 0;
  };

  Object.defineProperties( SpriteBatchModel.prototype, prototypeAccessors );

  return SpriteBatchModel;
}(Model));

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

function _createInputAssembler(out) {
  var vb = new gfx.VertexBuffer(
    out._device,
    new gfx.VertexFormat(out._vertAttrs),
    gfx.USAGE_DYNAMIC,
    null,
    out._capacity * 4
  );

  var indices = new Array(out._capacity);
  var dst = 0;
  for (var i = 0; i < out._capacity; ++i) {
    var baseIdx = 4 * i;
    indices[dst++] = baseIdx;
    indices[dst++] = baseIdx + 1;
    indices[dst++] = baseIdx + 2;
    indices[dst++] = baseIdx + 3;
    indices[dst++] = baseIdx + 2;
    indices[dst++] = baseIdx + 1;
  }
  var ib = new gfx.IndexBuffer(
    out._device,
    gfx.INDEX_FMT_UINT16,
    gfx.USAGE_STATIC,
    new Uint16Array(indices),
    indices.length
  );

  out._ia = new InputAssembler(vb, ib);
}

var ParticleBatchModel = (function (Model$$1) {
  function ParticleBatchModel(device, capacity,
    vertAttrs) {
    if ( vertAttrs === void 0 ) vertAttrs = [
      { name: gfx.ATTR_POSITION, type: gfx.ATTR_TYPE_FLOAT32, num: 3 },
      { name: gfx.ATTR_UV, type: gfx.ATTR_TYPE_FLOAT32, num: 3 },
      { name: gfx.ATTR_UV0, type: gfx.ATTR_TYPE_FLOAT32, num: 2 },
      { name: gfx.ATTR_COLOR, type: gfx.ATTR_TYPE_FLOAT32, num: 4 } ];

    Model$$1.call(this);

    this._type = 'particle-batch';
    this._device = device;
    this._vertAttrs = vertAttrs;
    this._capacity = capacity;
    _createInputAssembler(this);
    this._vertAttrsSize = this._ia._vertexBuffer._format._bytes / 4; // number of float
    this._vdataF32 = new Float32Array(capacity * 4 * this._vertAttrsSize);
  }

  if ( Model$$1 ) ParticleBatchModel.__proto__ = Model$$1;
  ParticleBatchModel.prototype = Object.create( Model$$1 && Model$$1.prototype );
  ParticleBatchModel.prototype.constructor = ParticleBatchModel;

  ParticleBatchModel.prototype.setVertexAttributes = function setVertexAttributes (attrs) {
    this._vertAttrs = attrs;
    // rebuid
    _createInputAssembler(this);
    this._vertAttrsSize = this._ia._vertexBuffer._format._bytes / 4; // number of float
    this._vdataF32 = new Float32Array(this._capacity * 4 * this._vertAttrsSize);
  };

  ParticleBatchModel.prototype.enableStretchedBillboard = function enableStretchedBillboard () {
    if (this._vertAttrs.find(function (attr) { return attr.name === gfx.ATTR_COLOR0; }) === undefined) {
      this._vertAttrs.push({ name: gfx.ATTR_COLOR0, type: gfx.ATTR_TYPE_FLOAT32, num: 3 });
      this.setVertexAttributes(this._vertAttrs);
    }
  };

  ParticleBatchModel.prototype.disableStretchedBillboard = function disableStretchedBillboard () {
    if (this._vertAttrs.find(function (attr) { return attr.name === gfx.ATTR_COLOR0; }) !== undefined) {
      this._vertAttrs.pop();
      this.setVertexAttributes(this._vertAttrs);
    }
  };

  ParticleBatchModel.prototype.addParticleVertexData = function addParticleVertexData (index, pvdata) {
    var this$1 = this;

    if (pvdata.length !== this._vertAttrs.length) {
      console.error('particle vertex stream data not match.');
    }
    var offset = index * this._vertAttrsSize;
    for (var i = 0; i < this._vertAttrs.length; ++i) {
      var curAttr = this$1._vertAttrs[i];
      if (curAttr.num === 1) {
        this$1._vdataF32[offset] = pvdata[i]; // if not a single float?
        offset++;
      } else if (curAttr.num === 2) {
        this$1._vdataF32[offset] = pvdata[i].x;
        this$1._vdataF32[offset + 1] = pvdata[i].y;
        offset += 2;
      } else if (curAttr.num === 3) {
        this$1._vdataF32[offset] = pvdata[i].x;
        this$1._vdataF32[offset + 1] = pvdata[i].y;
        this$1._vdataF32[offset + 2] = pvdata[i].z;
        offset += 3;
      } else if (curAttr.num === 4) {
        this$1._vdataF32[offset] = pvdata[i].x;
        this$1._vdataF32[offset + 1] = pvdata[i].y;
        this$1._vdataF32[offset + 2] = pvdata[i].z;
        this$1._vdataF32[offset + 3] = pvdata[i].w;
        offset += 4;
      } else {
        console.error('particle vertex attribute format not support');
      }
    }
  };

  ParticleBatchModel.prototype.updateIA = function updateIA (count) {
    this._ia._count = count;
    this._ia._vertexBuffer.update(0, this._vdataF32);
  };

  ParticleBatchModel.prototype.clear = function clear () {
    this._ia._count = 0;
  };

  ParticleBatchModel.prototype.destroy = function destroy () {
    this._vdataF32 = null;
    this._ia._vertexBuffer.destroy();
    this._ia._indexBuffer.destroy();
  };

  return ParticleBatchModel;
}(Model));

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

var SkinningModel = (function (Model$$1) {
  function SkinningModel() {
    Model$$1.call(this);

    this._type = 'skinning';
    this._jointsTexture = null;
  }

  if ( Model$$1 ) SkinningModel.__proto__ = Model$$1;
  SkinningModel.prototype = Object.create( Model$$1 && Model$$1.prototype );
  SkinningModel.prototype.constructor = SkinningModel;

  SkinningModel.prototype.setJointsTexture = function setJointsTexture (texture) {
    this._jointsTexture = texture;
  };

  return SkinningModel;
}(Model));

var shaderChunks = {
  'common.frag': '\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define saturate(a) clamp( a, 0.0, 1.0 )',
  'gamma-correction.frag': '\nvec3 gammaToLinearSpaceRGB(vec3 sRGB) { \n  return sRGB * (sRGB * (sRGB * 0.305306011 + 0.682171111) + 0.012522878);\n}\nvec3 linearToGammaSpaceRGB(vec3 RGB) { \n  vec3 S1 = sqrt(RGB);\n  vec3 S2 = sqrt(S1);\n  vec3 S3 = sqrt(S2);\n  return 0.585122381 * S1 + 0.783140355 * S2 - 0.368262736 * S3;\n}\nvec4 gammaToLinearSpaceRGBA(vec4 sRGBA) {\n  return vec4(gammaToLinearSpaceRGB(sRGBA.rgb), sRGBA.a);\n}\nvec4 linearToGammaSpaceRGBA(vec4 RGBA) {\n  return vec4(linearToGammaSpaceRGB(RGBA.rgb), RGBA.a);\n}\nfloat gammaToLinearSpaceExact(float val) {\n  if (val <= 0.04045) {\n    return val / 12.92;\n  } else if (val < 1.0) {\n    return pow((val + 0.055) / 1.055, 2.4);\n  } else {\n    return pow(val, 2.2);\n  }\n}\nfloat linearToGammaSpaceExact(float val) {\n  if (val <= 0.0) {\n    return 0.0;\n  } else if (val <= 0.0031308) {\n    return 12.92 * val;\n  } else if (val < 1.0) {\n    return 1.055 * pow(val, 0.4166667) - 0.055;\n  } else {\n    return pow(val, 0.45454545);\n  }\n}',
  'packing.frag': '\nvec4 packDepthToRGBA(float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nfloat unpackRGBAToDepth(vec4 color) {\n  return dot(color, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n}',
  'pbr-lighting.frag': '\nstruct LightInfo {\n  vec3 lightDir;\n  vec3 radiance;\n};\n#if NUM_DIR_LIGHTS > 0\n  #pragma for id in range(0, NUM_DIR_LIGHTS)\n    uniform vec3 dir_light{id}_direction;\n    uniform vec3 dir_light{id}_color;\n  #pragma endFor\n#endif\n#if NUM_POINT_LIGHTS > 0\n  #pragma for id in range(0, NUM_POINT_LIGHTS)\n    uniform vec3 point_light{id}_position;\n    uniform vec3 point_light{id}_color;\n    uniform float point_light{id}_range;\n  #pragma endFor\n#endif\n#if NUM_SPOT_LIGHTS > 0\n  #pragma for id in range(0, NUM_SPOT_LIGHTS)\n    uniform vec3 spot_light{id}_position;\n    uniform vec3 spot_light{id}_direction;\n    uniform vec3 spot_light{id}_color;\n    uniform vec2 spot_light{id}_spot;\n    uniform float spot_light{id}_range;\n  #pragma endFor\n#endif\nLightInfo computeDirectionalLighting(\n  vec3 lightDirection,\n  vec3 lightColor\n) {\n  LightInfo ret;\n  ret.lightDir = -normalize(lightDirection);\n  ret.radiance = lightColor;\n  return ret;\n}\nLightInfo computePointLighting(\n  vec3 lightPosition,\n  vec3 positionW,\n  vec3 lightColor,\n  float lightRange\n) {\n  LightInfo ret;\n  vec3 lightDir = lightPosition - positionW;\n  float attenuation = max(0.0, 1.0 - length(lightDir) / lightRange);\n  ret.lightDir = normalize(lightDir);\n  ret.radiance = lightColor * attenuation;\n  return ret;\n}\nLightInfo computeSpotLighting(\n  vec3 lightPosition,\n  vec3 positionW,\n  vec3 lightDirection,\n  vec3 lightColor,\n  vec2 lightSpot,\n  float lightRange\n) {\n  LightInfo ret;\n  vec3 lightDir = lightPosition - positionW;\n  float attenuation = max(0., 1.0 - length(lightDir) / lightRange);\n  float cosConeAngle = max(0., dot(lightDirection, -lightDir));\n  cosConeAngle = cosConeAngle < lightSpot.x ? 0.0 : cosConeAngle;\n  cosConeAngle = pow(cosConeAngle,lightSpot.y);\n  ret.lightDir = normalize(lightDir);\n  ret.radiance = lightColor * attenuation * cosConeAngle;\n  return ret;\n}',
  'phong-lighting.frag': '\nstruct LightInfo {\n  vec3 diffuse;\n  vec3 specular;\n};\nLightInfo computeDirectionalLighting(\n  vec3 lightDirection,\n  vec3 lightColor,\n  vec3 normal,\n  vec3 viewDirection,\n  float glossiness\n) {\n  LightInfo lightingResult;\n  float ndl = 0.0;\n  float ndh = 0.0;\n  vec3 lightDir = -normalize(lightDirection);\n  ndl = max(0.0, dot(normal, lightDir));\n  lightingResult.diffuse = lightColor * ndl;\n  vec3 dirH = normalize(viewDirection + lightDir);\n  ndh = max(0.0, dot(normal, dirH));\n  ndh = (ndl == 0.0) ? 0.0: ndh;\n  ndh = pow(ndh, max(1.0, glossiness * 128.0));\n  lightingResult.specular = lightColor * ndh;\n  return lightingResult;\n}\nLightInfo computePointLighting(\n  vec3 lightPosition,\n  vec3 lightColor,\n  float lightRange,\n  vec3 normal,\n  vec3 positionW,\n  vec3 viewDirection,\n  float glossiness\n) {\n  LightInfo lightingResult;\n  float ndl = 0.0;\n  float ndh = 0.0;\n  vec3 lightDir = vec3(0, 0, 0);\n  float attenuation = 1.0;\n  lightDir = lightPosition - positionW;\n  attenuation = max(0., 1.0 - length(lightDir) / lightRange);\n  lightDir = normalize(lightDir);\n  ndl = max(0.0, dot(normal, lightDir));\n  lightingResult.diffuse = lightColor * ndl * attenuation;\n  vec3 dirH = normalize(viewDirection + lightDir);\n  ndh = max(0.0, dot(normal, dirH));\n  ndh = (ndl == 0.0) ? 0.0: ndh;\n  ndh = pow(ndh, max(1.0, glossiness * 128.0));\n  lightingResult.specular = lightColor * ndh * attenuation;\n  return lightingResult;\n}\nLightInfo computeSpotLighting(\n  vec3 lightPosition,\n  vec3 lightDirection,\n  vec3 lightColor,\n  float lightRange,\n  vec2 lightSpot,\n  vec3 normal,\n  vec3 positionW,\n  vec3 viewDirection,\n  float glossiness\n) {\n  LightInfo lightingResult;\n  float ndl = 0.0;\n  float ndh = 0.0;\n  vec3 lightDir = vec3(0, 0, 0);\n  float attenuation = 1.0;\n  float cosConeAngle = 1.0;\n  lightDir = lightPosition - positionW;\n  attenuation = max(0., 1.0 - length(lightDir) / lightRange);\n  lightDir = normalize(lightDir);\n  cosConeAngle = max(0., dot(lightDirection, -lightDir));\n  cosConeAngle = cosConeAngle < lightSpot.x ? 0.0 : cosConeAngle;\n  cosConeAngle = pow(cosConeAngle,lightSpot.y);\n  ndl = max(0.0, dot(normal, lightDir));\n  lightingResult.diffuse = lightColor * ndl * attenuation * cosConeAngle;\n  vec3 dirH = normalize(viewDirection + lightDir);\n  ndh = max(0.0, dot(normal, dirH));\n  ndh = (ndl == 0.0) ? 0.0: ndh;\n  ndh = pow(ndh, max(1.0, glossiness * 128.0));\n  lightingResult.specular = lightColor * ndh * attenuation * cosConeAngle;\n  return lightingResult;\n}\n#if NUM_DIR_LIGHTS > 0\n  #pragma for id in range(0, NUM_DIR_LIGHTS)\n    uniform vec3 dir_light{id}_direction;\n    uniform vec3 dir_light{id}_color;\n  #pragma endFor\n#endif\n#if NUM_POINT_LIGHTS > 0\n  #pragma for id in range(0, NUM_POINT_LIGHTS)\n    uniform vec3 point_light{id}_position;\n    uniform vec3 point_light{id}_color;\n    uniform float point_light{id}_range;\n  #pragma endFor\n#endif\n#if NUM_SPOT_LIGHTS > 0\n  #pragma for id in range(0, NUM_SPOT_LIGHTS)\n    uniform vec3 spot_light{id}_position;\n    uniform vec3 spot_light{id}_direction;\n    uniform vec3 spot_light{id}_color;\n    uniform float spot_light{id}_range;\n    uniform vec2 spot_light{id}_spot;\n  #pragma endFor\n#endif\nLightInfo getPhongLighting(\n  vec3 normal,\n  vec3 positionW,\n  vec3 viewDirection,\n  float glossiness\n) {\n  LightInfo result;\n  result.diffuse = vec3(0, 0, 0);\n  result.specular = vec3(0, 0, 0);\n  LightInfo dirLighting;\n  #if NUM_DIR_LIGHTS > 0\n    #pragma for id in range(0, NUM_DIR_LIGHTS)\n      dirLighting = computeDirectionalLighting(dir_light{id}_direction,dir_light{id}_color,normal, viewDirection, glossiness);\n      result.diffuse += dirLighting.diffuse;\n      result.specular += dirLighting.specular;\n    #pragma endFor\n  #endif\n  LightInfo pointLighting;\n  #if NUM_POINT_LIGHTS > 0\n    #pragma for id in range(0, NUM_POINT_LIGHTS)\n      pointLighting = computePointLighting(point_light{id}_position, point_light{id}_color, point_light{id}_range,\n                                          normal, positionW, viewDirection, glossiness);\n      result.diffuse += pointLighting.diffuse;\n      result.specular += pointLighting.specular;\n    #pragma endFor\n  #endif\n  LightInfo spotLighting;\n  #if NUM_SPOT_LIGHTS > 0\n    #pragma for id in range(0, NUM_SPOT_LIGHTS)\n      spotLighting = computeSpotLighting(spot_light{id}_position, spot_light{id}_direction, spot_light{id}_color,\n                      spot_light{id}_range, spot_light{id}_spot,normal, positionW, viewDirection, glossiness);\n      result.diffuse += spotLighting.diffuse;\n      result.specular += spotLighting.specular;\n    #pragma endFor\n  #endif\n  return result;\n}\n',
  'shadow-mapping.frag': '\n#if NUM_SHADOW_LIGHTS > 0\n  #pragma for id in range(0, NUM_SHADOW_LIGHTS)\n    uniform sampler2D shadowMap_{id};\n    uniform float darkness_{id};\n    uniform float depthScale_{id};\n    uniform float frustumEdgeFalloff_{id};\n    uniform float bias_{id};\n    uniform vec2 texelSize_{id};\n    varying vec4 pos_lightspace_{id};\n    varying float vDepth_{id};\n  #pragma endFor\n#endif\nfloat computeShadow(sampler2D shadowMap, vec4 pos_lightspace, float bias) {\n  vec3 projCoords = pos_lightspace.xyz / pos_lightspace.w;\n  projCoords = projCoords * 0.5 + 0.5;\n  float closestDepth = unpackRGBAToDepth(texture2D(shadowMap, projCoords.xy));\n  float currentDepth = projCoords.z;\n  float shadow = (currentDepth - bias > closestDepth) ? 0.0 : 1.0;\n  return shadow;\n}\nfloat computeFallOff(float esm, vec2 coords, float frustumEdgeFalloff) {\n  float mask = smoothstep(1.0 - frustumEdgeFalloff, 1.0, clamp(dot(coords, coords), 0.0, 1.0));\n  return mix(esm, 1.0, mask);\n}\nfloat computeShadowESM(sampler2D shadowMap, vec4 pos_lightspace, float vDepth, float depthScale, float darkness, float frustumEdgeFalloff) {\n  vec2 projCoords = pos_lightspace.xy / pos_lightspace.w;\n  vec2 shadowUV = projCoords * 0.5 + vec2(0.5);\n  if (shadowUV.x < 0.0 || shadowUV.x > 1.0 || shadowUV.y < 0.0 || shadowUV.y > 1.0) {\n    return 1.0;\n  }\n  float currentDepth = clamp(vDepth, 0.0, 1.0);\n  float closestDepth = unpackRGBAToDepth(texture2D(shadowMap, shadowUV));\n  \n  float esm = clamp(exp(-depthScale * (currentDepth - closestDepth)), 1.0 - darkness, 1.0);\n  return computeFallOff(esm, projCoords, frustumEdgeFalloff);\n}\nfloat computeShadowPCF(sampler2D shadowMap, vec4 pos_lightspace, float vDepth, float darkness, vec2 texelSize, float frustumEdgeFalloff) {\n  vec2 projCoords = pos_lightspace.xy / pos_lightspace.w;\n  vec2 shadowUV = projCoords * 0.5 + vec2(0.5);\n  if (shadowUV.x < 0.0 || shadowUV.x > 1.0 || shadowUV.y < 0.0 || shadowUV.y > 1.0) {\n    return 1.0;\n  }\n  float currentDepth = clamp(vDepth, 0.0, 1.0);\n  float visibility = 1.0;\n  vec2 poissonDisk[4];\n  poissonDisk[0] = vec2(-0.94201624, -0.39906216);\n  poissonDisk[1] = vec2(0.94558609, -0.76890725);\n  poissonDisk[2] = vec2(-0.094184101, -0.92938870);\n  poissonDisk[3] = vec2(0.34495938, 0.29387760);\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[0] * texelSize)) < currentDepth) visibility -= 0.25;\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[1] * texelSize)) < currentDepth) visibility -= 0.25;\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[2] * texelSize)) < currentDepth) visibility -= 0.25;\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[3] * texelSize)) < currentDepth) visibility -= 0.25;\n  return computeFallOff(min(1.0, visibility + 1.0 - darkness), projCoords, frustumEdgeFalloff);\n}',
  'skinning.vert': '\nattribute vec4 a_weights;\nattribute vec4 a_joints;\nuniform sampler2D u_jointsTexture;\nuniform float u_jointsTextureSize;\nmat4 getBoneMatrix(const in float i) {\n  float size = u_jointsTextureSize;\n  float j = i * 4.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  vec4 v1 = texture2D(u_jointsTexture, vec2(dx * (x + 0.5), y));\n  vec4 v2 = texture2D(u_jointsTexture, vec2(dx * (x + 1.5), y));\n  vec4 v3 = texture2D(u_jointsTexture, vec2(dx * (x + 2.5), y));\n  vec4 v4 = texture2D(u_jointsTexture, vec2(dx * (x + 3.5), y));\n  return mat4(v1, v2, v3, v4);\n}\nmat4 skinMatrix() {\n  return\n    getBoneMatrix(a_joints.x) * a_weights.x +\n    getBoneMatrix(a_joints.y) * a_weights.y +\n    getBoneMatrix(a_joints.z) * a_weights.z +\n    getBoneMatrix(a_joints.w) * a_weights.w\n    ;\n}',
  'unpack.frag': '\nvec3 unpackNormal(vec4 nmap) {\n  return nmap.xyz * 2.0 - 1.0;\n}\nvec3 unpackRGBE(vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}',
};

var shaderTemplates = [
  {
    name: 'gaussian-blur',
    vert: '\nattribute vec2 a_position;\nattribute vec2 a_uv0;\nvarying vec2 uv;\nvoid main() {\n  uv = a_uv0;\n  gl_Position = vec4(a_position.x, a_position.y, 0.0, 1.0);\n}',
    frag: '\nvarying vec2 uv;\nuniform sampler2D texture;\nuniform vec2 pixelSize;\n\nvec4 packDepthToRGBA(float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nfloat unpackRGBAToDepth(vec4 color) {\n  return dot(color, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n}\nfloat kGaussianBlur[10];\nfloat log_conv(float x0, float X, float y0, float Y) {\n  return ( X + log( x0 + (y0 * exp(Y - X) ) ) );\n}\nvoid main() {\n  kGaussianBlur[0] = 0.0882357;\n  kGaussianBlur[1] = 0.0957407;\n  kGaussianBlur[2] = 0.101786;\n  kGaussianBlur[3] = 0.106026;\n  kGaussianBlur[4] = 0.108212;\n  kGaussianBlur[5] = 0.108212;\n  kGaussianBlur[6] = 0.106026;\n  kGaussianBlur[7] = 0.101786;\n  kGaussianBlur[8] = 0.0957407;\n  kGaussianBlur[9] = 0.0882357;\n  float sample[10];\n  for (int i = 0; i < 10; ++i) {\n    float offset = float(i) - 4.5;\n    vec2 texCoord = vec2( uv.x + offset * pixelSize.x, uv.y + offset * pixelSize.y);\n    sample[i] = unpackRGBAToDepth(texture2D(texture, texCoord));\n  }\n  float sum = log_conv(kGaussianBlur[0], sample[0], kGaussianBlur[1], sample[1]);\n  for (int i = 2; i < 10; ++i) {\n    sum = log_conv(1.0, sum, kGaussianBlur[i], sample[i]);\n  }\n  gl_FragColor = packDepthToRGBA(sum);\n}\n',
    defines: [],
  },
  {
    name: 'grid',
    vert: '\nattribute vec2 a_uv0;\nattribute vec3 a_position;\nattribute vec3 a_normal;\nuniform mat4 model;\nuniform mat4 viewProj;\nvarying vec2 uv0;\nvarying vec4 pos_w;\n#if USE_WORLD_POS\n  uniform mat3 normalMatrix;\n  varying vec3 normal_w;\n#endif\nvoid main () {\n  uv0 = a_uv0;\n  pos_w = model * vec4(a_position, 1);\n  #if USE_WORLD_POS\n    normal_w = normalMatrix * a_normal;\n  #endif\n  gl_Position = viewProj * pos_w;\n}',
    frag: '\nvarying vec2 uv0;\nvarying vec4 pos_w;\n#if USE_WORLD_POS\n  varying vec3 normal_w;\n#endif\nuniform vec2 tiling;\nuniform vec3 baseColorWhite;\nuniform vec3 baseColorBlack;\nuniform sampler2D basePattern;\nuniform vec2 basePatternTiling;\nuniform vec2 basePatternOffset;\nuniform vec4 subPatternColor;\nuniform sampler2D subPattern;\nuniform vec2 subPatternTiling;\nuniform vec2 subPatternOffset;\nuniform vec4 subPatternColor2;\nuniform sampler2D subPattern2;\nuniform vec2 subPattern2Tiling;\nuniform vec2 subPattern2Offset;\nvoid main () {\n  vec2 uv = uv0 * tiling;\n  vec2 uvBase = uv * basePatternTiling + basePatternOffset;\n  vec2 uvSub = uv * subPatternTiling + subPatternOffset;\n  vec2 uvSub2 = uv * subPattern2Tiling + subPattern2Offset;\n  #if USE_WORLD_POS\n    vec3 dnormal_w = normalize(normal_w);\n    if (abs(dnormal_w.x)>0.5) { \n      uvBase = (pos_w.zy * tiling * basePatternTiling) + basePatternOffset;\n      uvSub = (pos_w.zy * tiling * subPatternTiling) + subPatternOffset;\n      uvSub2 = (pos_w.zy * tiling * subPattern2Tiling) + subPattern2Offset;\n    } else if (abs(dnormal_w.z)>0.5) { \n      uvBase = (pos_w.xy * tiling * basePatternTiling) + basePatternOffset;\n      uvSub = (pos_w.xy * tiling * subPatternTiling) + subPatternOffset;\n      uvSub2 = (pos_w.xy * tiling * subPattern2Tiling) + subPattern2Offset;\n    } else { \n      uvBase = (pos_w.xz * tiling * basePatternTiling) + basePatternOffset;\n      uvSub = (pos_w.xz * tiling * subPatternTiling) + subPatternOffset;\n      uvSub2 = (pos_w.xz * tiling * subPattern2Tiling) + subPattern2Offset;\n    }\n  #endif\n  vec4 texColBase = texture2D(basePattern, uvBase);\n  vec4 texColSub = texture2D(subPattern, uvSub);\n  vec4 texColSub2 = texture2D(subPattern2, uvSub2);\n  \n  \n  \n  vec4 color = vec4(baseColorWhite,1) * texColBase + vec4(baseColorBlack,1) * (1.0-texColBase);\n  color =\n    color * (1.0 - texColSub) +\n    (subPatternColor * subPatternColor.a + color * (1.0-subPatternColor.a)) * texColSub\n    ;\n  color =\n    color * (1.0 - texColSub2) +\n    (subPatternColor2 * subPatternColor2.a + color * (1.0-subPatternColor2.a)) * texColSub2\n    ;\n  \n  \n  gl_FragColor = color;\n}',
    defines: [
      { name: 'USE_WORLD_POS', } ],
  },
  {
    name: 'line',
    vert: '\nattribute vec3 a_position;\nattribute vec3 a_color;\nuniform mat4 model;\nuniform mat4 viewProj;\nvarying vec3 color;\nvoid main () {\n  vec4 pos = viewProj * model * vec4(a_position, 1);\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  color = a_color;\n  gl_Position = pos;\n}',
    frag: '\nvarying vec3 color;\nvoid main () {\n  gl_FragColor = vec4(color, 1.0);\n}',
    defines: [],
  },
  {
    name: 'matcap',
    vert: '\nattribute vec3 a_position;\nattribute vec3 a_normal;\nuniform   mat4 model;\nuniform   mat4 viewProj;\nuniform   mat3 normalMatrix;\nvarying   vec2 matcapUV;\n#if USE_MAIN_TEX\n  attribute vec2 a_uv0;\n  varying   vec2 uv0;\n#endif\n#if USE_SKINNING\n  \nattribute vec4 a_weights;\nattribute vec4 a_joints;\nuniform sampler2D u_jointsTexture;\nuniform float u_jointsTextureSize;\nmat4 getBoneMatrix(const in float i) {\n  float size = u_jointsTextureSize;\n  float j = i * 4.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  vec4 v1 = texture2D(u_jointsTexture, vec2(dx * (x + 0.5), y));\n  vec4 v2 = texture2D(u_jointsTexture, vec2(dx * (x + 1.5), y));\n  vec4 v3 = texture2D(u_jointsTexture, vec2(dx * (x + 2.5), y));\n  vec4 v4 = texture2D(u_jointsTexture, vec2(dx * (x + 3.5), y));\n  return mat4(v1, v2, v3, v4);\n}\nmat4 skinMatrix() {\n  return\n    getBoneMatrix(a_joints.x) * a_weights.x +\n    getBoneMatrix(a_joints.y) * a_weights.y +\n    getBoneMatrix(a_joints.z) * a_weights.z +\n    getBoneMatrix(a_joints.w) * a_weights.w\n    ;\n}\n#endif\nvoid main(void){\n  #if USE_MAIN_TEX\n    uv0 = a_uv0;\n  #endif\n  vec4 pos = vec4(a_position, 1);\n  #if USE_SKINNING\n    mat4 skinMat = skinMatrix();\n    pos = skinMat * pos;\n  #endif\n  pos = viewProj * model * pos;\n  gl_Position = pos;\n  vec4 normal = vec4(a_normal, 0);\n  #if USE_SKINNING\n    normal = skinMat * normal;\n  #endif\n  normal = vec4(normalize(normalMatrix * normal.xyz), 0);\n  matcapUV = normal.xy;\n  matcapUV = matcapUV * 0.5 + 0.5;\n}',
    frag: '\nprecision mediump float;\nuniform sampler2D matcapTex;\nuniform float colorFactor;\nuniform vec4 color;\nvarying vec2 matcapUV;\n#if USE_MAIN_TEX\n  varying vec2 uv0;\n  uniform sampler2D mainTex;\n#endif\nvoid main(void){\n  vec4 col = vec4(1, 1, 1, 1);\n  col *= color;\n  #if USE_MAIN_TEX\n    col *= texture2D(mainTex, uv0);\n  #endif\n  vec4 matcapColor = texture2D(matcapTex, matcapUV);\n  gl_FragColor = col * colorFactor + matcapColor * (1.0 - colorFactor);\n}',
    defines: [
      { name: 'USE_MAIN_TEX', },
      { name: 'USE_SKINNING', } ],
  },
  {
    name: 'particle-add-multiply',
    vert: '\nattribute vec3 a_position; \nattribute vec3 a_uv;  \nattribute vec2 a_uv0; \nattribute vec4 a_color;\n#if USE_STRETCHED_BILLBOARD\nattribute vec3 a_color0; \n#endif\nuniform vec2 frameTile; \nuniform vec2 mainTiling;\nuniform vec2 mainOffset;\nuniform mat4 model;\nuniform mat4 viewProj;\n#if USE_BILLBOARD || USE_VERTICAL_BILLBOARD\n  uniform mat4 view;\n#endif\n#if USE_STRETCHED_BILLBOARD\n  uniform vec3 eye;\n  uniform float velocityScale;\n  uniform float lengthScale;\n#endif\nvarying vec2 uv;\nvarying vec4 color;\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n#if USE_STRETCHED_BILLBOARD\n  vec4 velocity = vec4(a_color0.xyz,0);\n#endif\n#if USE_WORLD_SPACE\n  \n#else\n  pos = model * pos;\n  #if USE_STRETCHED_BILLBOARD\n  velocity = model * velocity;\n  #endif\n#endif\n  vec2 cornerOffset = vec2((a_uv.x - 0.5) * a_uv0.x, (a_uv.y - 0.5) * a_uv0.x); \n#if USE_STRETCHED_BILLBOARD\n  \n#else\n  \n  vec2 rotatedOffset;\n  rotatedOffset.x = cos(a_uv0.y) * cornerOffset.x - sin(a_uv0.y) * cornerOffset.y;\n  rotatedOffset.y = sin(a_uv0.y) * cornerOffset.x + cos(a_uv0.y) * cornerOffset.y;\n#endif\n#if USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += (camRight * rotatedOffset.x) + (camUp * rotatedOffset.y);\n#elif USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * a_uv0.x;\n  pos.xyz += (camRight * abs(cornerOffset.x) * sign(cornerOffset.y)) - camUp * a_uv.x;\n#elif USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += (camRight * rotatedOffset.x) + (camUp * rotatedOffset.y);\n#elif USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += (camRight * rotatedOffset.x) + (camUp * rotatedOffset.y);\n#else\n  pos.x += rotatedOffset.x;\n  pos.y += rotatedOffset.y;\n#endif\n  pos = viewProj * pos;\n  vec2 aniUV = vec2(0, floor(a_uv.z * frameTile.y));\n  aniUV.x = floor(a_uv.z * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n  aniUV.y = frameTile.y - aniUV.y - 1.0;\n  aniUV = (aniUV.xy + a_uv.xy) / vec2(frameTile.x, frameTile.y);\n  uv = aniUV * mainTiling + mainOffset;\n  color = a_color;\n  gl_Position = pos;\n}',
    frag: '\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvarying vec2 uv;\nvarying vec4 color;\nvoid main () {\n  \n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  gl_FragColor = col;\n}',
    defines: [
      { name: 'USE_SOFT_PARTICLE', },
      { name: 'USE_BILLBOARD', },
      { name: 'USE_STRETCHED_BILLBOARD', },
      { name: 'USE_HORIZONTAL_BILLBOARD', },
      { name: 'USE_VERTICAL_BILLBOARD', },
      { name: 'USE_WORLD_SPACE', } ],
  },
  {
    name: 'particle-add-smooth',
    vert: '\nattribute vec3 a_position; \nattribute vec3 a_uv;  \nattribute vec2 a_uv0; \nattribute vec4 a_color;\n#if USE_STRETCHED_BILLBOARD\nattribute vec3 a_color0; \n#endif\nuniform vec2 frameTile;\nuniform vec2 mainTiling;\nuniform vec2 mainOffset;\nuniform mat4 model;\nuniform mat4 viewProj;\n#if USE_BILLBOARD || USE_VERTICAL_BILLBOARD\n  uniform mat4 view;\n#endif\n#if USE_STRETCHED_BILLBOARD\n  uniform vec3 eye;\n  uniform float velocityScale;\n  uniform float lengthScale;\n#endif\nvarying vec2 uv;\nvarying vec4 color;\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n#if USE_STRETCHED_BILLBOARD\n  vec4 velocity = vec4(a_color0.xyz,0);\n#endif\n#if USE_WORLD_SPACE\n  \n#else\n  pos = model * pos;\n  #if USE_STRETCHED_BILLBOARD\n  velocity = model * velocity;\n  #endif\n#endif\n  vec2 cornerOffset = vec2((a_uv.x - 0.5) * a_uv0.x, (a_uv.y - 0.5) * a_uv0.x);\n#if USE_STRETCHED_BILLBOARD\n  \n#else\n  \n  vec2 rotatedOffset;\n  rotatedOffset.x = cos(a_uv0.y) * cornerOffset.x - sin(a_uv0.y) * cornerOffset.y;\n  rotatedOffset.y = sin(a_uv0.y) * cornerOffset.x + cos(a_uv0.y) * cornerOffset.y;\n#endif\n#if USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += (camRight * rotatedOffset.x) + (camUp * rotatedOffset.y);\n#elif USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * a_uv0.x;\n  pos.xyz += (camRight * abs(cornerOffset.x) * sign(cornerOffset.y)) - camUp * a_uv.x;\n#elif USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += (camRight * rotatedOffset.x) + (camUp * rotatedOffset.y);\n#elif USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += (camRight * rotatedOffset.x) + (camUp * rotatedOffset.y);\n#else\n  pos.x += rotatedOffset.x;\n  pos.y += rotatedOffset.y;\n#endif\n  pos = viewProj * pos;\n  vec2 aniUV = vec2(0, floor(a_uv.z * frameTile.y));\n  aniUV.x = floor(a_uv.z * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n  aniUV.y = frameTile.y - aniUV.y - 1.0;\n  aniUV = (aniUV.xy + a_uv.xy) / vec2(frameTile.x, frameTile.y);\n  uv = aniUV * mainTiling + mainOffset;\n  color = a_color;\n  gl_Position = pos;\n}',
    frag: '\nuniform sampler2D mainTexture;\nvarying vec2 uv;\nvarying vec4 color;\nvoid main () {\n  \n  vec4 col = color * texture2D(mainTexture, uv);\n  col.rgb *= col.a;\n  gl_FragColor = col;\n}',
    defines: [
      { name: 'USE_SOFT_PARTICLE', },
      { name: 'USE_BILLBOARD', },
      { name: 'USE_STRETCHED_BILLBOARD', },
      { name: 'USE_HORIZONTAL_BILLBOARD', },
      { name: 'USE_VERTICAL_BILLBOARD', },
      { name: 'USE_WORLD_SPACE', } ],
  },
  {
    name: 'particle-add',
    vert: '\nattribute vec3 a_position; \nattribute vec3 a_uv;  \nattribute vec2 a_uv0; \nattribute vec4 a_color;\n#if USE_STRETCHED_BILLBOARD\nattribute vec3 a_color0; \n#endif\nuniform vec2 frameTile;\nuniform vec2 mainTiling;\nuniform vec2 mainOffset;\nuniform mat4 model;\nuniform mat4 viewProj;\n#if USE_BILLBOARD || USE_VERTICAL_BILLBOARD\n  uniform mat4 view;\n#endif\n#if USE_STRETCHED_BILLBOARD\n  uniform vec3 eye;\n  uniform float velocityScale;\n  uniform float lengthScale;\n#endif\nvarying vec2 uv;\nvarying vec4 color;\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n#if USE_STRETCHED_BILLBOARD\n  vec4 velocity = vec4(a_color0.xyz,0);\n#endif\n#if USE_WORLD_SPACE\n  \n#else\n  pos = model * pos;\n  #if USE_STRETCHED_BILLBOARD\n  velocity = model * velocity;\n  #endif\n#endif\n  vec2 cornerOffset = vec2((a_uv.x - 0.5) * a_uv0.x, (a_uv.y - 0.5) * a_uv0.x);\n#if USE_STRETCHED_BILLBOARD\n  \n#else\n  \n  vec2 rotatedOffset;\n  rotatedOffset.x = cos(a_uv0.y) * cornerOffset.x - sin(a_uv0.y) * cornerOffset.y;\n  rotatedOffset.y = sin(a_uv0.y) * cornerOffset.x + cos(a_uv0.y) * cornerOffset.y;\n#endif\n#if USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += (camRight * rotatedOffset.x) + (camUp * rotatedOffset.y);\n#elif USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * a_uv0.x;\n  pos.xyz += (camRight * abs(cornerOffset.x) * sign(cornerOffset.y)) - camUp * a_uv.x;\n#elif USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += (camRight * rotatedOffset.x) + (camUp * rotatedOffset.y);\n#elif USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += (camRight * rotatedOffset.x) + (camUp * rotatedOffset.y);\n#else\n  pos.x += rotatedOffset.x;\n  pos.y += rotatedOffset.y;\n#endif\n  pos = viewProj * pos;\n  vec2 aniUV = vec2(0, floor(a_uv.z * frameTile.y));\n  aniUV.x = floor(a_uv.z * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n  aniUV.y = frameTile.y - aniUV.y - 1.0;\n  aniUV = (aniUV.xy + a_uv.xy) / vec2(frameTile.x, frameTile.y);\n  uv = aniUV * mainTiling + mainOffset;\n  color = a_color;\n  gl_Position = pos;\n}',
    frag: '\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvarying vec2 uv;\nvarying vec4 color;\nvoid main () {\n  \n  gl_FragColor = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n}',
    defines: [
      { name: 'USE_SOFT_PARTICLE', },
      { name: 'USE_BILLBOARD', },
      { name: 'USE_STRETCHED_BILLBOARD', },
      { name: 'USE_HORIZONTAL_BILLBOARD', },
      { name: 'USE_VERTICAL_BILLBOARD', },
      { name: 'USE_WORLD_SPACE', } ],
  },
  {
    name: 'particle-alpha-blend',
    vert: '\nattribute vec3 a_position; \nattribute vec3 a_uv;  \nattribute vec2 a_uv0; \nattribute vec4 a_color;\n#if USE_STRETCHED_BILLBOARD\nattribute vec3 a_color0; \n#endif\nuniform vec2 frameTile;\nuniform vec2 mainTiling;\nuniform vec2 mainOffset;\nuniform mat4 model;\nuniform mat4 viewProj;\n#if USE_BILLBOARD || USE_VERTICAL_BILLBOARD\n  uniform mat4 view;\n#endif\n#if USE_STRETCHED_BILLBOARD\n  uniform vec3 eye;\n  uniform float velocityScale;\n  uniform float lengthScale;\n#endif\nvarying vec2 uv;\nvarying vec4 color;\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n#if USE_STRETCHED_BILLBOARD\n  vec4 velocity = vec4(a_color0.xyz,0);\n#endif\n#if USE_WORLD_SPACE\n  \n#else\n  pos = model * pos;\n  #if USE_STRETCHED_BILLBOARD\n  velocity = model * velocity;\n  #endif\n#endif\n  vec2 cornerOffset = vec2((a_uv.x - 0.5) * a_uv0.x, (a_uv.y - 0.5) * a_uv0.x); \n#if USE_STRETCHED_BILLBOARD\n  \n#else\n  \n  vec2 rotatedOffset;\n  rotatedOffset.x = cos(a_uv0.y) * cornerOffset.x - sin(a_uv0.y) * cornerOffset.y;\n  rotatedOffset.y = sin(a_uv0.y) * cornerOffset.x + cos(a_uv0.y) * cornerOffset.y;\n#endif\n#if USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += (camRight * rotatedOffset.x) + (camUp * rotatedOffset.y);\n#elif USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * a_uv0.x;\n  pos.xyz += (camRight * abs(cornerOffset.x) * sign(cornerOffset.y)) - camUp * a_uv.x;\n#elif USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += (camRight * rotatedOffset.x) + (camUp * rotatedOffset.y);\n#elif USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += (camRight * rotatedOffset.x) + (camUp * rotatedOffset.y);\n#else\n  pos.x += rotatedOffset.x;\n  pos.y += rotatedOffset.y;\n#endif\n  pos = viewProj * pos;\n  vec2 aniUV = vec2(0, floor(a_uv.z * frameTile.y));\n  aniUV.x = floor(a_uv.z * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n  aniUV.y = frameTile.y - aniUV.y - 1.0;\n  aniUV = (aniUV.xy + a_uv.xy) / vec2(frameTile.x, frameTile.y);\n  uv = aniUV * mainTiling + mainOffset;\n  color = a_color;\n  gl_Position = pos;\n}',
    frag: '\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvarying vec2 uv;\nvarying vec4 color;\nvoid main () {\n  \n  gl_FragColor = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n}',
    defines: [
      { name: 'USE_SOFT_PARTICLE', },
      { name: 'USE_BILLBOARD', },
      { name: 'USE_STRETCHED_BILLBOARD', },
      { name: 'USE_HORIZONTAL_BILLBOARD', },
      { name: 'USE_VERTICAL_BILLBOARD', },
      { name: 'USE_WORLD_SPACE', } ],
  },
  {
    name: 'particle-premultiply-blend',
    vert: '\nattribute vec3 a_position; \nattribute vec3 a_uv;  \nattribute vec2 a_uv0; \nattribute vec4 a_color;\n#if USE_STRETCHED_BILLBOARD\nattribute vec3 a_color0; \n#endif\nuniform vec2 frameTile;\nuniform vec2 mainTiling;\nuniform vec2 mainOffset;\nuniform mat4 model;\nuniform mat4 viewProj;\n#if USE_BILLBOARD || USE_VERTICAL_BILLBOARD\n  uniform mat4 view;\n#endif\n#if USE_STRETCHED_BILLBOARD\n  uniform vec3 eye;\n  uniform float velocityScale;\n  uniform float lengthScale;\n#endif\nvarying vec2 uv;\nvarying vec4 color;\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n#if USE_STRETCHED_BILLBOARD\n  vec4 velocity = vec4(a_color0.xyz,0);\n#endif\n#if USE_WORLD_SPACE\n  \n#else\n  pos = model * pos;\n  #if USE_STRETCHED_BILLBOARD\n  velocity = model * velocity;\n  #endif\n#endif\n  vec2 cornerOffset = vec2((a_uv.x - 0.5) * a_uv0.x, (a_uv.y - 0.5) * a_uv0.x);\n#if USE_STRETCHED_BILLBOARD\n  \n#else\n  \n  vec2 rotatedOffset;\n  rotatedOffset.x = cos(a_uv0.y) * cornerOffset.x - sin(a_uv0.y) * cornerOffset.y;\n  rotatedOffset.y = sin(a_uv0.y) * cornerOffset.x + cos(a_uv0.y) * cornerOffset.y;\n#endif\n#if USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += (camRight * rotatedOffset.x) + (camUp * rotatedOffset.y);\n#elif USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * a_uv0.x;\n  pos.xyz += (camRight * abs(cornerOffset.x) * sign(cornerOffset.y)) - camUp * a_uv.x;\n#elif USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += (camRight * rotatedOffset.x) + (camUp * rotatedOffset.y);\n#elif USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += (camRight * rotatedOffset.x) + (camUp * rotatedOffset.y);\n#else\n  pos.x += rotatedOffset.x;\n  pos.y += rotatedOffset.y;\n#endif\n  pos = viewProj * pos;\n  vec2 aniUV = vec2(0, floor(a_uv.z * frameTile.y));\n  aniUV.x = floor(a_uv.z * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n  aniUV.y = frameTile.y - aniUV.y - 1.0;\n  aniUV = (aniUV.xy + a_uv.xy) / vec2(frameTile.x, frameTile.y);\n  uv = aniUV * mainTiling + mainOffset;\n  color = a_color;\n  gl_Position = pos;\n}',
    frag: '\nuniform sampler2D mainTexture;\nvarying vec2 uv;\nvarying vec4 color;\nvoid main () {\n  \n  gl_FragColor = color * texture2D(mainTexture, uv) * color.a;\n}',
    defines: [
      { name: 'USE_SOFT_PARTICLE', },
      { name: 'USE_BILLBOARD', },
      { name: 'USE_STRETCHED_BILLBOARD', },
      { name: 'USE_HORIZONTAL_BILLBOARD', },
      { name: 'USE_VERTICAL_BILLBOARD', },
      { name: 'USE_WORLD_SPACE', } ],
  },
  {
    name: 'pbr',
    vert: '\nattribute vec3 a_position;\nattribute vec3 a_normal;\nvarying vec3 pos_w;\nvarying vec3 normal_w;\nuniform mat4 model;\nuniform mat4 viewProj;\nuniform mat3 normalMatrix;\n#if USE_NORMAL_TEXTURE || USE_ALBEDO_TEXTURE || USE_MRA_TEXTURE || USE_METALLIC_TEXTURE || USE_ROUGHNESS_TEXTURE || USE_AO_TEXTURE || USE_EMISSIVE_TEXTURE\n  attribute vec2 a_uv0;\n  uniform vec2 mainTiling;\n  uniform vec2 mainOffset;\n  varying vec2 uv0;\n#endif\n#if USE_SKINNING\n  \nattribute vec4 a_weights;\nattribute vec4 a_joints;\nuniform sampler2D u_jointsTexture;\nuniform float u_jointsTextureSize;\nmat4 getBoneMatrix(const in float i) {\n  float size = u_jointsTextureSize;\n  float j = i * 4.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  vec4 v1 = texture2D(u_jointsTexture, vec2(dx * (x + 0.5), y));\n  vec4 v2 = texture2D(u_jointsTexture, vec2(dx * (x + 1.5), y));\n  vec4 v3 = texture2D(u_jointsTexture, vec2(dx * (x + 2.5), y));\n  vec4 v4 = texture2D(u_jointsTexture, vec2(dx * (x + 3.5), y));\n  return mat4(v1, v2, v3, v4);\n}\nmat4 skinMatrix() {\n  return\n    getBoneMatrix(a_joints.x) * a_weights.x +\n    getBoneMatrix(a_joints.y) * a_weights.y +\n    getBoneMatrix(a_joints.z) * a_weights.z +\n    getBoneMatrix(a_joints.w) * a_weights.w\n    ;\n}\n#endif\n#if USE_SHADOW_MAP\n  #if NUM_SHADOW_LIGHTS > 0\n    #pragma for id in range(0, NUM_SHADOW_LIGHTS)\n      uniform mat4 lightViewProjMatrix_{id};\n      uniform float minDepth_{id};\n      uniform float maxDepth_{id};\n      varying vec4 pos_lightspace_{id};\n      varying float vDepth_{id};\n    #pragma endFor\n  #endif\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_SKINNING\n    mat4 skinMat = skinMatrix();\n    pos = skinMat * pos;\n  #endif\n  pos_w = (model * pos).xyz;\n  pos = viewProj * model * pos;\n  #if USE_NORMAL_TEXTURE || USE_ALBEDO_TEXTURE || USE_MRA_TEXTURE || USE_METALLIC_TEXTURE || USE_ROUGHNESS_TEXTURE || USE_AO_TEXTURE || USE_EMISSIVE_TEXTURE\n    uv0 = a_uv0 * mainTiling + mainOffset;\n  #endif\n  vec4 normal = vec4(a_normal, 0);\n  #if USE_SKINNING\n    normal = skinMat * normal;\n  #endif\n  normal_w = normalMatrix * normal.xyz;\n  #if USE_SHADOW_MAP\n    #if NUM_SHADOW_LIGHTS > 0\n      #pragma for id in range(0, NUM_SHADOW_LIGHTS)\n        pos_lightspace_{id} = lightViewProjMatrix_{id} * vec4(pos_w, 1.0);\n        vDepth_{id} = (pos_lightspace_{id}.z + minDepth_{id}) / (minDepth_{id} + maxDepth_{id});\n      #pragma endFor\n    #endif\n  #endif\n  gl_Position = pos;\n}',
    frag: '\n#if USE_NORMAL_TEXTURE\n#extension GL_OES_standard_derivatives : enable\n#endif\n#if USE_TEX_LOD\n#extension GL_EXT_shader_texture_lod: enable\n#endif\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define saturate(a) clamp( a, 0.0, 1.0 )\n\nvec3 gammaToLinearSpaceRGB(vec3 sRGB) { \n  return sRGB * (sRGB * (sRGB * 0.305306011 + 0.682171111) + 0.012522878);\n}\nvec3 linearToGammaSpaceRGB(vec3 RGB) { \n  vec3 S1 = sqrt(RGB);\n  vec3 S2 = sqrt(S1);\n  vec3 S3 = sqrt(S2);\n  return 0.585122381 * S1 + 0.783140355 * S2 - 0.368262736 * S3;\n}\nvec4 gammaToLinearSpaceRGBA(vec4 sRGBA) {\n  return vec4(gammaToLinearSpaceRGB(sRGBA.rgb), sRGBA.a);\n}\nvec4 linearToGammaSpaceRGBA(vec4 RGBA) {\n  return vec4(linearToGammaSpaceRGB(RGBA.rgb), RGBA.a);\n}\nfloat gammaToLinearSpaceExact(float val) {\n  if (val <= 0.04045) {\n    return val / 12.92;\n  } else if (val < 1.0) {\n    return pow((val + 0.055) / 1.055, 2.4);\n  } else {\n    return pow(val, 2.2);\n  }\n}\nfloat linearToGammaSpaceExact(float val) {\n  if (val <= 0.0) {\n    return 0.0;\n  } else if (val <= 0.0031308) {\n    return 12.92 * val;\n  } else if (val < 1.0) {\n    return 1.055 * pow(val, 0.4166667) - 0.055;\n  } else {\n    return pow(val, 0.45454545);\n  }\n}\n\nstruct LightInfo {\n  vec3 lightDir;\n  vec3 radiance;\n};\n#if NUM_DIR_LIGHTS > 0\n  #pragma for id in range(0, NUM_DIR_LIGHTS)\n    uniform vec3 dir_light{id}_direction;\n    uniform vec3 dir_light{id}_color;\n  #pragma endFor\n#endif\n#if NUM_POINT_LIGHTS > 0\n  #pragma for id in range(0, NUM_POINT_LIGHTS)\n    uniform vec3 point_light{id}_position;\n    uniform vec3 point_light{id}_color;\n    uniform float point_light{id}_range;\n  #pragma endFor\n#endif\n#if NUM_SPOT_LIGHTS > 0\n  #pragma for id in range(0, NUM_SPOT_LIGHTS)\n    uniform vec3 spot_light{id}_position;\n    uniform vec3 spot_light{id}_direction;\n    uniform vec3 spot_light{id}_color;\n    uniform vec2 spot_light{id}_spot;\n    uniform float spot_light{id}_range;\n  #pragma endFor\n#endif\nLightInfo computeDirectionalLighting(\n  vec3 lightDirection,\n  vec3 lightColor\n) {\n  LightInfo ret;\n  ret.lightDir = -normalize(lightDirection);\n  ret.radiance = lightColor;\n  return ret;\n}\nLightInfo computePointLighting(\n  vec3 lightPosition,\n  vec3 positionW,\n  vec3 lightColor,\n  float lightRange\n) {\n  LightInfo ret;\n  vec3 lightDir = lightPosition - positionW;\n  float attenuation = max(0.0, 1.0 - length(lightDir) / lightRange);\n  ret.lightDir = normalize(lightDir);\n  ret.radiance = lightColor * attenuation;\n  return ret;\n}\nLightInfo computeSpotLighting(\n  vec3 lightPosition,\n  vec3 positionW,\n  vec3 lightDirection,\n  vec3 lightColor,\n  vec2 lightSpot,\n  float lightRange\n) {\n  LightInfo ret;\n  vec3 lightDir = lightPosition - positionW;\n  float attenuation = max(0., 1.0 - length(lightDir) / lightRange);\n  float cosConeAngle = max(0., dot(lightDirection, -lightDir));\n  cosConeAngle = cosConeAngle < lightSpot.x ? 0.0 : cosConeAngle;\n  cosConeAngle = pow(cosConeAngle,lightSpot.y);\n  ret.lightDir = normalize(lightDir);\n  ret.radiance = lightColor * attenuation * cosConeAngle;\n  return ret;\n}\n\nvec3 unpackNormal(vec4 nmap) {\n  return nmap.xyz * 2.0 - 1.0;\n}\nvec3 unpackRGBE(vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\n#if USE_SHADOW_MAP\n  \nvec4 packDepthToRGBA(float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nfloat unpackRGBAToDepth(vec4 color) {\n  return dot(color, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n}\n  \n#if NUM_SHADOW_LIGHTS > 0\n  #pragma for id in range(0, NUM_SHADOW_LIGHTS)\n    uniform sampler2D shadowMap_{id};\n    uniform float darkness_{id};\n    uniform float depthScale_{id};\n    uniform float frustumEdgeFalloff_{id};\n    uniform float bias_{id};\n    uniform vec2 texelSize_{id};\n    varying vec4 pos_lightspace_{id};\n    varying float vDepth_{id};\n  #pragma endFor\n#endif\nfloat computeShadow(sampler2D shadowMap, vec4 pos_lightspace, float bias) {\n  vec3 projCoords = pos_lightspace.xyz / pos_lightspace.w;\n  projCoords = projCoords * 0.5 + 0.5;\n  float closestDepth = unpackRGBAToDepth(texture2D(shadowMap, projCoords.xy));\n  float currentDepth = projCoords.z;\n  float shadow = (currentDepth - bias > closestDepth) ? 0.0 : 1.0;\n  return shadow;\n}\nfloat computeFallOff(float esm, vec2 coords, float frustumEdgeFalloff) {\n  float mask = smoothstep(1.0 - frustumEdgeFalloff, 1.0, clamp(dot(coords, coords), 0.0, 1.0));\n  return mix(esm, 1.0, mask);\n}\nfloat computeShadowESM(sampler2D shadowMap, vec4 pos_lightspace, float vDepth, float depthScale, float darkness, float frustumEdgeFalloff) {\n  vec2 projCoords = pos_lightspace.xy / pos_lightspace.w;\n  vec2 shadowUV = projCoords * 0.5 + vec2(0.5);\n  if (shadowUV.x < 0.0 || shadowUV.x > 1.0 || shadowUV.y < 0.0 || shadowUV.y > 1.0) {\n    return 1.0;\n  }\n  float currentDepth = clamp(vDepth, 0.0, 1.0);\n  float closestDepth = unpackRGBAToDepth(texture2D(shadowMap, shadowUV));\n  \n  float esm = clamp(exp(-depthScale * (currentDepth - closestDepth)), 1.0 - darkness, 1.0);\n  return computeFallOff(esm, projCoords, frustumEdgeFalloff);\n}\nfloat computeShadowPCF(sampler2D shadowMap, vec4 pos_lightspace, float vDepth, float darkness, vec2 texelSize, float frustumEdgeFalloff) {\n  vec2 projCoords = pos_lightspace.xy / pos_lightspace.w;\n  vec2 shadowUV = projCoords * 0.5 + vec2(0.5);\n  if (shadowUV.x < 0.0 || shadowUV.x > 1.0 || shadowUV.y < 0.0 || shadowUV.y > 1.0) {\n    return 1.0;\n  }\n  float currentDepth = clamp(vDepth, 0.0, 1.0);\n  float visibility = 1.0;\n  vec2 poissonDisk[4];\n  poissonDisk[0] = vec2(-0.94201624, -0.39906216);\n  poissonDisk[1] = vec2(0.94558609, -0.76890725);\n  poissonDisk[2] = vec2(-0.094184101, -0.92938870);\n  poissonDisk[3] = vec2(0.34495938, 0.29387760);\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[0] * texelSize)) < currentDepth) visibility -= 0.25;\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[1] * texelSize)) < currentDepth) visibility -= 0.25;\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[2] * texelSize)) < currentDepth) visibility -= 0.25;\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[3] * texelSize)) < currentDepth) visibility -= 0.25;\n  return computeFallOff(min(1.0, visibility + 1.0 - darkness), projCoords, frustumEdgeFalloff);\n}\n#endif\nuniform vec3 eye;\nvarying vec3 pos_w;\nvarying vec3 normal_w;\n#if USE_NORMAL_TEXTURE || USE_ALBEDO_TEXTURE || USE_MRA_TEXTURE || USE_METALLIC_TEXTURE || USE_ROUGHNESS_TEXTURE || USE_AO_TEXTURE || USE_EMISSIVE_TEXTURE\n  varying vec2 uv0;\n#endif\n#if USE_IBL\n  uniform samplerCube diffuseEnvTexture;\n  uniform samplerCube specularEnvTexture;\n  uniform sampler2D brdfLUT;\n  #if USE_TEX_LOD\n    uniform float maxReflectionLod;\n  #endif\n#endif\nuniform vec4 albedo;\n#if USE_ALBEDO_TEXTURE\n  uniform sampler2D albedo_texture;\n#endif\n#if USE_MRA_TEXTURE\n  uniform vec2 sampler2D mra_texture;\n#endif\nuniform float metallic;\n#if USE_METALLIC_TEXTURE\n  uniform sampler2D metallic_texture;\n#endif\nuniform float roughness;\n#if USE_ROUGHNESS_TEXTURE\n  uniform sampler2D roughness_texture;\n#endif\nuniform float ao;\n#if USE_AO_TEXTURE\n  uniform sampler2D ao_texture;\n#endif\n#if USE_EMISSIVE\n  uniform vec3 emissive;\n  #if USE_EMISSIVE_TEXTURE\n    uniform sampler2D emissive_texture;\n  #endif\n#endif\n#if USE_ALPHA_TEST\n  uniform float alphaTestThreshold;\n#endif\n#if USE_NORMAL_TEXTURE\n  uniform sampler2D normal_texture;\n  \n  vec3 getNormalFromTexture() {\n    vec3 tangentNormal = texture2D(normal_texture, uv0).rgb * 2.0 - 1.0;\n    vec3 q1  = dFdx(pos_w);\n    vec3 q2  = dFdy(pos_w);\n    vec2 st1 = dFdx(uv0);\n    vec2 st2 = dFdy(uv0);\n    vec3 N   = normalize(normal_w);\n    vec3 T   = normalize(q1*st2.t - q2*st1.t);\n    vec3 B   = -normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n    return normalize(TBN * tangentNormal);\n  }\n#endif\nfloat distributionGGX(vec3 N, vec3 H, float roughness) {\n  float a = roughness * roughness;\n  float a2 = a * a;\n  float NdotH = max(dot(N, H), 0.0);\n  float NdotH2 = NdotH * NdotH;\n  float nom   = a2;\n  float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n  denom = PI * denom * denom;\n  return nom / denom;\n}\nfloat geometrySchlickGGX(float NdotV, float roughness) {\n  float r = (roughness + 1.0);\n  float k = (r * r) / 8.0;\n  float nom   = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n  return nom / denom;\n}\nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2 = geometrySchlickGGX(NdotV, roughness);\n  float ggx1 = geometrySchlickGGX(NdotL, roughness);\n  return ggx1 * ggx2;\n}\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n  float fresnel = exp2((-5.55473 * cosTheta - 6.98316) * cosTheta);\n  return F0 + (1.0 - F0) * fresnel;\n}\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  float fresnel = exp2((-5.55473 * cosTheta - 6.98316) * cosTheta);\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) * fresnel;\n}\nvec3 brdf(LightInfo lightInfo, vec3 N, vec3 V, vec3 F0, vec3 albedo, float metallic, float roughness) {\n  vec3 H = normalize(V + lightInfo.lightDir);\n  float NDF = distributionGGX(N, H, roughness);\n  float G   = geometrySmith(N, V, lightInfo.lightDir, roughness);\n  vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);\n  vec3 nominator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, lightInfo.lightDir), 0.0) + 0.001; \n  vec3 specular = nominator / denominator;\n  \n  vec3 kS = F;\n  \n  \n  \n  vec3 kD = vec3(1.0) - kS;\n  \n  \n  \n  kD *= 1.0 - metallic;\n  float NdotL = max(dot(N, lightInfo.lightDir), 0.0);\n  return (kD * albedo / PI + specular) * lightInfo.radiance * NdotL;\n}\nvoid main() {\n  float opacity = 1.0;\n  #if USE_ALBEDO_TEXTURE\n    vec4 baseColor = albedo * gammaToLinearSpaceRGBA(texture2D(albedo_texture, uv0));\n    vec3 albedo = baseColor.rgb;\n    opacity = baseColor.a;\n  #else\n    opacity = albedo.a;\n    vec3 albedo = albedo.rgb;\n  #endif\n  #if USE_ALPHA_TEST\n    if(opacity < alphaTestThreshold) discard;\n  #endif\n  #if USE_MRA_TEXTURE\n    vec3 metalRoughness = texture2D(mra_texture, uv0).rgb;\n    float metallic = metalRoughness.r;\n    float roughness = metalRoughness.g;\n    float ao = metalRoughness.b;\n  #else\n    #if USE_METALLIC_TEXTURE\n      float metallic  = texture2D(metallic_texture, uv0).r;\n    #endif\n    #if USE_ROUGHNESS_TEXTURE\n      float roughness  = texture2D(roughness_texture, uv0).r;\n    #endif\n    #if USE_AO_TEXTURE\n      float ao  = texture2D(ao_texture, uv0).r;\n    #endif\n  #endif\n  vec3 N = normalize(normal_w);\n  #if USE_NORMAL_TEXTURE\n    N = getNormalFromTexture();\n  #endif\n  vec3 V = normalize(eye - pos_w);\n  \n  \n  vec3 F0 = vec3(0.04);\n  F0 = mix(F0, albedo, metallic);\n  \n  vec3 Lo = vec3(0.0);\n  \n  #if NUM_POINT_LIGHTS > 0\n    #pragma for id in range(0, NUM_POINT_LIGHTS)\n      LightInfo pointLight{id};\n      pointLight{id} = computePointLighting(point_light{id}_position, pos_w, point_light{id}_color, point_light{id}_range);\n      Lo += brdf(pointLight{id}, N, V, F0, albedo, metallic, roughness);\n    #pragma endFor\n  #endif\n  #if NUM_DIR_LIGHTS > 0\n    #pragma for id in range(0, NUM_DIR_LIGHTS)\n      LightInfo directionalLight{id};\n      directionalLight{id} = computeDirectionalLighting(dir_light{id}_direction, dir_light{id}_color);\n      Lo += brdf(directionalLight{id}, N, V, F0, albedo, metallic, roughness);\n    #pragma endFor\n  #endif\n  #if NUM_SPOT_LIGHTS > 0\n    #pragma for id in range(0, NUM_SPOT_LIGHTS)\n      LightInfo spotLight{id};\n      spotLight{id} = computeSpotLighting(spot_light{id}_position, pos_w, spot_light{id}_direction, spot_light{id}_color, spot_light{id}_spot, spot_light{id}_range);\n      Lo += brdf(spotLight{id}, N, V, F0, albedo, metallic, roughness);\n    #pragma endFor\n  #endif\n  #if USE_EMISSIVE\n    vec3 emissiveColor = gammaToLinearSpaceRGB(emissive);\n    #if USE_EMISSIVE_TEXTURE\n      emissiveColor *= gammaToLinearSpaceRGB(texture2D(emissive_texture, uv0).rgb);\n    #endif\n    Lo += emissiveColor;\n  #endif\n  \n  vec3 ambient = vec3(0.03) * albedo * ao;\n  #if USE_IBL\n    \n    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\n    vec3 kS = F;\n    vec3 kD = vec3(1.0) - kS;\n    kD *= 1.0 - metallic;\n    #if USE_RGBE_HDR_IBL_DIFFUSE\n      vec3 diffuseEnv = unpackRGBE(textureCube(diffuseEnvTexture, N));\n    #else\n      vec3 diffuseEnv = textureCube(diffuseEnvTexture, N).rgb;\n    #endif\n    vec3 diffuse = diffuseEnv * albedo;\n    \n    vec3 R = reflect(-V, N);\n    #if USE_TEX_LOD\n      #if USE_RGBE_HDR_IBL_SPECULAR\n        vec3 specularEnv = unpackRGBE(textureCubeLodEXT(specularEnvTexture, R, roughness * maxReflectionLod));\n      #else\n        vec3 specularEnv = textureCubeLodEXT(specularEnvTexture, R, roughness * maxReflectionLod).rgb;\n      #endif\n    #else\n      #if USE_RGBE_HDR_IBL_SPECULAR\n        vec3 specularEnv = unpackRGBE(textureCube(specularEnvTexture, R));\n      #else\n        vec3 specularEnv = textureCube(specularEnvTexture, R).rgb;\n      #endif\n    #endif\n    vec2 brdf  = texture2D(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;\n    vec3 specular = specularEnv * (F * brdf.x + brdf.y);\n    ambient = (kD * diffuse + specular) * ao;\n  #endif\n  #if USE_SHADOW_MAP\n    float shadow = 1.0;\n    #if NUM_SHADOW_LIGHTS > 0\n      #pragma for id in range(0, NUM_SHADOW_LIGHTS)\n        shadow *= computeShadowESM(shadowMap_{id}, pos_lightspace_{id}, vDepth_{id}, depthScale_{id}, darkness_{id}, frustumEdgeFalloff_{id});\n      #pragma endFor\n    #endif\n    vec3 color = (ambient + Lo) * shadow;\n  #else\n    vec3 color = ambient + Lo;\n  #endif\n  \n  color = color / (color + vec3(1.0));\n  \n  vec4 finalColor = vec4(color, opacity);\n  gl_FragColor = linearToGammaSpaceRGBA(finalColor);\n}',
    defines: [
      { name: 'USE_NORMAL_TEXTURE', },
      { name: 'USE_ALBEDO_TEXTURE', },
      { name: 'USE_METALLIC_ROUGHNESS_TEXTURE', },
      { name: 'USE_METALLIC_TEXTURE', },
      { name: 'USE_ROUGHNESS_TEXTURE', },
      { name: 'USE_AO_TEXTURE', },
      { name: 'USE_EMISSIVE', },
      { name: 'USE_EMISSIVE_TEXTURE', },
      { name: 'USE_IBL', },
      { name: 'USE_TEX_LOD', },
      { name: 'USE_ALPHA_TEST', },
      { name: 'USE_SHADOW_MAP', },
      { name: 'USE_SKINNING', },
      { name: 'NUM_DIR_LIGHTS', min: 0, max: 4, },
      { name: 'NUM_POINT_LIGHTS', min: 0, max: 4, },
      { name: 'NUM_SPOT_LIGHTS', min: 0, max: 4, },
      { name: 'NUM_SHADOW_LIGHTS', min: 0, max: 4, } ],
  },
  {
    name: 'phong',
    vert: '\nattribute vec3 a_position;\nattribute vec3 a_normal;\nuniform mat4 model;\nuniform mat4 viewProj;\nuniform mat3 normalMatrix;\nvarying vec3 normal_w;\nvarying vec3 pos_w;\n#if USE_NORMAL_TEXTURE || USE_DIFFUSE_TEXTURE || USE_EMISSIVE_TEXTURE\n  attribute vec2 a_uv0;\n  uniform vec2 mainTiling;\n  uniform vec2 mainOffset;\n  varying vec2 uv0;\n#endif\n#if USE_SKINNING\n  \nattribute vec4 a_weights;\nattribute vec4 a_joints;\nuniform sampler2D u_jointsTexture;\nuniform float u_jointsTextureSize;\nmat4 getBoneMatrix(const in float i) {\n  float size = u_jointsTextureSize;\n  float j = i * 4.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  vec4 v1 = texture2D(u_jointsTexture, vec2(dx * (x + 0.5), y));\n  vec4 v2 = texture2D(u_jointsTexture, vec2(dx * (x + 1.5), y));\n  vec4 v3 = texture2D(u_jointsTexture, vec2(dx * (x + 2.5), y));\n  vec4 v4 = texture2D(u_jointsTexture, vec2(dx * (x + 3.5), y));\n  return mat4(v1, v2, v3, v4);\n}\nmat4 skinMatrix() {\n  return\n    getBoneMatrix(a_joints.x) * a_weights.x +\n    getBoneMatrix(a_joints.y) * a_weights.y +\n    getBoneMatrix(a_joints.z) * a_weights.z +\n    getBoneMatrix(a_joints.w) * a_weights.w\n    ;\n}\n#endif\n#if USE_SHADOW_MAP\n  #if NUM_SHADOW_LIGHTS > 0\n    #pragma for id in range(0, NUM_SHADOW_LIGHTS)\n      uniform mat4 lightViewProjMatrix_{id};\n      uniform float minDepth_{id};\n      uniform float maxDepth_{id};\n      varying vec4 pos_lightspace_{id};\n      varying float vDepth_{id};\n    #pragma endFor\n  #endif\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_SKINNING\n    mat4 skinMat = skinMatrix();\n    pos = skinMat * pos;\n  #endif\n  pos_w = (model * pos).xyz;\n  pos = viewProj * model * pos;\n  #if USE_NORMAL_TEXTURE || USE_DIFFUSE_TEXTURE || USE_EMISSIVE_TEXTURE\n    uv0 = a_uv0 * mainTiling + mainOffset;\n  #endif\n  vec4 normal = vec4(a_normal, 0);\n  #if USE_SKINNING\n    normal = skinMat * normal;\n  #endif\n  normal_w = normalMatrix * normal.xyz;\n  #if USE_SHADOW_MAP\n    #if NUM_SHADOW_LIGHTS > 0\n      #pragma for id in range(0, NUM_SHADOW_LIGHTS)\n        pos_lightspace_{id} = lightViewProjMatrix_{id} * vec4(pos_w, 1.0);\n        vDepth_{id} = (pos_lightspace_{id}.z + minDepth_{id}) / (minDepth_{id} + maxDepth_{id});\n      #pragma endFor\n    #endif\n  #endif\n  gl_Position = pos;\n}',
    frag: '\n#if USE_NORMAL_TEXTURE\n#extension GL_OES_standard_derivatives : enable\n#endif\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define saturate(a) clamp( a, 0.0, 1.0 )\n\nvec3 gammaToLinearSpaceRGB(vec3 sRGB) { \n  return sRGB * (sRGB * (sRGB * 0.305306011 + 0.682171111) + 0.012522878);\n}\nvec3 linearToGammaSpaceRGB(vec3 RGB) { \n  vec3 S1 = sqrt(RGB);\n  vec3 S2 = sqrt(S1);\n  vec3 S3 = sqrt(S2);\n  return 0.585122381 * S1 + 0.783140355 * S2 - 0.368262736 * S3;\n}\nvec4 gammaToLinearSpaceRGBA(vec4 sRGBA) {\n  return vec4(gammaToLinearSpaceRGB(sRGBA.rgb), sRGBA.a);\n}\nvec4 linearToGammaSpaceRGBA(vec4 RGBA) {\n  return vec4(linearToGammaSpaceRGB(RGBA.rgb), RGBA.a);\n}\nfloat gammaToLinearSpaceExact(float val) {\n  if (val <= 0.04045) {\n    return val / 12.92;\n  } else if (val < 1.0) {\n    return pow((val + 0.055) / 1.055, 2.4);\n  } else {\n    return pow(val, 2.2);\n  }\n}\nfloat linearToGammaSpaceExact(float val) {\n  if (val <= 0.0) {\n    return 0.0;\n  } else if (val <= 0.0031308) {\n    return 12.92 * val;\n  } else if (val < 1.0) {\n    return 1.055 * pow(val, 0.4166667) - 0.055;\n  } else {\n    return pow(val, 0.45454545);\n  }\n}\n\nstruct LightInfo {\n  vec3 diffuse;\n  vec3 specular;\n};\nLightInfo computeDirectionalLighting(\n  vec3 lightDirection,\n  vec3 lightColor,\n  vec3 normal,\n  vec3 viewDirection,\n  float glossiness\n) {\n  LightInfo lightingResult;\n  float ndl = 0.0;\n  float ndh = 0.0;\n  vec3 lightDir = -normalize(lightDirection);\n  ndl = max(0.0, dot(normal, lightDir));\n  lightingResult.diffuse = lightColor * ndl;\n  vec3 dirH = normalize(viewDirection + lightDir);\n  ndh = max(0.0, dot(normal, dirH));\n  ndh = (ndl == 0.0) ? 0.0: ndh;\n  ndh = pow(ndh, max(1.0, glossiness * 128.0));\n  lightingResult.specular = lightColor * ndh;\n  return lightingResult;\n}\nLightInfo computePointLighting(\n  vec3 lightPosition,\n  vec3 lightColor,\n  float lightRange,\n  vec3 normal,\n  vec3 positionW,\n  vec3 viewDirection,\n  float glossiness\n) {\n  LightInfo lightingResult;\n  float ndl = 0.0;\n  float ndh = 0.0;\n  vec3 lightDir = vec3(0, 0, 0);\n  float attenuation = 1.0;\n  lightDir = lightPosition - positionW;\n  attenuation = max(0., 1.0 - length(lightDir) / lightRange);\n  lightDir = normalize(lightDir);\n  ndl = max(0.0, dot(normal, lightDir));\n  lightingResult.diffuse = lightColor * ndl * attenuation;\n  vec3 dirH = normalize(viewDirection + lightDir);\n  ndh = max(0.0, dot(normal, dirH));\n  ndh = (ndl == 0.0) ? 0.0: ndh;\n  ndh = pow(ndh, max(1.0, glossiness * 128.0));\n  lightingResult.specular = lightColor * ndh * attenuation;\n  return lightingResult;\n}\nLightInfo computeSpotLighting(\n  vec3 lightPosition,\n  vec3 lightDirection,\n  vec3 lightColor,\n  float lightRange,\n  vec2 lightSpot,\n  vec3 normal,\n  vec3 positionW,\n  vec3 viewDirection,\n  float glossiness\n) {\n  LightInfo lightingResult;\n  float ndl = 0.0;\n  float ndh = 0.0;\n  vec3 lightDir = vec3(0, 0, 0);\n  float attenuation = 1.0;\n  float cosConeAngle = 1.0;\n  lightDir = lightPosition - positionW;\n  attenuation = max(0., 1.0 - length(lightDir) / lightRange);\n  lightDir = normalize(lightDir);\n  cosConeAngle = max(0., dot(lightDirection, -lightDir));\n  cosConeAngle = cosConeAngle < lightSpot.x ? 0.0 : cosConeAngle;\n  cosConeAngle = pow(cosConeAngle,lightSpot.y);\n  ndl = max(0.0, dot(normal, lightDir));\n  lightingResult.diffuse = lightColor * ndl * attenuation * cosConeAngle;\n  vec3 dirH = normalize(viewDirection + lightDir);\n  ndh = max(0.0, dot(normal, dirH));\n  ndh = (ndl == 0.0) ? 0.0: ndh;\n  ndh = pow(ndh, max(1.0, glossiness * 128.0));\n  lightingResult.specular = lightColor * ndh * attenuation * cosConeAngle;\n  return lightingResult;\n}\n#if NUM_DIR_LIGHTS > 0\n  #pragma for id in range(0, NUM_DIR_LIGHTS)\n    uniform vec3 dir_light{id}_direction;\n    uniform vec3 dir_light{id}_color;\n  #pragma endFor\n#endif\n#if NUM_POINT_LIGHTS > 0\n  #pragma for id in range(0, NUM_POINT_LIGHTS)\n    uniform vec3 point_light{id}_position;\n    uniform vec3 point_light{id}_color;\n    uniform float point_light{id}_range;\n  #pragma endFor\n#endif\n#if NUM_SPOT_LIGHTS > 0\n  #pragma for id in range(0, NUM_SPOT_LIGHTS)\n    uniform vec3 spot_light{id}_position;\n    uniform vec3 spot_light{id}_direction;\n    uniform vec3 spot_light{id}_color;\n    uniform float spot_light{id}_range;\n    uniform vec2 spot_light{id}_spot;\n  #pragma endFor\n#endif\nLightInfo getPhongLighting(\n  vec3 normal,\n  vec3 positionW,\n  vec3 viewDirection,\n  float glossiness\n) {\n  LightInfo result;\n  result.diffuse = vec3(0, 0, 0);\n  result.specular = vec3(0, 0, 0);\n  LightInfo dirLighting;\n  #if NUM_DIR_LIGHTS > 0\n    #pragma for id in range(0, NUM_DIR_LIGHTS)\n      dirLighting = computeDirectionalLighting(dir_light{id}_direction,dir_light{id}_color,normal, viewDirection, glossiness);\n      result.diffuse += dirLighting.diffuse;\n      result.specular += dirLighting.specular;\n    #pragma endFor\n  #endif\n  LightInfo pointLighting;\n  #if NUM_POINT_LIGHTS > 0\n    #pragma for id in range(0, NUM_POINT_LIGHTS)\n      pointLighting = computePointLighting(point_light{id}_position, point_light{id}_color, point_light{id}_range,\n                                          normal, positionW, viewDirection, glossiness);\n      result.diffuse += pointLighting.diffuse;\n      result.specular += pointLighting.specular;\n    #pragma endFor\n  #endif\n  LightInfo spotLighting;\n  #if NUM_SPOT_LIGHTS > 0\n    #pragma for id in range(0, NUM_SPOT_LIGHTS)\n      spotLighting = computeSpotLighting(spot_light{id}_position, spot_light{id}_direction, spot_light{id}_color,\n                      spot_light{id}_range, spot_light{id}_spot,normal, positionW, viewDirection, glossiness);\n      result.diffuse += spotLighting.diffuse;\n      result.specular += spotLighting.specular;\n    #pragma endFor\n  #endif\n  return result;\n}\n\n#if USE_SHADOW_MAP\n  \nvec4 packDepthToRGBA(float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nfloat unpackRGBAToDepth(vec4 color) {\n  return dot(color, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n}\n  \n#if NUM_SHADOW_LIGHTS > 0\n  #pragma for id in range(0, NUM_SHADOW_LIGHTS)\n    uniform sampler2D shadowMap_{id};\n    uniform float darkness_{id};\n    uniform float depthScale_{id};\n    uniform float frustumEdgeFalloff_{id};\n    uniform float bias_{id};\n    uniform vec2 texelSize_{id};\n    varying vec4 pos_lightspace_{id};\n    varying float vDepth_{id};\n  #pragma endFor\n#endif\nfloat computeShadow(sampler2D shadowMap, vec4 pos_lightspace, float bias) {\n  vec3 projCoords = pos_lightspace.xyz / pos_lightspace.w;\n  projCoords = projCoords * 0.5 + 0.5;\n  float closestDepth = unpackRGBAToDepth(texture2D(shadowMap, projCoords.xy));\n  float currentDepth = projCoords.z;\n  float shadow = (currentDepth - bias > closestDepth) ? 0.0 : 1.0;\n  return shadow;\n}\nfloat computeFallOff(float esm, vec2 coords, float frustumEdgeFalloff) {\n  float mask = smoothstep(1.0 - frustumEdgeFalloff, 1.0, clamp(dot(coords, coords), 0.0, 1.0));\n  return mix(esm, 1.0, mask);\n}\nfloat computeShadowESM(sampler2D shadowMap, vec4 pos_lightspace, float vDepth, float depthScale, float darkness, float frustumEdgeFalloff) {\n  vec2 projCoords = pos_lightspace.xy / pos_lightspace.w;\n  vec2 shadowUV = projCoords * 0.5 + vec2(0.5);\n  if (shadowUV.x < 0.0 || shadowUV.x > 1.0 || shadowUV.y < 0.0 || shadowUV.y > 1.0) {\n    return 1.0;\n  }\n  float currentDepth = clamp(vDepth, 0.0, 1.0);\n  float closestDepth = unpackRGBAToDepth(texture2D(shadowMap, shadowUV));\n  \n  float esm = clamp(exp(-depthScale * (currentDepth - closestDepth)), 1.0 - darkness, 1.0);\n  return computeFallOff(esm, projCoords, frustumEdgeFalloff);\n}\nfloat computeShadowPCF(sampler2D shadowMap, vec4 pos_lightspace, float vDepth, float darkness, vec2 texelSize, float frustumEdgeFalloff) {\n  vec2 projCoords = pos_lightspace.xy / pos_lightspace.w;\n  vec2 shadowUV = projCoords * 0.5 + vec2(0.5);\n  if (shadowUV.x < 0.0 || shadowUV.x > 1.0 || shadowUV.y < 0.0 || shadowUV.y > 1.0) {\n    return 1.0;\n  }\n  float currentDepth = clamp(vDepth, 0.0, 1.0);\n  float visibility = 1.0;\n  vec2 poissonDisk[4];\n  poissonDisk[0] = vec2(-0.94201624, -0.39906216);\n  poissonDisk[1] = vec2(0.94558609, -0.76890725);\n  poissonDisk[2] = vec2(-0.094184101, -0.92938870);\n  poissonDisk[3] = vec2(0.34495938, 0.29387760);\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[0] * texelSize)) < currentDepth) visibility -= 0.25;\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[1] * texelSize)) < currentDepth) visibility -= 0.25;\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[2] * texelSize)) < currentDepth) visibility -= 0.25;\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[3] * texelSize)) < currentDepth) visibility -= 0.25;\n  return computeFallOff(min(1.0, visibility + 1.0 - darkness), projCoords, frustumEdgeFalloff);\n}\n#endif\nuniform vec3 eye;\nuniform vec3 sceneAmbient;\nvarying vec3 normal_w;\nvarying vec3 pos_w;\n#if USE_NORMAL_TEXTURE || USE_DIFFUSE_TEXTURE || USE_EMISSIVE_TEXTURE\n  varying vec2 uv0;\n#endif\nstruct phongMaterial\n{\n  vec3 diffuse;\n  vec3 emissive;\n  vec3 specular;\n  float glossiness;\n  float opacity;\n};\nuniform vec4 diffuseColor;\n#if USE_DIFFUSE_TEXTURE\n  uniform sampler2D diffuse_texture;\n#endif\n#if USE_EMISSIVE\n  uniform vec3 emissiveColor;\n  #if USE_EMISSIVE_TEXTURE\n    uniform sampler2D emissive_texture;\n  #endif\n#endif\n#if USE_SPECULAR\n  uniform vec3 specularColor;\n  uniform float glossiness;\n  #if USE_SPECULAR_TEXTURE\n    uniform sampler2D specular_texture;\n  #endif\n#endif\n#if USE_NORMAL_TEXTURE\n  uniform sampler2D normal_texture;\n  uniform float normalScale;  \n  vec3 getNormal(vec3 pos, vec3 normal) {\n    vec3 q0 = vec3( dFdx( pos.x ), dFdx( pos.y ), dFdx( pos.z ) );\n    vec3 q1 = vec3( dFdy( pos.x ), dFdy( pos.y ), dFdy( pos.z ) );\n    vec2 st0 = dFdx( uv0.st );\n    vec2 st1 = dFdy( uv0.st );\n    vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n    vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n    vec3 N = normal;\n    vec3 mapN = texture2D(normal_texture, uv0).rgb * 2.0 - 1.0;\n    mapN.xy = 1.0 * mapN.xy;\n    mat3 tsn = mat3( S, T, N );\n    return normalize( tsn * mapN );\n  }\n#endif\n#if USE_ALPHA_TEST\n  uniform float alphaTestThreshold;\n#endif\nphongMaterial getPhongMaterial() {\n  phongMaterial result;\n  #if USE_DIFFUSE_TEXTURE\n    vec4 baseColor = diffuseColor * gammaToLinearSpaceRGBA(texture2D(diffuse_texture, uv0));\n    result.diffuse = baseColor.rgb;\n    result.opacity = baseColor.a;\n  #else\n    result.diffuse = diffuseColor.rgb;\n    result.opacity = diffuseColor.a;\n  #endif\n  #if USE_EMISSIVE\n    result.emissive = gammaToLinearSpaceRGB(emissiveColor);\n    #if USE_EMISSIVE_TEXTURE\n      result.emissive *= gammaToLinearSpaceRGB(texture2D(emissive_texture, uv0).rgb);\n    #endif\n  #endif\n  #if USE_SPECULAR\n    result.specular = gammaToLinearSpaceRGB(specularColor);\n    #if USE_SPECULAR_TEXTURE\n      result.specular = gammaToLinearSpaceRGB(texture2D(specular_texture, uv0).rgb);\n    #endif\n    result.glossiness = glossiness;\n  #endif\n  return result;\n}\nvec4 composePhongShading(LightInfo lighting, phongMaterial mtl, float shadow)\n{\n  vec4 o = vec4(0.0, 0.0, 0.0, 1.0);\n  \n  o.xyz = lighting.diffuse * mtl.diffuse;\n  #if USE_EMISSIVE\n    o.xyz += mtl.emissive;\n  #endif\n  #if USE_SPECULAR\n    o.xyz += lighting.specular * mtl.specular;\n  #endif\n  o.xyz *= shadow;\n  o.w = mtl.opacity;\n  return o;\n}\nvoid main () {\n  LightInfo phongLighting;\n  vec3 viewDirection = normalize(eye - pos_w);\n  phongMaterial mtl = getPhongMaterial();\n  #if USE_ALPHA_TEST\n    if(mtl.opacity < alphaTestThreshold) discard;\n  #endif\n  vec3 normal = normalize(normal_w);\n  #if USE_NORMAL_TEXTURE\n    normal = getNormal(pos_w, normal);\n  #endif\n  phongLighting = getPhongLighting(normal, pos_w, viewDirection, mtl.glossiness);\n  phongLighting.diffuse += sceneAmbient;\n  #if USE_SHADOW_MAP\n    float shadow = 1.0;\n    #if NUM_SHADOW_LIGHTS > 0\n      #pragma for id in range(0, NUM_SHADOW_LIGHTS)\n        shadow *= computeShadowESM(shadowMap_{id}, pos_lightspace_{id}, vDepth_{id}, depthScale_{id}, darkness_{id}, frustumEdgeFalloff_{id});\n      #pragma endFor\n    #endif\n    vec4 finalColor = composePhongShading(phongLighting, mtl, shadow);\n  #else\n    vec4 finalColor = composePhongShading(phongLighting, mtl, 1.0);\n  #endif\n  gl_FragColor = linearToGammaSpaceRGBA(finalColor);\n}',
    defines: [
      { name: 'USE_NORMAL_TEXTURE', },
      { name: 'USE_DIFFUSE_TEXTURE', },
      { name: 'USE_SPECULAR', },
      { name: 'USE_SPECULAR_TEXTURE', },
      { name: 'USE_EMISSIVE', },
      { name: 'USE_EMISSIVE_TEXTURE', },
      { name: 'USE_ALPHA_TEST', },
      { name: 'USE_SKINNING', },
      { name: 'USE_SHADOW_MAP', },
      { name: 'NUM_DIR_LIGHTS', min: 0, max: 4, },
      { name: 'NUM_POINT_LIGHTS', min: 0, max: 4, },
      { name: 'NUM_SPOT_LIGHTS', min: 0, max: 4, },
      { name: 'NUM_SHADOW_LIGHTS', min: 0, max: 4, } ],
  },
  {
    name: 'shadow-depth',
    vert: '\nattribute vec3 a_position;\nuniform mat4 model;\nuniform mat4 lightViewProjMatrix;\nuniform float minDepth;\nuniform float maxDepth;\nuniform float bias;\nvarying float vDepth;\n#if USE_SKINNING\n  \nattribute vec4 a_weights;\nattribute vec4 a_joints;\nuniform sampler2D u_jointsTexture;\nuniform float u_jointsTextureSize;\nmat4 getBoneMatrix(const in float i) {\n  float size = u_jointsTextureSize;\n  float j = i * 4.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  vec4 v1 = texture2D(u_jointsTexture, vec2(dx * (x + 0.5), y));\n  vec4 v2 = texture2D(u_jointsTexture, vec2(dx * (x + 1.5), y));\n  vec4 v3 = texture2D(u_jointsTexture, vec2(dx * (x + 2.5), y));\n  vec4 v4 = texture2D(u_jointsTexture, vec2(dx * (x + 3.5), y));\n  return mat4(v1, v2, v3, v4);\n}\nmat4 skinMatrix() {\n  return\n    getBoneMatrix(a_joints.x) * a_weights.x +\n    getBoneMatrix(a_joints.y) * a_weights.y +\n    getBoneMatrix(a_joints.z) * a_weights.z +\n    getBoneMatrix(a_joints.w) * a_weights.w\n    ;\n}\n#endif\nvoid main() {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_SKINNING\n    mat4 skinMat = skinMatrix();\n    pos = skinMat * pos;\n  #endif\n  gl_Position = lightViewProjMatrix * model * pos;\n  \n  vDepth = ((gl_Position.z + minDepth) / (minDepth + maxDepth)) + bias;\n}',
    frag: '\nuniform float depthScale;\nvarying float vDepth;\n\nvec4 packDepthToRGBA(float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nfloat unpackRGBAToDepth(vec4 color) {\n  return dot(color, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n}\nvoid main() {\n  \n  \n  gl_FragColor = packDepthToRGBA(vDepth);\n  \n  \n}',
    defines: [
      { name: 'USE_SKINNING', } ],
  },
  {
    name: 'simple',
    vert: '\nattribute vec3 a_position;\nuniform mat4 model;\nuniform mat4 viewProj;\n#if USE_TEXTURE\n  attribute vec2 a_uv0;\n  varying vec2 uv0;\n#endif\nvoid main () {\n  vec4 pos = viewProj * model * vec4(a_position, 1);\n  #if USE_TEXTURE\n    uv0 = a_uv0;\n  #endif\n  gl_Position = pos;\n}',
    frag: '\n#if USE_TEXTURE\n  uniform sampler2D texture;\n  varying vec2 uv0;\n#endif\n#if USE_COLOR\n  uniform vec4 color;\n#endif\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture2D(texture, uv0);\n  #endif\n  #if USE_COLOR\n    o *= color;\n  #endif\n  if (!gl_FrontFacing) {\n    o.rgb *= 0.5;\n  }\n  gl_FragColor = o;\n}',
    defines: [
      { name: 'USE_TEXTURE', },
      { name: 'USE_COLOR', } ],
  },
  {
    name: 'skybox',
    vert: '\nattribute vec3 a_position;\nuniform mat4 view;\nuniform mat4 proj;\nvarying vec3 viewDir;\nvoid main() {\n  mat4 rotView = mat4(mat3(view));\n  vec4 clipPos = proj * rotView * vec4(a_position, 1.0);\n  gl_Position = clipPos.xyww;\n  viewDir = a_position;\n}\n',
    frag: '\nvarying vec3 viewDir;\nuniform samplerCube cubeMap;\n\nvec3 gammaToLinearSpaceRGB(vec3 sRGB) { \n  return sRGB * (sRGB * (sRGB * 0.305306011 + 0.682171111) + 0.012522878);\n}\nvec3 linearToGammaSpaceRGB(vec3 RGB) { \n  vec3 S1 = sqrt(RGB);\n  vec3 S2 = sqrt(S1);\n  vec3 S3 = sqrt(S2);\n  return 0.585122381 * S1 + 0.783140355 * S2 - 0.368262736 * S3;\n}\nvec4 gammaToLinearSpaceRGBA(vec4 sRGBA) {\n  return vec4(gammaToLinearSpaceRGB(sRGBA.rgb), sRGBA.a);\n}\nvec4 linearToGammaSpaceRGBA(vec4 RGBA) {\n  return vec4(linearToGammaSpaceRGB(RGBA.rgb), RGBA.a);\n}\nfloat gammaToLinearSpaceExact(float val) {\n  if (val <= 0.04045) {\n    return val / 12.92;\n  } else if (val < 1.0) {\n    return pow((val + 0.055) / 1.055, 2.4);\n  } else {\n    return pow(val, 2.2);\n  }\n}\nfloat linearToGammaSpaceExact(float val) {\n  if (val <= 0.0) {\n    return 0.0;\n  } else if (val <= 0.0031308) {\n    return 12.92 * val;\n  } else if (val < 1.0) {\n    return 1.055 * pow(val, 0.4166667) - 0.055;\n  } else {\n    return pow(val, 0.45454545);\n  }\n}\n\nvec3 unpackNormal(vec4 nmap) {\n  return nmap.xyz * 2.0 - 1.0;\n}\nvec3 unpackRGBE(vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvoid main() {\n#if USE_RGBE_HDR\n    vec3 c = unpackRGBE(textureCube(cubeMap, viewDir));\n    c = linearToGammaSpaceRGB(c / (1.0 + c));\n    gl_FragColor = vec4(c, 1.0);\n#else\n    gl_FragColor = textureCube(cubeMap, viewDir);\n#endif\n}',
    defines: [],
  },
  {
    name: 'sprite',
    vert: '\nattribute vec3 a_position;\nuniform mat4 model;\nuniform mat4 viewProj;\nattribute vec2 a_uv0;\nattribute vec4 a_color;\nvarying vec2 uv0;\nvarying vec4 color;\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  pos = viewProj * model * pos;\n  uv0 = a_uv0;\n  color = a_color;\n  gl_Position = pos;\n}',
    frag: '\nuniform sampler2D mainTexture;\nvarying vec2 uv0;\nvarying vec4 color;\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  o *= texture2D(mainTexture, uv0);\n  o *= color;\n  gl_FragColor = o;\n}',
    defines: [],
  },
  {
    name: 'unlit',
    vert: '\nattribute vec3 a_position;\nuniform mat4 model;\nuniform mat4 viewProj;\n#if USE_TEXTURE\n  attribute vec2 a_uv0;\n  uniform vec2 mainTiling;\n  uniform vec2 mainOffset;\n  varying vec2 uv0;\n#endif\n#if USE_SKINNING\n  \nattribute vec4 a_weights;\nattribute vec4 a_joints;\nuniform sampler2D u_jointsTexture;\nuniform float u_jointsTextureSize;\nmat4 getBoneMatrix(const in float i) {\n  float size = u_jointsTextureSize;\n  float j = i * 4.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  vec4 v1 = texture2D(u_jointsTexture, vec2(dx * (x + 0.5), y));\n  vec4 v2 = texture2D(u_jointsTexture, vec2(dx * (x + 1.5), y));\n  vec4 v3 = texture2D(u_jointsTexture, vec2(dx * (x + 2.5), y));\n  vec4 v4 = texture2D(u_jointsTexture, vec2(dx * (x + 3.5), y));\n  return mat4(v1, v2, v3, v4);\n}\nmat4 skinMatrix() {\n  return\n    getBoneMatrix(a_joints.x) * a_weights.x +\n    getBoneMatrix(a_joints.y) * a_weights.y +\n    getBoneMatrix(a_joints.z) * a_weights.z +\n    getBoneMatrix(a_joints.w) * a_weights.w\n    ;\n}\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_SKINNING\n    pos = skinMatrix() * pos;\n  #endif\n  pos = viewProj * model * pos;\n  #if USE_TEXTURE\n    uv0 = a_uv0 * mainTiling + mainOffset;\n  #endif\n  gl_Position = pos;\n}',
    frag: '\n#if USE_TEXTURE\n  uniform sampler2D mainTexture;\n  varying vec2 uv0;\n#endif\n#if USE_COLOR\n  uniform vec4 color;\n#endif\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, uv0);\n  #endif\n  #if USE_COLOR\n    o *= color;\n  #endif\n  gl_FragColor = o;\n}',
    defines: [
      { name: 'USE_TEXTURE', },
      { name: 'USE_COLOR', },
      { name: 'USE_SKINNING', } ],
  },
  {
    name: 'wireframe',
    vert: '\nattribute vec3 a_position;\nattribute vec3 a_normal;\nuniform mat4 model, viewProj;\nuniform mat3 normalMatrix;\nvarying vec3 position_w;\nvarying vec3 normal_w;\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  position_w = (model * pos).xyz;\n  pos = viewProj * model * pos;\n  normal_w = normalMatrix * a_normal.xyz;\n  gl_Position = pos;\n}',
    frag: '\nuniform vec3 eye;\nuniform vec3 color;\nvarying vec3 position_w;\nvarying vec3 normal_w;\nvoid main () {\n  gl_FragColor = vec4(color, 1.0);\n  vec3 e2p = normalize(eye - position_w);\n  if (dot (normal_w, e2p) <= 0.0) {\n    gl_FragColor.rgb *= 0.6;\n  }\n}',
    defines: [],
  } ];

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

var _shdID = 0;

function _generateDefines(device, defs, deps) {
  var defines = [];
  for (var def in defs) {
    if (deps[def] === undefined) { // if define has no dependency
      if (defs[def] === true) {
        defines.push(("#define " + def + " 1"));
      } else if (defs[def] === false) {
        defines.push(("#define " + def + " 0"));
      }
    } else { // define has dependency, need to check if dependency is supported by current device
      if (device.ext(deps[def]) && defs[def] === true) {
        defines.push(("#define " + def + " 1"));
      } else {
        defines.push(("#define " + def + " 0"));
      }
    }
  }
  return defines.join('\n');
}

function _replaceMacroNums(string, defs) {
  var cache = {};
  var tmp = string;
  for (var def in defs) {
    if (Number.isInteger(defs[def])) {
      cache[def] = defs[def];
    }
  }
  for (var def$1 in cache) {
    var reg = new RegExp(def$1, 'g');
    tmp = tmp.replace(reg, cache[def$1]);
  }
  return tmp;
}

function _unrollLoops(string) {
  var pattern = /#pragma for (\w+) in range\(\s*(\d+)\s*,\s*(\d+)\s*\)([\s\S]+?)#pragma endFor/g;
  function replace(match, index, begin, end, snippet) {
    var unroll = '';
    var parsedBegin = parseInt(begin);
    var parsedEnd = parseInt(end);
    if (parsedBegin.isNaN || parsedEnd.isNaN) {
      console.error('Unroll For Loops Error: begin and end of range must be an int num.');
    }
    for (var i = parsedBegin; i < parsedEnd; ++i) {
      unroll += snippet.replace(new RegExp(("{" + index + "}"), 'g'), i);
    }
    return unroll;
  }
  return string.replace(pattern, replace);
}

var ProgramLib = function ProgramLib(device, templates, chunks) {
  var this$1 = this;
  if ( templates === void 0 ) templates = [];
  if ( chunks === void 0 ) chunks = {};

  this._device = device;
  this._precision = "precision highp float;\n";

  // register templates
  this._templates = {};
  for (var i = 0; i < templates.length; ++i) {
    var tmpl = templates[i];
    this$1.define(tmpl.name, tmpl.vert, tmpl.frag, tmpl.defines);
  }

  // register chunks
  this._chunks = {};
  Object.assign(this._chunks, chunks);

  this._cache = {};
};

/**
 * @param {string} name
 * @param {string} vert
 * @param {string} frag
 * @param {Object[]} defines
 *
 * @example:
 * programLib.define('foobar', vertTmpl, fragTmpl, [
 *   { name: 'shadow' },
 *   { name: 'lightCount', min: 1, max: 4 }
 * ]);
 */
ProgramLib.prototype.define = function define (name, vert, frag, defines) {
  if (this._templates[name]) {
    console.warn(("Failed to define shader " + name + ": already exists."));
    return;
  }

  var id = ++_shdID;

  // calculate option mask offset
  var offset = 0;
  for (var i = 0; i < defines.length; ++i) {
    var def = defines[i];
    var cnt = 1;

    if (def.min !== undefined && def.max !== undefined) {
      cnt = Math.ceil((def.max - def.min) * 0.5);

      def._map = function (value) {
        return (value - this.min) << this._offset;
      }.bind(def);
    } else {
      def._map = function (value) {
        if (value) {
          return 1 << this._offset;
        }
        return 0;
      }.bind(def);
    }

    offset += cnt;
    def._offset = offset;
  }

  vert = this._precision + vert;
  frag = this._precision + frag;

  // store it
  this._templates[name] = {
    id: id,
    name: name,
    vert: vert,
    frag: frag,
    defines: defines
  };
};

/**
 * Does this library has the specified program?
 * @param {string} name
 * @returns {boolean}
 */
ProgramLib.prototype.hasProgram = function hasProgram (name) {
  return this._templates[name] !== undefined;
};

/**
 * @param {string} name
 * @param {Object} defines
 */
ProgramLib.prototype.getKey = function getKey (name, defines) {
  var tmpl = this._templates[name];
  var key = 0;
  for (var i = 0; i < tmpl.defines.length; ++i) {
    var tmplDefs = tmpl.defines[i];
    var value = defines[tmplDefs.name];
    if (value === undefined) {
      continue;
    }

    key |= tmplDefs._map(value);
  }

  return key << 8 | tmpl.id;
};

/**
 * @param {string} name
 * @param {Object} defines
 * @param {Object} dependencies
 */
ProgramLib.prototype.getProgram = function getProgram (name, defines, dependencies) {
  var key = this.getKey(name, defines);
  var program = this._cache[key];
  if (program) {
    return program;
  }

  // get template
  var tmpl = this._templates[name];
  var customDef = _generateDefines(this._device, defines, dependencies) + '\n';
  var vert = _replaceMacroNums(tmpl.vert, defines);
  vert = customDef + _unrollLoops(vert);
  var frag = _replaceMacroNums(tmpl.frag, defines);
  frag = customDef + _unrollLoops(frag);

  program = new gfx.Program(this._device, {
    vert: vert,
    frag: frag
  });
  program.link();
  this._cache[key] = program;

  return program;
};

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

var _m3_tmp$1 = mat3.create();
var _m4_tmp$2 = mat4.create();
var _v3_tmp = vec3.zero();
var _v3_tmp2 = vec3.zero();
var _qt_tmp = quat.create();

var _stageInfos = new RecyclePool(function () {
  return {
    stage: null,
    items: null,
  };
}, 8);

var _float2_pool = new RecyclePool(function () {
  return new Float32Array(2);
}, 8);

var _float3_pool = new RecyclePool(function () {
  return new Float32Array(3);
}, 8);

var _float4_pool = new RecyclePool(function () {
  return new Float32Array(4);
}, 8);

var _float9_pool = new RecyclePool(function () {
  return new Float32Array(9);
}, 8);

var _float16_pool = new RecyclePool(function () {
  return new Float32Array(16);
}, 8);

var _float64_pool = new RecyclePool(function () {
  return new Float32Array(64);
}, 8);

var _int2_pool = new RecyclePool(function () {
  return new Int32Array(2);
}, 8);

var _int3_pool = new RecyclePool(function () {
  return new Int32Array(3);
}, 8);

var _int4_pool = new RecyclePool(function () {
  return new Int32Array(4);
}, 8);

var _int64_pool = new RecyclePool(function () {
  return new Int32Array(64);
}, 8);

var _type2uniformValue = {};
_type2uniformValue[enums$1.PARAM_INT] = function (value) {
    return value;
  };
_type2uniformValue[enums$1.PARAM_INT2] = function (value) {
    return vec2.array(_int2_pool.add(), value);
  };
_type2uniformValue[enums$1.PARAM_INT3] = function (value) {
    return vec3.array(_int3_pool.add(), value);
  };
_type2uniformValue[enums$1.PARAM_INT4] = function (value) {
    return vec4.array(_int4_pool.add(), value);
  };
_type2uniformValue[enums$1.PARAM_FLOAT] = function (value) {
    return value;
  };
_type2uniformValue[enums$1.PARAM_FLOAT2] = function (value) {
    return vec2.array(_float2_pool.add(), value);
  };
_type2uniformValue[enums$1.PARAM_FLOAT3] = function (value) {
    return vec3.array(_float3_pool.add(), value);
  };
_type2uniformValue[enums$1.PARAM_FLOAT4] = function (value) {
    return vec4.array(_float4_pool.add(), value);
  };
_type2uniformValue[enums$1.PARAM_COLOR3] = function (value) {
    return color3.array(_float3_pool.add(), value);
  };
_type2uniformValue[enums$1.PARAM_COLOR4] = function (value) {
    return color4.array(_float4_pool.add(), value);
  };
_type2uniformValue[enums$1.PARAM_MAT2] = function (value) {
    return mat2.array(_float4_pool.add(), value);
  };
_type2uniformValue[enums$1.PARAM_MAT3] = function (value) {
    return mat3.array(_float9_pool.add(), value);
  };
_type2uniformValue[enums$1.PARAM_MAT4] = function (value) {
    return mat4.array(_float16_pool.add(), value);
  };

var _type2uniformArrayValue = {};
_type2uniformArrayValue[enums$1.PARAM_INT] = {
    func: function func (values) {
      var result = _int64_pool.add();
      for (var i = 0; i < values.length; ++i) {
        result[i] = values[i];
      }
      return result;
    },
    size: 1,
  };
_type2uniformArrayValue[enums$1.PARAM_INT2] = {
    func: function func (values) {
      var result = _int64_pool.add();
      for (var i = 0; i < values.length; ++i) {
        result[2 * i] = values[i].x;
        result[2 * i + 1] = values[i].y;
      }
      return result;
    },
    size: 2,
  };
_type2uniformArrayValue[enums$1.PARAM_INT3] = {
    func: undefined,
    size: 3,
  };
_type2uniformArrayValue[enums$1.PARAM_INT4] = {
    func: function func (values) {
      var result = _int64_pool.add();
      for (var i = 0; i < values.length; ++i) {
        var v = values[i];
        result[4 * i] = v.x;
        result[4 * i + 1] = v.y;
        result[4 * i + 2] = v.z;
        result[4 * i + 3] = v.w;
      }
      return result;
    },
    size: 4,
  };
_type2uniformArrayValue[enums$1.PARAM_FLOAT] = {
    func: function func (values) {
      var result = _float64_pool.add();
      for (var i = 0; i < values.length; ++i) {
        result[i] = values[i];
      }
      return result;
    },
    size: 1
  };
_type2uniformArrayValue[enums$1.PARAM_FLOAT2] = {
    func: function func (values) {
      var result = _float64_pool.add();
      for (var i = 0; i < values.length; ++i) {
        result[2 * i] = values[i].x;
        result[2 * i + 1] = values[i].y;
      }
      return result;
    },
    size: 2,
  };
_type2uniformArrayValue[enums$1.PARAM_FLOAT3] = {
    func: undefined,
    size: 3,
  };
_type2uniformArrayValue[enums$1.PARAM_FLOAT4] = {
    func: function func (values) {
      var result = _float64_pool.add();
      for (var i = 0; i < values.length; ++i) {
        var v = values[i];
        result[4 * i] = v.x;
        result[4 * i + 1] = v.y;
        result[4 * i + 2] = v.z;
        result[4 * i + 3] = v.w;
      }
      return result;
    },
    size: 4,
  };
_type2uniformArrayValue[enums$1.PARAM_COLOR3] = {
    func: undefined,
    size: 3,
  };
_type2uniformArrayValue[enums$1.PARAM_COLOR4] = {
    func: function func (values) {
      var result = _float64_pool.add();
      for (var i = 0; i < values.length; ++i) {
        var v = values[i];
        result[4 * i] = v.r;
        result[4 * i + 1] = v.g;
        result[4 * i + 2] = v.b;
        result[4 * i + 3] = v.a;
      }
      return result;
    },
    size: 4,
  };
_type2uniformArrayValue[enums$1.PARAM_MAT2] = {
    func: function func (values) {
      var result = _float64_pool.add();
      for (var i = 0; i < values.length; ++i) {
        var v = values[i];
        result[4 * i] = v.m00;
        result[4 * i + 1] = v.m01;
        result[4 * i + 2] = v.m02;
        result[4 * i + 3] = v.m03;
      }
      return result;
    },
    size: 4
  };
_type2uniformArrayValue[enums$1.PARAM_MAT3] = {
    func: undefined,
    size: 9
  };
_type2uniformArrayValue[enums$1.PARAM_MAT4] = {
    func: function func (values) {
      var result = _float64_pool.add();
      for (var i = 0; i < values.length; ++i) {
        var v = values[i];
        result[16 * i] = v.m00;
        result[16 * i + 1] = v.m01;
        result[16 * i + 2] = v.m02;
        result[16 * i + 3] = v.m03;
        result[16 * i + 4] = v.m04;
        result[16 * i + 5] = v.m05;
        result[16 * i + 6] = v.m06;
        result[16 * i + 7] = v.m07;
        result[16 * i + 8] = v.m08;
        result[16 * i + 9] = v.m09;
        result[16 * i + 10] = v.m10;
        result[16 * i + 11] = v.m11;
        result[16 * i + 12] = v.m12;
        result[16 * i + 13] = v.m13;
        result[16 * i + 14] = v.m14;
        result[16 * i + 15] = v.m15;
      }
      return result;
    },
    size: 16
  };

var BaseRenderer = function BaseRenderer(device, opts) {
  var obj;

  this._device = device;
  this._programLib = new ProgramLib(device, shaderTemplates, shaderChunks);
  this._opts = opts;
  this._type2defaultValue = ( obj = {}, obj[enums$1.PARAM_INT] = 0, obj[enums$1.PARAM_INT2] = vec2.new(0, 0), obj[enums$1.PARAM_INT3] = vec3.new(0, 0, 0), obj[enums$1.PARAM_INT4] = vec4.new(0, 0, 0, 0), obj[enums$1.PARAM_FLOAT] = 0.0, obj[enums$1.PARAM_FLOAT2] = vec2.new(0, 0), obj[enums$1.PARAM_FLOAT3] = vec3.new(0, 0, 0), obj[enums$1.PARAM_FLOAT4] = vec4.new(0, 0, 0, 0), obj[enums$1.PARAM_COLOR3] = color3.new(0, 0, 0), obj[enums$1.PARAM_COLOR4] = color4.new(0, 0, 0, 1), obj[enums$1.PARAM_MAT2] = mat2.create(), obj[enums$1.PARAM_MAT3] = mat3.create(), obj[enums$1.PARAM_MAT4] = mat4.create(), obj[enums$1.PARAM_TEXTURE_2D] = opts.defaultTexture, obj[enums$1.PARAM_TEXTURE_CUBE] = opts.defaultTextureCube, obj);
  this._stage2fn = {};
  this._modelType2fn = {};
  this._usedTextureUnits = 0;
  this.frustum_test_func = intersect.box_frustum;
  this._accurateFrustumCulling = false;

  this._viewPools = new RecyclePool(function () {
    return new View();
  }, 8);

  this._drawItemsPools = new RecyclePool(function () {
    return {
      model: null,
      node: null,
      ia: null,
      effect: null,
      defines: null,
      dependencies: null,
    };
  }, 100);

  this._stageItemsPools = new RecyclePool(function () {
    return new RecyclePool(function () {
      return {
        model: null,
        node: null,
        ia: null,
        effect: null,
        defines: null,
        dependencies: null,
        technique: null,
        sortKey: -1,
      };
    }, 100);
  }, 16);
};

var prototypeAccessors$11 = { accurateFrustumCulling: { configurable: true } };

BaseRenderer.prototype._resetTextureUnit = function _resetTextureUnit () {
  this._usedTextureUnits = 0;
};

BaseRenderer.prototype._allocTextureUnit = function _allocTextureUnit () {
  var device = this._device;

  var unit = this._usedTextureUnits;
  if (unit >= device._caps.maxTextureUnits) {
    console.warn(("Trying to use " + unit + " texture units while this GPU supports only " + (device._caps.maxTextureUnits)));
  }

  this._usedTextureUnits += 1;
  return unit;
};

BaseRenderer.prototype._registerStage = function _registerStage (name, fn) {
  this._stage2fn[name] = fn;
};

BaseRenderer.prototype._registerModel = function _registerModel (name, fn) {
  this._modelType2fn[name] = fn;
};

BaseRenderer.prototype._reset = function _reset () {
  this._viewPools.reset();
  this._stageItemsPools.reset();
};

BaseRenderer.prototype._requestView = function _requestView () {
  var view = this._viewPools.add();
  view.fullUpdate = this._accurateFrustumCulling;
  return view;
};

prototypeAccessors$11.accurateFrustumCulling.set = function (accurate) {
  this._accurateFrustumCulling = accurate;
  if (!accurate) { this.frustum_test_func = intersect.box_frustum; }
  else { this.frustum_test_func = intersect.box_frustum_accurate; }
};

BaseRenderer.prototype._render = function _render (view, scene) {
    var this$1 = this;

  var device = this._device;

  // setup framebuffer
  device.setFrameBuffer(view._framebuffer);

  // setup viewport
  device.setViewport(
    view._rect.x,
    view._rect.y,
    view._rect.w,
    view._rect.h
  );

  // setup clear
  var clearOpts = {};
  if (view._clearFlags & enums$1.CLEAR_COLOR) {
    clearOpts.color = [
      view._color.r,
      view._color.g,
      view._color.b,
      view._color.a
    ];
  }
  if (view._clearFlags & enums$1.CLEAR_DEPTH) {
    clearOpts.depth = view._depth;
  }
  if (view._clearFlags & enums$1.CLEAR_STENCIL) {
    clearOpts.stencil = view._stencil;
  }
  device.clear(clearOpts);

  // get all draw items
  this._drawItemsPools.reset();

  if ((view._clearFlags & enums$1.CLEAR_SKYBOX) && view._clearModel != null) {
    var drawItem = this._drawItemsPools.add();
    view._clearModel.extractDrawItem(drawItem);
  }

  for (var i = 0; i < scene._models.length; ++i) {
    var model = scene._models.data[i];

    // TODO: HACK: filter model by view
    if (view._cullingByID) {
      if (model._viewID !== view._id) {
        continue;
      }
    } else {
      if (model._viewID !== -1) {
        continue;
      }
    }

    // frustum culling
    if (model._boundingBox !== null) { // if model does not have boundingBox, skip culling.
      model._node._getWorldPRS(_v3_tmp, _qt_tmp, _v3_tmp2);
      box.setTransform(model._boundingBox, _v3_tmp, _qt_tmp, _v3_tmp2, model._bbModelSpace);
      if (!this$1.frustum_test_func(model._boundingBox, view._frustum)) {
        // console.log('model is not in view frustum.');
        continue;
      }
    }

    var drawItem$1 = this$1._drawItemsPools.add();
    model.extractDrawItem(drawItem$1);
  }

  // dispatch draw items to different stage
  _stageInfos.reset();

  for (var i$1 = 0; i$1 < view._stages.length; ++i$1) {
    var stage = view._stages[i$1];
    var stageItems = this$1._stageItemsPools.add();
    stageItems.reset();

    for (var j = 0; j < this._drawItemsPools.length; ++j) {
      var drawItem$2 = this$1._drawItemsPools.data[j];
      var tech = drawItem$2.effect.getTechnique(stage);

      if (tech) {
        var stageItem = stageItems.add();
        stageItem.model = drawItem$2.model;
        stageItem.node = drawItem$2.node;
        stageItem.ia = drawItem$2.ia;
        stageItem.effect = drawItem$2.effect;
        stageItem.defines = drawItem$2.defines;
        stageItem.dependencies = drawItem$2.dependencies;
        stageItem.technique = tech;
        stageItem.sortKey = -1;
      }
    }

    var stageInfo = _stageInfos.add();
    stageInfo.stage = stage;
    stageInfo.items = stageItems;
  }

  // render stages
  for (var i$2 = 0; i$2 < _stageInfos.length; ++i$2) {
    var info = _stageInfos.data[i$2];
    var stageFn = this$1._stage2fn[info.stage];

    stageFn(view, info.items);
  }
};

BaseRenderer.prototype._drawModel = function _drawModel (item) {
  var model = item.model;
  var drawFn = this._modelType2fn[model._type];

  if (!drawFn) {
    // console.warn(`Can not find draw function for modle type ${model.type}`);
    return;
  }

  drawFn(item);
};

BaseRenderer.prototype._draw = function _draw (item) {
    var this$1 = this;

  var device = this._device;
  var programLib = this._programLib;
  var node = item.node;
    var ia = item.ia;
    var effect = item.effect;
    var technique = item.technique;
    var defines = item.defines;
    var dependencies = item.dependencies;

  // reset the pool
  // NOTE: we can use drawCounter optimize this
  // TODO: should be configurable
  _float2_pool.reset();
  _float3_pool.reset();
  _float4_pool.reset();
  _float9_pool.reset();
  _float16_pool.reset();
  _float64_pool.reset();
  _int2_pool.reset();
  _int3_pool.reset();
  _int4_pool.reset();
  _int64_pool.reset();

  // set common uniforms
  // TODO: try commit this depends on effect
  // {
  node.getWorldMatrix(_m4_tmp$2);
  device.setUniform('model', mat4.array(_float16_pool.add(), _m4_tmp$2));

  mat3.normalFromMat4(_m3_tmp$1, _m4_tmp$2);
  device.setUniform('normalMatrix', mat3.array(_float9_pool.add(), _m3_tmp$1));
  // }

  // set technique uniforms
  for (var i = 0; i < technique._parameters.length; ++i) {
    var param = technique._parameters[i];
    var prop = effect.getProperty(param.name);

    if (prop === undefined || prop === null) {
      prop = param.val;
    }

    if (prop === undefined || prop === null) {
      prop = this$1._type2defaultValue[param.type];
    }

    if (prop === undefined || prop === null) {
      console.warn(("Failed to set technique property " + (param.name) + ", value not found."));
      continue;
    }

    if (
      param.type === enums$1.PARAM_TEXTURE_2D ||
      param.type === enums$1.PARAM_TEXTURE_CUBE
    ) {
      if (defines['USE_'+param.name.toUpperCase()] == false) { continue; }
      if (param.size !== undefined) {
        if (param.size !== prop.length) {
          console.error(("The length of texture array (" + (prop.length) + ") is not corrent(expect " + (param.size) + ")."));
          continue;
        }
        var slots = _int64_pool.add();
        for (var index = 0; index < prop.length; ++index) {
          slots[index] = this$1._allocTextureUnit();
        }
        device.setTextureArray(param.name, prop, slots);
      } else {
        device.setTexture(param.name, prop, this$1._allocTextureUnit());
      }
    } else {
      var convertedValue = (void 0);
      if (param.size !== undefined) {
        var convertArray = _type2uniformArrayValue[param.type];
        if (convertArray.func === undefined) {
          console.error('Uniform array of color3/int3/float3/mat3 can not be supportted!');
          continue;
        }
        if (param.size * convertArray.size > 64) {
          console.error('Uniform array is too long!');
          continue;
        }
        convertedValue = convertArray.func(prop);
      } else {
        var convertFn = _type2uniformValue[param.type];
        convertedValue = convertFn(prop);
      }
      device.setUniform(param.name, convertedValue);
    }
  }

  // for each pass
  for (var i$1 = 0; i$1 < technique._passes.length; ++i$1) {
    var pass = technique._passes[i$1];
    var count = ia.count;

    // set vertex buffer
    device.setVertexBuffer(0, ia._vertexBuffer);

    // set index buffer
    if (ia._indexBuffer) {
      device.setIndexBuffer(ia._indexBuffer);
    }

    // set primitive type
    device.setPrimitiveType(ia._primitiveType);

    // set program
    var program = programLib.getProgram(pass._programName, defines, dependencies);
    device.setProgram(program);

    // cull mode
    device.setCullMode(pass._cullMode);

    // blend
    if (pass._blend) {
      device.enableBlend();
      device.setBlendFuncSep(
        pass._blendSrc,
        pass._blendDst,
        pass._blendSrcAlpha,
        pass._blendDstAlpha
      );
      device.setBlendEqSep(
        pass._blendEq,
        pass._blendAlphaEq
      );
      device.setBlendColor32(pass._blendColor);
    }

    // depth test & write
    if (pass._depthTest) {
      device.enableDepthTest();
      device.setDepthFunc(pass._depthFunc);
    }
    if (pass._depthWrite) {
      device.enableDepthWrite();
    }

    // stencil
    if (pass._stencilTest) {
      device.enableStencilTest();

      // front
      device.setStencilFuncFront(
        pass._stencilFuncFront,
        pass._stencilRefFront,
        pass._stencilMaskFront
      );
      device.setStencilOpFront(
        pass._stencilFailOpFront,
        pass._stencilZFailOpFront,
        pass._stencilZPassOpFront,
        pass._stencilWriteMaskFront
      );

      // back
      device.setStencilFuncBack(
        pass._stencilFuncBack,
        pass._stencilRefBack,
        pass._stencilMaskBack
      );
      device.setStencilOpBack(
        pass._stencilFailOpBack,
        pass._stencilZFailOpBack,
        pass._stencilZPassOpBack,
        pass._stencilWriteMaskBack
      );
    }

    // draw pass
    device.draw(ia._start, count);

    this$1._resetTextureUnit();
  }
};

Object.defineProperties( BaseRenderer.prototype, prototypeAccessors$11 );

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

function _defineProperty(target, name, internalName, arrayFn) {
  target[internalName] = new arrayFn(target._data);
  Object.defineProperty(target, name, {
    get: function get() {
      return this[internalName];
    },
  });
}

var ArrayBufferHelper = function ArrayBufferHelper(size, viewTypes) {
  var this$1 = this;

  this._data = new ArrayBuffer(size);

  for (var i = 0; i < viewTypes.length; ++i) {
    var type = viewTypes[i];

    if (type === enums$1.BUFFER_VIEW_INT8) {
      _defineProperty(this$1, 'int8View', '_int8View', Int8Array);
    } else if (type === enums$1.BUFFER_VIEW_UINT8) {
      _defineProperty(this$1, 'uint8View', '_uint8View', Uint8Array);
    } else if (type === enums$1.BUFFER_VIEW_INT16) {
      _defineProperty(this$1, 'int16View', '_int16View', Int16Array);
    } else if (type === enums$1.BUFFER_VIEW_UINT16) {
      _defineProperty(this$1, 'uint16View', '_uint16View', Uint16Array);
    } else if (type === enums$1.BUFFER_VIEW_INT32) {
      _defineProperty(this$1, 'int32View', '_int32View', Int32Array);
    } else if (type === enums$1.BUFFER_VIEW_UINT32) {
      _defineProperty(this$1, 'uint32View', '_uint32View', Uint32Array);
    } else if (type === enums$1.BUFFER_VIEW_FLOAT32) {
      _defineProperty(this$1, 'float32View', '_float32View', Float32Array);
    }
  }
};

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

var _DEFAULT_MAX_BATCH_BYTES = 512000; // 500 kb
var _MIN_BATCH_BYTES = 64;

var _minLog = bits.log2(_MIN_BATCH_BYTES);

var BufferPool = function BufferPool(maxBytes, viewTypes) {
  var this$1 = this;
  if ( maxBytes === void 0 ) maxBytes = _DEFAULT_MAX_BATCH_BYTES;
  if ( viewTypes === void 0 ) viewTypes = [enums$1.BUFFER_VIEW_FLOAT32];

  this._buffers = [];
  this._maxBytes = bits.nextPow2(maxBytes);
  this._maxLog = bits.log2(this._maxBytes);

  for (var i = _minLog; i <= this._maxLog; ++i) {
    this$1._buffers.push(new ArrayBufferHelper(1 << i, viewTypes));
  }
};

var prototypeAccessors$12 = { maxBytes: { configurable: true } };

prototypeAccessors$12.maxBytes.get = function () {
  return this._maxBytes;
};

BufferPool.prototype.request = function request (size) {
  var np2 = bits.nextPow2(size);
  var curLog = bits.log2(np2);
  if (curLog > this._maxLog) {
    return this._buffers[this._maxLog - _minLog];
  } else if (curLog < _minLog) {
    return this._buffers[0];
  } else {
    return this._buffers[curLog - _minLog];
  }
};

Object.defineProperties( BufferPool.prototype, prototypeAccessors$12 );

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

var _attr2bufviewType = {};
_attr2bufviewType[gfx.ATTR_TYPE_INT8] = enums$1.BUFFER_VIEW_INT8;
_attr2bufviewType[gfx.ATTR_TYPE_UINT8] = enums$1.BUFFER_VIEW_UINT8;
_attr2bufviewType[gfx.ATTR_TYPE_INT16] = enums$1.BUFFER_VIEW_INT16;
_attr2bufviewType[gfx.ATTR_TYPE_UINT16] = enums$1.BUFFER_VIEW_UINT16;
_attr2bufviewType[gfx.ATTR_TYPE_INT32] = enums$1.BUFFER_VIEW_INT32;
_attr2bufviewType[gfx.ATTR_TYPE_UINT32] = enums$1.BUFFER_VIEW_UINT32;
_attr2bufviewType[gfx.ATTR_TYPE_FLOAT32] = enums$1.BUFFER_VIEW_FLOAT32;

var DynamicIAPool = function DynamicIAPool(device, maxBuffers, pt, vfmt, maxVerts, ifmt, maxIndices) {
  var this$1 = this;
  if ( ifmt === void 0 ) ifmt = gfx.INDEX_FMT_UINT16;
  if ( maxIndices === void 0 ) maxIndices = -1;

  // create vdata pool
  var vbufviewTypes = [];
  for (var i = 0; i < vfmt._elements.length; ++i) {
    var attrType = vfmt._elements[i].type;
    var bufviewType = _attr2bufviewType[attrType];
    if (vbufviewTypes.indexOf(bufviewType) === -1) {
      vbufviewTypes.push(bufviewType);
    }
  }
  this._bytesPerVeretx = vfmt._bytes;
  this._vdataPool = new BufferPool(this._bytesPerVeretx * maxVerts, vbufviewTypes);

  // create idata pool
  if (maxIndices !== -1) {
    var ibufviewType = -1;

    if (ifmt === gfx.INDEX_FMT_UINT8) {
      ibufviewType = enums$1.BUFFER_VIEW_UINT8;
      this._bytesPerIndex = 1;
    } else if (ifmt === gfx.INDEX_FMT_UINT16) {
      ibufviewType = enums$1.BUFFER_VIEW_UINT16;
      this._bytesPerIndex = 2;
    } else if (ifmt === gfx.INDEX_FMT_UINT32) {
      ibufviewType = enums$1.BUFFER_VIEW_UINT32;
      this._bytesPerIndex = 4;
    }

    this._idataPool = new BufferPool(
      this._bytesPerIndex * maxIndices,
      [ibufviewType]
    );
  }

  this._maxVerts = maxVerts;
  this._maxIndices = maxIndices;

  this._IAs = new CircularPool(function () {
    return new InputAssembler(
      new gfx.VertexBuffer(
        device,
        vfmt,
        gfx.USAGE_DYNAMIC,
        null,
        Math.ceil(this$1._vdataPool.maxBytes / this$1._bytesPerVeretx)
      ),
      maxIndices === -1 ? null : new gfx.IndexBuffer(
        device,
        ifmt,
        gfx.USAGE_DYNAMIC,
        null,
        Math.ceil(this$1._idataPool.maxBytes / this$1._bytesPerIndex)
      ),
      pt
    );
  }, maxBuffers);
};

var prototypeAccessors$13 = { maxVerts: { configurable: true },maxIndices: { configurable: true } };

prototypeAccessors$13.maxVerts.get = function () {
  return this._maxVerts;
};

prototypeAccessors$13.maxIndices.get = function () {
  return this._maxIndices;
};

DynamicIAPool.prototype.requestIA = function requestIA () {
  return this._IAs.request();
};

DynamicIAPool.prototype.requestVData = function requestVData (count) {
  return this._vdataPool.request(count * this._bytesPerVeretx);
};

DynamicIAPool.prototype.requestIData = function requestIData (count) {
  return this._idataPool.request(count * this._bytesPerIndex);
};

Object.defineProperties( DynamicIAPool.prototype, prototypeAccessors$13 );

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

var _camPos = vec3.zero();
var _camFwd = vec3.zero();
var _v3_tmp1 = vec3.zero();

var _a16_view = new Float32Array(16);
var _a16_proj = new Float32Array(16);
var _a16_viewProj = new Float32Array(16);
var _a16_lightViewProj = new Float32Array(16);
var _a3_camPos = new Float32Array(3);

var ForwardRenderer = (function (BaseRenderer$$1) {
  function ForwardRenderer(device, builtin) {
    BaseRenderer$$1.call(this, device, builtin);
    this._directionalLights = [];
    this._pointLights = [];
    this._spotLights = [];
    this._shadowLights = [];
    this._sceneAmbient = new Float32Array([0.5, 0.5, 0.5]);

    this._registerStage('shadowcast', this._shadowStage.bind(this));
    this._registerStage('opaque', this._opaqueStage.bind(this));
    this._registerStage('transparent', this._transparentStage.bind(this));
    this._registerStage('ui', this._uiStage.bind(this));

    this._registerModel('default', this._draw.bind(this));
    this._registerModel('line-batch', this._drawLineBatch.bind(this));
    this._registerModel('sprite-batch', this._drawSpriteBatch.bind(this));
    this._registerModel('particle-batch', this._drawParticleBatch.bind(this));
    this._registerModel('skinning', this._drawSkinning.bind(this));

    // this._blur = new GaussianBlur(device, this._programLib);

    // lineIAs
    this._lineIAs = new DynamicIAPool(
      device, 2,
      gfx.PT_LINES,
      new gfx.VertexFormat([
        { name: gfx.ATTR_POSITION, type: gfx.ATTR_TYPE_FLOAT32, num: 3 },
        { name: gfx.ATTR_COLOR, type: gfx.ATTR_TYPE_FLOAT32, num: 3 }
      ]),
      2000
    );

    // spriteIAs
    this._spriteIAs = new DynamicIAPool(
      device, 2,
      gfx.PT_TRIANGLES,
      new gfx.VertexFormat([
        { name: gfx.ATTR_POSITION, type: gfx.ATTR_TYPE_FLOAT32, num: 3 },
        { name: gfx.ATTR_UV0, type: gfx.ATTR_TYPE_FLOAT32, num: 2 },
        { name: gfx.ATTR_COLOR, type: gfx.ATTR_TYPE_FLOAT32, num: 4 }
      ]),
      2000,
      gfx.INDEX_FMT_UINT16,
      2000
    );
  }

  if ( BaseRenderer$$1 ) ForwardRenderer.__proto__ = BaseRenderer$$1;
  ForwardRenderer.prototype = Object.create( BaseRenderer$$1 && BaseRenderer$$1.prototype );
  ForwardRenderer.prototype.constructor = ForwardRenderer;

  ForwardRenderer.prototype.updateLights = function updateLights (scene) {
    var this$1 = this;

    this._directionalLights.length = 0;
    this._pointLights.length = 0;
    this._spotLights.length = 0;
    this._shadowLights.length = 0;
    var lights = scene._lights;
    for (var i = 0; i < lights.length; ++i) {
      var light = lights.data[i];
      light.update(this$1._device);
      if (light.shadowType !== enums$1.SHADOW_NONE) {
        this$1._shadowLights.push(light);
        var view = this$1._requestView();
        light.extractView(view, ['shadowcast']);
      }
      if (light._type === enums$1.LIGHT_DIRECTIONAL) {
        this$1._directionalLights.push(light);
      } else if (light._type === enums$1.LIGHT_POINT) {
        this$1._pointLights.push(light);
      } else {
        this$1._spotLights.push(light);
      }
    }
  };

  ForwardRenderer.prototype.render = function render (scene) {
    var this$1 = this;

    this._reset();

    // extract views from cameras, lights and so on
    var canvas = this._device._gl.canvas;

    // update lights, extract shadow view.
    this.updateLights(scene);

    if (scene._debugCamera) {
      var view = this._requestView();
      scene._debugCamera.extractView(view, canvas.width, canvas.height);
    } else {
      for (var i = 0; i < scene._cameras.length; ++i) {
        var view$1 = this$1._requestView();
        scene._cameras.data[i].extractView(view$1, canvas.width, canvas.height);
      }
    }

    // render by cameras
    this._viewPools.sort(function (a, b) {
      return (a._priority - b._priority);
    });
    scene._views.sort(function (a, b) {
      return (a._priority - b._priority);
    });
    for (var i$1 = 0; i$1 < this._viewPools.length; ++i$1) {
      var view$2 = this$1._viewPools.data[i$1];
      this$1._render(view$2, scene);
    }

    // render by views (ui)
    for (var i$2 = 0; i$2 < scene._views.length; ++i$2) {
      var view$3 = scene._views[i$2];
      this$1._render(view$3, scene);
    }
  };

  ForwardRenderer.prototype._submitLightUniforms = function _submitLightUniforms () {
    var this$1 = this;

    this._device.setUniform('sceneAmbient', this._sceneAmbient);

    if (this._directionalLights.length > 0) {
      for (var index = 0; index < this._directionalLights.length; ++index) {
        var light = this$1._directionalLights[index];
        this$1._device.setUniform(("dir_light" + index + "_direction"), light._directionUniform);
        this$1._device.setUniform(("dir_light" + index + "_color"), light._colorUniform);
      }
    }
    if (this._pointLights.length > 0) {
      for (var index$1 = 0; index$1 < this._pointLights.length; ++index$1) {
        var light$1 = this$1._pointLights[index$1];
        this$1._device.setUniform(("point_light" + index$1 + "_position"), light$1._positionUniform);
        this$1._device.setUniform(("point_light" + index$1 + "_color"), light$1._colorUniform);
        this$1._device.setUniform(("point_light" + index$1 + "_range"), light$1._range);
      }
    }

    if (this._spotLights.length > 0) {
      for (var index$2 = 0; index$2 < this._spotLights.length; ++index$2) {
        var light$2 = this$1._spotLights[index$2];
        this$1._device.setUniform(("spot_light" + index$2 + "_position"), light$2._positionUniform);
        this$1._device.setUniform(("spot_light" + index$2 + "_direction"), light$2._directionUniform);
        this$1._device.setUniform(("spot_light" + index$2 + "_color"), light$2._colorUniform);
        this$1._device.setUniform(("spot_light" + index$2 + "_range"), light$2._range);
        this$1._device.setUniform(("spot_light" + index$2 + "_spot"), light$2._spotUniform);
      }
    }
  };

  ForwardRenderer.prototype._submitShadowStageUniforms = function _submitShadowStageUniforms (view) {
    var light = view._shadowLight;
    this._device.setUniform('minDepth', light.shadowMinDepth);
    this._device.setUniform('maxDepth', light.shadowMaxDepth);
    this._device.setUniform('bias', light.shadowBias);
    this._device.setUniform('depthScale', light.shadowDepthScale);
  };

  ForwardRenderer.prototype._submitOtherStagesUniforms = function _submitOtherStagesUniforms () {
    var this$1 = this;

    for (var index = 0; index < this._shadowLights.length; ++index) {
      var light = this$1._shadowLights[index];
      this$1._device.setUniform(("lightViewProjMatrix_" + index), mat4.array(_a16_lightViewProj, light.viewProjMatrix));
      this$1._device.setUniform(("minDepth_" + index), light.shadowMinDepth);
      this$1._device.setUniform(("maxDepth_" + index), light.shadowMaxDepth);
      this$1._device.setUniform(("bias_" + index), light.shadowBias);
      this$1._device.setUniform(("depthScale_" + index), light.shadowDepthScale);
      this$1._device.setUniform(("darkness_" + index), light.shadowDarkness);
      this$1._device.setUniform(("frustumEdgeFalloff_" + index), light.frustumEdgeFalloff);
      this$1._device.setUniform(("texelSize_" + index), new Float32Array([1.0 / light.shadowResolution, 1.0 / light.shadowResolution]));
    }
  };

  ForwardRenderer.prototype._updateShaderDefines = function _updateShaderDefines (items) {
    var this$1 = this;

    for (var i = 0; i < items.length; ++i) {
      var item = items.data[i];
      var defines = item.defines;

      defines.NUM_DIR_LIGHTS = Math.min(4, this$1._directionalLights.length);
      defines.NUM_POINT_LIGHTS = Math.min(4, this$1._pointLights.length);
      defines.NUM_SPOT_LIGHTS = Math.min(4, this$1._spotLights.length);

      defines.NUM_SHADOW_LIGHTS = Math.min(4, this$1._shadowLights.length);
    }
  };

  ForwardRenderer.prototype._uiStage = function _uiStage (view, items) {
    var this$1 = this;

    // update uniforms
    this._device.setUniform('view', mat4.array(_a16_view, view._matView));
    this._device.setUniform('proj', mat4.array(_a16_proj, view._matProj));
    this._device.setUniform('viewProj', mat4.array(_a16_viewProj, view._matViewProj));

    // sort items
    items.sort(function (a, b) {
      return a.model._userKey - b.model._userKey;
    });

    // draw it
    for (var i = 0; i < items.length; ++i) {
      var item = items.data[i];
      this$1._drawModel(item);
    }
  };

  ForwardRenderer.prototype._shadowStage = function _shadowStage (view, items) {
    var this$1 = this;

    var programLib = this._programLib;
    this._device.setUniform('lightViewProjMatrix', mat4.array(_a16_viewProj, view._matViewProj));

    // update rendering
    this._submitLightUniforms();
    this._submitShadowStageUniforms(view);
    this._updateShaderDefines(items);

    // calculate sorting key
    for (var i = 0; i < items.length; ++i) {
      var item = items.data[i];
      item.sortKey = programLib.getKey(
        item.technique._passes[0]._programName,
        item.defines
      );
    }

    // sort items
    items.sort(function (a, b) {
      var techA = a.technique;
      var techB = b.technique;

      if (techA._layer !== techB._layer) {
        return techA._layer - techB._layer;
      }

      if (techA._passes.length !== techB._passes.length) {
        return techA._passes.length - techB._passes.length;
      }

      return a.sortKey - b.sortKey;
    });

    // draw it
    for (var i$1 = 0; i$1 < items.length; ++i$1) {
      var item$1 = items.data[i$1];
      if (item$1.model._castShadow) {
        this$1._drawModel(item$1);
      }
    }

  };

  ForwardRenderer.prototype._opaqueStage = function _opaqueStage (view, items) {
    var this$1 = this;

    var programLib = this._programLib;
    view.getPosition(_camPos);

    // update uniforms
    this._device.setUniform('view', mat4.array(_a16_view, view._matView));
    this._device.setUniform('proj', mat4.array(_a16_proj, view._matProj));
    this._device.setUniform('viewProj', mat4.array(_a16_viewProj, view._matViewProj));
    this._device.setUniform('eye', vec3.array(_a3_camPos, _camPos));

    // update rendering
    this._submitLightUniforms();
    this._submitOtherStagesUniforms();
    this._updateShaderDefines(items);

    // calculate sorting key
    for (var i = 0; i < items.length; ++i) {
      var item = items.data[i];
      item.sortKey = programLib.getKey(
        item.technique._passes[0]._programName,
        item.defines
      );
    }

    // sort items
    items.sort(function (a, b) {
      var techA = a.technique;
      var techB = b.technique;

      if (techA._layer !== techB._layer) {
        return techA._layer - techB._layer;
      }

      if (techA._passes.length !== techB._passes.length) {
        return techA._passes.length - techB._passes.length;
      }

      return a.sortKey - b.sortKey;
    });

    // draw it
    for (var i$1 = 0; i$1 < items.length; ++i$1) {
      var item$1 = items.data[i$1];

      for (var index = 0; index < this._shadowLights.length; ++index) {
        var light = this$1._shadowLights[index];
        this$1._device.setTexture(("shadowMap_" + index), light.shadowMap, this$1._allocTextureUnit());
      }

      this$1._drawModel(item$1);
    }
  };

  ForwardRenderer.prototype._transparentStage = function _transparentStage (view, items) {
    var this$1 = this;

    view.getPosition(_camPos);
    view.getForward(_camFwd);

    // update uniforms
    this._device.setUniform('view', mat4.array(_a16_view, view._matView));
    this._device.setUniform('proj', mat4.array(_a16_proj, view._matProj));
    this._device.setUniform('viewProj', mat4.array(_a16_viewProj, view._matViewProj));
    this._device.setUniform('eye', vec3.array(_a3_camPos, _camPos));

    // calculate zdist
    for (var i = 0; i < items.length; ++i) {
      var item = items.data[i];

      // TODO: we should use mesh center instead!
      item.node.getWorldPos(_v3_tmp1);

      vec3.sub(_v3_tmp1, _v3_tmp1, _camPos);
      item.sortKey = vec3.dot(_v3_tmp1, _camFwd);
    }

    // update rendering
    this._submitLightUniforms();
    this._submitOtherStagesUniforms();
    this._updateShaderDefines(items);

    // sort items
    items.sort(function (a, b) {
      if (a.technique._layer !== b.technique._layer) {
        return a.technique._layer - b.technique._layer;
      }

      return b.sortKey - a.sortKey;
    });

    // draw it
    for (var i$1 = 0; i$1 < items.length; ++i$1) {
      var item$1 = items.data[i$1];

      for (var index = 0; index < this._shadowLights.length; ++index) {
        var light = this$1._shadowLights[index];
        this$1._device.setTexture(("shadowMap_" + index), light.shadowMap, this$1._allocTextureUnit());
      }

      this$1._drawModel(item$1);
    }
  };

  ForwardRenderer.prototype._drawSkinning = function _drawSkinning (item) {
    var model = item.model;
    var defines = item.defines;

    defines.USE_SKINNING = true;
    this._device.setTexture('u_jointsTexture', model._jointsTexture, this._allocTextureUnit());
    this._device.setUniform('u_jointsTextureSize', model._jointsTexture._width);

    this._draw(item);
  };

  ForwardRenderer.prototype._drawLineBatch = function _drawLineBatch (item) {
    var this$1 = this;

    var model = item.model;
    var curVertCount = 0;
    var vdata = this._lineIAs.requestVData(model.vertCount);
    var vdataF32 = vdata.float32View;

    for (var i = model.lineCount - 1; i >= 0; --i) {
      var line = model.getLine(i);

      // flush when verts exceeds
      if (curVertCount + 2 >= this$1._lineIAs.maxVerts) {
        var ia = this$1._lineIAs.requestIA();
        ia._vertexBuffer.update(0, vdataF32);
        ia._start = 0;
        ia._count = curVertCount;

        item.ia = ia;
        this$1._draw(item);
        curVertCount = 0;
      }

      //
      var idx = curVertCount * 6;
      vdataF32[idx] = line.start.x;
      vdataF32[idx + 1] = line.start.y;
      vdataF32[idx + 2] = line.start.z;
      vdataF32[idx + 3] = line.color.r;
      vdataF32[idx + 4] = line.color.g;
      vdataF32[idx + 5] = line.color.b;

      vdataF32[idx + 6] = line.end.x;
      vdataF32[idx + 7] = line.end.y;
      vdataF32[idx + 8] = line.end.z;
      vdataF32[idx + 9] = line.color.r;
      vdataF32[idx + 10] = line.color.g;
      vdataF32[idx + 11] = line.color.b;

      curVertCount += 2;
    }

    // flush rest verts
    if (curVertCount > 0) {
      var ia$1 = this._lineIAs.requestIA();
      ia$1._vertexBuffer.update(0, vdataF32);
      ia$1._start = 0;
      ia$1._count = curVertCount;

      item.ia = ia$1;
      this._draw(item);
    }
  };

  ForwardRenderer.prototype._drawSpriteBatch = function _drawSpriteBatch (item) {
    var this$1 = this;

    var model = item.model;
    var curVertOffset = 0;
    var curVertCount = 0;
    var curIndexCount = 0;
    var vdata = this._spriteIAs.requestVData(model.vertCount);
    var idata = this._spriteIAs.requestIData(model.indexCount);
    var vdataF32 = vdata.float32View;
    var idataU16 = idata.uint16View;

    for (var i = 0; i < model.spriteCount; ++i) {
      var sprite = model.getSprite(i);
      var vcount = sprite.refPositions.length;
      var icount = sprite.refIndices.length;

      // flush when verts exceeds
      if (
        curVertCount + vcount >= this$1._spriteIAs.maxVerts ||
        curIndexCount + icount >= this$1._spriteIAs.maxIndices
      ) {
        var ia = this$1._spriteIAs.requestIA();
        ia._vertexBuffer.update(0, vdataF32);
        ia._indexBuffer.update(0, idataU16);

        ia._start = 0;
        ia._count = curIndexCount;

        item.ia = ia;
        this$1._draw(item);

        curVertOffset = 0;
        curVertCount = 0;
        curIndexCount = 0;
      }

      //
      for (var j = 0; j < vcount; ++j) {
        var idx = curVertCount * 9;

        vdataF32[idx] = sprite.refPositions[j].x;
        vdataF32[idx + 1] = sprite.refPositions[j].y;
        vdataF32[idx + 2] = sprite.refPositions[j].z;
        vdataF32[idx + 3] = sprite.refUVs[j].x;
        vdataF32[idx + 4] = sprite.refUVs[j].y;
        vdataF32[idx + 5] = sprite.refColor.r;
        vdataF32[idx + 6] = sprite.refColor.g;
        vdataF32[idx + 7] = sprite.refColor.b;
        vdataF32[idx + 8] = sprite.refColor.a;

        curVertCount += 1;
      }

      for (var j$1 = 0; j$1 < icount; ++j$1) {
        var idx$1 = curIndexCount;

        idataU16[idx$1] = curVertOffset + sprite.refIndices[j$1];

        curIndexCount += 1;
      }

      curVertOffset += vcount;
    }

    // flush rest verts & indices
    if (curIndexCount > 0) {
      var ia$1 = this._spriteIAs.requestIA();
      ia$1._vertexBuffer.update(0, vdataF32);
      ia$1._indexBuffer.update(0, idataU16);
      ia$1._start = 0;
      ia$1._count = curIndexCount;

      item.ia = ia$1;
      this._draw(item);
    }
  };

  ForwardRenderer.prototype._drawParticleBatch = function _drawParticleBatch (item) {
    item.ia = item.model._ia;
    this._draw(item);
  };

  return ForwardRenderer;
}(BaseRenderer));

var renderer = {
  // config
  addStage: config.addStage,

  // utils
  createIA: createIA,

  // core
  Pass: Pass,
  Technique: Technique,
  Effect: Effect,
  InputAssembler: InputAssembler,
  View: View,

  // scene
  Light: Light,
  Camera: Camera,
  Model: Model,
  Scene: Scene,

  // models
  LineBatchModel: LineBatchModel,
  SpriteBatchModel: SpriteBatchModel,
  ParticleBatchModel: ParticleBatchModel,
  SkinningModel: SkinningModel,

  // renderers
  ForwardRenderer: ForwardRenderer,
};
Object.assign(renderer, enums$1);

var enums$2 = {
  KEY_NONE: 0,
  KEY_DOWN: 1,
  KEY_PRESSING: 2,
  KEY_UP: 3,

  TOUCH_START: 0,
  TOUCH_PRESSING: 1,
  TOUCH_END: 2,
  TOUCH_CANCEL: 3,

  LOCK_NEVER: 0,
  LOCK_WHEN_PRESSED: 1,
  LOCK_ALWAYS: 2,
};

var _dragMask = null;
var _phases = [
  'start',
  'pressing',
  'end',
  'cancel'
];

var _states = [
  'none',
  'down',
  'pressing',
  'up' ];

var Input = function Input(element, opts) {
  var this$1 = this;

  opts = opts || {};

  if (!_dragMask && opts.useMask) {
    _dragMask = document.createElement('div');
    _dragMask.classList.add('drag-mask');
    _dragMask.style.position = 'fixed';
    _dragMask.style.zIndex = '9999';
    _dragMask.style.top = '0';
    _dragMask.style.right = '0';
    _dragMask.style.bottom = '0';
    _dragMask.style.left = '0';
    _dragMask.oncontextmenu = function () { return false; };
  }

  this._element = element || document.body;
  this._element.requestPointerLock = this._element.requestPointerLock || this._element.mozRequestPointerLock;
  this._element.exitPointerLock = this._element.exitPointerLock || this._element.mozExitPointerLock;

  // setup options

  this._enabled = true;
  if (opts.enabled !== undefined) {
    this._enabled = opts.enabled;
  }

  this._lock = enums$2.LOCK_NEVER;
  if (opts.lock !== undefined) {
    this._lock = opts.lock;
  }

  this._useMask = false;
  if (opts.useMask !== undefined) {
    this._useMask = opts.useMask;
  }

  this._maskCursor = 'default';
  if (opts.maskCursor !== undefined) {
    this._maskCursor = opts.maskCursor;
  }

  this._invertY = false;
  if (opts.invertY !== undefined) {
    this._invertY = opts.invertY;
  }

  //
  var ua = navigator.userAgent.toLowerCase();
  if (/mobile|android|iphone|ipad|phone/i.test(ua)) {
    this._hasTouch = true;
  }

  // mouse internal states
  this._globalEventInstalled = false;
  this._pointerLocked = false;
  this._mouseGrabbed = false;

  this._bcr = element.getBoundingClientRect();

  // the mouse state
  this._mouse = {
    x: 0,
    y: 0,
    dx: 0,
    dy: 0,
    prevX: 0,
    prevY: 0,

    // mouse wheel (delta)
    scrollX: 0,
    scrollY: 0,

    // buttons
    left: enums$2.KEY_NONE,
    right: enums$2.KEY_NONE,
    middle: enums$2.KEY_NONE,
  };

  // the keyboard state
  this._keys = new LinkedArray(function () {
    return {
      _next: null,
      _prev: null,
      _state: 0,
      key: '',
      get state () {
        return _states[this._state];
      }
    };
  }, 100);

  //the touch state
  this._touches = new RecyclePool(function () {
    return {
      id: -1, // touch.identifier
      x: 0,
      y: 0,
      dx: 0,
      dy: 0,
      prevX: 0,
      prevY: 0,
      get phase() {
        return _phases[this._phase];
      },
      _phase: -1, // 0: START, 1: PRESSING, 2: END
    };
  }, 16);

  // mousemove
  this._mousemoveHandle = function (event) {
    event.preventDefault();
    event.stopPropagation();

    this$1._mouse.dx = event.movementX;
    this$1._mouse.dy = event.movementY;

    if (this$1._pointerLocked) {
      this$1._mouse.x += event.movementX;
      if (this$1._invertY) {
        this$1._mouse.y -= event.movementY;
      } else {
        this$1._mouse.y += event.movementY;
      }
    } else {
      this$1._mouse.x = this$1._calcOffsetX(event.clientX);
      this$1._mouse.y = this$1._calcOffsetY(event.clientY);
    }
  };

  // mousewheel
  this._mousewheelHandle = function (event) {
    event.preventDefault();
    event.stopPropagation();

    this$1._mouse.scrollX = event.deltaX;
    this$1._mouse.scrollY = event.deltaY;
  };

  this._domMouseWheelHandle = function (event) {
    event.preventDefault();
    event.stopPropagation();

    // No horizon scrolling current.
    this$1._mouse.scrollX = 0;
    // When scroll forward, it's multiply of -3,
    // otherwise when scroll backward, it's multiply of 3.
    this$1._mouse.scrollY = event.detail / 3;
  };

  // mousedown
  this._mousedownHandle = function (event) {
    // NOTE: this will prevent mouse enter the text selection state.
    event.preventDefault();
    event.stopPropagation();

    if (this$1._lock) {
      this$1._lockPointer(true);
    }

    this$1._installGlobalEvents();
    this$1._element.focus();

    // handle mouse button
    switch (event.button) {
      // left mouse down
      case 0:
        // NOTE: do not reset KEY_DOWN when it already pressed
        if (this$1._mouse.left !== enums$2.KEY_PRESSING) {
          this$1._mouse.left = enums$2.KEY_DOWN;
        }
        break;

      // middle mouse down
      case 1:
        // NOTE: do not reset KEY_DOWN when it already pressed
        if (this$1._mouse.middle !== enums$2.KEY_PRESSING) {
          this$1._mouse.middle = enums$2.KEY_DOWN;
        }
        break;

      // right mouse down
      case 2:
        // NOTE: do not reset KEY_DOWN when it already pressed
        if (this$1._mouse.right !== enums$2.KEY_PRESSING) {
          this$1._mouse.right = enums$2.KEY_DOWN;
        }
        break;
    }
  };

  // mouseup
  this._mouseupHandle = function (event) {
    event.preventDefault();
    event.stopPropagation();

    // reset mouse position
    this$1._mouse.dx = event.movementX;
    this$1._mouse.dy = event.movementY;
    this$1._mouse.prevX = this$1._mouse.x = this$1._calcOffsetX(event.clientX);
    this$1._mouse.prevY = this$1._mouse.y = this$1._calcOffsetY(event.clientY);

    // handle mouse button
    switch (event.button) {
      // left mouse up
      case 0:
        this$1._mouse.left = enums$2.KEY_UP;
        break;

      // middle mouse up
      case 1:
        this$1._mouse.middle = enums$2.KEY_UP;
        break;

      // right mouse up
      case 2:
        this$1._mouse.right = enums$2.KEY_UP;
        break;
    }
  };

  // mouseenter
  this._mouseenterHandle = function (event) {
    event.preventDefault();
    event.stopPropagation();

    this$1._mouse.dx = 0.0;
    this$1._mouse.dy = 0.0;
    this$1._mouse.prevX = this$1._mouse.x = this$1._calcOffsetX(event.clientX);
    this$1._mouse.prevY = this$1._mouse.y = this$1._calcOffsetY(event.clientY);
  };

  // mouseleave
  this._mouseleaveHandle = function (event) {
    event.preventDefault();
    event.stopPropagation();

    if (this$1._mouseGrabbed) {
      return;
    }

    this$1._uninstallGlobalEvents();

    this$1._mouse.dx = event.movementX;
    this$1._mouse.dy = event.movementY;
    this$1._mouse.prevX = this$1._mouse.x = this$1._calcOffsetX(event.clientX);
    this$1._mouse.prevY = this$1._mouse.y = this$1._calcOffsetY(event.clientY);
  };

  // keydown
  this._keydownHandle = function (event) {
    event.stopPropagation();

    var iter = this$1._keys.head;
    while (iter) {
      if (iter.key === event.key) {
        break;
      }
      iter = iter._next;
    }

    // NOTE: do not reset KEY_DOWN when it already pressed
    if (iter && iter._state === enums$2.KEY_PRESSING) {
      return;
    }

    if (!iter) {
      iter = this$1._keys.add();
    }
    iter.key = event.key;
    iter._state = enums$2.KEY_DOWN;
  };

  // keyup
  this._keyupHandle = function (event) {
    event.stopPropagation();

    var iter = this$1._keys.head;
    while (iter) {
      if (iter.key === event.key) {
        break;
      }
      iter = iter._next;
    }

    if (iter) {
      this$1._keys.remove(iter);
    }

    iter = this$1._keys.add();
    iter.key = event.key;
    iter._state = enums$2.KEY_UP;
  };

  // touchstart
  this._touchstartHandle = function (event) {
    event.preventDefault();

    for (var i = 0; i < event.changedTouches.length; i++) {
      var changedTouch = event.changedTouches[i];
      var touch = this$1._touches.add();

      touch.id = changedTouch.identifier;
      touch._phase = enums$2.TOUCH_START;
      touch.x = this$1._calcOffsetX(changedTouch.clientX);
      touch.y = this$1._calcOffsetY(changedTouch.clientY);
      touch.dx = 0;
      touch.dy = 0;
      touch.prevX = 0;
      touch.prevY = 0;
    }
  };

  // touchmove
  this._touchmoveHandle = function (event) {
    event.preventDefault();

    for (var i = 0; i < this$1._touches.length; i++) {
      for (var j = 0; j < event.changedTouches.length; j++) {
        var touch = this$1._touches.data[i];
        var changedTouch = event.changedTouches[j];

        if (touch.id === changedTouch.identifier) {
          touch._phase = enums$2.TOUCH_PRESSING;
          touch.x = this$1._calcOffsetX(changedTouch.clientX);
          touch.y = this$1._calcOffsetY(changedTouch.clientY);
          touch.dx = touch.x - touch.prevX;
          touch.dy = touch.y - touch.prevY;
        }
      }
    }
  };

  // touchend
  this._touchendHandle = function (event) {
    event.preventDefault();

    for (var i = 0; i < this$1._touches.length; i++) {
      for (var j = 0; j < event.changedTouches.length; j++) {
        var touch = this$1._touches.data[i];
        var changedTouch = event.changedTouches[j];

        if (touch.id === changedTouch.identifier) {
          touch._phase = enums$2.TOUCH_END;
          touch.prevX = touch.x = this$1._calcOffsetX(changedTouch.clientX);
          touch.prevY = touch.y = this$1._calcOffsetY(changedTouch.clientY);
          touch.dx = 0;
          touch.dy = 0;
        }
      }
    }
  };

  // touchcancel
  this._touchcancelHandle = function (event) {
    event.preventDefault();

    for (var i = 0; i < this$1._touches.length; i++) {
      for (var j = 0; j < event.changedTouches.length; j++) {
        var touch = this$1._touches.data[i];
        var changedTouch = event.changedTouches[j];

        if (touch.id === changedTouch.identifier) {
          touch._phase = enums$2.TOUCH_CANCEL;
          touch.prevX = touch.x = this$1._calcOffsetX(changedTouch.clientX);
          touch.prevY = touch.y = this$1._calcOffsetY(changedTouch.clientY);
          touch.dx = 0;
          touch.dy = 0;
        }
      }
    }
  };

  // contextmenu
  this._contextmenuHandle = function (event) {
    event.preventDefault();
    event.stopPropagation();
  };

  this._lockChangeHandle = function () {
    if(document.pointerLockElement === this$1._element ||
    document.mozPointerLockElement === this$1._element) {
      this$1._pointerLocked = true;
    } else {
      this$1._pointerLocked = false;
    }
  };

  if (this._enabled) {
    this._registerEvents();
  }
};

var prototypeAccessors$14 = { enabled: { configurable: true },hasTouch: { configurable: true },mouseX: { configurable: true },mouseY: { configurable: true },mouseDeltaX: { configurable: true },mouseDeltaY: { configurable: true },mousePrevX: { configurable: true },mousePrevY: { configurable: true },mouseScrollX: { configurable: true },mouseScrollY: { configurable: true },mouseButtons: { configurable: true },touchCount: { configurable: true },hasKeyDown: { configurable: true },hasKeyUp: { configurable: true },hasMouseDown: { configurable: true },hasMouseUp: { configurable: true } };

/**
 * Firefox use 'DOMMouseScroll' as their mouse wheel event name.
 * Other browsers(Safari, Chrome, Edge have been tested) use 'mousewheel' instead.
*/

Input.prototype._registerMousewheelEvent = function _registerMousewheelEvent () {
  this._element.addEventListener('mousewheel', this._mousewheelHandle, { passive: false });
  this._element.addEventListener('DOMMouseScroll', this._domMouseWheelHandle, { passive: false });
};

Input.prototype._unregisterMousewheelEvent = function _unregisterMousewheelEvent () {
  this._element.removeEventListener('mousewheel', this._mousewheelHandle, { passive: true });
  this._element.removeEventListener('DOMMouseScroll', this._domMouseWheelHandle, { passive: true });
};

Input.prototype.destroy = function destroy () {
  this._element.removeEventListener('mousedown', this._mousedownHandle);
  this._element.removeEventListener('mouseenter', this._mouseenterHandle);
  this._element.removeEventListener('mouseleave', this._mouseleaveHandle);
  this._element.removeEventListener('mousemove', this._mousemoveHandle);
  this._unregisterMousewheelEvent();
  this._element.removeEventListener('keydown', this._keydownHandle);
  this._element.removeEventListener('keyup', this._keyupHandle);
  this._element.removeEventListener('touchstart', this._touchstartHandle);
  this._element.removeEventListener('touchend', this._touchendHandle);
  this._element.removeEventListener('touchcancel', this._touchcancelHandle);
  this._element.removeEventListener('touchmove', this._touchmoveHandle);

  this._element.removeEventListener('contextmenu', this._contextmenuHandle);
  document.removeEventListener('pointerlockchange', this._lockChangeHandle);

  this._uninstallGlobalEvents();
};

Input.prototype._registerEvents = function _registerEvents () {
  this._element.addEventListener('mousedown', this._mousedownHandle);
  this._element.addEventListener('mouseenter', this._mouseenterHandle);
  this._element.addEventListener('mouseleave', this._mouseleaveHandle);
  this._element.addEventListener('mousemove', this._mousemoveHandle);
  this._registerMousewheelEvent();
  this._element.addEventListener('keydown', this._keydownHandle);
  this._element.addEventListener('keyup', this._keyupHandle);
  this._element.addEventListener('touchstart', this._touchstartHandle, false);
  this._element.addEventListener('touchend', this._touchendHandle, false);
  this._element.addEventListener('touchcancel', this._touchcancelHandle, false);
  this._element.addEventListener('touchmove', this._touchmoveHandle, false);

  this._element.addEventListener('contextmenu', this._contextmenuHandle);
  document.addEventListener('pointerlockchange', this._lockChangeHandle, false);
};

Input.prototype._installGlobalEvents = function _installGlobalEvents () {
  if (this._globalEventInstalled) {
    return;
  }

  document.addEventListener('mouseup', this._mouseupHandle);
  document.addEventListener('mousemove', this._mousemoveHandle);
  document.addEventListener('mousewheel', this._mousewheelHandle, { passive: true });

  if (this._useMask) {
    _dragMask.style.cursor = this._maskCursor || 'default';
    document.body.appendChild(_dragMask);
  }

  this._globalEventInstalled = true;
};

Input.prototype._uninstallGlobalEvents = function _uninstallGlobalEvents () {
  if (!this._globalEventInstalled) {
    return;
  }

  // if we have mouse key pressed, skip it
  if (
    (this._mouse.left !== enums$2.KEY_NONE && this._mouse.left !== enums$2.KEY_UP) ||
    (this._mouse.right !== enums$2.KEY_NONE && this._mouse.right !== enums$2.KEY_UP) ||
    (this._mouse.middle !== enums$2.KEY_NONE && this._mouse.middle !== enums$2.KEY_UP)
  ) {
    return;
  }

  // unlock mouse here
  if (this._lock === enums$2.LOCK_WHEN_PRESSED) {
    this._lockPointer(false);
  }

  // if we are grabbing mouse, skip it
  if (this._mouseGrabbed) {
    return;
  }

  document.removeEventListener('mouseup', this._mouseupHandle);
  document.removeEventListener('mousemove', this._mousemoveHandle);
  document.removeEventListener('mousewheel', this._mousewheelHandle, { passive: true });

  if (this._useMask) {
    _dragMask.remove();
  }

  this._globalEventInstalled = false;
};

// NOTE: in web-browser, requestPointerLock only works in mousedown event
Input.prototype._lockPointer = function _lockPointer (locked) {
  if (locked) {
    if (this._pointerLocked) {
      return;
    }

    if (this._element.requestPointerLock) {
      this._element.requestPointerLock();
      this._pointerLocked = true;
    }

    return;
  } else {
    if (!this._pointerLocked) {
      return;
    }

    if (document.exitPointerLock) {
      document.exitPointerLock();
      this._pointerLocked = false;
    }
  }
};

Input.prototype._calcOffsetX = function _calcOffsetX (clientX) {
  return clientX - this._bcr.left;
};

Input.prototype._calcOffsetY = function _calcOffsetY (clientY) {
  if (this._invertY) {
    return this._bcr.height - (clientY - this._bcr.top);
  }

  return clientY - this._bcr.top;
};

/**
 * @property {boolean} enabled
 */
prototypeAccessors$14.enabled.get = function () {
  return this._enabled;
};
prototypeAccessors$14.enabled.set = function (val) {
  if (this._enabled !== val) {
    this._enabled = val;

    if (this._enabled) {
      this._registerEvents();
      if (this._mouseGrabbed) {
        this._installGlobalEvents();
      }
    } else {
      this.destroy();
    }
  }
};

/**
 * @property {boolean} hasTouch
 */
prototypeAccessors$14.hasTouch.get = function () {
  return this._hasTouch;
};

/**
 * @property {number} mouseX
 */
prototypeAccessors$14.mouseX.get = function () {
  return this._mouse.x;
};

/**
 * @property {number} mouseY
 */
prototypeAccessors$14.mouseY.get = function () {
  return this._mouse.y;
};

/**
 * @property {number} mouseDeltaX
 */
prototypeAccessors$14.mouseDeltaX.get = function () {
  return this._mouse.dx;
};

/**
 * @property {number} mouseDeltaY
 */
prototypeAccessors$14.mouseDeltaY.get = function () {
  return this._mouse.dy;
};

/**
 * @property {number} mousePrevX
 */
prototypeAccessors$14.mousePrevX.get = function () {
  return this._mouse.prevX;
};

/**
 * @property {number} mousePrevY
 */
prototypeAccessors$14.mousePrevY.get = function () {
  return this._mouse.prevY;
};

/**
 * @property {number} mouseScrollX
 */
prototypeAccessors$14.mouseScrollX.get = function () {
  return this._mouse.scrollX;
};

/**
 * @property {number} mouseScrollY
 */
prototypeAccessors$14.mouseScrollY.get = function () {
  return this._mouse.scrollY;
};

/**
 * @property {number} mouseButtons - mouse buttons in pressing states
 */
prototypeAccessors$14.mouseButtons.get = function () {
  var buttons = 0;

  var btn = this._mouse.left;
  if (btn === enums$2.KEY_DOWN || btn === enums$2.KEY_PRESSING) {
    buttons |= 1;
  }

  btn = this._mouse.right;
  if (btn === enums$2.KEY_DOWN || btn === enums$2.KEY_PRESSING) {
    buttons |= 2;
  }

  btn = this._mouse.middle;
  if (btn === enums$2.KEY_DOWN || btn === enums$2.KEY_PRESSING) {
    buttons |= 4;
  }

  return buttons;
};

/**
 * @property {number} touchCount
 */
prototypeAccessors$14.touchCount.get = function () {
  return this._touches.length;
};

/**
 * @property {boolean} hasKeyDown
 */
prototypeAccessors$14.hasKeyDown.get = function () {
  var iter = this._keys.head;
  while (iter) {
    if (iter._state === enums$2.KEY_DOWN || iter._state === enums$2.KEY_PRESSING) {
      return true;
    }
    iter = iter._next;
  }
  return false;
};

/**
 * @property {boolean} hasKeyUp
 */
prototypeAccessors$14.hasKeyUp.get = function () {
  var iter = this._keys.head;
  while (iter) {
    if (iter._state === enums$2.KEY_UP) {
      return true;
    }
    iter = iter._next;
  }
  return false;
};

/**
 * @property {boolean} hasMouseDown
 */
prototypeAccessors$14.hasMouseDown.get = function () {
  if (
    this._mouse.left === enums$2.KEY_DOWN ||
    this._mouse.middle === enums$2.KEY_DOWN ||
    this._mouse.right === enums$2.KEY_DOWN
  ) {
    return true;
  }

  return false;
};

/**
 * @property {boolean} hasMouseUp
 */
prototypeAccessors$14.hasMouseUp.get = function () {
  if (
    this._mouse.left === enums$2.KEY_UP ||
    this._mouse.middle === enums$2.KEY_UP ||
    this._mouse.right === enums$2.KEY_UP
  ) {
    return true;
  }

  return false;
};

/**
 * @method getTouchInfo
 * @param {number} idx
 */
Input.prototype.getTouchInfo = function getTouchInfo (idx) {
  return this._touches.data[idx];
};

/**
 * @method reset
 *
 * Reset the input states.
 * NOTE: you should call this at the end of your frame.
 */
Input.prototype.reset = function reset () {
    var this$1 = this;

  if (this._enabled === false) {
    return;
  }

  // update mouse states
  this._mouse.prevX = this._mouse.x;
  this._mouse.prevY = this._mouse.y;

  this._mouse.dx = 0;
  this._mouse.dy = 0;

  this._mouse.scrollX = 0;
  this._mouse.scrollY = 0;

  if (this._mouse.left === enums$2.KEY_DOWN) {
    this._mouse.left = enums$2.KEY_PRESSING;
  } else if (this._mouse.left === enums$2.KEY_UP) {
    this._mouse.left = enums$2.KEY_NONE;
  }

  if (this._mouse.middle === enums$2.KEY_DOWN) {
    this._mouse.middle = enums$2.KEY_PRESSING;
  } else if (this._mouse.middle === enums$2.KEY_UP) {
    this._mouse.middle = enums$2.KEY_NONE;
  }

  if (this._mouse.right === enums$2.KEY_DOWN) {
    this._mouse.right = enums$2.KEY_PRESSING;
  } else if (this._mouse.right === enums$2.KEY_UP) {
    this._mouse.right = enums$2.KEY_NONE;
  }

  // update keyboard states
  var iter = this._keys.head;
  var next = iter;
  while (next) {
    iter = next;
    next = iter._next;

    if (iter._state === enums$2.KEY_DOWN) {
      iter._state = enums$2.KEY_PRESSING;
    } else if (iter._state === enums$2.KEY_UP) {
      this$1._keys.remove(iter);
    }
  }

  // update touch states
  for (var i = 0; i < this._touches.length; i++) {
    this$1._touches.data[i].prevX = this$1._touches.data[i].x;
    this$1._touches.data[i].prevY = this$1._touches.data[i].y;
    this$1._touches.data[i].dx = 0;
    this$1._touches.data[i].dy = 0;
    if (this$1._touches.data[i]._phase === enums$2.TOUCH_START) {
      this$1._touches.data[i]._phase = enums$2.TOUCH_PRESSING;
    }
    if (this$1._touches.data[i]._phase === enums$2.TOUCH_END || this$1._touches.data[i]._phase === enums$2.TOUCH_CANCEL) {
      this$1._touches.remove(i);
    }
  }

  // check if uninstall global events
  this._uninstallGlobalEvents();
};

/**
 * @method resize
 *
 * Update cached bounding client size.
 */
Input.prototype.resize = function resize () {
  this._bcr = this._element.getBoundingClientRect();
};

/**
 * @method grabMouse
 * @param {boolean} grabbed
 *
 * Keep tracing mouse move event when mouse leave the target element.
 */
Input.prototype.grabMouse = function grabMouse (grabbed) {
  this._mouseGrabbed = grabbed;

  // NOTE: we can mark mouse grabbed, but don't register events for it.
  if (this._enabled === false) {
    return;
  }

  if (grabbed) {
    this._installGlobalEvents();
  } else {
    this._uninstallGlobalEvents();
  }
};

/**
 * @method mousedown
 * @param {string} name - 'left', 'right' or 'middle'
 */
Input.prototype.mousedown = function mousedown (name) {
  var btn = this._mouse[name];
  if (btn !== undefined) {
    return btn === enums$2.KEY_DOWN;
  }

  return false;
};

/**
 * @method mousepress
 * @param {string} name - 'left', 'right' or 'middle'
 */
Input.prototype.mousepress = function mousepress (name) {
  var btn = this._mouse[name];
  if (btn !== undefined) {
    return btn === enums$2.KEY_DOWN || btn === enums$2.KEY_PRESSING;
  }

  return false;
};

/**
 * @method mouseup
 * @param {string} name - 'left', 'right' or 'middle'
 */
Input.prototype.mouseup = function mouseup (name) {
  var btn = this._mouse[name];
  if (btn !== undefined) {
    return btn === enums$2.KEY_UP;
  }

  return false;
};

/**
 * @method keydown
 * @param {string} name
 */
Input.prototype.keydown = function keydown (name) {
  var iter = this._keys.head;
  while (iter) {
    if (iter.key === name && iter._state === enums$2.KEY_DOWN) {
      return true;
    }
    iter = iter._next;
  }

  return false;
};

/**
 * @method keyup
 * @param {string} name
 */
Input.prototype.keyup = function keyup (name) {
  var iter = this._keys.head;
  while (iter) {
    if (iter.key === name && iter._state === enums$2.KEY_UP) {
      return true;
    }
    iter = iter._next;
  }

  return false;
};

/**
 * @method keypress
 * @param {string} name
 */
Input.prototype.keypress = function keypress (name) {
  var iter = this._keys.head;
  while (iter) {
    if (iter.key === name &&
      (iter._state === enums$2.KEY_DOWN || iter._state === enums$2.KEY_PRESSING)
    ) {
      return true;
    }
    iter = iter._next;
  }

  return false;
};

Object.defineProperties( Input.prototype, prototypeAccessors$14 );

Object.assign(Input, enums$2);

/**
 * @class Event
 */
var Event = function Event(name, opts) {
  if ( opts === void 0 ) opts = {};

  this.name = name;
  this.detail = opts.detail;
  this.bubbles = !!opts.bubbles;

  // NOTE: DO NOT set target from opts,
  // the target must be set manually from the user who create the event.
  this.target = null;
  this._stopped = false;
};

/**
 * @method stop
 *
 * Stop propgation
 */
Event.prototype.stop = function stop () {
  this._stopped = true;
};

var has = Object.prototype.hasOwnProperty;

/**
 * An event-table is a plain object whose properties are event names.
 */
function _createTable() {
  var obj = Object.create(null);
  obj.__tmp__ = undefined;
  delete obj.__tmp__;

  return obj;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function _EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function _addListener(emitter, evt, fn, context, once) {
  var listener = new _EE(fn, context || emitter, once);

  if (!emitter._events[evt]) {
    emitter._events[evt] = listener;
    emitter._eventsCount++;
  } else if (!emitter._events[evt].fn) {
    emitter._events[evt].push(listener);
  } else {
    emitter._events[evt] = [emitter._events[evt], listener];
  }

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function _clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) {
    emitter._events = _createTable();
  } else {
    delete emitter._events[evt];
  }
}

/**
 * bubble event
 *
 * @param {Event} event
 * @private
 */
function _dispatchEvent(event) {
  var emitter = event.target;

  while (emitter) {
    emitter.emit(event.name, event);

    if (!event.bubbles || event._stopped) {
      break;
    }

    emitter = emitter.parent;
  }
}

/**
 * @class EventEmitter
 */
var EventEmitter = function EventEmitter() {
  this._events = _createTable();
  this._eventsCount = 0;
};

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 */
EventEmitter.mixin = function mixin (cls) {
  Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function (name) {
    if (cls.prototype.hasOwnProperty(name) === false) {
      Object.defineProperty(
        cls.prototype,
        name,
        Object.getOwnPropertyDescriptor(EventEmitter.prototype, name)
      );
    }
  });
  cls.prototype.__initEventEmitter = function () {
    this._events = _createTable();
    this._eventsCount = 0;
  };
};

EventEmitter.prototype.eventNames = function eventNames () {
    var this$1 = this;

  var names = [], events, name;

  if (this._eventsCount === 0) {
    return names;
  }

  for (name in (events = this$1._events)) {
    if (has.call(events, name)) {
      names.push(name);
    }
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} evt The event name.
 * @param {Boolean} exists Only check if there are listeners.
 * @returns {(Array|Boolean)}
 */
EventEmitter.prototype.listeners = function listeners (evt, exists) {
  var available = this._events[evt];

  if (exists) {
    return !!available;
  }

  if (!available) {
    return [];
  }

  if (available.fn) {
    return [available.fn];
  }

  var l = available.length;
  var ee = new Array(l);

  for (var i = 0; i < l; ++i) {
    ee[i] = available[i].fn;
  }

  return ee;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} evt The event name.
 * @param {*} a1
 * @param {*} a2
 * @param {*} a3
 * @param {*} a4
 * @param {*} a5
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 */
EventEmitter.prototype.emit = function emit (evt, a1, a2, a3, a4, a5) {
    var arguments$1 = arguments;
    var this$1 = this;

  if (!this._events[evt]) {
    return false;
  }

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) {
      this.off(evt, listeners.fn, undefined, true);
    }

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len - 1); i < len; i++) {
      args[i - 1] = arguments$1[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length, j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) {
        this$1.off(evt, listeners[i].fn, undefined, true);
      }

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) {
            for (j = 1, args = new Array(len - 1); j < len; j++) {
              args[j - 1] = arguments$1[j];
            }
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} evt The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on (evt, fn, context) {
  return _addListener(this, evt, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} evt The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once (evt, fn, context) {
  return _addListener(this, evt, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} evt The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.off = function off (evt, fn, context, once) {
  if (!this._events[evt]) {
    return this;
  }

  if (!fn) {
    _clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      _clearEvent(this, evt);
    }
  } else {
    var events = [];
    for (var i = 0, l = listeners.length; i < l; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) {
      this._events[evt] = events.length === 1 ? events[0] : events;
    } else {
      _clearEvent(this, evt);
    }
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [evt] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners (evt) {
  if (evt) {
    if (this._events[evt]) {
      _clearEvent(this, evt);
    }
  } else {
    this._events = _createTable();
    this._eventsCount = 0;
  }

  return this;
};

/**
 * @param {Event|string} evt
 * @param {object} [opts]
 */
EventEmitter.prototype.dispatch = function dispatch (evt, opts) {
  var event = evt;
  if (typeof evt === 'string') {
    event = new Event(evt, opts);
  }

  event.target = this;
  _dispatchEvent(event);
};

var ComponentEvent = (function (Event) {
  function ComponentEvent(name, opts) {
    Event.call(this, name, opts);

    this.component = null;
  }

  if ( Event ) ComponentEvent.__proto__ = Event;
  ComponentEvent.prototype = Object.create( Event && Event.prototype );
  ComponentEvent.prototype.constructor = ComponentEvent;

  return ComponentEvent;
}(Event));

var Component = function Component() {
  this._enabled = true;
  this._destroyed = false;
  this._inited = false;

  // app internal data
  this._app = null;
  this._system = null;
  this._entity = null;
};

var prototypeAccessors$15 = { enabled: { configurable: true },destroyed: { configurable: true },system: { configurable: true },entity: { configurable: true } };

prototypeAccessors$15.enabled.get = function () {
  return this._entity.activeInHierarchy && this._enabled;
};
prototypeAccessors$15.enabled.set = function (val) {
  if (this._enabled !== val) {
    this._enabled = val;

    if (this._entity.activeInHierarchy) {
      if (this._enabled) {
        this.onEnable && this.onEnable();
      } else {
        this.onDisable && this.onDisable();
      }
    }
  }
};

Component.prototype._onEntityActiveChanged = function _onEntityActiveChanged (active) {
  // todo add implementation
  if (!this._inited) {
    this._inited = true;
    if (this.onInit) {
      this.onInit();
    }
  }
  if (this._enabled) {
    if (active) {
      this.onEnable && this.onEnable();
    } else {
      this.onDisable && this.onDisable();
    }
  }
};

Component.prototype._onComponentNeedDestroy = function _onComponentNeedDestroy () {
  if(this._inited) {
    this.onDestroy && this.onDestroy();
    this._inited = false;
  }
};

prototypeAccessors$15.destroyed.get = function () {
  return this._entity.destroyed || this._destroyed;
};

prototypeAccessors$15.system.get = function () {
  return this._system;
};

prototypeAccessors$15.entity.get = function () {
  return this._entity;
};

Component.prototype.dispatch = function dispatch (evt, opts) {
  var event = evt;
  if (typeof evt === 'string') {
    event = new ComponentEvent(evt, opts);
  }

  event.target = this._entity;
  event.component = this;
  this._entity.dispatch(event);
};

Component.prototype.destroy = function destroy () {
  if (this._destroyed) {
    return;
  }

  // mark as destroyed
  this._destroyed = true;
  // call entityInactive
  var ent = this._entity;

  if (this.enabled) {
    this.onDisable && this.onDisable();
  }

  // submit destroy request
  this._app._destroyComp(this);
};

Object.defineProperties( Component.prototype, prototypeAccessors$15 );



/**
 * callbacks:
 *
 *  - onInit()
 *  - onDestroy()
 *  - onEnable()
 *  - onDisable()
 *  - onClone(src)
 *
 * static members:
 *
 *  - events: {
 *    'foo': 'onFoo',
 *    'bar': 'onBar'
 *  }
 *
 *  - schema: {
 *    'foo': { default: 'hello', type: 'string', array: false }
 *  }
 */

var Entity = function Entity(name) {
  this.__initNode();
  this.__initEventEmitter();

  this.name = name || '';
  this._active = false;
  // NOTE: _ancestorActive not include self
  this._ancestorActive = false;
  this._destroyed = false;
  this._comps = [];

  // app internal data
  this._app = null;
  this._poolID = -1;
};

var prototypeAccessors$16 = { active: { configurable: true },activeInHierarchy: { configurable: true },destroyed: { configurable: true } };

/**
 * @property {boolean} active
 */
prototypeAccessors$16.active.get = function () {
  return this._active;
};
prototypeAccessors$16.active.set = function (val) {
  val = !!val;
  if (this._active !== val) {
    if (val) {
      this.activate();
    } else {
      this.deactivate();
    }
  }

};

prototypeAccessors$16.activeInHierarchy.get = function () {
  return this._active && this._ancestorActive;
};

prototypeAccessors$16.destroyed.get = function () {
  return this._destroyed;
};

Entity.prototype.activate = function activate () {
  if (this._active === true) {
    return;
  }
  this._active = true;
  if (this._ancestorActive) {
    this._notifyComponents(true);
    this._notifyChildren(true);
  }
};

Entity.prototype.deactivate = function deactivate () {
  if (this._active === false) {
    return;
  }
  this._active = false;
  if (this._ancestorActive) {
    this._notifyComponents(false);
    this._notifyChildren(false);
  }
};

Entity.prototype._notifyComponents = function _notifyComponents (active) {
    var this$1 = this;


  this.emit(active ? 'active' : 'inactive');

  for (var i = 0; i < this._comps.length; ++i) {
    var comp = this$1._comps[i];
    comp._onEntityActiveChanged(active);
  }
};

Entity.prototype._notifyChildren = function _notifyChildren (active) {
    var this$1 = this;

  for (var i = 0; i < this._children.length; ++i) {
    var child = this$1._children[i];
    child._ancestorActive = active;
    // do not need to set if child is inactive
    if (child.active) {
      child._notifyComponents(active);
      child._notifyChildren(active);
    }

  }
};

Entity.prototype.destroy = function destroy () {
    var this$1 = this;

  if (this._destroyed) {
    return;
  }

  // mark as destroyed
  this._destroyed = true;

  // recursively destroy child entities
  for (var i = 0; i < this._children.length; ++i) {
    var child = this$1._children[i];
    child.destroy();
  }

  // remove all components
  for (var i$1 = 0; i$1 < this._comps.length; ++i$1) {
    var comp = this$1._comps[i$1];
    comp.destroy();
  }
  // emit disable
  if (this.activeInHierarchy) {
    this.emit('inactive');
  }
  // submit destroy request
  this._app._destroyEntity(this);
};

Entity.prototype._onParentChanged = function _onParentChanged (oldParent, newParent) {
  var oldAncestorState = !!(oldParent && oldParent.activeInHierarchy);
  this._ancestorActive = !!(newParent && newParent.activeInHierarchy);
  if (this._active && this._ancestorActive !== oldAncestorState) {
    this._notifyComponents(this._ancestorActive);
    this._notifyChildren(this._ancestorActive);
  }
  this.emit('parent-changed', oldParent, newParent);
};

Entity.prototype.clone = function clone () {
  return this._app.cloneEntity(this);
};

Entity.prototype.deepClone = function deepClone () {
  return this._app.deepCloneEntity(this);
};

Entity.prototype.getComp = function getComp (classname) {
    var this$1 = this;

  var ctor = this._app.getClass(classname);

  for (var i = 0; i < this._comps.length; ++i) {
    var comp = this$1._comps[i];
    if (comp instanceof ctor) {
      return comp;
    }
  }

  return null;
};

Entity.prototype.getComps = function getComps (classname) {
    var this$1 = this;

  var ctor = this._app.getClass(classname);
  var results = [];

  for (var i = 0; i < this._comps.length; ++i) {
    var comp = this$1._comps[i];
    if (comp instanceof ctor) {
      results.push(comp);
    }
  }

  return results;
};

Entity.prototype.getCompsInChildren = function getCompsInChildren (classname) {
  var ctor = this._app.getClass(classname);
  var results = [];

  utils.walk(this, function (n) {
    for (var i = 0; i < n._comps.length; ++i) {
      var comp = n._comps[i];
      if (comp instanceof ctor) {
        results.push(comp);
      }
    }
  });

  return results;
};

Entity.prototype.addComp = function addComp (classname, data) {
  var ctor = this._app.getClass(classname);

  if (!ctor.multiple) {
    if (this.getComp(classname)) {
      return null;
    }
  }

  var comp = this._app._createComp(ctor, this, data);
  this._comps.push(comp);
  if (this.activeInHierarchy) {
    comp._onEntityActiveChanged(true);
  }
  return comp;
};

// call by app
Entity.prototype._removeComp = function _removeComp (comp) {
    var this$1 = this;

  for (var i = 0; i < this._comps.length; ++i) {
    var c = this$1._comps[i];
    if (c === comp) {
      this$1._comps.splice(i, 1);
      return true;
    }
  }

  return false;
};

Object.defineProperties( Entity.prototype, prototypeAccessors$16 );

Node.mixin(Entity);
EventEmitter.mixin(Entity);

var Level = (function (Entity$$1) {
  function Level(name) {
    Entity$$1.call(this, name);
  }

  if ( Entity$$1 ) Level.__proto__ = Entity$$1;
  Level.prototype = Object.create( Entity$$1 && Entity$$1.prototype );
  Level.prototype.constructor = Level;

  Level.prototype.addComp = function addComp () {
    console.warn('Can not add component in level');
  };

  Level.prototype.setParent = function setParent () {
    console.error('Can not set parent to level');
  };

  Level.prototype.activate = function activate () {
    if (this._active === true && this._ancestorActive === true) {
      return;
    }
    this._ancestorActive = true;
    Entity$$1.prototype.activate.call(this);
  };

  Level.prototype.deactivate = function deactivate () {
    if (this._active === false && this._ancestorActive === false) {
      return;
    }
    this._ancestorActive = false;
    Entity$$1.prototype.deactivate.call(this);
  };

  return Level;
}(Entity));

var System = function System() {
  this._enabled = true;

  // set by app
  this._id = '';
  this._app = null;
  this._priority = 0;
  this._componentCls = null;
};

System.prototype.init = function init () {
  // Example:
  // this._components = new FixedArray(this._poolSize);
};

System.prototype.add = function add (/*comp*/) {
  // Example:
  // this._components.push(comp);
};

System.prototype.remove = function remove (/*comp*/) {
  // Example:
  // for (let i = 0; i < this._components.length; ++i) {
  // let component = this._components.data[i];
  // if (component === comp) {
  //   this._components.fastRemove(i);
  //   break;
  // }
  // }
};

System.prototype.tick = function tick () {
  // Example:
  // for (let i = 0; i < this._components.length; ++i) {
  // let comp = this._components[i];
  // comp.update();
  // }
};

System.prototype.postTick = function postTick () {
  // Example:
  // for (let i = 0; i < this._components.length; ++i) {
  // let comp = this._components[i];
  // comp.postUpdate();
  // }
};

function _getClassParser(typename) {
  return function (app, data, propInfo, entities) {
    var ctor = app.getClass(typename);
    if (ctor === undefined) {
      console.warn(("Can not find class " + typename + "."));
      return null;
    }

    data = data || {};

    if (data instanceof ctor) {
      return data;
    }

    if (data.constructor && data.constructor.__classname__) {
      console.warn(("Invalid class instance, it is not instanceof " + typename + "."));
      return null;
    }

    var obj = new ctor();
    parse(app, obj, data, entities);

    return obj;
  };
}

function _getArrayParser(elementParser) {
  if (elementParser) {
    return function (app, data, propInfo, entities) {
      if(data === null)
        { return []; }
      var result = new Array(data.length);

      for (var i = 0; i < data.length; ++i) {
        result[i] = elementParser(app, data[i], propInfo, entities);
      }

      return result;
    };
  }

  return function (app, data) {
    return data;
  };
}

function _getParser(app, propInfo) {
  if (propInfo.parse) {
    return propInfo.parse;
  }

  var parser = null;

  // get parser
  var typeInfo = app.getType(propInfo.type);
  if (typeInfo) {
    parser = typeInfo.parse || null;
  } else {
    parser = _getClassParser(propInfo.type);
  }

  // if this is an array, get array parser
  if (propInfo.array) {
    return _getArrayParser(parser);
  }

  return parser;
}

function _wrapSet(app, name, propInfo, parser) {
  // if we have parser
  if (parser) {
    // if we have set
    if (propInfo.set) {
      return function (val) {
        propInfo.set.call(this, parser(app, val, propInfo));
      };
    }

    // default
    return function (val) {
      this[name] = parser(app, val, propInfo);
    };
  }

  // if we have set
  if (propInfo.set) {
    return propInfo.set;
  }

  // default
  return function (val) {
    this[name] = val;
  };
}

function _wrapGet(app, name, propInfo) {
  // if we have get
  if (propInfo.get) {
    return propInfo.get;
  }

  // default
  return function () {
    return this[name];
  };
}

function createPrototypeAccessors(app, schema) {
  var prototypeAccessors = {};

  for (var name in schema) {
    var propInfo = schema[name];

    // type & default syntax validation
    if (propInfo.type === undefined && propInfo.default === undefined) {
      console.warn(("Invalid property " + name + ": you must provide 'default' or 'type'."));
      continue;
    }

    // confirm array attributes in propInfo
    if (propInfo.array === undefined) {
      // propInfo.array = Array.isArray(propInfo.default);
      propInfo.array = false;
    }

    // array syntax validation
    if (propInfo.array && propInfo.type === undefined) {
      console.warn(("Invalid property " + name + ": array value must have a 'type'."));
      continue;
    }

    // confirm type attributes in propInfo
    var typename = propInfo.type;
    if (typename === undefined) {
      propInfo.type = typeof propInfo.default;
    }

    // confirm default attributes in propInfo
    if (propInfo.default === undefined) {
      var typeInfo = app.getType(propInfo.type);
      if (typeInfo) {
        propInfo.default = typeInfo.default;
      } else {
        propInfo.default = null;
      }
    }

    // get parser
    var parser = _getParser(app, propInfo);

    // create get & set function
    var interName = "_" + name;
    var getFn = _wrapGet(app, interName, propInfo);
    var setFn = _wrapSet(app, interName, propInfo, parser);

    prototypeAccessors[name] = {
      configurable: true,
      enumerable: true,
      get: getFn,
      set: setFn,
    };
  }

  return prototypeAccessors;
}

function parse(app, obj, data, entities) {
  var proto = obj.constructor;

  while (proto.__classname__ !== undefined) {
    if (proto.hasOwnProperty('schema') === false) {
      proto = Object.getPrototypeOf(proto);
      continue;
    }

    for (var name in proto.schema) {
      var interName = "_" + name;
      if (obj[interName] !== undefined) {
        continue;
      }

      var propInfo = proto.schema[name];

      // get parser and parse value
      var parser = _getParser(app, propInfo);
      var value = data && data[name];
      if (value === undefined) {
        value = propInfo.default;
      }

      //
      if (parser) {
        var result = parser(app, value, propInfo, entities);
        obj[interName] = result;
      } else {
        obj[interName] = value;
      }
    }

    proto = Object.getPrototypeOf(proto);
  }
}

var Schema = {
  createPrototypeAccessors: createPrototypeAccessors,
  parse: parse,
};

var App = function App(opts) {
  var this$1 = this;
  if ( opts === void 0 ) opts = {};

  var poolSize = opts.poolSize || 100;

  this._types = {};
  this._classes = {};
  this._systems = [];

  this._activeLevel = new Level();
  this._activeLevel._app = this;
  this._activeLevel.activate();

  // NOTE: we don't use recycles pool here because reused entity may be refereced by others
  this._entities = new FixedArray(poolSize);
  this._deadComponents = new FixedArray(poolSize);
  this._deadEntities = new FixedArray(poolSize);

  //
  if (opts.systems) {
    for (var i = 0; i < opts.systems.length; ++i) {
      var info = opts.systems[i];
      this$1.registerSystem(
        info.id,
        info.system,
        info.component,
        info.priority
      );
    }
  }
  this._sortSystems();
};

var prototypeAccessors$17 = { activeLevel: { configurable: true } };

/**
 * @property {Level} activeLevel
 */
prototypeAccessors$17.activeLevel.get = function () {
  return this._activeLevel;
};

/**
 * @param {string} name
 * @param {object} info
 */
App.prototype.registerType = function registerType (name, info) {
  this._types[name] = info;
};

/**
 * @param {string} name
 * @param {class} cls
 */
App.prototype.registerClass = function registerClass (name, cls) {
  cls.__classname__ = name;

  var schema = null;
  if (cls.hasOwnProperty('schema')) {
    schema = cls.schema;
  }

  if (schema) {
    var prototypeAccessors = Schema.createPrototypeAccessors(this, schema);
    Object.defineProperties(cls.prototype, prototypeAccessors);
  }

  // add name to cls
  this._classes[name] = cls;
};

/**
 * @param {string} id
 * @param {string} systemCls
 * @param {string} compClsName
 * @param {number} priority
 */
App.prototype.registerSystem = function registerSystem (id, systemCls, compClsName, priority) {
    if ( priority === void 0 ) priority = 0;

  var sys = new systemCls();

  sys._id = id;
  sys._app = this;
  sys._priority = priority;
  sys._componentCls = this.getClass(compClsName);
  if (!sys._componentCls) {
    console.warn(("Failed to get class " + compClsName + ", please register it first."));
  }

  sys.init();

  this._systems.push(sys);

  return sys;
};

/**
 * @param {string} name
 */
App.prototype.getType = function getType (name) {
  return this._types[name];
};

/**
 * @param {string} name
 */
App.prototype.getClass = function getClass (name) {
  return this._classes[name];
};

/**
 * @param {function|object} clsOrInst
 */
App.prototype.getClassName = function getClassName (clsOrInst) {
  if (typeof clsOrInst === 'function') {
    return clsOrInst.__classname__;
  }

  return clsOrInst.constructor.__classname__;
};

/**
 * @param {string} classname
 * @param {object} data
 */
App.prototype.createObject = function createObject (classname, data) {
  var ctor = this.getClass(classname);
  var obj = new ctor();
  Schema.parse(this, obj, data || {});

  return obj;
};

/**
 * @param {string} name
 * @param {Level} level
 */
App.prototype.createEntity = function createEntity (name, level) {
    if ( level === void 0 ) level = null;

  var ent = new Entity(name);
  ent._app = this;
  ent._active = true;
  this._entities.push(ent);

  var lv = level || this._activeLevel;
  if (lv) {
    ent.setParent(lv);
  }

  return ent;
};

/**
 * @param {Entity} ent
 */
App.prototype.cloneEntity = function cloneEntity (ent) {
    var this$1 = this;

  // clone & deepClone will mute the event and component callback
  return utils.clone(ent, Entity, function (newEnt, src) {
    newEnt._app = this$1;
    newEnt._active = src._active;

    // clone components
    for (var i = 0; i < src._comps.length; ++i) {
      var comp = src._comps[i];

      // skip destroyed component
      if (comp._destroyed) {
        continue;
      }

      // create & clone the component
      var newComp = this$1._createComp(comp.constructor, newEnt, comp);
      newComp._enabled = comp._enabled;

      // invoke onClone
      if (newComp.onClone) {
        newComp.onClone(comp);
      }

      // add component to entity
      newEnt._comps.push(newComp);
    }
    this$1._entities.push(newEnt);
  });
};

/**
 * @param {Entity} ent
 */
App.prototype.deepCloneEntity = function deepCloneEntity (ent) {
    var this$1 = this;

  // clone & deepClone will mute the event and component callback
  return utils.deepClone(ent, Entity, function (newEnt, src) {
    newEnt._app = this$1;
    newEnt._active = src._active;

    // clone components
    for (var i = 0; i < src._comps.length; ++i) {
      var comp = src._comps[i];

      // skip destroyed component
      if (comp._destroyed) {
        continue;
      }

      // create & clone the component
      var newComp = this$1._createComp(comp.constructor, newEnt, comp);
      newComp._enabled = comp._enabled;

      // invoke onClone
      if (newComp.onClone) {
        newComp.onClone(comp);
      }

      // add component to entity
      newEnt._comps.push(newComp);
    }
    this$1._entities.push(newEnt);
  });
};

/**
 * @param {Level} level
 */
App.prototype.loadLevel = function loadLevel (level) {
  if (this._activeLevel) {
    utils.walk(this._activeLevel, function (ent) {
      ent.destroy();
    });
  }

  this._activeLevel = level;
  this._activeLevel._app = this;
  this._activeLevel.activate();
};

/**
 *
 */
App.prototype.tick = function tick () {
    var this$1 = this;

  // tick all systems
  for (var i = 0; i < this._systems.length; ++i) {
    var sys = this$1._systems[i];
    sys.tick();
  }

  // post-tick all systems
  for (var i$1 = 0; i$1 < this._systems.length; ++i$1) {
    var sys$1 = this$1._systems[i$1];
    sys$1.postTick();
  }

  // handle dead components
  for (var i$2 = 0; i$2 < this._deadComponents.length; ++i$2) {
    var comp = this$1._deadComponents.data[i$2];

    comp._onComponentNeedDestroy();
    comp._entity._removeComp(comp);

    for (var j = 0; j < comp.__events__.length; ++j) {
      var evt = comp.__events__[j];
      comp._entity.off(evt.name, evt.fn);
    }

    // de-reference
    comp._app = null;
    comp._system = null;
    comp._entity = null;
  }

  // handle dead entities
  for (var i$3 = 0; i$3 < this._deadEntities.length; ++i$3) {
    var ent = this$1._deadEntities.data[i$3];

    // emit destroy event
    ent.emit('destroy');

    // removed from parent
    if (ent._parent && ent._parent._destroyed === false) {
      ent.setParent(null);
    }

    // unmanage it
    var lastEnt = this$1._entities.data[this$1._entities.length - 1];
    this$1._entities.fastRemove(ent._poolID);
    lastEnt._poolID = ent._poolID;

    // de-reference
    ent._poolID = -1;
    ent._app = null;
    ent._parent = null;
    ent._children.length = 0;
    ent._comps.length = 0;
  }

  // reset pool
  this._deadComponents.reset();
  this._deadEntities.reset();
};

/**
 * @param {string} id
 */
App.prototype.system = function system (id) {
    var this$1 = this;

  for (var i = 0; i < this._systems.length; ++i) {
    var sys = this$1._systems[i];
    if (sys._id === id) {
      return sys;
    }
  }

  return null;
};

// ====================
// internal
// ====================

App.prototype._getSystem = function _getSystem (comp) {
    var this$1 = this;

  for (var i = 0; i < this._systems.length; ++i) {
    var sys = this$1._systems[i];
    if (comp instanceof sys._componentCls) {
      return sys;
    }
  }

  return null;
};

App.prototype._destroyEntity = function _destroyEntity (ent) {

  this._deadEntities.push(ent);
};

App.prototype._finalizeComp = function _finalizeComp (comp, data, entities) {
  var ent = comp._entity;
  var proto = comp.constructor;

  // add event listeners
  while (proto.__classname__ !== undefined) {
    if (proto.hasOwnProperty('events')) {
      for (var name in proto.events) {
        var method = proto.events[name];
        var fn = comp[method];
        if (fn) {
          fn = fn.bind(comp);
          ent.on(name, fn);
          comp.__events__.push({ name: name, fn: fn });
        }
      }
    }
    proto = Object.getPrototypeOf(proto);
  }

  // parse schema data
  Schema.parse(this, comp, data, entities);
};

App.prototype._createComp = function _createComp (ctor, ent, data) {
    if ( data === void 0 ) data = {};

  var comp = new ctor();
  comp._app = this;
  comp._system = this._getSystem(comp);
  comp._entity = ent;
  comp.__events__ = [];

  this._finalizeComp(comp, data, null);

  return comp;
};

App.prototype._destroyComp = function _destroyComp (comp) {
  //
  this._deadComponents.push(comp);
};

App.prototype._sortSystems = function _sortSystems () {
  this._systems.sort(function (a, b) {
    return a._priority - b._priority;
  });
};

Object.defineProperties( App.prototype, prototypeAccessors$17 );

var _loaderInfos = [];
var _classInfos = [];
var _typeInfos = [];
var _systemInfos = [];

var registry = {
  registerLoader: function registerLoader(id, def) {
    _loaderInfos.push({
      id: id, def: def
    });
  },

  registerType: function registerType(id, def) {
    _typeInfos.push({
      id: id, def: def
    });
  },

  registerClass: function registerClass(id, def) {
    _classInfos.push({
      id: id, def: def
    });
  },

  registerSystem: function registerSystem(id, system, component, priority) {
    _systemInfos.push({
      id: id, system: system, component: component, priority: priority
    });
  },

  _init: function _init (app) {
    for (var i = 0; i < _loaderInfos.length; ++i) {
      var info = _loaderInfos[i];
      app._assetMng.registerLoader(info.id, info.def);
    }

    for (var i$1 = 0; i$1 < _typeInfos.length; ++i$1) {
      var info$1 = _typeInfos[i$1];
      app.registerType(info$1.id, info$1.def);
    }

    for (var i$2 = 0; i$2 < _classInfos.length; ++i$2) {
      var info$2 = _classInfos[i$2];
      app.registerClass(info$2.id, info$2.def);
    }

    for (var i$3 = 0; i$3 < _systemInfos.length; ++i$3) {
      var info$3 = _systemInfos[i$3];
      app.registerSystem(info$3.id, info$3.system, info$3.component, info$3.priority);
    }
  }
};

/**
 * (c) 2016 Mikola Lysenko. MIT License
 * https://github.com/regl-project/resl
 */

/* global XMLHttpRequest */
var configParameters = [
  'manifest',
  'onDone',
  'onProgress',
  'onError'
];

var manifestParameters = [
  'type',
  'src',
  'stream',
  'credentials',
  'parser'
];

var parserParameters = [
  'onData',
  'onDone'
];

var STATE_ERROR = -1;
var STATE_DATA = 0;
var STATE_COMPLETE = 1;

function raise(message) {
  throw new Error('resl: ' + message);
}

function checkType(object, parameters, name) {
  Object.keys(object).forEach(function (param) {
    if (parameters.indexOf(param) < 0) {
      raise('invalid parameter "' + param + '" in ' + name);
    }
  });
}

function Loader(name, cancel) {
  this.state = STATE_DATA;
  this.ready = false;
  this.progress = 0;
  this.name = name;
  this.cancel = cancel;
}

function resl(config) {
  if (typeof config !== 'object' || !config) {
    raise('invalid or missing configuration');
  }

  checkType(config, configParameters, 'config');

  var manifest = config.manifest;
  if (typeof manifest !== 'object' || !manifest) {
    raise('missing manifest');
  }

  function getFunction(name) {
    if (name in config) {
      var func = config[name];
      if (typeof func !== 'function') {
        raise('invalid callback "' + name + '"');
      }
      return func;
    }
    return null;
  }

  var onDone = getFunction('onDone');
  if (!onDone) {
    raise('missing onDone() callback');
  }

  var onProgress = getFunction('onProgress');
  var onError = getFunction('onError');

  var assets = {};

  var state = STATE_DATA;

  function loadXHR(request) {
    var name = request.name;
    var stream = request.stream;
    var binary = request.type === 'binary';
    var parser = request.parser;

    var xhr = new XMLHttpRequest();
    var asset = null;

    var loader = new Loader(name, cancel);

    if (stream) {
      xhr.onreadystatechange = onReadyStateChange;
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
          onReadyStateChange();
        }
      };
    }

    if (binary) {
      xhr.responseType = 'arraybuffer';
    }

    function onReadyStateChange() {
      if (xhr.readyState < 2 ||
        loader.state === STATE_COMPLETE ||
        loader.state === STATE_ERROR) {
        return;
      }
      if (xhr.status !== 200) {
        return abort('error loading resource "' + request.name + '"');
      }
      if (xhr.readyState > 2 && loader.state === STATE_DATA) {
        var response;
        if (request.type === 'binary') {
          response = xhr.response;
        } else {
          response = xhr.responseText;
        }
        if (parser.data) {
          try {
            asset = parser.data(response);
          } catch (e) {
            return abort(e);
          }
        } else {
          asset = response;
        }
      }
      if (xhr.readyState > 3 && loader.state === STATE_DATA) {
        if (parser.done) {
          try {
            asset = parser.done();
          } catch (e) {
            return abort(e);
          }
        }
        loader.state = STATE_COMPLETE;
      }
      assets[name] = asset;
      loader.progress = 0.75 * loader.progress + 0.25;
      loader.ready =
        (request.stream && !!asset) ||
        loader.state === STATE_COMPLETE;
      notifyProgress();
    }

    function cancel() {
      if (loader.state === STATE_COMPLETE || loader.state === STATE_ERROR) {
        return;
      }
      xhr.onreadystatechange = null;
      xhr.abort();
      loader.state = STATE_ERROR;
    }

    // set up request
    if (request.credentials) {
      xhr.withCredentials = true;
    }
    xhr.open('GET', request.src, true);
    xhr.send();

    return loader;
  }

  function loadElement(request, element) {
    var name = request.name;
    var parser = request.parser;

    var loader = new Loader(name, cancel);
    var asset = element;

    function handleProgress() {
      if (loader.state === STATE_DATA) {
        if (parser.data) {
          try {
            asset = parser.data(element);
          } catch (e) {
            return abort(e);
          }
        } else {
          asset = element;
        }
      }
    }

    function onProgress(e) {
      handleProgress();
      assets[name] = asset;
      if (e.lengthComputable) {
        loader.progress = Math.max(loader.progress, e.loaded / e.total);
      } else {
        loader.progress = 0.75 * loader.progress + 0.25;
      }
      notifyProgress(name);
    }

    function onComplete() {
      handleProgress();
      if (loader.state === STATE_DATA) {
        if (parser.done) {
          try {
            asset = parser.done();
          } catch (e) {
            return abort(e);
          }
        }
        loader.state = STATE_COMPLETE;
      }
      loader.progress = 1;
      loader.ready = true;
      assets[name] = asset;
      removeListeners();
      notifyProgress('finish ' + name);
    }

    function onError() {
      abort('error loading asset "' + name + '"');
    }

    if (request.stream) {
      element.addEventListener('progress', onProgress);
    }
    if (request.type === 'image') {
      element.addEventListener('load', onComplete);
    } else {
      var canPlay = false;
      var loadedMetaData = false;
      element.addEventListener('loadedmetadata', function () {
        loadedMetaData = true;
        if (canPlay) {
          onComplete();
        }
      });
      element.addEventListener('canplay', function () {
        canPlay = true;
        if (loadedMetaData) {
          onComplete();
        }
      });
    }
    element.addEventListener('error', onError);

    function removeListeners() {
      if (request.stream) {
        element.removeEventListener('progress', onProgress);
      }
      if (request.type === 'image') {
        element.addEventListener('load', onComplete);
      } else {
        element.addEventListener('canplay', onComplete);
      }
      element.removeEventListener('error', onError);
    }

    function cancel() {
      if (loader.state === STATE_COMPLETE || loader.state === STATE_ERROR) {
        return;
      }

      loader.state = STATE_ERROR;
      removeListeners();
      element.src = '';
    }

    // set up request
    if (request.credentials) {
      element.crossOrigin = 'use-credentials';
    } else {
      element.crossOrigin = 'anonymous';
    }
    element.src = request.src;

    return loader;
  }

  var loaders = {
    text: loadXHR,
    binary: function (request) {
      // TODO use fetch API for streaming if supported
      return loadXHR(request);
    },
    image: function (request) {
      return loadElement(request, document.createElement('img'));
    },
    video: function (request) {
      return loadElement(request, document.createElement('video'));
    },
    audio: function (request) {
      return loadElement(request, document.createElement('audio'));
    }
  };

  // First we parse all objects in order to verify that all type information
  // is correct
  var pending = Object.keys(manifest).map(function (name) {
    var request = manifest[name];
    if (typeof request === 'string') {
      request = {
        src: request
      };
    } else if (typeof request !== 'object' || !request) {
      raise('invalid asset definition "' + name + '"');
    }

    checkType(request, manifestParameters, 'asset "' + name + '"');

    function getParameter(prop, accepted, init) {
      var value = init;
      if (prop in request) {
        value = request[prop];
      }
      if (accepted.indexOf(value) < 0) {
        raise('invalid ' + prop + ' "' + value + '" for asset "' + name + '", possible values: ' + accepted);
      }
      return value;
    }

    function getString(prop, required, init) {
      var value = init;
      if (prop in request) {
        value = request[prop];
      } else if (required) {
        raise('missing ' + prop + ' for asset "' + name + '"');
      }
      if (typeof value !== 'string') {
        raise('invalid ' + prop + ' for asset "' + name + '", must be a string');
      }
      return value;
    }

    function getParseFunc(name, dflt) {
      if (name in request.parser) {
        var result = request.parser[name];
        if (typeof result !== 'function') {
          raise('invalid parser callback ' + name + ' for asset "' + name + '"');
        }
        return result;
      } else {
        return dflt;
      }
    }

    var parser = {};
    if ('parser' in request) {
      if (typeof request.parser === 'function') {
        parser = {
          data: request.parser
        };
      } else if (typeof request.parser === 'object' && request.parser) {
        checkType(request.parser, parserParameters, 'parser for asset "' + name + '"');
        if (!('onData' in request.parser)) {
          raise('missing onData callback for parser in asset "' + name + '"');
        }
        parser = {
          data: getParseFunc('onData'),
          done: getParseFunc('onDone')
        };
      } else {
        raise('invalid parser for asset "' + name + '"');
      }
    }

    return {
      name: name,
      type: getParameter('type', Object.keys(loaders), 'text'),
      stream: !!request.stream,
      credentials: !!request.credentials,
      src: getString('src', true, ''),
      parser: parser
    };
  }).map(function (request) {
    return (loaders[request.type])(request);
  });

  function abort(message) {
    if (state === STATE_ERROR || state === STATE_COMPLETE) {
      return;
    }
    state = STATE_ERROR;
    pending.forEach(function (loader) {
      loader.cancel();
    });
    if (onError) {
      if (typeof message === 'string') {
        onError(new Error('resl: ' + message));
      } else {
        onError(message);
      }
    } else {
      console.error('resl error:', message);
    }
  }

  function notifyProgress(message) {
    if (state === STATE_ERROR || state === STATE_COMPLETE) {
      return;
    }

    var progress = 0;
    var numReady = 0;
    pending.forEach(function (loader) {
      if (loader.ready) {
        numReady += 1;
      }
      progress += loader.progress;
    });

    if (numReady === pending.length) {
      state = STATE_COMPLETE;
      onDone(assets);
    } else {
      if (onProgress) {
        onProgress(progress / pending.length, message);
      }
    }
  }

  if (pending.length === 0) {
    setTimeout(function () {
      notifyProgress('done');
    }, 1);
  }
}

var _internal_id = -1;

var Asset = function Asset() {
  ++_internal_id;

  this._uuid = "internal-" + _internal_id;
  this._name = '';
  this._loaded = false;

  // TODO
  // this._caches = {}; // downloaded caches (for reload)
};

var prototypeAccessors$18 = { uuid: { configurable: true },name: { configurable: true } };

prototypeAccessors$18.uuid.get = function () {
  return this._uuid;
};

prototypeAccessors$18.name.get = function () {
  return this._name;
};

/**
 * Overwrite this if you have sub-assets
 */
Asset.prototype.subAsset = function subAsset (/*localID*/) {
  return null;
};

Asset.prototype.unload = function unload () {
  this._loaded = false;
};

Asset.prototype.reload = function reload () {
};

Asset.prototype.clone = function clone () {
};

Object.defineProperties( Asset.prototype, prototypeAccessors$18 );

var Mesh = (function (Asset$$1) {
  function Mesh() {
    Asset$$1.call(this);

    this._subMeshes = null; // [renderer.InputAssemblers]
    this._skinning = null; // {jointIndices, bindposes}

    this._minPos = null; // vec3
    this._maxPos = null; // vec3
  }

  if ( Asset$$1 ) Mesh.__proto__ = Asset$$1;
  Mesh.prototype = Object.create( Asset$$1 && Asset$$1.prototype );
  Mesh.prototype.constructor = Mesh;

  var prototypeAccessors = { skinning: { configurable: true },subMeshCount: { configurable: true } };

  Mesh.prototype.unload = function unload () {
    var this$1 = this;

    if (!this._loaded) {
      return;
    }

    // destroy vertex buffer
    this._subMeshes[0]._vertexBuffer.destroy();

    // destroy index buffers
    for (var i = 0; i < this._subMeshes.length; ++i) {
      var mesh = this$1._subMeshes[i];
      mesh._indexBuffer.destroy();
    }

    this._subMeshes = null;

    Asset$$1.prototype.unload.call(this);
  };

  prototypeAccessors.skinning.get = function () {
    return this._skinning;
  };

  prototypeAccessors.subMeshCount.get = function () {
    return this._subMeshes.length;
  };

  Mesh.prototype.getSubMesh = function getSubMesh (idx) {
    return this._subMeshes[idx];
  };

  Object.defineProperties( Mesh.prototype, prototypeAccessors );

  return Mesh;
}(Asset));

var Texture$2 = (function (Asset$$1) {
  function Texture(device) {
    Asset$$1.call(this);

    this._device = device;
    this._texture = null; // gfx.Texture2D | gfx.TextureCube
  }

  if ( Asset$$1 ) Texture.__proto__ = Asset$$1;
  Texture.prototype = Object.create( Asset$$1 && Asset$$1.prototype );
  Texture.prototype.constructor = Texture;

  return Texture;
}(Asset));

var gfxFilters = {
  'linear': gfx.FILTER_LINEAR,
  'nearest': gfx.FILTER_NEAREST,
};

var gfxWraps = {
  'repeat': gfx.WRAP_REPEAT,
  'clamp': gfx.WRAP_CLAMP,
  'mirror': gfx.WRAP_MIRROR,
};

var gfxTextureFmts = {
  // compress formats
  'rgb-dxt1': gfx.TEXTURE_FMT_RGB_DXT1,
  'rgba-dxt1': gfx.TEXTURE_FMT_RGBA_DXT1,
  'rgba-dxt3': gfx.TEXTURE_FMT_RGBA_DXT3,
  'rgba-dxt5': gfx.TEXTURE_FMT_RGBA_DXT5,
  'rgb-etc1': gfx.TEXTURE_FMT_RGB_ETC1,
  'rgb-pvrtc-2bppv1': gfx.TEXTURE_FMT_RGB_PVRTC_2BPPV1,
  'rgba-pvrtc-2bppv1': gfx.TEXTURE_FMT_RGBA_PVRTC_2BPPV1,
  'rgb-pvrtc-4bppv1': gfx.TEXTURE_FMT_RGB_PVRTC_4BPPV1,
  'rgba-pvrtc-4bppv1': gfx.TEXTURE_FMT_RGBA_PVRTC_4BPPV1,

  // normal formats
  'a8': gfx.TEXTURE_FMT_A8,
  'l8': gfx.TEXTURE_FMT_L8,
  'l8-a8': gfx.TEXTURE_FMT_L8_A8,
  'r5-g6-b5': gfx.TEXTURE_FMT_R5_G6_B5,
  'r5-g5-b5-a1': gfx.TEXTURE_FMT_R5_G5_B5_A1,
  'r4-g4-b4-a4': gfx.TEXTURE_FMT_R4_G4_B4_A4,
  'rgb8': gfx.TEXTURE_FMT_RGB8,
  'rgba8': gfx.TEXTURE_FMT_RGBA8,
  'rgb16f': gfx.TEXTURE_FMT_RGB16F,
  'rgba16f': gfx.TEXTURE_FMT_RGBA16F,
  'rgb32f': gfx.TEXTURE_FMT_RGB32F,
  'rgba32f': gfx.TEXTURE_FMT_RGBA32F,
  'r32f': gfx.TEXTURE_FMT_R32F,
  '111110f': gfx.TEXTURE_FMT_111110F,
  'srgb': gfx.TEXTURE_FMT_SRGB,
  'srgba': gfx.TEXTURE_FMT_SRGBA,

  // depth formats
  'd16': gfx.TEXTURE_FMT_D16,
  'd32': gfx.TEXTURE_FMT_D32,
  'd24s8': gfx.TEXTURE_FMT_D24S8,
};

var _opts = {
  images: [],
  mipmap: true,
  width: 2,
  height: 2,
  format: gfx.TEXTURE_FMT_RGBA8,
  anisotropy: 1,
  wrapS: gfx.WRAP_REPEAT,
  wrapT: gfx.WRAP_REPEAT,
  minFilter: gfx.FILTER_LINEAR,
  magFilter: gfx.FILTER_LINEAR,
  mipFilter: gfx.FILTER_LINEAR,
  premultiplyAlpha: false,
};

function _updateOpts(out, texture) {
  if (texture._writable) {
    out.images = [texture._data];
  } else {
    out.images = texture._images;
  }

  out.mipmap = texture._mipmap;
  out.width = texture._width;
  out.height = texture._height;
  out.format = gfxTextureFmts[texture._format];
  out.anisotropy = texture._anisotropy;
  out.wrapS = gfxWraps[texture._wrapS];
  out.wrapT = gfxWraps[texture._wrapT];
  out.minFilter = gfxFilters[texture._minFilter];
  out.magFilter = gfxFilters[texture._magFilter];
  out.mipFilter = gfxFilters[texture._mipFilter];
  out.premultiplyAlpha = texture._premultiplyAlpha;
}

function _allocData(texture) {
  if (texture._format === 'a8') {
    return new Uint8Array(texture._width * texture._height);
  } else if (texture._format === 'rgb8') {
    return new Uint8Array(texture._width * texture._height * 3);
  } else if (texture._format === 'rgba8') {
    return new Uint8Array(texture._width * texture._height * 4);
  } else if (texture._format === 'rgba32f') {
    return new Float32Array(texture._width * texture._height * 4);
  }

  return null;
}

var Texture2D$2 = (function (Texture) {
  function Texture2D(device, width, height, fmt) {
    if ( width === void 0 ) width = 2;
    if ( height === void 0 ) height = 2;
    if ( fmt === void 0 ) fmt = 'rgba8';

    Texture.call(this, device);

    //
    this._writable = false;
    this._data = null;

    // opts
    this._images = [];
    this._mipmap = true;
    this._width = width;
    this._height = height;
    this._format = fmt;
    this._anisotropy = 1;
    this._wrapS = 'repeat';
    this._wrapT = 'repeat';
    this._minFilter = 'linear';
    this._magFilter = 'linear';
    this._mipFilter = 'linear';
    this._premultiplyAlpha = false;
  }

  if ( Texture ) Texture2D.__proto__ = Texture;
  Texture2D.prototype = Object.create( Texture && Texture.prototype );
  Texture2D.prototype.constructor = Texture2D;

  var prototypeAccessors = { width: { configurable: true },height: { configurable: true },format: { configurable: true },data: { configurable: true },writable: { configurable: true },mipmap: { configurable: true },anisotropy: { configurable: true },wrapS: { configurable: true },wrapT: { configurable: true },minFilter: { configurable: true },magFilter: { configurable: true },mipFilter: { configurable: true },premultiplyAlpha: { configurable: true } };

  Texture2D.prototype.unload = function unload () {
    if (!this._loaded) {
      return;
    }

    this._texture.destroy();
    Texture.prototype.unload.call(this);
  };

  Texture2D.prototype.setImage = function setImage (level, img) {
    if (
      img instanceof HTMLCanvasElement ||
      img instanceof HTMLImageElement ||
      img instanceof HTMLVideoElement
    ) {
      this._images[level] = img;

      if (level === 0) {
        this.resize(img.width, img.height);
      }

      // TODO: if writable, get data by canvas.drawImage(), canvas.getImageData();
    }
  };

  Texture2D.prototype.setImages = function setImages (imgs) {
    this._images = imgs;
    this.resize(imgs[0].width, imgs[0].height);
  };

  Texture2D.prototype.resize = function resize (width, height) {
    this._width = width;
    this._height = height;

    if (this._writable) {
      this._data = _allocData(this);
    }
  };

  prototypeAccessors.width.get = function () {
    return this._width;
  };

  prototypeAccessors.height.get = function () {
    return this._height;
  };

  prototypeAccessors.format.get = function () {
    return this._format;
  };

  prototypeAccessors.data.get = function () {
    return this._data;
  };

  prototypeAccessors.writable.set = function (val) {
    this._writable = val;

    if (this._writable) {
      this._data = _allocData(this);
    } else {
      this._data = null;
    }
  };
  prototypeAccessors.writable.get = function () {
    return this._writable;
  };

  prototypeAccessors.mipmap.set = function (val) {
    this._mipmap = val;
  };
  prototypeAccessors.mipmap.get = function () {
    return this._mipmap;
  };

  prototypeAccessors.anisotropy.set = function (val) {
    this._anisotropy = val;
  };
  prototypeAccessors.anisotropy.get = function () {
    return this._anisotropy;
  };

  prototypeAccessors.wrapS.set = function (val) {
    this._wrapS = val;
  };
  prototypeAccessors.wrapS.get = function () {
    return this._wrapS;
  };

  prototypeAccessors.wrapT.set = function (val) {
    this._wrapT = val;
  };
  prototypeAccessors.wrapT.get = function () {
    return this._wrapT;
  };

  prototypeAccessors.minFilter.set = function (val) {
    this._minFilter = val;
  };
  prototypeAccessors.minFilter.get = function () {
    return this._minFilter;
  };

  prototypeAccessors.magFilter.set = function (val) {
    this._magFilter = val;
  };
  prototypeAccessors.magFilter.get = function () {
    return this._magFilter;
  };

  prototypeAccessors.mipFilter.set = function (val) {
    this._mipFilter = val;
  };
  prototypeAccessors.mipFilter.get = function () {
    return this._mipFilter;
  };

  prototypeAccessors.premultiplyAlpha.set = function (val) {
    this._premultiplyAlpha = val;
  };
  prototypeAccessors.premultiplyAlpha.get = function () {
    return this._premultiplyAlpha;
  };

  Texture2D.prototype.commit = function commit () {
    _updateOpts(_opts, this);
    if (!this._texture) {
      this._texture = new gfx.Texture2D(this._device, _opts);
    } else {
      this._texture.update(_opts);
    }
    this._images = [];
  };

  Object.defineProperties( Texture2D.prototype, prototypeAccessors );

  return Texture2D;
}(Texture$2));

function parallel(tasks, callback) {
  var length = tasks.length;
  if (length === 0) {
    callback(null);
  }

  var completed = 0;

  for (var i = 0; i < tasks.length; ++i) {
    var task = tasks[i];
    task(function (err) {
      if (err) {
        callback(err);
      } else if (++completed === length) {
        callback(null);
      }
    });
  }
}

var async = {
  parallel: parallel
};

function _applyModifications(json, modifications) {
  for (var i = 0; i < modifications.length; i++) {
    var mod = modifications[i];
    var ent = json.entities[mod.entity];
    var words = mod.property.split('.');

    if (words.length === 1) {
      ent[mod.property] = mod.value;
      continue;
    }

    var compInfo = null;
    for (var j = 0; j < ent.components.length; j++) {
      var expectType = words[0];
      var curComp = ent.components[j];
      if (curComp.type === expectType) {
        compInfo = curComp;
        break;
      }
    }

    if (compInfo === null) {
      console.warn(("Failed to apply modification for entity " + (ent.name) + ": component " + (words[0]) + " not found."));
      continue;
    }

    // TODO: generic the solution by:
    // let words = propPath.split('.')
    // foreach words: word.match(/(.*)\[(\d+)\]/)
    var propPath = words[1];
    var results = propPath.match(/(.*)\[(\d+)\]/);
    if (results) {
      var propName = results[1];
      var idx = parseInt(results[2]);
      compInfo.properties[propName][idx] = mod.value;
    } else {
      if (words[1] === 'enabled') {
        compInfo[words[1]] = mod.value;
      } else {
        compInfo.properties[words[1]] = mod.value;
      }
    }
  }

  return json;
}

/**
 * @param {App} app
 * @param {Entity} ent
 * @param {Object} info
 */
function createComponent(app, ent, info) {
  var ctor = app.getClass(info.type);
  if (!ctor) {
    var comp$1 = new Component();
    comp$1._app = app;
    comp$1._system = null;
    comp$1._entity = ent;
    comp$1.__events__ = [];
    if (info.enabled !== undefined) {
      comp$1._enabled = info.enabled;
    }
    console.error(("component type " + (info.type) + " not found."));
    return comp$1;
  }

  // DELME
  // const data = info.properties;
  // let comp = app._createComp(ctor, ent, data);
  var comp = new ctor();
  comp._app = app;
  comp._system = app._getSystem(comp);
  comp._entity = ent;
  comp.__events__ = [];
  if (info.enabled !== undefined) {
    comp._enabled = info.enabled;
  }

  // console.warn(`Failed to load component ${info.type}, parser not found.`);
  return comp;
}

/**
 * @param {App} app
 * @param {Object} info
 * @param {Level} level
 */
function createEntity(app, info, level) {
  // let ent = new Entity(info.name);
  // ent._app = app;
  var ent = app.createEntity(info.name, level);

  if (info.enabled !== undefined) {
    ent._active = info.enabled;
  }

  // if we don't have component, just return
  if (!info.components) {
    return ent;
  }

  // load components (async)
  ent._comps = new Array(info.components.length);

  for (var i = 0; i < info.components.length; ++i) {
    var compInfo = info.components[i];
    ent._comps[i] = createComponent(app, ent, compInfo);
  }

  return ent;
}

/**
 * @param {App} app
 * @param {Object} json
 * @param {Object[]} modifications
 * @param {Level} level
 */
function createPrefab(app, json, modifications, level) {
  // apply modificiations
  if (modifications) {
    json = JSON.parse(JSON.stringify(json));
    json = _applyModifications(json, modifications);
  }

  var entInfos = json.entities;
  var entities = new Array(json.entities.length);

  for (var i = 0; i < entInfos.length; ++i) {
    var entInfo = entInfos[i];
    if (entInfo.prefab) {
      // TODO: implement nested prefab
      // TODO: nested prefab needs prefabTree, which can help for detecting recursive reference
      console.warn('nested prefab have not implemented.');
    } else {
      entities[i] = createEntity(app, entInfo, level);
    }
  }

  finalize(app, entities, entInfos);

  return entities[0];
}

/**
 * @param {App} app
 * @param {object} json
 * @param {function} callback
 */
function preloadAssets(app, json, callback) {
  var assets = {};
  var uuids = json.preloads;
  var tasks = [];

  // push tasks
  var loop = function ( i ) {
    var uuid = uuids[i];
    tasks.push(function (done) {
      app.assets.load(uuid, function (err, asset) {
        if (err) {
          console.error(err);
          done();
          return;
        }

        assets[uuid] = asset;
        done();
      });
    });
  };

  for (var i = 0; i < uuids.length; ++i) loop( i );

  // load assets
  async.parallel(tasks, function (err) {
    callback(err, assets);
  });
}

/**
 * @param {App} app
 * @param {Array} entities
 * @param {Array} entityInfos
 */
function finalize(app, entities, entityInfos) {
  for (var i = 0; i < entityInfos.length; ++i) {
    var ent = entities[i];
    var entInfo = entityInfos[i];

    if (!ent) {
      continue;
    }

    if (entInfo.translation) {
      vec3.set(
        ent.lpos,
        entInfo.translation[0],
        entInfo.translation[1],
        entInfo.translation[2]
      );
    } else {
      vec3.set(ent.lpos, 0, 0, 0);
    }

    if (entInfo.rotation) {
      quat.set(
        ent.lrot,
        entInfo.rotation[0],
        entInfo.rotation[1],
        entInfo.rotation[2],
        entInfo.rotation[3]
      );
    } else {
      quat.set(ent.lrot, 0, 0, 0, 1);
    }

    if (entInfo.scale) {
      vec3.set(
        ent.lscale,
        entInfo.scale[0],
        entInfo.scale[1],
        entInfo.scale[2]
      );
    } else {
      vec3.set(ent.lscale, 1, 1, 1);
    }

    // append children
    if (entInfo.children) {
      for (var j = 0; j < entInfo.children.length; ++j) {
        var index = entInfo.children[j];
        ent.append(entities[index]);
      }
    }

    // init comps (events, schema)
    if (entInfo.components) {
      for (var i$1 = 0; i$1 < entInfo.components.length; ++i$1) {
        var comp = ent._comps[i$1];
        var compInfo = entInfo.components[i$1];

        app._finalizeComp(comp, compInfo.properties, entities);
      }
    }
  }
}

var ecsUtils = {
  createComponent: createComponent,
  createEntity: createEntity,
  createPrefab: createPrefab,
  preloadAssets: preloadAssets,
  finalize: finalize,
};

function parseLevel (app, json, callback) {
  ecsUtils.preloadAssets(app, json, function () {
    var entInfos = json.entities;
    var entities = new Array(json.entities.length);
    // add them to level
    var level = new Level();

    // create entities and prefabs
    for (var i = 0; i < entInfos.length; ++i) {
      var entInfo = entInfos[i];
      if (entInfo.prefab) {
        var prefab = app.assets.get(entInfo.prefab);
        if (!prefab) {
          console.error(("Failed to load prefab " + (entInfo.prefab)));
          continue;
        }

        entities[i] = prefab.instantiate(entInfo.modifications, level);
      } else {
        entities[i] = ecsUtils.createEntity(app, entInfo, level);
      }

      console.log(((entInfo.name) + " loaded"));
    }

    // finalize entities
    ecsUtils.finalize(app, entities, json.entities);

    for (var i$1 = 0; i$1 < json.children.length; ++i$1) {
      var idx = json.children[i$1];
      level.append(entities[idx]);
    }

    if (callback) {
      callback(null, level);
    }
  });
}

function createJointsTexture(app, skinning) {
  var jointCount = skinning.jointIndices.length;

  // set jointsTexture
  var size;
  if (jointCount > 256) {
    size = 64;
  } else if (jointCount > 64) {
    size = 32;
  } else if (jointCount > 16) {
    size = 16;
  } else {
    size = 8;
  }

  var texture = new Texture2D$2(app.device, size, size, 'rgba32f');
  texture.minFilter = 'nearest';
  texture.magFilter = 'nearest';
  texture.wrapS = 'clamp';
  texture.wrapT = 'clamp';
  texture.mipmap = false;
  texture.writable = true;
  texture.commit();

  return texture;
}

function createMesh(app, data) {
  var ia = renderer.createIA(app.device, data);
  var meshAsset = new Mesh();
  meshAsset._subMeshes = [ia];
  meshAsset._minPos = data.minPos;
  meshAsset._maxPos = data.maxPos;

  return meshAsset;
}

var utils$1 = {
  createJointsTexture: createJointsTexture,
  createMesh: createMesh,

  parseLevel: parseLevel,

  walk: utils.walk,
  flat: utils.flat,
  find: utils.find,
  Layers: Layers,
};

function _createTable$1() {
  var obj = Object.create(null);
  obj.__tmp__ = undefined;
  delete obj.__tmp__;

  return obj;
}

function _wrapCallback(localID, callback) {
  return function (err, asset) {
    if (err) {
      if (callback) {
        callback(err);
      }
      return;
    }

    if (callback) {
      // if we are requesting subAsset, go get it.
      if (localID) {
        asset = asset.subAsset(localID);
        if (!asset) {
          callback(new Error(("subasset " + localID + " not found.")));
          return;
        }
      }
      callback(null, asset);
    }
  };
}

var AssetTask = (function (EventEmitter) {
  function AssetTask() {
    EventEmitter.call(this);
  }

  if ( EventEmitter ) AssetTask.__proto__ = EventEmitter;
  AssetTask.prototype = Object.create( EventEmitter && EventEmitter.prototype );
  AssetTask.prototype.constructor = AssetTask;

  AssetTask.prototype.run = function run (assetMng, uuid, info) {
    var this$1 = this;

    assetMng.loadUrls(info.type, info.urls, function (err, asset) {
      // remove loadings
      delete assetMng._loadings[uuid];

      // emit error
      if (err) {
        this$1.emit('loaded', err);
        return;
      }

      // emit loaded
      asset._uuid = uuid;
      asset._loaded = true;
      assetMng.add(uuid, asset);

      this$1.emit('loaded', null, asset);
    });
  };

  return AssetTask;
}(EventEmitter));

var AssetMng = function AssetMng(app) {
  this._app = app;
  this._loaders = _createTable$1(); // asset type to loader
  this._assetInfos = _createTable$1(); // uuid to asset-infos
  this._assets = _createTable$1(); // uuid to asset
  this._loadings = _createTable$1(); // uuid to loading tasks
  this._levelInfos = _createTable$1(); // sceneName to scene file
};

AssetMng.prototype.registerLoader = function registerLoader (type, loader) {
  this._loaders[type] = loader;
};

AssetMng.prototype.registerAsset = function registerAsset (uuid, info) {
  if (this._assetInfos[uuid]) {
    console.warn(("asset " + uuid + " already registerred."));
    return;
  }

  this._assetInfos[uuid] = info;
};

AssetMng.prototype.registerLevel = function registerLevel (name, file) {
  if (this._levelInfos[name]) {
    console.warn(("level " + name + " is already registerred."));
    return;
  }

  this._levelInfos[name] = file;
};

AssetMng.prototype.loadLevel = function loadLevel (name, callback) {
  if (!this._levelInfos[name]) {
    console.error(("Cannot load scene " + name));
    callback && callback(new Error('loadFail'), null);
  } else {
    var app = this._app;
    resl({
      manifest: {
        sceneJson: {
          type: 'text',
          parser: JSON.parse,
          src: this._levelInfos[name]
        }
      },
      onDone: function onDone(data) {
        utils$1.parseLevel(
          app,
          data.sceneJson,
          function (err, level) {
            callback && callback(err, level);
          }
        );
      },
      onError: function onError(err) {
        callback && callback(err, null);
      }
    });
  }
};

AssetMng.prototype.add = function add (uuid, asset) {
  if (this._assets[uuid]) {
    console.warn(("Failed to add asset " + uuid + ", already exists."));
    return;
  }
  this._assets[uuid] = asset;
};

AssetMng.prototype.get = function get (uuid) {
  // if this is a sub-asset
  var subIdx = uuid.indexOf('@');

  if (subIdx === -1) {
    return this._assets[uuid];
  }

  var localID = uuid.substring(0, subIdx);
  uuid = uuid.substring(subIdx + 1);

  var asset = this._assets[uuid];
  if (asset && localID) {
    return asset.subAsset(localID);
  }

  return null;
};

AssetMng.prototype.load = function load (uuid, callback) {
  // if this is a sub-asset
  var subIdx = uuid.indexOf('@');
  var localID;

  if (subIdx !== -1) {
    localID = uuid.substring(0, subIdx);
    uuid = uuid.substring(subIdx + 1);
  }

  // check if asset loaded
  var asset = this._assets[uuid];
  if (asset) {
    // if we already loaded
    if (callback) {
      // if we are requesting subAsset, go get it.
      if (localID) {
        asset = asset.subAsset(localID);
        if (!asset) {
          callback(new Error(("subasset " + localID + " not found.")));
          return;
        }
      }

      callback(null, asset);
    }
    return;
  }

  // if this is a loading task
  var task = this._loadings[uuid];
  var taskCallback = _wrapCallback(localID, callback);
  if (task) {
    task.once('loaded', taskCallback);
    return;
  }

  // check if we have asset-info for loading asset
  var info = this._assetInfos[uuid];
  if (!info) {
    if (callback) {
      callback(new Error(("asset info " + uuid + " not found, please add it first.")));
    }
    return;
  }

  // create new task
  task = new AssetTask(this);
  this._loadings[uuid] = task;

  task.once('loaded', _wrapCallback(localID, callback));
  task.run(this, uuid, info);
};

AssetMng.prototype.loadUrls = function loadUrls (type, urls, callback) {
  var loader = this._loaders[type];
  if (!loader) {
    if (callback) {
      callback(new Error(("can not find loader for asset type " + type + ", please register it first.")));
    }

    return;
  }

  loader(this._app, urls, callback);
};

var damping = 10.0;
var moveSpeed = 10.0;

var v3_f = vec3.new(0, 0, -1);
var v3_r = vec3.new(1, 0, 0);
var v3_u = vec3.new(0, 1, 0);

var rot3x3 = mat3.create();

var front = vec3.zero();
var right = vec3.zero();
var up = vec3.new(0, 1, 0);
var front2 = vec3.zero();
var right2 = vec3.zero();

var OrbitCamera = function OrbitCamera(input) {
  this._input = input;
  this._node = new Node('debug-camera');
  vec3.set(this._node.lpos, 10, 10, 10);
  this._node.lookAt(vec3.new(0, 0, 0));

  this._df = 0;
  this._dr = 0;
  this._panX = 0;
  this._panY = 0;
  this._panZ = 0;
  this._rotX = 0;
  this._rotY = 0;

  this._curRot = quat.create();
  this._destRot = quat.create();

  this._curEye = vec3.zero();
  this._destEye = vec3.zero();

  this._node.getWorldRot(this._curRot);
  this._destRot = quat.clone(this._curRot);

  this._node.getWorldPos(this._curEye);
  this._destEye = vec3.clone(this._curEye);
};

OrbitCamera.prototype.reset = function reset () {
  this._df = 0;
  this._dr = 0;
  this._du = 0;
  this._panX = 0;
  this._panY = 0;
  this._panZ = 0;
  this._rotX = 0;
  this._rotY = 0;

  this._node.getWorldRot(this._curRot);
  this._destRot = quat.clone(this._curRot);

  this._node.getWorldPos(this._curEye);
  this._destEye = vec3.clone(this._curEye);
};

OrbitCamera.prototype.tick = function tick (dt) {
  var input = this._input;

  this._handleMouseAndKeyboard();

  if (input.hasTouch) {
    this._handleTouches();
  }
  this._lerp(dt);
};

OrbitCamera.prototype._handleMouseAndKeyboard = function _handleMouseAndKeyboard () {
  var input = this._input;

  this._df = 0;
  this._dr = 0;
  this._du = 0;
  this._panX = 0;
  this._panY = 0;
  this._panZ = 0;
  this._rotX = 0;
  this._rotY = 0;

  if (input.mousepress('left') && input.mousepress('right')) {
    var dx = input.mouseDeltaX;
    var dy = input.mouseDeltaY;

    this._panX = dx;
    this._panY = -dy;

  } else if (input.mousepress('left')) {
    var dx$1 = input.mouseDeltaX;
    var dy$1 = input.mouseDeltaY;

    this._rotY = -dx$1 * 0.002;
    this._panZ = -dy$1;

  } else if (input.mousepress('right')) {
    var dx$2 = input.mouseDeltaX;
    var dy$2 = input.mouseDeltaY;

    this._rotY = -dx$2 * 0.002;
    this._rotX = -dy$2 * 0.002;
  }

  if (input.keypress('w')) {
    this._df += 1;
  }
  if (input.keypress('s')) {
    this._df -= 1;
  }
  if (input.keypress('a')) {
    this._dr -= 1;
  }
  if (input.keypress('d')) {
    this._dr += 1;
  }
  if (input.keypress('q')) {
    this._du -= 1;
  }
  if (input.keypress('e')) {
    this._du += 1;
  }

  if (input.mouseScrollY) {
    this._df -= input.mouseScrollY * 0.05;
  }
};

OrbitCamera.prototype._handleTouches = function _handleTouches () {
  var input = this._input;

  this._df = 0;
  this._dr = 0;
  this._panX = 0;
  this._panY = 0;
  this._panZ = 0;
  this._rotX = 0;
  this._rotY = 0;

  if (input.touchCount === 1) {
    var touch = input.getTouchInfo(0);
    var dx = touch.dx;
    var dy = touch.dy;

    if (touch.prevX === 0 && touch.prevY === 0) {
      dx = 0;
      dy = 0;
    }

    this._rotY = -dx * 0.002;
    this._rotX = dy * 0.002;

  } else if (input.touchCount === 2) {
    var touch0 = input.getTouchInfo(0);
    var touch1 = input.getTouchInfo(1);
    var lenCur = Math.sqrt((touch0.x - touch1.x) * (touch0.x - touch1.x) + (touch0.y - touch1.y) * (touch0.y - touch1.y));
    var lenPrev = Math.sqrt((touch0.prevX - touch1.prevX) * (touch0.prevX - touch1.prevX) + (touch0.prevY - touch1.prevY) * (touch0.prevY - touch1.prevY));
    var dLen = Math.abs(lenCur - lenPrev);

    if ((touch0.dx != 0 || touch0.dy != 0) && (touch1.dx != 0 || touch1.dy != 0) && dLen < 100) {
      if (lenCur > lenPrev) {
        this._df += dLen;
      } else {
        this._df -= dLen;
      }
    }

    if (touch1.phase === 2 || touch0.phase === 2) {
      input.touchCount = 2;
    }

  } else if (input.touchCount === 3) {
    var touch0$1 = input.getTouchInfo(0);
    var dx$1 = touch0$1.dx;
    var dy$1 = touch0$1.dy;
    if (dx$1 < 100 && dy$1 < 100) {
      this._rotY = -dx$1 * 0.002;
      this._panZ = -dy$1;
    }
  }
};

OrbitCamera.prototype._lerp = function _lerp (dt) {
  var panX = this._panX;
  var panY = this._panY;
  var panZ = this._panZ;
  var eye = this._destEye;
  var rot = this._destRot;

  // calculate curRot
  quat.rotateX(rot, rot, this._rotX);
  quat.rotateAround(rot, rot, v3_u, this._rotY);
  quat.slerp(this._curRot, this._curRot, rot, dt * damping);

  // calculate curEye
  mat3.fromQuat(rot3x3, this._curRot);

  vec3.transformMat3(front, v3_f, rot3x3);
  vec3.transformMat3(right, v3_r, rot3x3);

  //
  if (this._df !== 0) {
    vec3.scaleAndAdd(eye, eye, front, this._df * dt * moveSpeed);
  }

  if (this._dr !== 0) {
    vec3.scaleAndAdd(eye, eye, right, this._dr * dt * moveSpeed);
  }

  if (this._du !== 0) {
    vec3.scaleAndAdd(eye, eye, up, this._du * dt * moveSpeed);
  }

  if (panZ !== 0) {
    vec3.copy(front2, front);
    front2.y = 0.0;
    vec3.normalize(front2, front2);
    vec3.scaleAndAdd(eye, eye, front2, panZ * dt * moveSpeed);
  }

  if (panX !== 0) {
    vec3.copy(right2, right);
    right2.y = 0.0;
    vec3.normalize(right2, right2);
    vec3.scaleAndAdd(eye, eye, right2, panX * dt * moveSpeed);
  }

  if (panY !== 0) {
    vec3.scaleAndAdd(eye, eye, v3_u, panY * dt * moveSpeed);
  }

  vec3.lerp(this._curEye, this._curEye, eye, dt * damping);

  //
  this._node.setWorldPos(this._curEye);
  this._node.setWorldRot(this._curRot);
};

/**
 * @param {Array} indices
 */
function wireframe(indices) {
  var offsets = [[0, 1], [1, 2], [2, 0]];
  var lines = [];
  var lineIDs = {};

  for (var i = 0; i < indices.length; i += 3) {
    for (var k = 0; k < 3; ++k) {
      var i1 = indices[i + offsets[k][0]];
      var i2 = indices[i + offsets[k][1]];

      // check if we already have the line in our lines
      var id = (i1 > i2) ? ((i2 << 16) | i1) : ((i1 << 16) | i2);
      if (lineIDs[id] === undefined) {
        lineIDs[id] = 0;
        lines.push(i1, i2);
      }
    }
  }

  return lines;
}

/**
 * @param {Array} positions
 * @param {Array} normals
 * @param {Number} length
 */
function normals(positions, normals, length) {
  if ( length === void 0 ) length = 1;

  var verts = new Array(2 * positions.length);

  for (var i = 0; i < positions.length/3; ++i) {
    var i3 = 3*i;
    var i6 = 6*i;

    // line start
    verts[i6 + 0] = positions[i3 + 0];
    verts[i6 + 1] = positions[i3 + 1];
    verts[i6 + 2] = positions[i3 + 2];

    // line end
    verts[i6 + 3] = positions[i3 + 0] + normals[i3 + 0] * length;
    verts[i6 + 4] = positions[i3 + 1] + normals[i3 + 1] * length;
    verts[i6 + 5] = positions[i3 + 2] + normals[i3 + 2] * length;
  }

  return verts;
}

var temp1 = vec3.zero();
var temp2 = vec3.zero();
var temp3 = vec3.zero();
var r = vec3.zero();
var c0 = vec3.zero();
var c1 = vec3.zero();
var c2 = vec3.zero();
var c3 = vec3.zero();
var c4 = vec3.zero();
var c5 = vec3.zero();
var c6 = vec3.zero();
var c7 = vec3.zero();

/**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} length
 * @param {Object} opts
 * @param {Number} opts.widthSegments
 * @param {Number} opts.heightSegments
 * @param {Number} opts.lengthSegments
 */
function box$2 (width, height, length, opts) {
  if ( width === void 0 ) width = 2;
  if ( height === void 0 ) height = 2;
  if ( length === void 0 ) length = 2;
  if ( opts === void 0 ) opts = {};

  var ws = opts.widthSegments !== undefined ? opts.widthSegments : 1;
  var hs = opts.heightSegments !== undefined ? opts.heightSegments : 1;
  var ls = opts.lengthSegments !== undefined ? opts.lengthSegments : 1;
  var inv = opts.invWinding !== undefined ? opts.invWinding : false;

  var hw = width * 0.5;
  var hh = height * 0.5;
  var hl = length * 0.5;

  var corners = [
    vec3.set(c0, -hw, -hh,  hl),
    vec3.set(c1,  hw, -hh,  hl),
    vec3.set(c2,  hw,  hh,  hl),
    vec3.set(c3, -hw,  hh,  hl),
    vec3.set(c4,  hw, -hh, -hl),
    vec3.set(c5, -hw, -hh, -hl),
    vec3.set(c6, -hw,  hh, -hl),
    vec3.set(c7,  hw,  hh, -hl) ];

  var faceAxes = [
    [ 0, 1, 3 ], // FRONT
    [ 4, 5, 7 ], // BACK
    [ 3, 2, 6 ], // TOP
    [ 1, 0, 4 ], // BOTTOM
    [ 1, 4, 2 ], // RIGHT
    [ 5, 0, 6 ]  // LEFT
  ];

  var faceNormals = [
    [  0,  0,  1 ], // FRONT
    [  0,  0, -1 ], // BACK
    [  0,  1,  0 ], // TOP
    [  0, -1,  0 ], // BOTTOM
    [  1,  0,  0 ], // RIGHT
    [ -1,  0,  0 ]  // LEFT
  ];

  var positions = [];
  var normals = [];
  var uvs = [];
  var indices = [];
  var minPos = vec3.new(-hw, -hh, -hl);
  var maxPos = vec3.new(hw, hh, hl);

  function _buildPlane (side, uSegments, vSegments) {
    var u, v;
    var ix, iy;
    var offset = positions.length / 3;
    var faceAxe = faceAxes[side];
    var faceNormal = faceNormals[side];

    for (iy = 0; iy <= vSegments; iy++) {
      for (ix = 0; ix <= uSegments; ix++) {
        u = ix / uSegments;
        v = iy / vSegments;

        vec3.lerp(temp1, corners[faceAxe[0]], corners[faceAxe[1]], u);
        vec3.lerp(temp2, corners[faceAxe[0]], corners[faceAxe[2]], v);
        vec3.sub(temp3, temp2, corners[faceAxe[0]]);
        vec3.add(r, temp1, temp3);

        positions.push(r.x, r.y, r.z);
        normals.push(faceNormal[0], faceNormal[1], faceNormal[2]);
        uvs.push(u, v);

        if ((ix < uSegments) && (iy < vSegments)) {
          var useg1 = uSegments + 1;
          var a = ix + iy * useg1;
          var b = ix + (iy + 1) * useg1;
          var c = (ix + 1) + (iy + 1) * useg1;
          var d = (ix + 1) + iy * useg1;

          if (inv) {
            indices.push(offset + a, offset + b, offset + d);
            indices.push(offset + d, offset + b, offset + c);
          } else {
            indices.push(offset + a, offset + d, offset + b);
            indices.push(offset + b, offset + d, offset + c);
          }
        }
      }
    }
  }

  _buildPlane(0, ws, hs); // FRONT
  _buildPlane(4, ls, hs); // RIGHT
  _buildPlane(1, ws, hs); // BACK
  _buildPlane(5, ls, hs); // LEFT
  _buildPlane(3, ws, ls); // BOTTOM
  _buildPlane(2, ws, ls); // TOP

  return {
    positions: positions,
    normals: normals,
    uvs: uvs,
    indices: indices,
    minPos: minPos,
    maxPos: maxPos
  };
}

var temp1$1 = vec3.zero();
var temp2$1 = vec3.zero();

/**
 * @param {Number} radiusTop
 * @param {Number} radiusBottom
 * @param {Number} height
 * @param {Object} opts
 * @param {Number} opts.radialSegments
 * @param {Number} opts.heightSegments
 * @param {Boolean} opts.capped
 * @param {Number} opts.arc
 */
function cylinder (radiusTop, radiusBottom, height, opts) {
  if ( radiusTop === void 0 ) radiusTop = 0.5;
  if ( radiusBottom === void 0 ) radiusBottom = 0.5;
  if ( height === void 0 ) height = 2;
  if ( opts === void 0 ) opts = {};

  var halfHeight = height * 0.5;
  var radialSegments = opts.radialSegments || 8;
  var heightSegments = opts.heightSegments || 1;
  var capped = opts.capped !== undefined ? opts.capped : true;
  var arc = opts.arc || 2.0 * Math.PI;

  var cntCap = 0;
  if (!capped) {
    if (radiusTop > 0) {
      cntCap++;
    }

    if (radiusBottom > 0) {
      cntCap++;
    }
  }

  // calculate vertex count
  var vertCount = (radialSegments + 1) * (heightSegments + 1);
  if (capped) {
    vertCount += ((radialSegments + 1) * cntCap) + (radialSegments * cntCap);
  }

  // calculate index count
  var indexCount = radialSegments * heightSegments * 2 * 3;
  if (capped) {
    indexCount += radialSegments * cntCap * 3;
  }

  var indices = new Array(indexCount);
  var positions = new Array(vertCount * 3);
  var normals = new Array(vertCount * 3);
  var uvs = new Array(vertCount * 2);
  var maxRadius = Math.max(radiusTop, radiusBottom);
  var minPos = vec3.new(-maxRadius, -halfHeight, -maxRadius);
  var maxPos = vec3.new(maxRadius, halfHeight, maxRadius);

  var index = 0;
  var indexOffset = 0;

  generateTorso();

  if (capped) {
    if (radiusBottom > 0) {
      generateCap(false);
    }

    if (radiusTop > 0) {
      generateCap(true);
    }
  }

  return {
    positions: positions,
    normals: normals,
    uvs: uvs,
    indices: indices,
    minPos: minPos,
    maxPos: maxPos
  };

  // =======================
  // internal fucntions
  // =======================

  function generateTorso() {
    var indexArray = [];

    // this will be used to calculate the normal
    var slope = (radiusTop - radiusBottom) / height;

    // generate positions, normals and uvs
    for (var y = 0; y <= heightSegments; y++) {
      var indexRow = [];
      var v = y / heightSegments;

      // calculate the radius of the current row
      var radius = v * (radiusTop - radiusBottom) + radiusBottom;

      for (var x = 0; x <= radialSegments; ++x) {
        var u = x / radialSegments;
        var theta = u * arc;

        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta);

        // vertex
        positions[3 * index] = radius * sinTheta;
        positions[3 * index + 1] = v * height - halfHeight;
        positions[3 * index + 2] = radius * cosTheta;

        // normal
        vec3.normalize(temp1$1, vec3.set(temp2$1, sinTheta, -slope, cosTheta));
        normals[3 * index] = temp1$1.x;
        normals[3 * index + 1] = temp1$1.y;
        normals[3 * index + 2] = temp1$1.z;

        // uv
        uvs[2 * index] = u;
        uvs[2 * index + 1] = v;

        // save index of vertex in respective row
        indexRow.push(index);

        // increase index
        ++index;
      }

      // now save positions of the row in our index array
      indexArray.push(indexRow);
    }

    // generate indices
    for (var y$1 = 0; y$1 < heightSegments; ++y$1) {
      for (var x$1 = 0; x$1 < radialSegments; ++x$1) {
        // we use the index array to access the correct indices
        var i1 = indexArray[y$1][x$1];
        var i2 = indexArray[y$1 + 1][x$1];
        var i3 = indexArray[y$1 + 1][x$1 + 1];
        var i4 = indexArray[y$1][x$1 + 1];

        // face one
        indices[indexOffset] = i1; ++indexOffset;
        indices[indexOffset] = i4; ++indexOffset;
        indices[indexOffset] = i2; ++indexOffset;

        // face two
        indices[indexOffset] = i4; ++indexOffset;
        indices[indexOffset] = i3; ++indexOffset;
        indices[indexOffset] = i2; ++indexOffset;
      }
    }
  }

  function generateCap(top) {
    var centerIndexStart, centerIndexEnd;

    var radius = top ? radiusTop : radiusBottom;
    var sign = top ? 1 : - 1;

    // save the index of the first center vertex
    centerIndexStart = index;

    // first we generate the center vertex data of the cap.
    // because the geometry needs one set of uvs per face,
    // we must generate a center vertex per face/segment

    for (var x = 1; x <= radialSegments; ++x) {
      // vertex
      positions[3 * index] = 0;
      positions[3 * index + 1] = halfHeight * sign;
      positions[3 * index + 2] = 0;

      // normal
      normals[3 * index] = 0;
      normals[3 * index + 1] = sign;
      normals[3 * index + 2] = 0;

      // uv
      uvs[2 * index] = 0.5;
      uvs[2 * index + 1] = 0.5;

      // increase index
      ++index;
    }

    // save the index of the last center vertex
    centerIndexEnd = index;

    // now we generate the surrounding positions, normals and uvs

    for (var x$1 = 0; x$1 <= radialSegments; ++x$1) {
      var u = x$1 / radialSegments;
      var theta = u * arc;

      var cosTheta = Math.cos(theta);
      var sinTheta = Math.sin(theta);

      // vertex
      positions[3 * index] = radius * sinTheta;
      positions[3 * index + 1] = halfHeight * sign;
      positions[3 * index + 2] = radius * cosTheta;

      // normal
      normals[3 * index] = 0;
      normals[3 * index + 1] = sign;
      normals[3 * index + 2] = 0;

      // uv
      uvs[2 * index] = 0.5 - (cosTheta * 0.5);
      uvs[2 * index + 1] = (sinTheta * 0.5 * sign) + 0.5;

      // increase index
      ++index;
    }

    // generate indices

    for (var x$2 = 0; x$2 < radialSegments; ++x$2) {
      var c = centerIndexStart + x$2;
      var i = centerIndexEnd + x$2;

      if (top) {
        // face top
        indices[indexOffset] = i + 1; ++indexOffset;
        indices[indexOffset] = c; ++indexOffset;
        indices[indexOffset] = i; ++indexOffset;
      } else {
        // face bottom
        indices[indexOffset] = c; ++indexOffset;
        indices[indexOffset] = i + 1; ++indexOffset;
        indices[indexOffset] = i; ++indexOffset;
      }
    }
  }
}

function cone (radius, height, opts) {
  if ( radius === void 0 ) radius = 0.5;
  if ( height === void 0 ) height = 1;
  if ( opts === void 0 ) opts = {};

  return cylinder(0, radius, height, opts);
}

var temp1$2 = vec3.zero();
var temp2$2 = vec3.zero();
var temp3$1 = vec3.zero();
var r$1 = vec3.zero();
var c00 = vec3.zero();
var c10 = vec3.zero();
var c01 = vec3.zero();

/**
 * @param {Number} width
 * @param {Number} length
 * @param {Object} opts
 * @param {Number} opts.widthSegments
 * @param {Number} opts.lengthSegments
 */
function plane$2 (width, length, opts) {
  if ( opts === void 0 ) opts = {};

  var uSegments = opts.widthSegments !== undefined ? opts.widthSegments : 5;
  var vSegments = opts.lengthSegments !== undefined ? opts.lengthSegments : 5;

  var hw = width * 0.5;
  var hl = length * 0.5;

  var positions = [];
  var normals = [];
  var uvs = [];
  var indices = [];
  var minPos = vec3.new(-hw, 0, -hl);
  var maxPos = vec3.new(hw, 0, hl);

  vec3.set(c00, -hw, 0,  hl);
  vec3.set(c10,  hw, 0,  hl);
  vec3.set(c01, -hw, 0, -hl);

  for (var y = 0; y <= vSegments; y++) {
    for (var x = 0; x <= uSegments; x++) {
      var u = x / uSegments;
      var v = y / vSegments;

      vec3.lerp(temp1$2, c00, c10, u);
      vec3.lerp(temp2$2, c00, c01, v);
      vec3.sub(temp3$1, temp2$2, c00);
      vec3.add(r$1, temp1$2, temp3$1);

      positions.push(r$1.x, r$1.y, r$1.z);
      normals.push(0, 1, 0);
      uvs.push(u, v);

      if ((x < uSegments) && (y < vSegments)) {
        var useg1 = uSegments + 1;
        var a = x + y * useg1;
        var b = x + (y + 1) * useg1;
        var c = (x + 1) + (y + 1) * useg1;
        var d = (x + 1) + y * useg1;

        indices.push(a, d, b);
        indices.push(d, c, b);
      }
    }
  }

  return {
    positions: positions,
    normals: normals,
    uvs: uvs,
    indices: indices,
    minPos: minPos,
    maxPos: maxPos
  };
}

var positions = [
  -0.5, -0.5, 0, // bottom-left
  -0.5,  0.5, 0, // top-left
   0.5,  0.5, 0, // top-right
   0.5, -0.5, 0 ];

var normals$1 = [
  0, 0, 1,
  0, 0, 1,
  0, 0, 1,
  0, 0, 1 ];

var uvs = [
  0, 0,
  0, 1,
  1, 1,
  1, 0 ];

var indices = [
  0, 3, 1,
  3, 2, 1
];

// TODO: ?
var minPos = vec3.new(-0.5, -0.5, 0);
var maxPos = vec3.new(0.5, 0.5, 0);

function quad () {
  return {
    positions: positions,
    indices: indices,
    normals: normals$1,
    uvs: uvs,
    minPos: minPos,
    maxPos: maxPos
  };
}

function sphere$2 (radius, opts) {
  if ( radius === void 0 ) radius = 1;
  if ( opts === void 0 ) opts = {};

  var segments = opts.segments !== undefined ? opts.segments : 16;

  // lat === latitude
  // lon === longitude

  var positions = [];
  var normals = [];
  var uvs = [];
  var indices = [];
  var minPos = vec3.new(-radius, -radius, -radius);
  var maxPos = vec3.new(radius, radius, radius);

  for (var lat = 0; lat <= segments; ++lat) {
    var theta = lat * Math.PI / segments;
    var sinTheta = Math.sin(theta);
    var cosTheta = -Math.cos(theta);

    for (var lon = 0; lon <= segments; ++lon) {
      var phi = lon * 2 * Math.PI / segments - Math.PI / 2.0;
      var sinPhi = Math.sin(phi);
      var cosPhi = Math.cos(phi);

      var x = sinPhi * sinTheta;
      var y = cosTheta;
      var z = cosPhi * sinTheta;
      var u = lon / segments;
      var v = lat / segments;

      positions.push(x * radius, y * radius, z * radius);
      normals.push(x, y, z);
      uvs.push(u, v);


      if ((lat < segments) && (lon < segments)) {
        var seg1 = segments + 1;
        var a = seg1 * lat + lon;
        var b = seg1 * (lat + 1) + lon;
        var c = seg1 * (lat + 1) + lon + 1;
        var d = seg1 * lat + lon + 1;

        indices.push(a, d, b);
        indices.push(d, c, b);
      }
    }
  }

  return {
    positions: positions,
    indices: indices,
    normals: normals,
    uvs: uvs,
    minPos: minPos,
    maxPos: maxPos
  };
}

function torus (radius, tube, opts) {
  if ( radius === void 0 ) radius = 0.5;
  if ( tube === void 0 ) tube = 0.2;
  if ( opts === void 0 ) opts = {};

  var radialSegments = opts.radialSegments || 30;
  var tubularSegments = opts.tubularSegments || 20;
  var arc = opts.arc || 2.0 * Math.PI;

  var positions = [];
  var normals = [];
  var uvs = [];
  var indices = [];
  var minPos = vec3.new(-radius - tube, -tube, -radius - tube);
  var maxPos = vec3.new(radius + tube, tube, radius + tube);

  for (var j = 0; j <= radialSegments; j++) {
    for (var i = 0; i <= tubularSegments; i++) {
      var u = i / tubularSegments;
      var v = j / radialSegments;

      var u1 = u * arc;
      var v1 = v * Math.PI * 2;

      // vertex
      var x = (radius + tube * Math.cos(v1)) * Math.sin(u1);
      var y = tube * Math.sin(v1);
      var z = (radius + tube * Math.cos(v1)) * Math.cos(u1);

      // this vector is used to calculate the normal
      var nx = Math.sin(u1) * Math.cos(v1);
      var ny = Math.sin(v1);
      var nz = Math.cos(u1) * Math.cos(v1);

      positions.push(x, y, z);
      normals.push(nx, ny, nz);
      uvs.push(u, v);

      if ((i < tubularSegments) && (j < radialSegments)) {
        var seg1 = tubularSegments + 1;
        var a = seg1 * j + i;
        var b = seg1 * (j + 1) + i;
        var c = seg1 * (j + 1) + i + 1;
        var d = seg1 * j + i + 1;

        indices.push(a, d, b);
        indices.push(d, c, b);
      }
    }
  }

  return {
    positions: positions,
    normals: normals,
    uvs: uvs,
    indices: indices,
    minPos: minPos,
    maxPos: maxPos
  };
}

var temp1$3 = vec3.zero();
var temp2$3 = vec3.zero();

/**
 * @param {Number} radiusTop
 * @param {Number} radiusBottom
 * @param {Number} height
 * @param {Object} opts
 * @param {Number} opts.sides
 * @param {Number} opts.heightSegments
 * @param {Boolean} opts.capped
 * @param {Number} opts.arc
 */
function capsule (radiusTop, radiusBottom, height, opts) {
  if ( radiusTop === void 0 ) radiusTop = 0.5;
  if ( radiusBottom === void 0 ) radiusBottom = 0.5;
  if ( height === void 0 ) height = 2;
  if ( opts === void 0 ) opts = {};

  var torsoHeight = height - radiusTop - radiusBottom;
  var sides = opts.sides || 16;
  var heightSegments = opts.heightSegments || 10;
  var bottomProp = radiusBottom / height;
  var torProp = torsoHeight / height;
  var topProp = radiusTop / height;
  var bottomSegments = Math.floor(heightSegments * bottomProp);
  var topSegments = Math.floor(heightSegments * topProp);
  var torSegments = Math.floor(heightSegments * torProp);
  var topOffset = torsoHeight + radiusBottom - height / 2;
  var torOffset = radiusBottom - height / 2;
  var bottomOffset = radiusBottom - height / 2;

  var arc = opts.arc || 2.0 * Math.PI;

  // calculate vertex count
  var positions = [];
  var normals = [];
  var uvs = [];
  var indices = [];
  var maxRadius = Math.max(radiusTop, radiusBottom);
  var minPos = vec3.new(-maxRadius, -height / 2, -maxRadius);
  var maxPos = vec3.new(maxRadius, height / 2, maxRadius);

  var index = 0;
  var indexArray = [];

  generateBottom();

  generateTorso();

  generateTop();

  return {
    positions: positions,
    normals: normals,
    uvs: uvs,
    indices: indices,
    minPos: minPos,
    maxPos: maxPos
  };

  // =======================
  // internal fucntions
  // =======================

  function generateTorso() {
    // this will be used to calculate the normal
    var slope = (radiusTop - radiusBottom) / torsoHeight;

    // generate positions, normals and uvs
    for (var y = 0; y <= torSegments; y++) {

      var indexRow = [];
      var lat = y / torSegments;
      var radius = lat * (radiusTop - radiusBottom) + radiusBottom;

      for (var x = 0; x <= sides; ++x) {
        var u = x / sides;
        var v = lat * torProp + bottomProp;
        var theta = u * arc - (arc / 4);

        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta);

        // vertex
        positions.push(radius * sinTheta);
        positions.push(lat * torsoHeight + torOffset);
        positions.push(radius * cosTheta);

        // normal
        vec3.normalize(temp1$3, vec3.set(temp2$3, sinTheta, -slope, cosTheta));
        normals.push(temp1$3.x);
        normals.push(temp1$3.y);
        normals.push(temp1$3.z);

        // uv
        uvs.push(u,v);
        // save index of vertex in respective row
        indexRow.push(index);

        // increase index
        ++index;
      }

      // now save positions of the row in our index array
      indexArray.push(indexRow);
    }

    // generate indices
    for (var y$1 = 0; y$1 < torSegments; ++y$1) {
      for (var x$1 = 0; x$1 < sides; ++x$1) {
        // we use the index array to access the correct indices
        var i1 = indexArray[y$1][x$1];
        var i2 = indexArray[y$1 + 1][x$1];
        var i3 = indexArray[y$1 + 1][x$1 + 1];
        var i4 = indexArray[y$1][x$1 + 1];

        // face one
        indices.push(i1);
        indices.push(i4);
        indices.push(i2);

        // face two
        indices.push(i4);
        indices.push(i3);
        indices.push(i2);
      }
    }
  }

  function generateBottom() {
    for (var lat = 0; lat <= bottomSegments; ++lat) {
      var theta = lat * Math.PI / bottomSegments / 2;
      var sinTheta = Math.sin(theta);
      var cosTheta = -Math.cos(theta);

      for (var lon = 0; lon <= sides; ++lon) {
        var phi = lon * 2 * Math.PI / sides - Math.PI / 2.0;
        var sinPhi = Math.sin(phi);
        var cosPhi = Math.cos(phi);

        var x = sinPhi * sinTheta;
        var y = cosTheta;
        var z = cosPhi * sinTheta;
        var u = lon / sides;
        var v = lat / heightSegments;

        positions.push(x * radiusBottom, y * radiusBottom + bottomOffset, z * radiusBottom);
        normals.push(x, y, z);
        uvs.push(u, v);

        if ((lat < bottomSegments) && (lon < sides)) {
          var seg1 = sides + 1;
          var a = seg1 * lat + lon;
          var b = seg1 * (lat + 1) + lon;
          var c = seg1 * (lat + 1) + lon + 1;
          var d = seg1 * lat + lon + 1;

          indices.push(a, d, b);
          indices.push(d, c, b);
        }

        ++index;
      }
    }
  }

  function generateTop() {
    for (var lat = 0; lat <= topSegments; ++lat) {
      var theta = lat * Math.PI / topSegments / 2 + Math.PI / 2;
      var sinTheta = Math.sin(theta);
      var cosTheta = -Math.cos(theta);

      for (var lon = 0; lon <= sides; ++lon) {
        var phi = lon * 2 * Math.PI / sides - Math.PI / 2.0;
        var sinPhi = Math.sin(phi);
        var cosPhi = Math.cos(phi);

        var x = sinPhi * sinTheta;
        var y = cosTheta;
        var z = cosPhi * sinTheta;
        var u = lon / sides;
        var v = lat / heightSegments + (1-topProp);

        positions.push(x * radiusTop, y * radiusTop + topOffset, z * radiusTop);
        normals.push(x, y, z);
        uvs.push(u, v);

        if ((lat < topSegments) && (lon < sides)) {
          var seg1 = sides + 1;
          var a = seg1 * lat + lon + indexArray[torSegments][sides] + 1;
          var b = seg1 * (lat + 1) + lon + indexArray[torSegments][sides] + 1;
          var c = seg1 * (lat + 1) + lon + 1 + indexArray[torSegments][sides] + 1;
          var d = seg1 * lat + lon + 1 + indexArray[torSegments][sides] + 1;

          indices.push(a, d, b);
          indices.push(d, c, b);
        }
      }
    }
  }
}



var primitives = Object.freeze({
	box: box$2,
	cone: cone,
	cylinder: cylinder,
	plane: plane$2,
	quad: quad,
	sphere: sphere$2,
	torus: torus,
	capsule: capsule,
	wireframe: wireframe,
	normals: normals
});

var _right = vec3.new(1, 0, 0);
var _up = vec3.new(0, 1, 0);
var _forward$1 = vec3.new(0, 0, 1);
var _v3_tmp$1 = vec3.zero();
var _v3_tmp2$1 = vec3.zero();
var _c3_tmp = color3.create();

var DrawMng = function DrawMng(app) {
  this._app = app;

  // debug view
  this._view2D = new renderer.View();
  this._view2D._clearFlags = 0;
  this._view2D._cullingByID = true;
  this._view2D._stages = [
    'opaque'
  ];

  this._lines = new LinkedArray(function () {
    return {
      start: vec3.zero(),
      end: vec3.zero(),
      color: color3.create(),
      duration: 0.0,
      depthTest: false,
      timer: 0.0,
      is2D: false,

      _prev: null,
      _next: null,
    };
  }, 2000);

  this._rects = new LinkedArray(function () {
    return {
      x: 0,
      y: 0,
      w: 1,
      h: 1,
      color: color3.create(),
      duration: 0.0,
      timer: 0.0,

      _prev: null,
      _next: null,
    };
  }, 2000);

  this._axesList = new LinkedArray(function () {
    return {
      pos: vec3.zero(),
      up: vec3.zero(),
      right: vec3.zero(),
      forward: vec3.zero(),
      duration: 0.0,
      depthTest: false,
      timer: 0.0,
      is2D: false,

      _prev: null,
      _next: null,
    };
  }, 2000);

  var wireframePass = new renderer.Pass('wireframe');
  wireframePass.setDepth(true, true);
  var wireframeTech = new renderer.Technique(
    ['opaque'],
    [
      { name: 'color', type: renderer.PARAM_COLOR3 }
    ],
    [wireframePass]
  );
  var wireframeEffect = new renderer.Effect([wireframeTech], {}, []);
  wireframeEffect.setProperty('color', color3.new(1, 1, 1));

  this._primitives = new LinkedArray(function () {
    return {
      model: (function () {
        var model = new renderer.Model();
        var node = new Node();
        model.setNode(node);
        model.setEffect(wireframeEffect);

        return model;
      })(),
      duration: 0.0,
      depthTest: false,
      timer: 0.0,

      _prev: null,
      _next: null,
    };
  }, 2000);

  var linePass = new renderer.Pass('line');
  linePass.setDepth(true, true);
  var lineTech = new renderer.Technique(
    ['opaque'],
    [],
    [linePass]
  );
  var lineEffect = new renderer.Effect([lineTech], {}, []);

  var lineBatchModel = new renderer.LineBatchModel();
  lineBatchModel.setNode(new Node('debug-lines'));
  lineBatchModel.setEffect(lineEffect);

  //
  var lineBatchModel2D = new renderer.LineBatchModel();
  lineBatchModel2D.setNode(new Node('debug-lines-2d'));
  lineBatchModel2D.setEffect(lineEffect);

  //
  var sphereData = sphere$2(1.0, {
    segments: 20,
  });
  sphereData.uvs = null;
  sphereData.indices = wireframe(sphereData.indices);
  this._sphereIA = renderer.createIA(app.device, sphereData);
  this._sphereIA._primitiveType = gfx.PT_LINES;

  //
  this._lineBatchModel = lineBatchModel;
  this._lineBatchModel2D = lineBatchModel2D;
};

DrawMng.prototype.start = function start () {
  this._app.scene.addView(this._view2D);
  this._app.scene.addModel(this._lineBatchModel);
  this._app.scene.addModel(this._lineBatchModel2D);
};

DrawMng.prototype.stop = function stop () {
    var this$1 = this;

  this._app.scene.removeView(this._view2D);
  this._app.scene.removeModel(this._lineBatchModel);
  this._app.scene.removeModel(this._lineBatchModel2D);

  this._primitives.forEach(function (item) {
    item.model.setInputAssembler(null);
    this$1._app.scene.removeModel(item.model);
    this$1._primitives.remove(item);
  });
};

/**
 *
 */
DrawMng.prototype.tick = function tick () {
    var this$1 = this;

  var dt = this._app.deltaTime;
  var canvasWidth = this._app._canvas.width;
  var canvasHeight = this._app._canvas.height;

  // update view
  mat4.ortho(this._view2D._matProj, 0, canvasWidth, 0, canvasHeight, -100, 100);
  mat4.copy(this._view2D._matViewProj, this._view2D._matProj);
  mat4.invert(this._view2D._matInvViewProj, this._view2D._matProj);
  this._view2D._rect.x = this._view2D._rect.y = 0;
  this._view2D._rect.w = canvasWidth;
  this._view2D._rect.h = canvasHeight;

  //
  this._lineBatchModel.clear();
  this._lineBatchModel2D.clear();
  this._lineBatchModel2D._viewID = this._view2D._id;

  // lines
  this._lines.forEach(function (item) {
    if (item.timer > item.duration) {
      this$1._lines.remove(item);
      return;
    }

    if (item.is2D) {
      this$1._lineBatchModel2D.addLine(item.start, item.end, item.color);
    } else if (item.depthTest) {
      this$1._lineBatchModel.addLine(item.start, item.end, item.color);
    } else {
      console.warn('We have not support it yet');
      // this._lineBatchModelNoDepth.addLine(start, end, color, duration);
    }

    item.timer += dt;
  });

  // rects
  this._rects.forEach(function (item) {
    if (item.timer > item.duration) {
      this$1._rects.remove(item);
      return;
    }

    this$1._lineBatchModel2D.addLine(
      vec3.set(_v3_tmp$1, item.x, item.y, 0.0),
      vec3.set(_v3_tmp2$1, item.x, item.y + item.h, 0.0),
      item.color
    );
    this$1._lineBatchModel2D.addLine(
      vec3.set(_v3_tmp$1, item.x, item.y + item.h, 0.0),
      vec3.set(_v3_tmp2$1, item.x + item.w, item.y + item.h, 0.0),
      item.color
    );
    this$1._lineBatchModel2D.addLine(
      vec3.set(_v3_tmp$1, item.x + item.w, item.y + item.h, 0.0),
      vec3.set(_v3_tmp2$1, item.x + item.w, item.y, 0.0),
      item.color
    );
    this$1._lineBatchModel2D.addLine(
      vec3.set(_v3_tmp$1, item.x + item.w, item.y, 0.0),
      vec3.set(_v3_tmp2$1, item.x, item.y, 0.0),
      item.color
    );

    item.timer += dt;
  });

  // axes list
  this._axesList.forEach(function (item) {
    if (item.timer > item.duration) {
      this$1._axesList.remove(item);
      return;
    }

    if (item.is2D) {
      this$1._lineBatchModel2D.addLine(item.pos, item.up, color3.set(_c3_tmp, 1, 0, 0));
      this$1._lineBatchModel2D.addLine(item.pos, item.right, color3.set(_c3_tmp, 0, 1, 0));
      this$1._lineBatchModel2D.addLine(item.pos, item.forward, color3.set(_c3_tmp, 0, 0, 1));
    } else if (item.depthTest) {
      this$1._lineBatchModel.addLine(item.pos, item.up, color3.set(_c3_tmp, 1, 0, 0));
      this$1._lineBatchModel.addLine(item.pos, item.right, color3.set(_c3_tmp, 0, 1, 0));
      this$1._lineBatchModel.addLine(item.pos, item.forward, color3.set(_c3_tmp, 0, 0, 1));
    } else {
      console.warn('We have not support it yet');
      // this._linesModelNoDepth.addLine(start, end, color, duration);
    }

    item.timer += dt;
  });

  // primitives
  this._primitives.forEach(function (item) {
    if (item.timer > item.duration) {
      item.model.setInputAssembler(null);
      this$1._app.scene.removeModel(item.model);

      this$1._primitives.remove(item);
      return;
    }

    item.timer += dt;
  });
};

DrawMng.prototype.addLine = function addLine (start, end, color, duration, depthTest, is2D) {
    if ( duration === void 0 ) duration = 0.0;
    if ( depthTest === void 0 ) depthTest = true;
    if ( is2D === void 0 ) is2D = false;

  var line = this._lines.add();

  vec3.copy(line.start, start);
  vec3.copy(line.end, end);
  color3.copy(line.color, color);
  line.duration = duration;
  line.depthTest = depthTest;
  line.timer = 0.0;
  line.is2D = is2D;

  if (is2D) {
    line.start.z = 0.0;
    line.end.z = 0.0;
  }
};

DrawMng.prototype.addRect2D = function addRect2D (x, y, width, height, color, duration) {
    if ( duration === void 0 ) duration = 0.0;

  var rect = this._rects.add();

  rect.x = x;
  rect.y = y;
  rect.w = width;
  rect.h = height;
  color3.copy(rect.color, color);
  rect.duration = duration;
  rect.timer = 0.0;
};

DrawMng.prototype.addAxes = function addAxes (pos, rotation, scale, duration, depthTest, is2D) {
    if ( duration === void 0 ) duration = 0.0;
    if ( depthTest === void 0 ) depthTest = true;
    if ( is2D === void 0 ) is2D = false;

  var axes = this._axesList.add();

  vec3.copy(axes.pos, pos);

  vec3.transformQuat(_v3_tmp$1, _right, rotation);
  vec3.scaleAndAdd(_v3_tmp$1, pos, _v3_tmp$1, scale), vec3.copy(axes.right, _v3_tmp$1);

  vec3.transformQuat(_v3_tmp$1, _up, rotation);
  vec3.scaleAndAdd(_v3_tmp$1, pos, _v3_tmp$1, scale), vec3.copy(axes.up, _v3_tmp$1);

  vec3.transformQuat(_v3_tmp$1, _forward$1, rotation);
  vec3.scaleAndAdd(_v3_tmp$1, pos, _v3_tmp$1, scale), vec3.copy(axes.forward, _v3_tmp$1);

  axes.duration = duration;
  axes.depthTest = depthTest;
  axes.timer = 0.0;
  axes.is2D = is2D;
};

DrawMng.prototype.addSphere = function addSphere (pos, radius, color, duration, depthTest) {
    if ( duration === void 0 ) duration = 0.0;
    if ( depthTest === void 0 ) depthTest = true;

  var primitive = this._primitives.add();
  primitive.model.setInputAssembler(this._sphereIA);
  vec3.copy(primitive.model._node.lpos, pos);
  vec3.set(primitive.model._node.lscale, radius, radius, radius);

  primitive.duration = duration;
  primitive.depthTest = depthTest;
  primitive.timer = 0.0;

  this._app.scene.addModel(primitive.model);
};

function createGrid(app, width, length, seg) {
  // create mesh
  var vertices = [];
  var hw = width * 0.5;
  var hl = length * 0.5;
  var dw = width / seg;
  var dl = length / seg;

  for (var x = -hw; x <= hw; x += dw) {
    vertices.push(x, 0, -hl);
    vertices.push(x, 0, hl);
  }

  for (var z = -hl; z <= hl; z += dl) {
    vertices.push(-hw, 0, z);
    vertices.push(hw, 0, z);
  }

  var ia = renderer.createIA(app.device, {
    positions: vertices
  });
  ia._primitiveType = gfx.PT_LINES;

  var simplePass = new renderer.Pass('simple');
  simplePass.setDepth(true, true);
  var simpleTech = new renderer.Technique(
    ['opaque'],
    [
      { name: 'color', type: renderer.PARAM_COLOR4 }
    ],
    [simplePass]
  );
  var simpleEffect = new renderer.Effect(
    [simpleTech],
    {},
    [
      { name: 'USE_TEXTURE', value: false },
      { name: 'USE_COLOR', value: true }
    ]
  );
  simpleEffect.define('USE_COLOR', true);
  simpleEffect.setProperty('color', color4.new(0.4, 0.4, 0.4, 1.0));

  var model = new renderer.Model();
  model.setInputAssembler(ia);
  model.setEffect(simpleEffect);
  model.setNode(new Node('debug-grid'));

  return model;
}

var Debugger = function Debugger(app) {
  this._state = 'sleep';
  this._app = app;
  this._drawMng = new DrawMng(app);
  this._debugInput = new Input(app._canvas, {
    lock: Input.LOCK_WHEN_PRESSED,
    invertY: true,
    enabled: false,
  });

  // debug camera
  this._orbit = new OrbitCamera(this._debugInput);
  this._camera = new renderer.Camera();
  this._camera.setColor(0.3, 0.3, 0.3, 1);
  this._camera.setNode(this._orbit._node);
  this._camera.setStages([
    'opaque',
    'transparent'
  ]);

  // grid
  this._grid = createGrid(app, 100, 100, 100);
};

Debugger.prototype.start = function start () {
  if (this._state !== 'sleep') {
    return;
  }

  this._state = 'enter';
};

Debugger.prototype.stop = function stop () {
  if (this._state === 'sleep') {
    return;
  }

  this._state = 'fade2normal';
};

Debugger.prototype.tick = function tick () {
  if (this._state === 'sleep') {
    return;
  }

  var name = "_" + (this._state);
  var fn = this[name];
  if (!fn) {
    console.warn(("Unknown state " + (this._state)));
    return;
  }

  this[name]();
};

Debugger.prototype.postTick = function postTick () {
  // update draw-mng before rendering after all systems ticked
  this._drawMng.tick();
};

// ====================
// debug draw
// ====================

Debugger.prototype.drawLine = function drawLine (start, end, color, duration, depthTest) {
  if ( this._state !== 'debug') {
    return;
  }
  this._drawMng.addLine(start, end, color, duration, depthTest, false);
};

Debugger.prototype.drawLine2D = function drawLine2D (start, end, color, duration) {
  if ( this._state !== 'debug') {
    return;
  }
  this._drawMng.addLine(start, end, color, duration, false, true);
};

Debugger.prototype.drawRect = function drawRect (x, y, w, h, color, duration) {
  if ( this._state !== 'debug') {
    return;
  }
  this._drawMng.addRect2D(x, y, w, h, color, duration);
};

Debugger.prototype.drawAxes = function drawAxes (pos, rotation, scale, duration, depthTest) {
  if ( this._state !== 'debug') {
    return;
  }
  this._drawMng.addAxes(pos, rotation, scale, duration, depthTest, false);
};

Debugger.prototype.drawAxes2D = function drawAxes2D (pos, rotation, scale, duration) {
  if ( this._state !== 'debug') {
    return;
  }
  this._drawMng.addAxes(pos, rotation, scale, duration, false, true);
};

Debugger.prototype.drawSphere = function drawSphere (pos, radius, color, duration, depthTest) {
  if ( this._state !== 'debug') {
    return;
  }
  this._drawMng.addSphere(pos, radius, color, duration, depthTest);
};

// ====================
// internal states
// ====================

Debugger.prototype._enter = function _enter () {
  var mainCam = null;
  utils$1.walk(this._app.activeLevel, function (ent) {
    mainCam = ent.getComp('Camera');
    if (mainCam) {
      return false;
    }
    return true;
  });

  if (!mainCam) {
    return;
  }

  this._app.input.enabled = false;
  this._debugInput.enabled = true;

  // setup debug camera
  vec3.copy(this._orbit._node.lpos, mainCam._entity.lpos);
  quat.copy(this._orbit._node.lrot, mainCam._entity.lrot);
  vec3.copy(this._orbit._node.lscale, mainCam._entity.lscale);
  this._orbit.reset();
  this._app.scene.setDebugCamera(this._camera);

  //
  this._app.scene.addModel(this._grid);

  //
  this._drawMng.start();

  //
  this._state = 'fade2debug';
};

Debugger.prototype._fade2debug = function _fade2debug () {
  this._state = 'debug';
};

Debugger.prototype._debug = function _debug () {
  var dt = this._app.deltaTime;

  // update orbit camera
  this._orbit.tick(dt);
  this._debugInput.reset();
};

Debugger.prototype._fade2normal = function _fade2normal () {
  this._state = 'exit';
};

Debugger.prototype._exit = function _exit () {
  this._debugInput.enabled = false;
  this._app.input.enabled = true;

  this._app.scene.removeModel(this._grid);

  // restore runtime states
  this._app.scene.setDebugCamera(null);

  //
  this._drawMng.stop();

  //
  this._state = 'sleep';
};

function _objArrayClone(val) {
  return val.map(function (obj) { return Object.assign({}, obj); });
}

var Material = (function (Asset$$1) {
  function Material() {
    Asset$$1.call(this);

    this._props = {};
    this._effectInst = null; // renderer.effect
    this._effect = null; // effect asset
  }

  if ( Asset$$1 ) Material.__proto__ = Asset$$1;
  Material.prototype = Object.create( Asset$$1 && Asset$$1.prototype );
  Material.prototype.constructor = Material;

  var prototypeAccessors = { effect: { configurable: true },effectInst: { configurable: true } };

  Material.prototype._updateEffectInst = function _updateEffectInst () {
    var this$1 = this;

    var techNum = this._effect.techniques.length;
    var techniques = new Array(techNum);
    var props = {};

    for (var j = 0; j < techNum; ++j) {
      var tech = this$1._effect.techniques[j];

      for (var k = 0; k < tech.params.length; ++k) {
        var param = tech.params[k];
        switch(param.type) {
          case renderer.PARAM_FLOAT:
            props[param.name] = param.value;
            break;
          case renderer.PARAM_FLOAT2:
            props[param.name] = vec2.new(param.value[0], param.value[1]);
            break;
          case renderer.PARAM_FLOAT3:
            props[param.name] = vec3.new(param.value[0], param.value[1], param.value[2]);
            break;
          case renderer.PARAM_FLOAT4:
            props[param.name] = vec4.new(param.value[0], param.value[1], param.value[2], param.value[3]);
            break;
          case renderer.PARAM_COLOR3:
            props[param.name] = color3.new(param.value[0], param.value[1], param.value[2]);
            break;
          case renderer.PARAM_COLOR4:
            props[param.name] = color4.new(param.value[0], param.value[1], param.value[2], param.value[3]);
            break;
          case renderer.PARAM_TEXTURE_2D:
          case renderer.PARAM_TEXTURE_CUBE:
            props[param.name] = null;
            break;
          default:
            console.warn('unsupport param type in effect json.');
        }
      }

      var passNum = tech.passes.length;
      var passes = new Array(passNum);
      for (var k$1 = 0; k$1 < passNum; ++k$1) {
        var pass = tech.passes[k$1];
        passes[k$1] = new renderer.Pass(pass.program);
        if (pass.depthTest !== undefined && pass.depthWrite !== undefined) {
          passes[k$1].setDepth(pass.depthTest, pass.depthWrite);
        }
        if (pass.cullMode !== undefined) {
          passes[k$1].setCullMode(pass.cullMode);
        }
        if (pass.blend === true) {
          passes[k$1].setBlend(pass.blendEq, pass.blendSrc, pass.blendDst, pass.blendAlphaEq, pass.blendSrcAlpha, pass.blendDstAlpha);
        }
      }

      techniques[j] = new renderer.Technique(tech.stages, tech.params, passes, tech.layer);
    }

    for (var name in props) {
      this$1._props[name] = props[name];
    }

    // reset material's props
    var defs = _objArrayClone(this._effect.defines);
    var deps = _objArrayClone(this._effect.dependencies);

    if (this._effectInst) {
      this._effectInst.clear();
      this._effectInst._techniques = techniques;
      this._effectInst._properties = props;
      this._effectInst._defines = defs;
      this._effectInst._dependencies = deps;
    } else {
      this._effectInst = new renderer.Effect(techniques, props, defs, deps);
    }
  };

  prototypeAccessors.effect.get = function () {
    return this._effect;
  };
  prototypeAccessors.effect.set = function (val) {
    if (this._effect !== val) {
      this._effect = val;
      this._updateEffectInst();
    }
  };

  prototypeAccessors.effectInst.get = function () {
    return this._effectInst;
  };

  Material.prototype.copy = function copy (mat) {
    var this$1 = this;

    if (this._effect !== mat._effect) {
      this._effect = mat._effect;
      this._updateEffectInst();
    }

    this._effectInst._defines = _objArrayClone(mat._effectInst._defines);
    this._effectInst._dependencies = _objArrayClone(mat._effectInst._dependencies);
    for (var name in mat._props) {
      this$1.setProperty(name, mat._props[name]);
    }
  };

  Material.prototype.setProperty = function setProperty (name, val) {
    this._props[name] = val;

    if (val instanceof Texture$2) {
      this._effectInst.setProperty(name, val._texture);
    } else {
      this._effectInst.setProperty(name, val);
    }
  };

  Material.prototype.define = function define (name, val) {
    this._effectInst.define(name, val);
  };

  Material.prototype.unload = function unload () {
    if (!this._loaded) {
      return;
    }

    // TODO: what should we do here ???

    Asset$$1.prototype.unload.call(this);
  };

  Object.defineProperties( Material.prototype, prototypeAccessors );

  return Material;
}(Asset));

var _opts$1 = {
  images: [],
  mipmap: true,
  width: 2,
  height: 2,
  format: gfx.TEXTURE_FMT_RGBA8,
  anisotropy: 1,
  wrapS: gfx.WRAP_REPEAT,
  wrapT: gfx.WRAP_REPEAT,
  minFilter: gfx.FILTER_LINEAR,
  magFilter: gfx.FILTER_LINEAR,
  mipFilter: gfx.FILTER_LINEAR,
};

function _updateOpts$1(out, texture) {
  out.images = texture._images;
  out.mipmap = texture._mipmap;
  out.width = texture._width;
  out.height = texture._height;
  out.format = gfxTextureFmts[texture._format];
  out.anisotropy = texture._anisotropy;
  out.wrapS = gfxWraps[texture._wrapS];
  out.wrapT = gfxWraps[texture._wrapT];
  out.minFilter = gfxFilters[texture._minFilter];
  out.magFilter = gfxFilters[texture._magFilter];
  out.mipFilter = gfxFilters[texture._mipFilter];
}

var TextureCube$2 = (function (Texture) {
  function TextureCube(device, width, height, fmt) {
    if ( width === void 0 ) width = 2;
    if ( height === void 0 ) height = 2;
    if ( fmt === void 0 ) fmt = 'rgba8';

    Texture.call(this, device);

    //
    this._images = [];
    this._mipmap = true;
    this._width = width;
    this._height = height;
    this._format = fmt;
    this._anisotropy = 1;
    this._wrapS = 'repeat';
    this._wrapT = 'repeat';
    this._minFilter = 'linear';
    this._magFilter = 'linear';
    this._mipFilter = 'linear';
  }

  if ( Texture ) TextureCube.__proto__ = Texture;
  TextureCube.prototype = Object.create( Texture && Texture.prototype );
  TextureCube.prototype.constructor = TextureCube;

  var prototypeAccessors = { width: { configurable: true },height: { configurable: true },mipmap: { configurable: true },anisotropy: { configurable: true },wrapS: { configurable: true },wrapT: { configurable: true },minFilter: { configurable: true },magFilter: { configurable: true },mipFilter: { configurable: true } };

  TextureCube.prototype.unload = function unload () {
    if (!this._loaded) {
      return;
    }

    this._texture.destroy();
    Texture.prototype.unload.call(this);
  };

  TextureCube.prototype.setImages = function setImages (imgs) {
    this._images = imgs;
    this.resize(imgs[0][0].width, imgs[0][0].height);
  };

  TextureCube.prototype.resize = function resize (width, height) {
    this._width = width;
    this._height = height;
  };

  prototypeAccessors.width.get = function () {
    return this._width;
  };

  prototypeAccessors.height.get = function () {
    return this._height;
  };

  prototypeAccessors.mipmap.set = function (val) {
    this._mipmap = val;
  };
  prototypeAccessors.mipmap.get = function () {
    return this._mipmap;
  };

  prototypeAccessors.anisotropy.set = function (val) {
    this._anisotropy = val;
  };
  prototypeAccessors.anisotropy.get = function () {
    return this._anisotropy;
  };

  prototypeAccessors.wrapS.set = function (val) {
    this._wrapS = val;
  };
  prototypeAccessors.wrapS.get = function () {
    return this._wrapS;
  };

  prototypeAccessors.wrapT.set = function (val) {
    this._wrapT = val;
  };
  prototypeAccessors.wrapT.get = function () {
    return this._wrapT;
  };

  prototypeAccessors.minFilter.set = function (val) {
    this._minFilter = val;
  };
  prototypeAccessors.minFilter.get = function () {
    return this._minFilter;
  };

  prototypeAccessors.magFilter.set = function (val) {
    this._magFilter = val;
  };
  prototypeAccessors.magFilter.get = function () {
    return this._magFilter;
  };

  prototypeAccessors.mipFilter.set = function (val) {
    this._mipFilter = val;
  };
  prototypeAccessors.mipFilter.get = function () {
    return this._mipFilter;
  };

  TextureCube.prototype.commit = function commit () {
    _updateOpts$1(_opts$1, this);
    if (!this._texture) {
      this._texture = new gfx.TextureCube(this._device, _opts$1);
    } else {
      this._texture.update(_opts$1);
    }
    this._images = [];
  };

  Object.defineProperties( TextureCube.prototype, prototypeAccessors );

  return TextureCube;
}(Texture$2));

var Effect$2 = (function (Asset$$1) {
  function Effect() {
    Asset$$1.call(this);

    // effect disc
    this._techniques = [];
    this._properties = {};
    this._defines = [];
    this._dependencies = [];
  }

  if ( Asset$$1 ) Effect.__proto__ = Asset$$1;
  Effect.prototype = Object.create( Asset$$1 && Asset$$1.prototype );
  Effect.prototype.constructor = Effect;

  var prototypeAccessors = { techniques: { configurable: true },properties: { configurable: true },defines: { configurable: true },dependencies: { configurable: true } };

  prototypeAccessors.techniques.set = function (val) {
    this._techniques = val;
  };

  prototypeAccessors.techniques.get = function () {
    return this._techniques;
  };

  prototypeAccessors.properties.set = function (val) {
    this._properties = val;
  };

  prototypeAccessors.properties.get = function () {
    return this._properties;
  };

  prototypeAccessors.defines.set = function (val) {
    this._defines = val;
  };

  prototypeAccessors.defines.get = function () {
    return this._defines;
  };

  prototypeAccessors.dependencies.set = function (val) {
    this._dependencies = val;
  };

  prototypeAccessors.dependencies.get = function () {
    return this._dependencies;
  };

  Effect.prototype.unload = function unload () {
    if (!this._loaded) {
      return;
    }

    // TODO: what should we do here ???

    Asset$$1.prototype.unload.call(this);
  };

  Object.defineProperties( Effect.prototype, prototypeAccessors );

  return Effect;
}(Asset));

var _t_tmp = vec3.zero();
var _s_tmp = vec3.zero();
var _mat4_tmp = mat4.create();
var _textureMatrix = mat4.create();

var Sprite = (function (Asset$$1) {
  function Sprite() {
    var this$1 = this;

    Asset$$1.call(this);

    this._texture = null;
    this._x = 0;
    this._y = 0;
    this._width = 64;
    this._height = 64;
    this._rotated = false;

    // sliced information
    this._left = 0;
    this._right = 0;
    this._top = 0;
    this._bottom = 0;

    // cached 16 uvs
    /**
     * uv12  uv13  uv14  uv15
     * uv08  uv09  uv10  uv11
     * uv04  uv05  uv06  uv07
     * uv00  uv01  uv02  uv03
     */

    // ues vec3 for uv to make it better use mat4 texture matrix
    this._uvs = new Array(16);
    for (var i = 0; i < 16; ++i) {
      this$1._uvs[i] = vec3.zero();
    }
  }

  if ( Asset$$1 ) Sprite.__proto__ = Asset$$1;
  Sprite.prototype = Object.create( Asset$$1 && Asset$$1.prototype );
  Sprite.prototype.constructor = Sprite;

  var prototypeAccessors = { texture: { configurable: true },x: { configurable: true },y: { configurable: true },width: { configurable: true },height: { configurable: true },rotated: { configurable: true },left: { configurable: true },right: { configurable: true },top: { configurable: true },bottom: { configurable: true },uvs: { configurable: true } };

  prototypeAccessors.texture.get = function () {
    return this._texture;
  };
  prototypeAccessors.texture.set = function (val) {
    this._texture = val;
  };

  prototypeAccessors.x.get = function () {
    return this._x;
  };
  prototypeAccessors.x.set = function (val) {
    this._x = val;
  };

  prototypeAccessors.y.get = function () {
    return this._y;
  };
  prototypeAccessors.y.set = function (val) {
    this._y = val;
  };

  prototypeAccessors.width.get = function () {
    return this._width;
  };
  prototypeAccessors.width.set = function (val) {
    this._width = val;
  };

  prototypeAccessors.height.get = function () {
    return this._height;
  };
  prototypeAccessors.height.set = function (val) {
    this._height = val;
  };

  prototypeAccessors.rotated.get = function () {
    return this._rotated;
  };
  prototypeAccessors.rotated.set = function (val) {
    this._rotated = val;
  };

  prototypeAccessors.left.get = function () {
    return this._left;
  };
  prototypeAccessors.left.set = function (val) {
    this._left = val;
  };

  prototypeAccessors.right.get = function () {
    return this._right;
  };
  prototypeAccessors.right.set = function (val) {
    this._right = val;
  };

  prototypeAccessors.top.get = function () {
    return this._top;
  };
  prototypeAccessors.top.set = function (val) {
    this._top = val;
  };

  prototypeAccessors.bottom.get = function () {
    return this._bottom;
  };
  prototypeAccessors.bottom.set = function (val) {
    this._bottom = val;
  };

  prototypeAccessors.uvs.get = function () {
    return this._uvs;
  };

  // commit values and calculated cached values
  Sprite.prototype.commit = function commit () {
    var this$1 = this;

    // todo: check if some value exceeds the bounds, such as x < 0, or x + width > texture.width

    var textureWidth = this._texture.width;
    var textureHeight = this._texture.height;

    // calculate texture matrix
    /**
     * if sprite is rotated
     * 3----4  is rotated to 1----3
     * |    |                |    |
     * |    |                |    |
     * 1----2                2----4
     */
    if (this._rotated) {
      vec3.set(_s_tmp, this._width, this._height, 1.0);
      mat4.fromScaling(_textureMatrix, _s_tmp);
      mat4.fromZRotation(_mat4_tmp, -Math.PI / 2);
      mat4.multiply(_textureMatrix, _mat4_tmp, _textureMatrix);

      vec3.set(_t_tmp, this._x, textureHeight - this._y, 0.0);
      mat4.fromTranslation(_mat4_tmp, _t_tmp);
      mat4.multiply(_textureMatrix, _mat4_tmp, _textureMatrix);

      vec3.set(_s_tmp, 1 / textureWidth, 1 / textureHeight, 1.0);
      mat4.fromScaling(_mat4_tmp, _s_tmp);
      mat4.multiply(_textureMatrix, _mat4_tmp, _textureMatrix);
    } else {
      vec3.set(_s_tmp, this._width, this._height, 1.0);
      mat4.fromScaling(_textureMatrix, _s_tmp);

      vec3.set(_t_tmp, this._x, textureHeight - (this._y + this._height), 0.0);
      mat4.fromTranslation(_mat4_tmp, _t_tmp);
      mat4.multiply(_textureMatrix, _mat4_tmp, _textureMatrix);

      vec3.set(_s_tmp, 1 / textureWidth, 1 / textureHeight, 1.0);
      mat4.fromScaling(_mat4_tmp, _s_tmp);
      mat4.multiply(_textureMatrix, _mat4_tmp, _textureMatrix);
    }

    // calculate uvs
    var uvs = this._uvs;
    uvs[0].x = uvs[4].x = uvs[8].x = uvs[12].x = 0.0;
    uvs[1].x = uvs[5].x = uvs[9].x = uvs[13].x = this._left / this._width;
    uvs[2].x = uvs[6].x = uvs[10].x = uvs[14].x = 1.0 - this._right / this._width;
    uvs[3].x = uvs[7].x = uvs[11].x = uvs[15].x = 1.0;

    uvs[0].y = uvs[1].y = uvs[2].y = uvs[3].y = 0.0;
    uvs[4].y = uvs[5].y = uvs[6].y = uvs[7].y = this._bottom / this._height;
    uvs[8].y = uvs[9].y = uvs[10].y = uvs[11].y = 1.0 - this._top / this._height;
    uvs[12].y = uvs[13].y = uvs[14].y = uvs[15].y = 1.0;

    // multiply uv by texture matrix
    for (var i = 0; i < this._uvs.length; ++i) {
      vec3.transformMat4(this$1._uvs[i], this$1._uvs[i], _textureMatrix);
    }
  };

  Object.defineProperties( Sprite.prototype, prototypeAccessors );

  return Sprite;
}(Asset));

var effectJsons = [
  {
    name: 'font',
    techniques: [{"stages":["ui"],"params":[{"name":"mainTexture","type":13,"value":null}],"passes":[{"program":"sprite","depthTest":true,"depthWrite":false,"blend":true,"blendEq":32774,"blendSrc":1,"blendDst":771,"blendAlphaEq":32774,"blendSrcAlpha":1,"blendDstAlpha":771}],"layer":0}],
    properties: {},
    defines: [],
    dependencies: undefined
  },
  {
    name: 'grid',
    techniques: [{"stages":["opaque"],"params":[{"name":"tiling","type":5,"value":[1,1]},{"name":"baseColorWhite","type":8,"value":[1,1,1]},{"name":"baseColorBlack","type":8,"value":[0,0,0]},{"name":"basePattern","type":13,"value":null},{"name":"basePatternTiling","type":5,"value":[1,1]},{"name":"basePatternOffset","type":5,"value":[0,0]},{"name":"subPatternColor","type":9,"value":[1,1,1,1]},{"name":"subPattern","type":13,"value":null},{"name":"subPatternTiling","type":5,"value":[1,1]},{"name":"subPatternOffset","type":5,"value":[0,0]},{"name":"subPatternColor2","type":9,"value":[1,1,1,1]},{"name":"subPattern2","type":13,"value":null},{"name":"subPattern2Tiling","type":5,"value":[1,1]},{"name":"subPattern2Offset","type":5,"value":[0,0]}],"passes":[{"program":"grid"}],"layer":0}],
    properties: {},
    defines: [{"name":"USE_WORLD_POS","value":false}],
    dependencies: undefined
  },
  {
    name: 'line',
    techniques: [{"stages":["opaque"],"params":[],"passes":[{"program":"line","depthTest":true,"depthWrite":true}],"layer":0}],
    properties: {},
    defines: [],
    dependencies: undefined
  },
  {
    name: 'matcap',
    techniques: [{"stages":["opaque"],"params":[{"name":"mainTex","type":13,"value":null},{"name":"matcapTex","type":13,"value":null},{"name":"colorFactor","type":4,"value":0.5},{"name":"color","type":9,"value":[1,1,1,1]}],"passes":[{"program":"matcap","depthTest":true,"depthWrite":true}],"layer":0}],
    properties: {},
    defines: [{"name":"USE_MAIN_TEX","value":false},{"name":"USE_SKINNING","value":false}],
    dependencies: undefined
  },
  {
    name: 'particle-add-multiply',
    techniques: [{"stages":["transparent"],"params":[{"name":"mainTexture","type":13,"value":null},{"name":"mainTiling","type":5,"value":[1,1]},{"name":"mainOffset","type":5,"value":[0,0]},{"name":"tintColor","type":9,"value":[0.5,0.5,0.5,0.5]},{"name":"frameTile","type":5,"value":[1,1]},{"name":"velocityScale","type":4,"value":0},{"name":"lengthScale","type":4,"value":0}],"passes":[{"program":"particle-add-multiply","cullMode":0,"depthTest":true,"depthWrite":false,"blend":true,"blendEq":32774,"blendSrc":1,"blendDst":771,"blendAlphaEq":32774,"blendSrcAlpha":1,"blendDstAlpha":771}],"layer":0}],
    properties: {},
    defines: [{"name":"USE_SOFT_PARTICLE","value":false},{"name":"USE_BILLBOARD","value":false},{"name":"USE_STRETCHED_BILLBOARD","value":false},{"name":"USE_HORIZONTAL_BILLBOARD","value":false},{"name":"USE_VERTICAL_BILLBOARD","value":false},{"name":"USE_WORLD_SPACE","value":false}],
    dependencies: undefined
  },
  {
    name: 'particle-add-smooth',
    techniques: [{"stages":["transparent"],"params":[{"name":"mainTexture","type":13,"value":null},{"name":"mainTiling","type":5,"value":[1,1]},{"name":"mainOffset","type":5,"value":[0,0]},{"name":"frameTile","type":5,"value":[1,1]},{"name":"velocityScale","type":4,"value":0},{"name":"lengthScale","type":4,"value":0}],"passes":[{"program":"particle-add-smooth","cullMode":0,"depthTest":true,"depthWrite":false,"blend":true,"blendEq":32774,"blendSrc":1,"blendDst":769,"blendAlphaEq":32774,"blendSrcAlpha":1,"blendDstAlpha":769}],"layer":0}],
    properties: {},
    defines: [{"name":"USE_SOFT_PARTICLE","value":false},{"name":"USE_BILLBOARD","value":false},{"name":"USE_STRETCHED_BILLBOARD","value":false},{"name":"USE_HORIZONTAL_BILLBOARD","value":false},{"name":"USE_VERTICAL_BILLBOARD","value":false},{"name":"USE_WORLD_SPACE","value":false}],
    dependencies: undefined
  },
  {
    name: 'particle-add',
    techniques: [{"stages":["transparent"],"params":[{"name":"mainTexture","type":13,"value":null},{"name":"mainTiling","type":5,"value":[1,1]},{"name":"mainOffset","type":5,"value":[0,0]},{"name":"tintColor","type":9,"value":[0.5,0.5,0.5,0.5]},{"name":"frameTile","type":5,"value":[1,1]},{"name":"velocityScale","type":4,"value":0},{"name":"lengthScale","type":4,"value":0}],"passes":[{"program":"particle-add","cullMode":0,"depthTest":true,"depthWrite":false,"blend":true,"blendEq":32774,"blendSrc":770,"blendDst":1,"blendAlphaEq":32774,"blendSrcAlpha":770,"blendDstAlpha":1}],"layer":0}],
    properties: {},
    defines: [{"name":"USE_SOFT_PARTICLE","value":false},{"name":"USE_BILLBOARD","value":false},{"name":"USE_STRETCHED_BILLBOARD","value":false},{"name":"USE_HORIZONTAL_BILLBOARD","value":false},{"name":"USE_VERTICAL_BILLBOARD","value":false},{"name":"USE_WORLD_SPACE","value":false}],
    dependencies: undefined
  },
  {
    name: 'particle-alpha-blend',
    techniques: [{"stages":["transparent"],"params":[{"name":"mainTexture","type":13,"value":null},{"name":"mainTiling","type":5,"value":[1,1]},{"name":"mainOffset","type":5,"value":[0,0]},{"name":"tintColor","type":9,"value":[0.5,0.5,0.5,0.5]},{"name":"frameTile","type":5,"value":[1,1]},{"name":"velocityScale","type":4,"value":0},{"name":"lengthScale","type":4,"value":0}],"passes":[{"program":"particle-alpha-blend","cullMode":0,"depthTest":true,"depthWrite":false,"blend":true,"blendEq":32774,"blendSrc":770,"blendDst":771,"blendAlphaEq":32774,"blendSrcAlpha":770,"blendDstAlpha":771}],"layer":0}],
    properties: {},
    defines: [{"name":"USE_SOFT_PARTICLE","value":false},{"name":"USE_BILLBOARD","value":false},{"name":"USE_STRETCHED_BILLBOARD","value":false},{"name":"USE_HORIZONTAL_BILLBOARD","value":false},{"name":"USE_VERTICAL_BILLBOARD","value":false},{"name":"USE_WORLD_SPACE","value":false}],
    dependencies: undefined
  },
  {
    name: 'particle-premultiply-blend',
    techniques: [{"stages":["transparent"],"params":[{"name":"mainTexture","type":13,"value":null},{"name":"mainTiling","type":5,"value":[1,1]},{"name":"mainOffset","type":5,"value":[0,0]},{"name":"frameTile","type":5,"value":[1,1]},{"name":"velocityScale","type":4,"value":0},{"name":"lengthScale","type":4,"value":0}],"passes":[{"program":"particle-premultiply-blend","cullMode":0,"depthTest":true,"depthWrite":false,"blend":true,"blendEq":32774,"blendSrc":1,"blendDst":771,"blendAlphaEq":32774,"blendSrcAlpha":1,"blendDstAlpha":771}],"layer":0}],
    properties: {},
    defines: [{"name":"USE_SOFT_PARTICLE","value":false},{"name":"USE_BILLBOARD","value":false},{"name":"USE_STRETCHED_BILLBOARD","value":false},{"name":"USE_HORIZONTAL_BILLBOARD","value":false},{"name":"USE_VERTICAL_BILLBOARD","value":false},{"name":"USE_WORLD_SPACE","value":false}],
    dependencies: undefined
  },
  {
    name: 'pbr-transparent',
    techniques: [{"stages":["transparent"],"params":[{"name":"albedo","type":9,"value":[1,1,1,1]},{"name":"mainTiling","type":5,"value":[1,1]},{"name":"mainOffset","type":5,"value":[0,0]},{"name":"albedo_texture","type":13,"value":null},{"name":"metallic","type":4,"value":1},{"name":"metallic_texture","type":13,"value":null},{"name":"roughness","type":4,"value":0.5},{"name":"roughness_texture","type":13,"value":null},{"name":"ao","type":4,"value":0.2},{"name":"ao_texture","type":13,"value":null},{"name":"emissive","type":8,"value":[0,0,0]},{"name":"emissive_texture","type":13,"value":null},{"name":"normal_texture","type":13,"value":null},{"name":"diffuseEnvTexture","type":14,"value":null},{"name":"specularEnvTexture","type":14,"value":null},{"name":"brdfLUT","type":13,"value":null},{"name":"maxReflectionLod","type":4,"value":9},{"name":"alphaTestThreshold","type":4,"value":0}],"passes":[{"program":"pbr","cullMode":1029,"depthTest":true,"depthWrite":false,"blend":true,"blendEq":32774,"blendSrc":770,"blendDst":771,"blendAlphaEq":32774,"blendSrcAlpha":1,"blendDstAlpha":771}],"layer":0},{"stages":["shadowcast"],"params":[],"passes":[{"program":"shadow-depth","cullMode":1029,"blendMode":0,"depthTest":true,"depthWrite":true}],"layer":0}],
    properties: {},
    defines: [{"name":"USE_NORMAL_TEXTURE","value":false},{"name":"USE_ALBEDO_TEXTURE","value":false},{"name":"USE_MRA_TEXTURE","value":false},{"name":"USE_METALLIC_TEXTURE","value":false},{"name":"USE_ROUGHNESS_TEXTURE","value":false},{"name":"USE_AO_TEXTURE","value":false},{"name":"USE_EMISSIVE","value":false},{"name":"USE_EMISSIVE_TEXTURE","value":false},{"name":"USE_IBL","value":false},{"name":"USE_TEX_LOD","value":false},{"name":"USE_ALPHA_TEST","value":false},{"name":"USE_SHADOW_MAP","value":false},{"name":"USE_SKINNING","value":false},{"name":"NUM_DIR_LIGHTS","value":0},{"name":"NUM_POINT_LIGHTS","value":0},{"name":"NUM_SPOT_LIGHTS","value":0},{"name":"NUM_SHADOW_LIGHTS","value":0}],
    dependencies: [{"define":"USE_NORMAL_TEXTURE","extension":"OES_standard_derivatives"},{"define":"USE_TEX_LOD","extension":"EXT_shader_texture_lod"}]
  },
  {
    name: 'pbr',
    techniques: [{"stages":["opaque"],"params":[{"name":"albedo","type":9,"value":[1,1,1,1]},{"name":"mainTiling","type":5,"value":[1,1]},{"name":"mainOffset","type":5,"value":[0,0]},{"name":"albedo_texture","type":13,"value":null},{"name":"metallic","type":4,"value":1},{"name":"metallic_texture","type":13,"value":null},{"name":"roughness","type":4,"value":0.5},{"name":"roughness_texture","type":13,"value":null},{"name":"ao","type":4,"value":0.2},{"name":"ao_texture","type":13,"value":null},{"name":"emissive","type":8,"value":[0,0,0]},{"name":"emissive_texture","type":13,"value":null},{"name":"normal_texture","type":13,"value":null},{"name":"diffuseEnvTexture","type":14,"value":null},{"name":"specularEnvTexture","type":14,"value":null},{"name":"brdfLUT","type":13,"value":null},{"name":"maxReflectionLod","type":4,"value":9},{"name":"alphaTestThreshold","type":4,"value":0}],"passes":[{"program":"pbr","cullMode":1029,"depthTest":true,"depthWrite":true}],"layer":0},{"stages":["shadowcast"],"params":[],"passes":[{"program":"shadow-depth","cullMode":1029,"blendMode":0,"depthTest":true,"depthWrite":true}],"layer":0}],
    properties: {},
    defines: [{"name":"USE_NORMAL_TEXTURE","value":false},{"name":"USE_ALBEDO_TEXTURE","value":false},{"name":"USE_MRA_TEXTURE","value":false},{"name":"USE_METALLIC_TEXTURE","value":false},{"name":"USE_ROUGHNESS_TEXTURE","value":false},{"name":"USE_AO_TEXTURE","value":false},{"name":"USE_EMISSIVE","value":false},{"name":"USE_EMISSIVE_TEXTURE","value":false},{"name":"USE_IBL","value":false},{"name":"USE_TEX_LOD","value":false},{"name":"USE_ALPHA_TEST","value":false},{"name":"USE_SHADOW_MAP","value":false},{"name":"USE_SKINNING","value":false},{"name":"NUM_DIR_LIGHTS","value":0},{"name":"NUM_POINT_LIGHTS","value":0},{"name":"NUM_SPOT_LIGHTS","value":0},{"name":"NUM_SHADOW_LIGHTS","value":0},{"name":"USE_RGBE_HDR_IBL_SPECULAR","value":false},{"name":"USE_RGBE_HDR_IBL_DIFFUSE","value":false}],
    dependencies: [{"define":"USE_NORMAL_TEXTURE","extension":"OES_standard_derivatives"},{"define":"USE_TEX_LOD","extension":"EXT_shader_texture_lod"}]
  },
  {
    name: 'phong-transparent',
    techniques: [{"stages":["transparent"],"params":[{"name":"diffuseColor","type":9,"value":[0.8,0.8,0.8,1]},{"name":"mainTiling","type":5,"value":[1,1]},{"name":"mainOffset","type":5,"value":[0,0]},{"name":"diffuse_texture","type":13,"value":null},{"name":"specularColor","type":8,"value":[0,0,0]},{"name":"specular_texture","type":13,"value":null},{"name":"emissiveColor","type":8,"value":[0,0,0]},{"name":"emissive_texture","type":13,"value":null},{"name":"glossiness","type":4,"value":10},{"name":"normal_texture","type":13,"value":null},{"name":"alphaTestThreshold","type":4,"value":0}],"passes":[{"program":"phong","cullMode":1029,"depthTest":true,"depthWrite":false,"blend":true,"blendEq":32774,"blendSrc":770,"blendDst":771,"blendAlphaEq":32774,"blendSrcAlpha":1,"blendDstAlpha":771}],"layer":0},{"stages":["shadowcast"],"params":[],"passes":[{"program":"shadow-depth","cullMode":1029,"depthTest":true,"depthWrite":true}],"layer":0}],
    properties: {},
    defines: [{"name":"USE_NORMAL_TEXTURE","value":false},{"name":"USE_DIFFUSE_TEXTURE","value":false},{"name":"USE_SPECULAR","value":false},{"name":"USE_SPECULAR_TEXTURE","value":false},{"name":"USE_EMISSIVE","value":false},{"name":"USE_EMISSIVE_TEXTURE","value":false},{"name":"USE_ALPHA_TEST","value":false},{"name":"USE_SKINNING","value":false},{"name":"USE_SHADOW_MAP","value":false},{"name":"NUM_DIR_LIGHTS","value":0},{"name":"NUM_POINT_LIGHTS","value":0},{"name":"NUM_SPOT_LIGHTS","value":0},{"name":"NUM_SHADOW_LIGHTS","value":0}],
    dependencies: [{"define":"USE_NORMAL_TEXTURE","extension":"OES_standard_derivatives"}]
  },
  {
    name: 'phong',
    techniques: [{"stages":["opaque"],"params":[{"name":"diffuseColor","type":9,"value":[0.8,0.8,0.8,1]},{"name":"mainTiling","type":5,"value":[1,1]},{"name":"mainOffset","type":5,"value":[0,0]},{"name":"diffuse_texture","type":13,"value":null},{"name":"specularColor","type":8,"value":[0,0,0]},{"name":"specular_texture","type":13,"value":null},{"name":"emissiveColor","type":8,"value":[0,0,0]},{"name":"emissive_texture","type":13,"value":null},{"name":"glossiness","type":4,"value":10},{"name":"normal_texture","type":13,"value":null},{"name":"alphaTestThreshold","type":4,"value":0}],"passes":[{"program":"phong","cullMode":1029,"depthTest":true,"depthWrite":true}],"layer":0},{"stages":["shadowcast"],"params":[],"passes":[{"program":"shadow-depth","cullMode":1029,"depthTest":true,"depthWrite":true}],"layer":0}],
    properties: {},
    defines: [{"name":"USE_NORMAL_TEXTURE","value":false},{"name":"USE_DIFFUSE_TEXTURE","value":false},{"name":"USE_SPECULAR","value":false},{"name":"USE_SPECULAR_TEXTURE","value":false},{"name":"USE_EMISSIVE","value":false},{"name":"USE_EMISSIVE_TEXTURE","value":false},{"name":"USE_ALPHA_TEST","value":false},{"name":"USE_SKINNING","value":false},{"name":"USE_SHADOW_MAP","value":false},{"name":"NUM_DIR_LIGHTS","value":0},{"name":"NUM_POINT_LIGHTS","value":0},{"name":"NUM_SPOT_LIGHTS","value":0},{"name":"NUM_SHADOW_LIGHTS","value":0}],
    dependencies: [{"define":"USE_NORMAL_TEXTURE","extension":"OES_standard_derivatives"}]
  },
  {
    name: 'simple',
    techniques: [{"stages":["opaque"],"params":[{"name":"color","type":9,"value":[0.4,0.4,0.4,1]}],"passes":[{"program":"simple","depthTest":true,"depthWrite":true}],"layer":0}],
    properties: {},
    defines: [{"name":"USE_TEXTURE","value":false},{"name":"USE_COLOR","value":false}],
    dependencies: undefined
  },
  {
    name: 'skybox',
    techniques: [{"stages":["opaque"],"params":[{"name":"cubeMap","type":14,"value":null}],"passes":[{"program":"skybox","cullMode":0}],"layer":-1}],
    properties: {},
    defines: [{"name":"USE_RGBE_HDR","value":false}],
    dependencies: undefined
  },
  {
    name: 'sprite',
    techniques: [{"stages":["ui"],"params":[{"name":"mainTexture","type":13,"value":null}],"passes":[{"program":"sprite","depthTest":true,"depthWrite":false,"blend":true,"blendEq":32774,"blendSrc":770,"blendDst":771,"blendAlphaEq":32774,"blendSrcAlpha":1,"blendDstAlpha":771}],"layer":0}],
    properties: {},
    defines: [],
    dependencies: undefined
  },
  {
    name: 'unlit-transparent',
    techniques: [{"stages":["transparent"],"params":[{"name":"color","type":9,"value":[1,1,1,1]},{"name":"mainTiling","type":5,"value":[1,1]},{"name":"mainOffset","type":5,"value":[0,0]},{"name":"mainTexture","type":13,"value":null}],"passes":[{"program":"unlit","cullMode":1029,"depthTest":true,"depthWrite":true,"blend":true,"blendEq":32774,"blendSrc":770,"blendDst":771,"blendAlphaEq":32774,"blendSrcAlpha":1,"blendDstAlpha":771}],"layer":0}],
    properties: {},
    defines: [{"name":"USE_TEXTURE","value":false},{"name":"USE_COLOR","value":false},{"name":"USE_SKINNING","value":false}],
    dependencies: undefined
  },
  {
    name: 'unlit',
    techniques: [{"stages":["opaque"],"params":[{"name":"color","type":9,"value":[1,1,1,1]},{"name":"mainTiling","type":5,"value":[1,1]},{"name":"mainOffset","type":5,"value":[0,0]},{"name":"mainTexture","type":13,"value":null}],"passes":[{"program":"unlit","cullMode":1029,"depthTest":true,"depthWrite":true}],"layer":0}],
    properties: {},
    defines: [{"name":"USE_TEXTURE","value":false},{"name":"USE_COLOR","value":false},{"name":"USE_SKINNING","value":false}],
    dependencies: undefined
  },
  {
    name: 'wireframe',
    techniques: [{"stages":["opaque"],"params":[{"name":"color","type":8,"value":[1,1,1]}],"passes":[{"program":"wireframe","depthTest":true,"depthWrite":true}],"layer":0}],
    properties: {},
    defines: [],
    dependencies: undefined
  } ];

function initBuiltins (device) {
  var obj;

  var canvas = document.createElement('canvas');
  var context = canvas.getContext('2d');

  // ============================
  // builtin textures
  // ============================

  // default texture canvas fill
  canvas.width = canvas.height = 128;
  context.fillStyle = '#ddd';
  context.fillRect(0, 0, 128, 128);
  context.fillStyle = '#555';
  context.fillRect(0, 0, 64, 64);
  context.fillStyle = '#555';
  context.fillRect(64, 64, 64, 64);

  // default-texture
  var defaultTexture = new Texture2D$2(device);
  defaultTexture.mipmap = true;
  defaultTexture.wrapS = 'repeat';
  defaultTexture.wrapT = 'repeat';
  defaultTexture.setImage(0, canvas);
  defaultTexture.commit();
  defaultTexture._uuid = 'default-texture';
  defaultTexture._loaded = true;

  // default-texture-cube
  var defaultTextureCube = new TextureCube$2(device);
  defaultTextureCube.setImages(
    [[canvas, canvas, canvas, canvas, canvas, canvas]]
  );
  defaultTextureCube.commit();
  defaultTextureCube._uuid = 'default-texture-cube';
  defaultTextureCube._loaded = true;

  // black texture canvas fill
  canvas.width = canvas.height = 2;
  context.fillStyle = '#000';
  context.fillRect(0, 0, 2, 2);

  // black-texture
  var blackTexture = new Texture2D$2(device);
  blackTexture.mipmap = false;
  blackTexture.wrapS = 'repeat';
  blackTexture.wrapT = 'repeat';
  blackTexture.minFilter = 'nearest';
  blackTexture.magFilter = 'nearest';
  blackTexture.setImage(0, canvas);
  blackTexture.commit();
  blackTexture._uuid = 'black-texture';
  blackTexture._loaded = true;

  // white texture canvas fill
  canvas.width = canvas.height = 2;
  context.fillStyle = '#fff';
  context.fillRect(0, 0, 2, 2);

  // white-texture
  var whiteTexture = new Texture2D$2(device);
  whiteTexture.mipmap = false;
  whiteTexture.wrapS = 'repeat';
  whiteTexture.wrapT = 'repeat';
  whiteTexture.minFilter = 'nearest';
  whiteTexture.magFilter = 'nearest';
  whiteTexture.setImage(0, canvas);
  whiteTexture.commit();
  whiteTexture._uuid = 'white-texture';
  whiteTexture._loaded = true;

  // ============================
  // builtin sprites
  // ============================

  // default-sprites
  var defaultSprite = new Sprite();
  defaultSprite._texture = whiteTexture;
  defaultSprite.width = whiteTexture.width;
  defaultSprite.height = whiteTexture.height;
  defaultSprite.commit();
  defaultSprite._uuid = 'default-sprite';
  defaultSprite._loaded = true;

  // ============================
  // builtin meshes
  // ============================

  // builtin-cube
  var cubeMesh = new Mesh();
  cubeMesh._subMeshes = new Array(1);
  var cubeDesc = box$2(1, 1, 1, {
    widthSegments: 1,
    heightSegments: 1,
    lengthSegments: 1,
  });
  cubeMesh._subMeshes[0] = renderer.createIA(device, cubeDesc);
  cubeMesh._uuid = 'builtin-cube';
  cubeMesh._loaded = true;
  cubeMesh._minPos = vec3.clone(cubeDesc.minPos);
  cubeMesh._maxPos = vec3.clone(cubeDesc.maxPos);

  // builtin-sphere
  var sphereMesh = new Mesh();
  sphereMesh._subMeshes = new Array(1);
  var sphereDesc = sphere$2(0.5, {
    segments: 64,
  });
  sphereMesh._subMeshes[0] = renderer.createIA(device, sphereDesc);
  sphereMesh._uuid = 'builtin-sphere';
  sphereMesh._loaded = true;
  sphereMesh._minPos = vec3.clone(sphereDesc.minPos);
  sphereMesh._maxPos = vec3.clone(sphereDesc.maxPos);

  // builtin-cylinder
  var cylinderMesh = new Mesh();
  cylinderMesh._subMeshes = new Array(1);
  var cylinderDesc = cylinder(0.5, 0.5, 2, {
    radialSegments: 20,
    capped: true,
  });
  cylinderMesh._subMeshes[0] = renderer.createIA(device, cylinderDesc);
  cylinderMesh._uuid = 'builtin-cylinder';
  cylinderMesh._loaded = true;
  cylinderMesh._minPos = vec3.clone(cylinderDesc.minPos);
  cylinderMesh._maxPos = vec3.clone(cylinderDesc.maxPos);

  // builtin-plane
  var planeMesh = new Mesh();
  planeMesh._subMeshes = new Array(1);
  var planeDesc = plane$2(10, 10, {
    uSegments: 10,
    vSegments: 10,
  });
  planeMesh._subMeshes[0] = renderer.createIA(device, planeDesc);
  planeMesh._uuid = 'builtin-plane';
  planeMesh._loaded = true;
  planeMesh._minPos = vec3.clone(planeDesc.minPos);
  planeMesh._maxPos = vec3.clone(planeDesc.maxPos);

  // builtin-capsule
  var capsuleMesh = new Mesh();
  capsuleMesh._subMeshes = new Array(1);
  var capsuleDesc = capsule(0.5, 0.5, 2, {
    heightSegments: 30,
    sides: 20,
  });
  capsuleMesh._subMeshes[0] = renderer.createIA(device, capsuleDesc);
  capsuleMesh._uuid = 'builtin-capsule';
  capsuleMesh._loaded = true;
  capsuleMesh._minPos = vec3.clone(capsuleDesc.minPos);
  capsuleMesh._maxPos = vec3.clone(capsuleDesc.maxPos);

  // ============================
  // builtin effects
  // ============================

  var effects = {};
  for (var i = 0; i < effectJsons.length; ++i) {
    var effectJson = effectJsons[i];
    var effect = new Effect$2();
    effect._name = effectJson.name;
    effect._uuid = "builtin-effect-" + (effectJson.name);
    effect._loaded = true;
    effect.techniques = effectJson.techniques;
    effect.properties = effectJson.properties;
    effect.defines = effectJson.defines;
    effect.dependencies = effectJson.dependencies ? effectJson.dependencies : [];
    effects[effect._uuid] = effect;
  }

  // ============================
  // builtin materials
  // ============================

  var materials = {};
  [
    'sprite',
    'font'
  ].forEach(function (name) {
    var mat = new Material();
    mat.effect = effects[("builtin-effect-" + name)];
    mat._uuid = "builtin-material-" + name;
    mat._loaded = true;
    materials[mat._uuid] = mat;
  });

  //
  return Object.assign(( obj = {}, obj[defaultTexture._uuid] = defaultTexture, obj[defaultTextureCube._uuid] = defaultTextureCube, obj[blackTexture._uuid] = blackTexture, obj[whiteTexture._uuid] = whiteTexture, obj[defaultSprite._uuid] = defaultSprite, obj[cubeMesh._uuid] = cubeMesh, obj[sphereMesh._uuid] = sphereMesh, obj[cylinderMesh._uuid] = cylinderMesh, obj[planeMesh._uuid] = planeMesh, obj[capsuleMesh._uuid] = capsuleMesh, obj), effects, materials);
}

var types = {
  // int
  int: {
    default: 0,
    parse: function parse(app, data, propInfo) {
      var result = data;

      if (typeof data === 'string') {
        result = parseInt(data);
      }

      if (propInfo.min !== undefined) {
        result = Math.max(propInfo.min, result);
      }

      if (propInfo.max !== undefined) {
        result = Math.min(propInfo.max, result);
      }

      return result;
    }
  },

  // number
  number: {
    default: 0.0,
    parse: function parse(app, data, propInfo) {
      var result = data;

      if (typeof data === 'string') {
        result = parseFloat(data);
      }

      if (propInfo.min !== undefined) {
        result = Math.max(propInfo.min, result);
      }

      if (propInfo.max !== undefined) {
        result = Math.min(propInfo.max, result);
      }

      return result;
    }
  },

  // string
  string: {
    default: '',
    parse: function parse(app, data) {
      return data;
    }
  },

  // boolean
  boolean: {
    default: true,
    parse: function parse(app, data) {
      return !!data;
    }
  },

  // object
  object: {
    default: null,
    parse: function parse(app, data) {
      return data;
    }
  },

  // enums
  enums: {
    default: '',
    parse: function parse(app, data, propInfo) {
      if (propInfo.options.indexOf(data) === -1) {
        console.log(("Invalid option: " + data));

        if (propInfo.default !== undefined) {
          return propInfo.default;
        }

        return '';
      }
      return data;
    }
  },

  // color3
  color3: {
    default: [1, 1, 1],
    parse: function parse(app, data) {
      if (Array.isArray(data)) {
        return color3.new(data[0], data[1], data[2]);
      }
      return data;
    }
  },

  // color4
  color4: {
    default: [1, 1, 1, 1],
    parse: function parse(app, data) {
      if (Array.isArray(data)) {
        return color4.new(data[0], data[1], data[2], data[3]);
      }
      return data;
    }
  },

  // vec2
  vec2: {
    default: [0, 0],
    parse: function parse(app, data) {
      if (Array.isArray(data)) {
        return vec2.new(data[0], data[1]);
      }
      return data;
    }
  },

  // vec3
  vec3: {
    default: [0, 0, 0],
    parse: function parse(app, data) {
      if (Array.isArray(data)) {
        return vec3.new(data[0], data[1], data[2]);
      }
      return data;
    }
  },

  // vec4
  vec4: {
    default: [0, 0, 0, 0],
    parse: function parse(app, data) {
      if (Array.isArray(data)) {
        return vec4.new(data[0], data[1], data[2], data[3]);
      }
      return data;
    }
  },

  // quat
  quat: {
    default: [0, 0, 0, 1],
    parse: function parse(app, data) {
      if (Array.isArray(data)) {
        return quat.new(data[0], data[1], data[2], data[3]);
      }
      return data;
    }
  },

  // mat3
  mat3: {
    default: [
      1, 0, 0,
      0, 1, 0,
      0, 0, 1
    ],
    parse: function parse(app, data) {
      if (Array.isArray(data)) {
        return mat3.new(
          data[0], data[1], data[2],
          data[3], data[4], data[5],
          data[6], data[7], data[8]
        );
      }
      return data;
    }
  },

  // mat4
  mat4: {
    default: [
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    ],
    parse: function parse(app, data) {
      if (Array.isArray(data)) {
        return mat4.new(
          data[0],  data[1],  data[2],  data[3],
          data[4],  data[5],  data[6],  data[7],
          data[8],  data[9],  data[10], data[11],
          data[12], data[13], data[14], data[15]
        );
      }
      return data;
    }
  },

  // asset
  asset: {
    default: null,
    parse: function parse(app, data) {
      if (typeof data === 'string') {
        return app.assets.get(data);
      }
      return data;
    }
  },

  // rect
  rect: {
    default: [0, 0, 1, 1],
    parse: function parse(app, data) {
      if (Array.isArray(data)) {
        return data;
      }
      return [data.x, data.y, data.w, data.h];
    }
  },

  // entity
  entity: {
    default: null,
    parse: function parse(app, data, propInfo, entities) {
      if (typeof data === 'string') {
        var results = data.match(/e(\d+)/);
        if (results) {
          var entIdx = parseInt(results[1]);
          return entities[entIdx];
        }
      }

      return data;
    }
  },

  // component
  component: {
    default: null,
    parse: function parse(app, data, propInfo, entities) {
      if (typeof data === 'string') {
        var results = data.match(/e(\d+)c(\d+)/);
        if (results) {
          var entIdx = parseInt(results[0]);
          var compIdx = parseInt(results[1]);

          var ent = entities[entIdx];
          var comp = ent._comps[compIdx];

          return comp;
        }
      }

      return data;
    }
  },
};

function _binaryIndexOf(array, key) {
  var lo = 0;
  var hi = array.length - 1;
  var mid;

  while (lo <= hi) {
    mid = ((lo + hi) >> 1);
    var val = array[mid];

    if (val < key) {
      lo = mid + 1;
    } else if (val > key) {
      hi = mid - 1;
    } else {
      return mid;
    }
  }

  return lo;
}

var AnimationClip = (function (Asset$$1) {
  function AnimationClip() {
    Asset$$1.call(this);

    /**
     * framesList: [{
     *   name: '',
     *   times: [0.0, ...],
     *   jionts: [{ id: -1, translations: [], rotations: [], scales: [] }, ...],
     * }, ...]
     */
    this._framesList = null;
    this._length = 0.0;

    // TODO:
    // this._events = []
  }

  if ( Asset$$1 ) AnimationClip.__proto__ = Asset$$1;
  AnimationClip.prototype = Object.create( Asset$$1 && Asset$$1.prototype );
  AnimationClip.prototype.constructor = AnimationClip;

  var prototypeAccessors = { length: { configurable: true } };

  prototypeAccessors.length.get = function () {
    return this._length;
  };

  AnimationClip.prototype.sample = function sample (skeleton, t) {
    var this$1 = this;

    clamp(t, 0, this._length);

    for (var i = 0; i < this._framesList.length; ++i) {
      var frames = this$1._framesList[i];

      if (frames.times.length === 1) {
        for (var j = 0; j < frames.joints.length; ++j) {
          var jointFrames = frames.joints[j];
          var joint = skeleton._joints[jointFrames.id];

          if (jointFrames.translations) {
            vec3.copy(joint.lpos, jointFrames.translations[0]);
          }

          if (jointFrames.rotations) {
            quat.copy(joint.lrot, jointFrames.rotations[0]);
          }

          if (jointFrames.scales) {
            vec3.copy(joint.lscale, jointFrames.scales[0]);
          }
        }
      } else {
        var idx = _binaryIndexOf(frames.times, t);
        if (idx === 0) {
          for (var j$1 = 0; j$1 < frames.joints.length; ++j$1) {
            var jointFrames$1 = frames.joints[j$1];
            var joint$1 = skeleton._joints[jointFrames$1.id];

            if (jointFrames$1.translations) {
              vec3.copy(joint$1.lpos, jointFrames$1.translations[0]);
            }

            if (jointFrames$1.rotations) {
              quat.copy(joint$1.lrot, jointFrames$1.rotations[0]);
            }

            if (jointFrames$1.scales) {
              vec3.copy(joint$1.lscale, jointFrames$1.scales[0]);
            }
          }

          return;
        }

        var loIdx = Math.max(idx - 1, 0);
        var hiIdx = Math.min(idx, frames.times.length);
        var ratio = (t - frames.times[loIdx]) / (frames.times[hiIdx] - frames.times[loIdx]);

        for (var j$2 = 0; j$2 < frames.joints.length; ++j$2) {
          var jointFrames$2 = frames.joints[j$2];
          var joint$2 = skeleton._joints[jointFrames$2.id];

          if (jointFrames$2.translations) {
            var a = jointFrames$2.translations[loIdx];
            var b = jointFrames$2.translations[hiIdx];

            vec3.lerp(joint$2.lpos, a, b, ratio);
          }

          if (jointFrames$2.rotations) {
            var a$1 = jointFrames$2.rotations[loIdx];
            var b$1 = jointFrames$2.rotations[hiIdx];

            quat.slerp(joint$2.lrot, a$1, b$1, ratio);
          }

          if (jointFrames$2.scales) {
            var a$2 = jointFrames$2.scales[loIdx];
            var b$2 = jointFrames$2.scales[hiIdx];

            vec3.lerp(joint$2.lscale, a$2, b$2, ratio);
          }
        }
      }
    }

    skeleton.updateMatrices();
  };

  Object.defineProperties( AnimationClip.prototype, prototypeAccessors );

  return AnimationClip;
}(Asset));

var Skeleton = function Skeleton() {
  this._root = null;
  this._joints = null;
  this._matrices = null;
};

Skeleton.prototype.setRoot = function setRoot (root) {
    var this$1 = this;

  this._root = root;
  this._joints = utils.flat(this._root);
  this._matrices = new Array(this._joints.length);

  for (var i = 0; i < this._joints.length; ++i) {
    this$1._matrices[i] = mat4.create();
  }
  this.updateMatrices();
};

Skeleton.prototype.blend = function blend (fromSkel, toSkel, alpha) {
    var this$1 = this;

  for (var i = 0; i < this._joints.length; ++i) {
    var joint = this$1._joints[i];
    var jointFrom = fromSkel._joints[i];
    var jointTo = toSkel._joints[i];

    vec3.lerp(joint.lpos, jointFrom.lpos, jointTo.lpos, alpha);
    vec3.lerp(joint.lscale, jointFrom.lscale, jointTo.lscale, alpha);
    quat.slerp(joint.lrot, jointFrom.lrot, jointTo.lrot, alpha);
  }
};

Skeleton.prototype.updateMatrices = function updateMatrices () {
    var this$1 = this;

  for (var i = 0; i < this._joints.length; ++i) {
    this$1._joints[i].getWorldMatrix(this$1._matrices[i]);
  }
};

Skeleton.prototype.getWorldMatrix = function getWorldMatrix (i) {
  return this._matrices[i];
};

Skeleton.prototype.clone = function clone () {
  var newSkeleton = new Skeleton();
  newSkeleton.setRoot(utils.deepClone(this._root));

  return newSkeleton;
};

var Joints = (function (Asset$$1) {
  function Joints() {
    Asset$$1.call(this);

    this._nodes = null;
  }

  if ( Asset$$1 ) Joints.__proto__ = Asset$$1;
  Joints.prototype = Object.create( Asset$$1 && Asset$$1.prototype );
  Joints.prototype.constructor = Joints;

  Joints.prototype.instantiate = function instantiate () {
    var joints = gltfUtils.createNodes(this._nodes);

    // create skeleton
    var skeleton = new Skeleton();
    skeleton.setRoot(joints[0]);

    return skeleton;
  };

  return Joints;
}(Asset));

var _type2size = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16,
};

var _compType2Array = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5124: Int32Array,
  5125: Uint32Array,
  5126: Float32Array,
};

/**
 * @param {object} gltf
 * @param {ArrayBuffer} bin
 * @param {number} accessorID
 */
function createArray(gltf, bin, accessorID) {
  var acc = gltf.accessors[accessorID];
  var bufView = gltf.bufferViews[acc.bufferView];

  var num = _type2size[acc.type];
  var typedArray = _compType2Array[acc.componentType];
  var result = new typedArray(bin, bufView.byteOffset + acc.byteOffset, acc.count * num);

  return result;
}

/**
 * @param {Array} gltfNodes
 */
function createNodes(gltfNodes) {
  var nodes = new Array(gltfNodes.length);

  for (var i = 0; i < gltfNodes.length; ++i) {
    var gltfNode = gltfNodes[i];
    var node = new Node(gltfNode.name);

    if (gltfNode.translation) {
      vec3.set(
        node.lpos,
        gltfNode.translation[0],
        gltfNode.translation[1],
        gltfNode.translation[2]
      );
    }

    if (gltfNode.rotation) {
      quat.set(
        node.lrot,
        gltfNode.rotation[0],
        gltfNode.rotation[1],
        gltfNode.rotation[2],
        gltfNode.rotation[3]
      );
    }

    if (gltfNode.scale) {
      vec3.set(
        node.lscale,
        gltfNode.scale[0],
        gltfNode.scale[1],
        gltfNode.scale[2]
      );
    }

    nodes[i] = node;
  }

  for (var i$1 = 0; i$1 < gltfNodes.length; ++i$1) {
    var gltfNode$1 = gltfNodes[i$1];
    var node$1 = nodes[i$1];

    if (gltfNode$1.children) {
      for (var j = 0; j < gltfNode$1.children.length; ++j) {
        var index = gltfNode$1.children[j];
        node$1.append(nodes[index]);
      }
    }
  }

  return nodes;
}

/**
 * @param {App} app
 * @param {Array} gltfNodes
 */
function createEntities(app, gltfNodes) {
  var nodes = new Array(gltfNodes.length);

  for (var i = 0; i < gltfNodes.length; ++i) {
    var gltfNode = gltfNodes[i];
    var node = app.createEntity(gltfNode.name);

    if (gltfNode.translation) {
      vec3.set(
        node.lpos,
        gltfNode.translation[0],
        gltfNode.translation[1],
        gltfNode.translation[2]
      );
    }

    if (gltfNode.rotation) {
      quat.set(
        node.lrot,
        gltfNode.rotation[0],
        gltfNode.rotation[1],
        gltfNode.rotation[2],
        gltfNode.rotation[3]
      );
    }

    if (gltfNode.scale) {
      vec3.set(
        node.lscale,
        gltfNode.scale[0],
        gltfNode.scale[1],
        gltfNode.scale[2]
      );
    }

    nodes[i] = node;
  }

  for (var i$1 = 0; i$1 < gltfNodes.length; ++i$1) {
    var gltfNode$1 = gltfNodes[i$1];
    var node$1 = nodes[i$1];

    if (gltfNode$1.children) {
      for (var j = 0; j < gltfNode$1.children.length; ++j) {
        var index = gltfNode$1.children[j];
        node$1.append(nodes[index]);
      }
    }
  }

  return nodes;
}

/**
 * @param {App} app
 * @param {Object} gltf
 * @param {ArrayBuffer} bin
 * @param {number} index
 */
function createMesh$1(app, gltf, bin, index) {
  if (index >= gltf.meshes.length) {
    return null;
  }

  var gltfMesh = gltf.meshes[index];
  var accessors = gltf.accessors;
  var attributes = gltfMesh.primitives[0].attributes;
  var vbView = null;

  // create mesh-asset
  var meshAsset = new Mesh();
  meshAsset._name = gltfMesh.name;
  meshAsset._subMeshes = new Array(gltfMesh.primitives.length);

  // create vertex-format
  var vfmt = [];
  var vcount = 0;

  if (attributes.POSITION !== undefined) {
    var acc = accessors[attributes.POSITION];
    vfmt.push({ name: gfx.ATTR_POSITION, type: acc.componentType, num: _type2size[acc.type] });

    vcount = acc.count;
    vbView = gltf.bufferViews[acc.bufferView];

    meshAsset._minPos = vec3.new(acc.min[0], acc.min[1], acc.min[2]);
    meshAsset._maxPos = vec3.new(acc.max[0], acc.max[1], acc.max[2]);
  }

  if (attributes.NORMAL !== undefined) {
    var acc$1 = accessors[attributes.NORMAL];
    vfmt.push({ name: gfx.ATTR_NORMAL, type: acc$1.componentType, num: _type2size[acc$1.type] });
  }

  if (attributes.TANGENT !== undefined) {
    var acc$2 = accessors[attributes.TANGENT];
    vfmt.push({ name: gfx.ATTR_TANGENT, type: acc$2.componentType, num: _type2size[acc$2.type] });
  }

  if (attributes.COLOR_0 !== undefined) {
    var acc$3 = accessors[attributes.COLOR_0];
    vfmt.push({ name: gfx.ATTR_COLOR0, type: acc$3.componentType, num: _type2size[acc$3.type] });
  }

  if (attributes.TEXCOORD_0 !== undefined) {
    var acc$4 = accessors[attributes.TEXCOORD_0];
    vfmt.push({ name: gfx.ATTR_UV0, type: acc$4.componentType, num: _type2size[acc$4.type] });
  }

  if (attributes.TEXCOORD_1 !== undefined) {
    var acc$5 = accessors[attributes.TEXCOORD_1];
    vfmt.push({ name: gfx.ATTR_UV1, type: acc$5.componentType, num: _type2size[acc$5.type] });
  }

  if (attributes.TEXCOORD_2 !== undefined) {
    var acc$6 = accessors[attributes.TEXCOORD_2];
    vfmt.push({ name: gfx.ATTR_UV2, type: acc$6.componentType, num: _type2size[acc$6.type] });
  }

  if (attributes.TEXCOORD_3 !== undefined) {
    var acc$7 = accessors[attributes.TEXCOORD_3];
    vfmt.push({ name: gfx.ATTR_UV3, type: acc$7.componentType, num: _type2size[acc$7.type] });
  }

  if (attributes.JOINTS_0 !== undefined) {
    var acc$8 = accessors[attributes.JOINTS_0];
    vfmt.push({ name: gfx.ATTR_JOINTS, type: acc$8.componentType, num: _type2size[acc$8.type] });
  }

  if (attributes.WEIGHTS_0 !== undefined) {
    var acc$9 = accessors[attributes.WEIGHTS_0];
    vfmt.push({ name: gfx.ATTR_WEIGHTS, type: acc$9.componentType, num: _type2size[acc$9.type] });
  }

  // create vertex-buffer
  var vbData = new Uint8Array(bin, vbView.byteOffset, vbView.byteLength);
  var vb = new gfx.VertexBuffer(
    app.device,
    new gfx.VertexFormat(vfmt),
    gfx.USAGE_STATIC,
    vbData,
    vcount
  );

  // create index-buffer
  for (var i = 0; i < gltfMesh.primitives.length; ++i) {
    var primitive = gltfMesh.primitives[i];
    var ib = null;

    if (primitive.indices !== undefined) {
      var ibAcc = accessors[primitive.indices];
      var ibView = gltf.bufferViews[ibAcc.bufferView];
      var ibData = new Uint8Array(bin, ibView.byteOffset, ibView.byteLength);

      ib = new gfx.IndexBuffer(
        app.device,
        ibAcc.componentType,
        gfx.USAGE_STATIC,
        ibData,
        ibAcc.count
      );
    }

    meshAsset._subMeshes[i] = new renderer.InputAssembler(vb, ib);
  }

  // create skinning if we found
  if (gltf.skins) {
    for (var i$1 = 0; i$1 < gltf.skins.length; ++i$1) {
      if (gltf.skins[i$1].name === gltfMesh.name) {
        meshAsset._skinning = createSkinning(gltf, bin, i$1);
      }
    }
  }

  return meshAsset;
}

/**
 * @param {Object} gltf
 * @param {ArrayBuffer} bin
 * @param {number} index
 */
function createSkinning(gltf, bin, index) {
  if (index >= gltf.skins.length) {
    return null;
  }

  var gltfSkin = gltf.skins[index];

  // extract bindposes mat4 data
  var accessor = gltf.accessors[gltfSkin.inverseBindMatrices];
  var bufView = gltf.bufferViews[accessor.bufferView];
  var data = new Float32Array(bin, bufView.byteOffset + accessor.byteOffset, accessor.count * 16);
  var bindposes = new Array(accessor.count);

  for (var i = 0; i < accessor.count; ++i) {
    bindposes[i] = mat4.new(
      data[16 * i + 0], data[16 * i + 1], data[16 * i + 2], data[16 * i + 3],
      data[16 * i + 4], data[16 * i + 5], data[16 * i + 6], data[16 * i + 7],
      data[16 * i + 8], data[16 * i + 9], data[16 * i + 10], data[16 * i + 11],
      data[16 * i + 12], data[16 * i + 13], data[16 * i + 14], data[16 * i + 15]
    );
  }

  return {
    jointIndices: gltfSkin.joints,
    bindposes: bindposes,
  };
}

/**
 * @param {Object} gltf
 * @param {ArrayBuffer} bin
 * @param {number} index
 */
function createAnimationClip(gltf, bin, index) {
  if (index >= gltf.animations.length) {
    return null;
  }

  var gltfAnimation = gltf.animations[index];
  var framesList = [];
  var maxLength = -1;

  for (var i = 0; i < gltfAnimation.channels.length; ++i) {
    var gltfChannel = gltfAnimation.channels[i];
    var inputAcc = gltf.accessors[gltfChannel.input];

    // find frames by input name
    var frames = (void 0);
    for (var j = 0; j < framesList.length; ++j) {
      if (framesList[j].name === inputAcc.name) {
        frames = framesList[j];
        break;
      }
    }

    // if not found, create one
    if (!frames) {
      var inArray = createArray(gltf, bin, gltfChannel.input);
      var inputs = new Array(inArray.length);
      for (var i$1 = 0; i$1 < inArray.length; ++i$1) {
        var t = inArray[i$1];
        inputs[i$1] = t;

        if (maxLength < t) {
          maxLength = t;
        }
      }

      frames = {
        name: inputAcc.name,
        times: inputs,
        joints: [],
      };
      framesList.push(frames);
    }

    // find output frames by node id
    var jointFrames = (void 0);
    for (var j$1 = 0; j$1 < frames.joints.length; ++j$1) {
      if (frames.joints[j$1].id === gltfChannel.node) {
        jointFrames = frames.joints[j$1];
        break;
      }
    }

    // if not found, create one
    if (!jointFrames) {
      jointFrames = {
        id: gltfChannel.node
      };
      frames.joints.push(jointFrames);
    }

    var outArray = createArray(gltf, bin, gltfChannel.output);
    if (gltfChannel.path === 'translation') {
      var cnt = outArray.length / 3;
      jointFrames.translations = new Array(cnt);
      for (var i$2 = 0; i$2 < cnt; ++i$2) {
        jointFrames.translations[i$2] = vec3.new(
          outArray[3 * i$2 + 0],
          outArray[3 * i$2 + 1],
          outArray[3 * i$2 + 2]
        );
      }
    } else if (gltfChannel.path === 'rotation') {
      var cnt$1 = outArray.length / 4;
      jointFrames.rotations = new Array(cnt$1);
      for (var i$3 = 0; i$3 < cnt$1; ++i$3) {
        jointFrames.rotations[i$3] = quat.new(
          outArray[4 * i$3 + 0],
          outArray[4 * i$3 + 1],
          outArray[4 * i$3 + 2],
          outArray[4 * i$3 + 3]
        );
      }
    } else if (gltfChannel.path === 'scale') {
      var cnt$2 = outArray.length / 3;
      jointFrames.scales = new Array(cnt$2);
      for (var i$4 = 0; i$4 < cnt$2; ++i$4) {
        jointFrames.scales[i$4] = vec3.new(
          outArray[3 * i$4 + 0],
          outArray[3 * i$4 + 1],
          outArray[3 * i$4 + 2]
        );
      }
    }
  }

  var animClip = new AnimationClip();
  animClip._name = gltfAnimation.name;
  animClip._framesList = framesList;
  animClip._length = maxLength;

  return animClip;
}

/**
 * @param {object} gltf
 */
function createJoints(gltf) {
  var joints = new Joints();
  joints._name = gltf.joints[0].name;
  joints._nodes = gltf.joints;

  return joints;
}

var gltfUtils = {
  createArray: createArray,
  createNodes: createNodes,
  createEntities: createEntities,
  createMesh: createMesh$1,
  createSkinning: createSkinning,
  createAnimationClip: createAnimationClip,
  createJoints: createJoints,
};

function meshLoader (app, urls, callback) {
  resl({
    manifest: {
      mesh: {
        type: 'text',
        parser: JSON.parse,
        src: urls.mesh,
      },
      bin: {
        type: 'binary',
        src: urls.bin
      }
    },

    onDone: function onDone(data) {
      var mesh = data.mesh;
      var bin = data.bin;

      if (!mesh.meshes.length) {
        callback(new Error('No mesh in the gltf.'));
        return;
      }

      var meshAsset = gltfUtils.createMesh(app, mesh, bin, 0);
      callback(null, meshAsset);
    }
  });
}

function materialLoader (app, urls, callback) {
  resl({
    manifest: {
      json: {
        type: 'text',
        parser: JSON.parse,
        src: urls.json,
      },
    },

    onDone: function onDone(data) {
      var json = data.json;

      var material = new Material();
      var props = json.properties;

      if (json.type === 'unlit') {
        material.effect = app.assets.get('builtin-effect-unlit');

        // values
        if (props.color) {
          material.setProperty('color', color4.new(
              props.color[0],
              props.color[1],
              props.color[2],
              props.color[3]
            )
          );
        }

        if (props.mainTiling) {
          material.setProperty('mainTiling', vec2.new(
              props.mainTiling[0],
              props.mainTiling[1]
            )
          );
        }

        if (props.mainOffset) {
          material.setProperty('mainOffset', vec2.new(
              props.mainOffset[0],
              props.mainOffset[1]
            )
          );
        }

        var tasks = [];

        // assets
        if (props.mainTexture) {
          tasks.push(function (done) {
            app.assets.load(props.mainTexture, function (err, asset) {
              // TODO: just set the texture instead
              material.setProperty('mainTexture', asset);
              material.define('USE_TEXTURE', true);
              done();
            });
          });
        }
        async.parallel(tasks, function (err) {
          if (err) {
            console.error(err);
          }

          callback(null, material);
        });

      } else if (json.type === 'phong') {
        material.effect = app.assets.get('builtin-effect-phong');

        // values
        if (props.diffuseColor) {
          material.setProperty('diffuseColor', color4.new(
              props.diffuseColor[0],
              props.diffuseColor[1],
              props.diffuseColor[2],
              props.diffuseColor[3]
            )
          );
        }

        if (props.mainTiling) {
          material.setProperty('mainTiling', vec2.new(
              props.mainTiling[0],
              props.mainTiling[1]
            )
          );
        }

        if (props.mainOffset) {
          material.setProperty('mainOffset', vec2.new(
              props.mainOffset[0],
              props.mainOffset[1]
            )
          );
        }

        material.define('USE_SPECULAR', props.USE_SPECULAR);
        if (props.specularColor) {
          material.setProperty('specularColor', color4.new(
              props.specularColor[0],
              props.specularColor[1],
              props.specularColor[2],
              props.specularColor[3]
            )
          );
        }

        material.define('USE_EMISSIVE', props.USE_EMISSIVE);
        if (props.emissiveColor) {
          material.setProperty('emissiveColor', color3.new(
              props.emissiveColor[0],
              props.emissiveColor[1],
              props.emissiveColor[2]
            )
          );
        }

        if (props.glossiness) {
          material.setProperty('glossiness', props.glossiness);
        }

        var tasks$1 = [];

        // assets
        material.define('USE_DIFFUSE_TEXTURE', props.USE_DIFFUSE_TEXTURE);
        if (props.diffuse_texture) {
          tasks$1.push(function (done) {
            app.assets.load(props.diffuse_texture, function (err, asset) {
              // TODO: just set the texture instead
              material.setProperty('diffuse_texture', asset);
              done();
            });
          });
        }

        material.define('USE_SPECULAR_TEXTURE', props.USE_SPECULAR_TEXTURE);
        if (props.specular_texture) {
          tasks$1.push(function (done) {
            app.assets.load(props.specular_texture, function (err, asset) {
              // TODO: just set the texture instead
              material.setProperty('specular_texture', asset);
              done();
            });
          });
        }

        material.define('USE_EMISSIVE_TEXTURE', props.USE_EMISSIVE_TEXTURE);
        if (props.emissive_texture) {
          tasks$1.push(function (done) {
            app.assets.load(props.emissive_texture, function (err, asset) {
              // TODO: just set the texture instead
              material.setProperty('emissive_texture', asset);
              done();
            });
          });
        }

        material.define('USE_NORMAL_TEXTURE', props.USE_NORMAL_TEXTURE);
        if (props.normal_texture) {
          tasks$1.push(function (done) {
            app.assets.load(props.normal_texture, function (err, asset) {
              // TODO: just set the texture instead
              material.setProperty('normal_texture', asset);
              done();
            });
          });
        }

        async.parallel(tasks$1, function (err) {
          if (err) {
            console.error(err);
          }

          callback(null, material);
        });
      } else if (json.type === 'grid') {
        material.effect = app.assets.get('builtin-effect-grid');

        material.define('USE_WORLD_POS', props.useWorldPos);
        material.setProperty('tiling', vec2.new(props.tilingX, props.tilingY));
        material.setProperty('baseColorBlack', color4.new(
            props.baseColorBlack[0],
            props.baseColorBlack[1],
            props.baseColorBlack[2],
            props.baseColorBlack[3]
          )
        );
        material.setProperty('baseColorWhite', color4.new(
            props.baseColorWhite[0],
            props.baseColorWhite[1],
            props.baseColorWhite[2],
            props.baseColorWhite[3]
          )
        );
        material.setProperty('subPatternColor', color4.new(
            props.subPatternColor[0],
            props.subPatternColor[1],
            props.subPatternColor[2],
            props.subPatternColor[3]
          )
        );
        material.setProperty('subPatternColor2', color4.new(
            props.subPatternColor2[0],
            props.subPatternColor2[1],
            props.subPatternColor2[2],
            props.subPatternColor2[3]
          )
        );

        material.setProperty('basePatternTiling', vec2.new(
            props.basePatternTiling[0],
            props.basePatternTiling[1]
          )
        );
        material.setProperty('basePatternOffset', vec2.new(
            props.basePatternOffset[0],
            props.basePatternOffset[1]
          )
        );

        material.setProperty('subPatternTiling', vec2.new(
            props.subPatternTiling[0],
            props.subPatternTiling[1]
          )
        );
        material.setProperty('subPatternOffset', vec2.new(
            props.subPatternOffset[0],
            props.subPatternOffset[1]
          )
        );

        material.setProperty('subPattern2Tiling', vec2.new(
            props.subPattern2Tiling[0],
            props.subPattern2Tiling[1]
          )
        );
        material.setProperty('subPattern2Offset', vec2.new(
            props.subPattern2Offset[0],
            props.subPattern2Offset[1]
          )
        );

        // HACK: we should have a way to set default texture
        app.assets.load('black-texture', function (err, asset) {
          material.setProperty('basePattern', asset);
          material.setProperty('subPattern', asset);
          material.setProperty('subPattern2', asset);
        });

        // textures
        var tasks$2 = [];
        if (props.basePattern) {
          tasks$2.push(function (done) {
            app.assets.load(props.basePattern, function (err, asset) {
              material.setProperty('basePattern', asset);
              done();
            });
          });
        }
        if (props.subPattern) {
          tasks$2.push(function (done) {
            app.assets.load(props.subPattern, function (err, asset) {
              material.setProperty('subPattern', asset);
              done();
            });
          });
        }
        if (props.subPattern2) {
          tasks$2.push(function (done) {
            app.assets.load(props.subPattern2, function (err, asset) {
              material.setProperty('subPattern2', asset);
              done();
            });
          });
        }

        //
        async.parallel(tasks$2, function (err) {
          if (err) {
            console.error(err);
          }

          callback(null, material);
        });
      } else if (json.type === 'matcap') {
        material.effect = app.assets.get('builtin-effect-matcap');

        // values
        if (props.colorFactor) {
          material.setProperty('colorFactor', props.colorFactor);
        }
        if (props.color) {
          material.setProperty('color', color4.new(
              props.color[0],
              props.color[1],
              props.color[2],
              props.color[3]
            )
          );
        }

        // textures
        var tasks$3 = [];

        if (props.mainTex) {
          tasks$3.push(function (done) {
            app.assets.load(props.mainTex, function (err, asset) {
              material.setProperty('mainTex', asset);
              material.define('USE_MAIN_TEX', true);
              done();
            });
          });
        }
        if (props.matcapTex) {
          tasks$3.push(function (done) {
            app.assets.load(props.matcapTex, function (err, asset) {
              material.setProperty('matcapTex', asset);
              done();
            });
          });
        }
        async.parallel(tasks$3, function (err) {
          if (err) {
            console.error(err);
          }

          callback(null, material);
        });
      } else if (json.type === 'pbr') {
        material.effect = app.assets.get('builtin-effect-pbr');

        material.setProperty('albedo', color4.new(
            props.albedo[0],
            props.albedo[1],
            props.albedo[2],
            props.albedo[3]
          )
        );

        if (props.mainTiling) {
          material.setProperty('mainTiling', vec2.new(
              props.mainTiling[0],
              props.mainTiling[1]
            )
          );
        }

        if (props.mainOffset) {
          material.setProperty('mainOffset', vec2.new(
              props.mainOffset[0],
              props.mainOffset[1]
            )
          );
        }

        if (props.metallic) {
          material.setProperty('metallic', props.metallic);
        }

        if (props.roughness) {
          material.setProperty('roughness', props.roughness);
        }

        if (props.ao) {
          material.setProperty('ao', props.ao);
        }

        material.define('USE_EMISSIVE', props.USE_EMISSIVE);
        if (props.emissive) {
          material.setProperty('emissive', color3.new(
              props.emissive[0],
              props.emissive[1],
              props.emissive[2]
            )
          );
        }

        // textures
        var tasks$4 = [];

        material.define('USE_ALBEDO_TEXTURE', props.USE_ALBEDO_TEXTURE);
        if (props.albedo_texture) {
          tasks$4.push(function (done) {
            app.assets.load(props.albedo_texture, function (err, asset) {
              material.setProperty('albedo_texture', asset);
              done();
            });
          });
        }

        material.define('USE_METALLIC_TEXTURE', props.USE_METALLIC_TEXTURE);
        if (props.metallic_texture) {
          tasks$4.push(function (done) {
            app.assets.load(props.metallic_texture, function (err, asset) {
              material.setProperty('metallic_texture', asset);
              done();
            });
          });
        }

        material.define('USE_ROUGHNESS_TEXTURE', props.USE_ROUGHNESS_TEXTURE);
        if (props.roughness_texture) {
          tasks$4.push(function (done) {
            app.assets.load(props.roughness_texture, function (err, asset) {
              material.setProperty('roughness_texture', asset);
              done();
            });
          });
        }

        material.define('USE_NORMAL_TEXTURE', props.USE_NORMAL_TEXTURE);
        if (props.normal_texture) {
          tasks$4.push(function (done) {
            app.assets.load(props.normal_texture, function (err, asset) {
              material.setProperty('normal_texture', asset);
              done();
            });
          });
        }

        material.define('USE_AO_TEXTURE', props.USE_AO_TEXTURE);
        if (props.ao_texture) {
          tasks$4.push(function (done) {
            app.assets.load(props.ao_texture, function (err, asset) {
              material.setProperty('ao_texture', asset);
              done();
            });
          });
        }

        material.define('USE_EMISSIVE_TEXTURE', props.USE_EMISSIVE_TEXTURE);
        if (props.emissive_texture) {
          tasks$4.push(function (done) {
            app.assets.load(props.emissive_texture, function (err, asset) {
              material.setProperty('emissive_texture', asset);
              done();
            });
          });
        }

        async.parallel(tasks$4, function (err) {
          if (err) {
            console.error(err);
          }

          callback(null, material);
        });

      } else if (json.type.startsWith('particle')) {
        material.effect = app.assets.get(("builtin-effect-" + (json.type)));

        // values
        if (props.tintColor) {
          material.setProperty('tintColor', color4.new(
              props.tintColor[0],
              props.tintColor[1],
              props.tintColor[2],
              props.tintColor[3]
            )
          );
        }

        if (props.mainTiling) {
          material.setProperty('mainTiling', vec2.new(
              props.mainTiling[0],
              props.mainTiling[1]
            )
          );
        }

        if (props.mainOffset) {
          material.setProperty('mainOffset', vec2.new(
              props.mainOffset[0],
              props.mainOffset[1]
            )
          );
        }

        var tasks$5 = [];

        // assets
        if (props.mainTexture) {
          tasks$5.push(function (done) {
            app.assets.load(props.mainTexture, function (err, asset) {
              // TODO: just set the texture instead
              material.setProperty('mainTexture', asset);
              done();
            });
          });
        }
        async.parallel(tasks$5, function (err) {
          if (err) {
            console.error(err);
          }

          callback(null, material);
        });
      } else { // TODO: support other materials that maybe loaded from assets.
        console.error('unsupported material loading');
      }
    }
  });
}

var TextureSprite = (function (Texture2D) {
  function TextureSprite(device) {
    Texture2D.call(this, device);

    this._sprites = {};
  }

  if ( Texture2D ) TextureSprite.__proto__ = Texture2D;
  TextureSprite.prototype = Object.create( Texture2D && Texture2D.prototype );
  TextureSprite.prototype.constructor = TextureSprite;

  var prototypeAccessors = { sprites: { configurable: true } };

  prototypeAccessors.sprites.get = function () {
    return this._sprites;
  };

  TextureSprite.prototype.unload = function unload () {
    var this$1 = this;

    if (!this._loaded) {
      return;
    }

    // unload all sprites
    for (var name in this$1._sprites) {
      this$1._sprites[name].unload();
    }

    Texture2D.prototype.unload.call(this);
  };

  TextureSprite.prototype.subAsset = function subAsset (localID) {
    var sprite = this._sprites[localID];
    return sprite || null;
  };

  Object.defineProperties( TextureSprite.prototype, prototypeAccessors );

  return TextureSprite;
}(Texture2D$2));

function createTexture2D(device, imgs, json) {
  var texture = new Texture2D$2(device);

  if (json) {
    texture.mipmap = json.mipmap;
    texture.anisotropy = json.anisotropy;
    texture.minFilter = json.minFilter;
    texture.magFilter = json.magFilter;
    texture.mipFilter = json.mipFilter;
    texture.wrapS = json.wrapS;
    texture.wrapT = json.wrapT;
  }

  texture.setImages(imgs);
  texture.commit();

  return texture;
}

function createTextureCube(device, imgs, json) {
  var texture = new TextureCube$2(device);

  if (json) {
    texture.mipmap = json.mipmap;
    texture.anisotropy = json.anisotropy;
    texture.minFilter = json.minFilter;
    texture.magFilter = json.magFilter;
    texture.mipFilter = json.mipFilter;
    texture.wrapS = json.wrapS;
    texture.wrapT = json.wrapT;
  }

  texture.setImages(imgs);
  texture.commit();

  return texture;
}

function createTextureSprite(device, imgs, json) {
  var texture = new TextureSprite(device);

  if (json) {
    texture.mipmap = json.mipmap;
    texture.anisotropy = json.anisotropy;
    texture.minFilter = json.minFilter;
    texture.magFilter = json.magFilter;
    texture.mipFilter = json.mipFilter;
    texture.wrapS = json.wrapS;
    texture.wrapT = json.wrapT;
  }

  texture.setImages(imgs);
  // NOTE: we need to commit texture first to get width & height so that sprites can commit correctly
  texture.commit();

  // create & commit sprites (asset)
  if (json && json.sprites) {
    for (var name in json.sprites) {
      var spriteJson = json.sprites[name];
      var sprite = new Sprite();
      sprite._name = name;
      sprite._rotated = spriteJson.rotated;
      sprite._x = spriteJson.x;
      sprite._y = spriteJson.y;
      sprite._width = spriteJson.width;
      sprite._height = spriteJson.height;
      sprite._left = spriteJson.left || 0;
      sprite._right = spriteJson.right || 0;
      sprite._top = spriteJson.top || 0;
      sprite._bottom = spriteJson.bottom || 0;
      sprite._texture = texture;
      sprite.commit();

      texture._sprites[name] = sprite;
    }
  }

  return texture;
}

function textureLoader (app, urls, callback) {
  var manifest = {};
  var maxLevel = 0;

  for (var name in urls) {
    if (name.indexOf('image') === 0) {
      var l = parseInt(name.split('@')[1]);
      if (l > maxLevel) {
        maxLevel = l;
      }

      manifest[name] = {
        type: 'image',
        src: urls[name]
      };
    }
  }
  maxLevel += 1;

  if (urls.json) {
    manifest.json = {
      type: 'text',
      parser: JSON.parse,
      src: urls.json,
    };
  }

  resl({
    manifest: manifest,
    onDone: function onDone(data) {
      var json = data.json;
      var images = [];
      var textureAsset;
      var type = json ? json.type : '2d';

      if (type === '2d' || type === 'sprite') {
        for (var l = 0; l < maxLevel; ++l) {
          if (l === 0) {
            images.push(
              data.image
            );
          } else {
            images.push(
              data[("image@" + l)]
            );
          }
        }

        if (type === '2d') {
          textureAsset = createTexture2D(app.device, images, json);
        } else if (type === 'sprite') {
          textureAsset = createTextureSprite(app.device, images, json);
        }
      } else if (type === 'cube') {
        for (var l$1 = 0; l$1 < maxLevel; ++l$1) {
          if (l$1 === 0) {
            images.push([
              data.imagePosX,
              data.imageNegX,
              data.imagePosY,
              data.imageNegY,
              data.imagePosZ,
              data.imageNegZ
            ]);
          } else {
            images.push([
              data[("imagePosX@" + l$1)],
              data[("imageNegX@" + l$1)],
              data[("imagePosY@" + l$1)],
              data[("imageNegY@" + l$1)],
              data[("imagePosZ@" + l$1)],
              data[("imageNegZ@" + l$1)]
            ]);
          }
        }

        // const { json, imagePosX, imageNegX, imagePosY, imageNegY, imagePosZ, imageNegZ } = data;
        textureAsset = createTextureCube(app.device, images, json);
      }

      callback(null, textureAsset);
    }
  });
}

var Prefab = (function (Asset$$1) {
  function Prefab() {
    Asset$$1.call(this);

    this._app = null;
    this._json = null;
    this._assets = null;
  }

  if ( Asset$$1 ) Prefab.__proto__ = Asset$$1;
  Prefab.prototype = Object.create( Asset$$1 && Asset$$1.prototype );
  Prefab.prototype.constructor = Prefab;

  Prefab.prototype.unload = function unload () {
    if (!this._loaded) {
      return;
    }

    // TODO: unload all assets referenced by the prefab ??

    Asset$$1.prototype.unload.call(this);
  };

  Prefab.prototype.instantiate = function instantiate (modifications, level) {
    if ( level === void 0 ) level = null;

    return ecsUtils.createPrefab(this._app, this._json, modifications, level);
  };

  return Prefab;
}(Asset));

function prefabLoader (app, urls, callback) {
  resl({
    manifest: {
      json: {
        type: 'text',
        parser: JSON.parse,
        src: urls.json,
      },
    },
    onDone: function onDone(data) {
      ecsUtils.preloadAssets(app, data.json, function (err, assets) {
        var prefab = new Prefab();
        prefab._app = app;
        prefab._json = data.json;
        prefab._assets = assets;

        if (err) {
          callback(err);
          return;
        }

        callback(null, prefab);
      });
    }
  });
}

var Gltf = (function (Asset$$1) {
  function Gltf() {
    Asset$$1.call(this);

    this._nodes = null; // [gltfNode, ...]
    this._meshes = null; // [Mesh, ...]
    this._joints = null; // Joints
  }

  if ( Asset$$1 ) Gltf.__proto__ = Asset$$1;
  Gltf.prototype = Object.create( Asset$$1 && Asset$$1.prototype );
  Gltf.prototype.constructor = Gltf;

  Gltf.prototype.subAsset = function subAsset (localID) {
    var id = parseInt(localID.substring(1));
    if (localID[0] === 'm') {
      return this._meshes[id];
    }

    if (localID === 'joints') {
      return this._joints;
    }

    return null;
  };

  return Gltf;
}(Asset));

function gltfLoader (app, urls, callback) {
  resl({
    manifest: {
      gltf: {
        type: 'text',
        parser: JSON.parse,
        src: urls.gltf,
      },
      bin: {
        type: 'binary',
        src: urls.bin
      }
    },

    onDone: function onDone(data) {
      var gltf = data.gltf;
      var bin = data.bin;

      var gltfAsset = new Gltf();

      gltfAsset._nodes = gltf.nodes;

      if (gltf.meshes) {
        gltfAsset._meshes = new Array(gltf.meshes.length);
        for (var i = 0; i < gltf.meshes.length; ++i) {
          gltfAsset._meshes[i] = gltfUtils.createMesh(app, gltf, bin, i);
        }
      }

      if (gltf.joints) {
        gltfAsset._joints = gltfUtils.createJoints(gltf);
      }

      callback(null, gltfAsset);
    }
  });
}

function animationLoader (app, urls, callback) {
  resl({
    manifest: {
      // a gltf-like json file
      anim: {
        type: 'text',
        parser: JSON.parse,
        src: urls.anim,
      },
      bin: {
        type: 'binary',
        src: urls.bin
      }
    },

    onDone: function onDone(data) {
      var anim = data.anim;
      var bin = data.bin;

      if (!anim.animations.length) {
        callback(new Error('No animation in the gltf.'));
        return;
      }

      var animClip = gltfUtils.createAnimationClip(anim, bin, 0);
      callback(null, animClip);
    }
  });
}

var enums$3 = {
  WEB_AUDIO: 0,
  DOM_AUDIO: 1,
};

/**
 * The wrapper class holding the clip resource
 */
var AudioClip = (function (Asset$$1) {
  function AudioClip() {
    Asset$$1.call(this);
    this.__initEventEmitter();
    this._audio = null;
    /**
     * Current load mode, using Web Audio API by default
     * @type {number}
     */
    this.loadMode = enums$3.WEB_AUDIO;
  }

  if ( Asset$$1 ) AudioClip.__proto__ = Asset$$1;
  AudioClip.prototype = Object.create( Asset$$1 && Asset$$1.prototype );
  AudioClip.prototype.constructor = AudioClip;

  var prototypeAccessors = { nativeAsset: { configurable: true } };

  /**
   * Get the actual audio asset, is either
   * the AudioBuffer from Web Audio API in WEB_MODE, 
   * or the audio DOM element in DOM_MODE
   * @return {AudioBuffer|HTMLAudioElement}
   */
  prototypeAccessors.nativeAsset.get = function () {
    return this._audio;
  };

  /**
   * Set the actual audio asset
   * @param {AudioBuffer|HTMLAudioElement} value
   */
  prototypeAccessors.nativeAsset.set = function (value) {
    this._audio = value;
    if (value) {
      this._loaded = true;
    }
  };

  Object.defineProperties( AudioClip.prototype, prototypeAccessors );

  return AudioClip;
}(Asset));

EventEmitter.mixin(AudioClip);
Object.assign(AudioClip, enums$3);

var sys = null;

/**
 * Load the audio resource at the specified URL
 * @param {App} app the global app instance
 * @param {{bin:string}} urls URL where the resource is located
 * @param {function(e:Error, c:AudioClip)} callback the callback after resource loaded or failed
 * @return {?Error} error message if there is one
 */
function audioLoader (app, urls, callback) {
  sys = app.system('audio');

  if (sys.__audioSupport.format.length === 0) {
    return new Error('no audio file format available.');
  }
  var audioID = sys.getIDByURL(urls.bin);
  if (audioID) {
    sys._getClipByID(audioID).once('load', function () {
      callback(null, sys._getClipByID(audioID));
    });
    return;
  }

  var loader = null;
  if (!sys.__audioSupport.WEB_AUDIO) {
    // If WebAudio is not supported, load using DOM mode
    loader = loadDomAudio;
  }
  else {
    // TODO: urls end with ?useDom=1
    loader = loadWebAudio;
  }
  urls.url = urls.bin;
  loader(urls, callback);
}

// TODO: merge with resl solution
function loadDomAudio (item, callback) {
  var dom = document.createElement('audio');
  dom.src = item.url;

  // if (CC_WECHATGAME) {
  //   callback(null, dom);
  //   return;
  // }

  var clearEvent = function () {
    clearTimeout(timer);
    dom.removeEventListener('canplaythrough', success, false);
    dom.removeEventListener('error', failure, false);
    if(sys.__audioSupport.USE_LOADER_EVENT)
      { dom.removeEventListener(sys.__audioSupport.USE_LOADER_EVENT, success, false); }
  };
  var timer = setTimeout(function () {
    if (dom.readyState === 0)
      { failure(); }
    else
      { success(); }
  }, 8000);
  var clip = new AudioClip();
  clip.url = item.url;
  sys.addClip(item.url, clip);
  var success = function () {
    clearEvent();
    clip.nativeAsset = dom;
    clip.loadMode = AudioClip.DOM_AUDIO;
    clip.emit('load');
    callback(null, clip);
  };
  var failure = function () {
    clearEvent();
    var message = 'load audio failure - ' + item.url;
    console.log(message);
    sys.removeClip(item.url);
    callback(message);
  };
  dom.addEventListener('canplaythrough', success, false);
  dom.addEventListener('error', failure, false);
  if(sys.__audioSupport.USE_LOADER_EVENT)
    { dom.addEventListener(sys.__audioSupport.USE_LOADER_EVENT, success, false); }
}

function loadWebAudio (item, callback) {
  if (!sys.__audioSupport.context) { callback(new Error('audio context not found.')); }

  var request = getXMLHttpRequest();
  request.open('GET', item.url, true);
  request.responseType = 'arraybuffer';

  // fist add reference to audio system
  var clip = new AudioClip();
  clip.url = item.url;
  sys.addClip(item.url, clip);
  // Our asynchronous callback
  request.onload = function () {
    sys.__audioSupport.context['decodeAudioData'](request.response, function(buffer){
      clip.nativeAsset = buffer;
      //success
      clip.emit('load');
      callback(null, clip);
    }, function(){
      //error
      sys.removeClip(item.url);
      callback('decode error', null);
    });
  };

  request.onerror = function(){
    sys.removeClip(item.url);
    callback('request error', null);
  };

  request.send();
}

function getXMLHttpRequest () {
  return window.XMLHttpRequest ? new window.XMLHttpRequest() : new window.ActiveXObject('MSXML2.XMLHTTP');
}

var Font = (function (Asset$$1) {
  function Font() {
    Asset$$1.call(this);

    this._size = 32; // font size
    this._type = 'unknow'; // font type: bitmap or opentype
    // bitmap font glyph: {char, x, y, width, height, xoffset, yoffset, xadvance}
    // opentype font glyph: {id, x, y, width, height, xoffset, yoffset, xadvance}
    this._glyphs = {};
    this._lineHeight = 32;
    this._useKerning = false;
  }

  if ( Asset$$1 ) Font.__proto__ = Asset$$1;
  Font.prototype = Object.create( Asset$$1 && Asset$$1.prototype );
  Font.prototype.constructor = Font;

  var prototypeAccessors = { size: { configurable: true },lineHeight: { configurable: true },type: { configurable: true } };

  prototypeAccessors.size.get = function () {
    return this._size;
  };

  prototypeAccessors.lineHeight.get = function () {
    return this._lineHeight;
  };

  prototypeAccessors.type.get = function () {
    return this._type;
  };

  Object.defineProperties( Font.prototype, prototypeAccessors );

  return Font;
}(Asset));

var BMFont = (function (Font$$1) {
  function BMFont() {
    Font$$1.call(this);

    this._texture = null;
    this._face = '';
    this._defaultGlyph = {
      char: ' ',
      x: 0,
      y: 0,
      width: 16,
      height: 16,
      xoffset: 0,
      yoffset: 0,
      xadvance: 16,
      uvs: [
        vec2.new(0, 0),
        vec2.new(0, 0),
        vec2.new(0, 0),
        vec2.new(0, 0)
      ],
    };
    this._type = 'bitmap';
  }

  if ( Font$$1 ) BMFont.__proto__ = Font$$1;
  BMFont.prototype = Object.create( Font$$1 && Font$$1.prototype );
  BMFont.prototype.constructor = BMFont;

  var prototypeAccessors = { texture: { configurable: true },face: { configurable: true } };

  prototypeAccessors.texture.get = function () {
    return this._texture;
  };

  prototypeAccessors.face.get = function () {
    return this._face;
  };

  Object.defineProperties( BMFont.prototype, prototypeAccessors );

  return BMFont;
}(Font));

function bmfontLoader (app, urls, callback) {
  resl({
    manifest: {
      json: {
        type: 'text',
        parser: JSON.parse,
        src: urls.json,
      },
    },

    onDone: function onDone(data) {
      var json = data.json;
      var font = new BMFont();
      app.assets.load(json.texture, function (err, asset) {
        if (err) {
          console.error(err);
          callback(err, null);
          return;
        }

        var textureWidth = asset._texture._width;
        var textureHeight = asset._texture._height;

        font._texture = asset;
        font._face = json.face;
        font._size = json.size;
        font._lineHeight = json.lineHeight;

        // TODO: add kernings here
        // json.kernings.forEach(kerning => {
        //   font._kernings[kerning.first] = font._kernings[kerning.first] || {};
        //   font._kernings[kerning.first][kerning.second] = kerning.amount;
        // });

        /**
         * v2------v3
         * |       |
         * |       |
         * |       |
         * v0      v1
         */
        for (var charCode in json.chars) {
          var glyph = json.chars[charCode];
          var u0 = glyph.x / textureWidth;
          var u1 = (glyph.x + glyph.width) / textureWidth;
          var v0 = 1.0 - (glyph.y + glyph.height) / textureHeight;
          var v1 = 1.0 - glyph.y / textureHeight;

          font._glyphs[charCode] = {
            char: String.fromCharCode(charCode),
            x: glyph.x,
            y: glyph.y,
            width: glyph.width,
            height: glyph.height,
            xoffset: glyph.xoffset,
            yoffset: glyph.yoffset,
            xadvance: glyph.xadvance
          };
          font._glyphs[charCode].uvs = [
            vec2.new(u0, v0),
            vec2.new(u1, v0),
            vec2.new(u0, v1),
            vec2.new(u1, v1)
          ];
        }

        callback(null, font);
      });
    }
  });
}

var TINF_OK = 0;
var TINF_DATA_ERROR = -3;

function Tree() {
  this.table = new Uint16Array(16);   /* table of code length counts */
  this.trans = new Uint16Array(288);  /* code -> symbol translation table */
}

function Data(source, dest) {
  this.source = source;
  this.sourceIndex = 0;
  this.tag = 0;
  this.bitcount = 0;
  
  this.dest = dest;
  this.destLen = 0;
  
  this.ltree = new Tree();  /* dynamic length/symbol tree */
  this.dtree = new Tree();  /* dynamic distance tree */
}

/* --------------------------------------------------- *
 * -- uninitialized global data (static structures) -- *
 * --------------------------------------------------- */

var sltree = new Tree();
var sdtree = new Tree();

/* extra bits and base tables for length codes */
var length_bits = new Uint8Array(30);
var length_base = new Uint16Array(30);

/* extra bits and base tables for distance codes */
var dist_bits = new Uint8Array(30);
var dist_base = new Uint16Array(30);

/* special ordering of code length codes */
var clcidx = new Uint8Array([
  16, 17, 18, 0, 8, 7, 9, 6,
  10, 5, 11, 4, 12, 3, 13, 2,
  14, 1, 15
]);

/* used by tinf_decode_trees, avoids allocations every call */
var code_tree = new Tree();
var lengths = new Uint8Array(288 + 32);

/* ----------------------- *
 * -- utility functions -- *
 * ----------------------- */

/* build extra bits and base tables */
function tinf_build_bits_base(bits, base, delta, first) {
  var i, sum;

  /* build bits table */
  for (i = 0; i < delta; ++i) { bits[i] = 0; }
  for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }

  /* build base table */
  for (sum = first, i = 0; i < 30; ++i) {
    base[i] = sum;
    sum += 1 << bits[i];
  }
}

/* build the fixed huffman trees */
function tinf_build_fixed_trees(lt, dt) {
  var i;

  /* build fixed length tree */
  for (i = 0; i < 7; ++i) { lt.table[i] = 0; }

  lt.table[7] = 24;
  lt.table[8] = 152;
  lt.table[9] = 112;

  for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }
  for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }
  for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }
  for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }

  /* build fixed distance tree */
  for (i = 0; i < 5; ++i) { dt.table[i] = 0; }

  dt.table[5] = 32;

  for (i = 0; i < 32; ++i) { dt.trans[i] = i; }
}

/* given an array of code lengths, build a tree */
var offs = new Uint16Array(16);

function tinf_build_tree(t, lengths, off, num) {
  var i, sum;

  /* clear code length count table */
  for (i = 0; i < 16; ++i) { t.table[i] = 0; }

  /* scan symbol lengths, and sum code length counts */
  for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }

  t.table[0] = 0;

  /* compute offset table for distribution sort */
  for (sum = 0, i = 0; i < 16; ++i) {
    offs[i] = sum;
    sum += t.table[i];
  }

  /* create code->symbol translation table (symbols sorted by code) */
  for (i = 0; i < num; ++i) {
    if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }
  }
}

/* ---------------------- *
 * -- decode functions -- *
 * ---------------------- */

/* get one bit from source stream */
function tinf_getbit(d) {
  /* check if tag is empty */
  if (!d.bitcount--) {
    /* load next tag */
    d.tag = d.source[d.sourceIndex++];
    d.bitcount = 7;
  }

  /* shift bit out of tag */
  var bit = d.tag & 1;
  d.tag >>>= 1;

  return bit;
}

/* read a num bit value from a stream and add base */
function tinf_read_bits(d, num, base) {
  if (!num)
    { return base; }

  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }

  var val = d.tag & (0xffff >>> (16 - num));
  d.tag >>>= num;
  d.bitcount -= num;
  return val + base;
}

/* given a data stream and a tree, decode a symbol */
function tinf_decode_symbol(d, t) {
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  
  var sum = 0, cur = 0, len = 0;
  var tag = d.tag;

  /* get more bits while code value is above sum */
  do {
    cur = 2 * cur + (tag & 1);
    tag >>>= 1;
    ++len;

    sum += t.table[len];
    cur -= t.table[len];
  } while (cur >= 0);
  
  d.tag = tag;
  d.bitcount -= len;

  return t.trans[sum + cur];
}

/* given a data stream, decode dynamic trees from it */
function tinf_decode_trees(d, lt, dt) {
  var hlit, hdist, hclen;
  var i, num, length;

  /* get 5 bits HLIT (257-286) */
  hlit = tinf_read_bits(d, 5, 257);

  /* get 5 bits HDIST (1-32) */
  hdist = tinf_read_bits(d, 5, 1);

  /* get 4 bits HCLEN (4-19) */
  hclen = tinf_read_bits(d, 4, 4);

  for (i = 0; i < 19; ++i) { lengths[i] = 0; }

  /* read code lengths for code length alphabet */
  for (i = 0; i < hclen; ++i) {
    /* get 3 bits code length (0-7) */
    var clen = tinf_read_bits(d, 3, 0);
    lengths[clcidx[i]] = clen;
  }

  /* build code length tree */
  tinf_build_tree(code_tree, lengths, 0, 19);

  /* decode code lengths for the dynamic trees */
  for (num = 0; num < hlit + hdist;) {
    var sym = tinf_decode_symbol(d, code_tree);

    switch (sym) {
      case 16:
        /* copy previous code length 3-6 times (read 2 bits) */
        var prev = lengths[num - 1];
        for (length = tinf_read_bits(d, 2, 3); length; --length) {
          lengths[num++] = prev;
        }
        break;
      case 17:
        /* repeat code length 0 for 3-10 times (read 3 bits) */
        for (length = tinf_read_bits(d, 3, 3); length; --length) {
          lengths[num++] = 0;
        }
        break;
      case 18:
        /* repeat code length 0 for 11-138 times (read 7 bits) */
        for (length = tinf_read_bits(d, 7, 11); length; --length) {
          lengths[num++] = 0;
        }
        break;
      default:
        /* values 0-15 represent the actual code lengths */
        lengths[num++] = sym;
        break;
    }
  }

  /* build dynamic trees */
  tinf_build_tree(lt, lengths, 0, hlit);
  tinf_build_tree(dt, lengths, hlit, hdist);
}

/* ----------------------------- *
 * -- block inflate functions -- *
 * ----------------------------- */

/* given a stream and two trees, inflate a block of data */
function tinf_inflate_block_data(d, lt, dt) {
  while (1) {
    var sym = tinf_decode_symbol(d, lt);

    /* check for end of block */
    if (sym === 256) {
      return TINF_OK;
    }

    if (sym < 256) {
      d.dest[d.destLen++] = sym;
    } else {
      var length, dist, offs;
      var i;

      sym -= 257;

      /* possibly get more bits from length code */
      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);

      dist = tinf_decode_symbol(d, dt);

      /* possibly get more bits from distance code */
      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);

      /* copy match */
      for (i = offs; i < offs + length; ++i) {
        d.dest[d.destLen++] = d.dest[i];
      }
    }
  }
}

/* inflate an uncompressed block of data */
function tinf_inflate_uncompressed_block(d) {
  var length, invlength;
  var i;
  
  /* unread from bitbuffer */
  while (d.bitcount > 8) {
    d.sourceIndex--;
    d.bitcount -= 8;
  }

  /* get length */
  length = d.source[d.sourceIndex + 1];
  length = 256 * length + d.source[d.sourceIndex];

  /* get one's complement of length */
  invlength = d.source[d.sourceIndex + 3];
  invlength = 256 * invlength + d.source[d.sourceIndex + 2];

  /* check length */
  if (length !== (~invlength & 0x0000ffff))
    { return TINF_DATA_ERROR; }

  d.sourceIndex += 4;

  /* copy block */
  for (i = length; i; --i)
    { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }

  /* make sure we start next block on a byte boundary */
  d.bitcount = 0;

  return TINF_OK;
}

/* inflate stream from source to dest */
function tinf_uncompress(source, dest) {
  var d = new Data(source, dest);
  var bfinal, btype, res;

  do {
    /* read final block flag */
    bfinal = tinf_getbit(d);

    /* read block type (2 bits) */
    btype = tinf_read_bits(d, 2, 0);

    /* decompress block */
    switch (btype) {
      case 0:
        /* decompress uncompressed block */
        res = tinf_inflate_uncompressed_block(d);
        break;
      case 1:
        /* decompress block with fixed huffman trees */
        res = tinf_inflate_block_data(d, sltree, sdtree);
        break;
      case 2:
        /* decompress block with dynamic huffman trees */
        tinf_decode_trees(d, d.ltree, d.dtree);
        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
        break;
      default:
        res = TINF_DATA_ERROR;
    }

    if (res !== TINF_OK)
      { throw new Error('Data error'); }

  } while (!bfinal);

  if (d.destLen < d.dest.length) {
    if (typeof d.dest.slice === 'function')
      { return d.dest.slice(0, d.destLen); }
    else
      { return d.dest.subarray(0, d.destLen); }
  }
  
  return d.dest;
}

/* -------------------- *
 * -- initialization -- *
 * -------------------- */

/* build fixed huffman trees */
tinf_build_fixed_trees(sltree, sdtree);

/* build extra bits and base tables */
tinf_build_bits_base(length_bits, length_base, 4, 3);
tinf_build_bits_base(dist_bits, dist_base, 2, 1);

/* fix a special case */
length_bits[28] = 0;
length_base[28] = 258;

var tinyInflate = tinf_uncompress;

// The Bounding Box object

function derive(v0, v1, v2, v3, t) {
    return Math.pow(1 - t, 3) * v0 +
        3 * Math.pow(1 - t, 2) * t * v1 +
        3 * (1 - t) * Math.pow(t, 2) * v2 +
        Math.pow(t, 3) * v3;
}
/**
 * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.
 * It is used to calculate the bounding box of a glyph or text path.
 *
 * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.
 *
 * @exports opentype.BoundingBox
 * @class
 * @constructor
 */
function BoundingBox() {
    this.x1 = Number.NaN;
    this.y1 = Number.NaN;
    this.x2 = Number.NaN;
    this.y2 = Number.NaN;
}

/**
 * Returns true if the bounding box is empty, that is, no points have been added to the box yet.
 */
BoundingBox.prototype.isEmpty = function() {
    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
};

/**
 * Add the point to the bounding box.
 * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.
 * @param {number} x - The X coordinate of the point.
 * @param {number} y - The Y coordinate of the point.
 */
BoundingBox.prototype.addPoint = function(x, y) {
    if (typeof x === 'number') {
        if (isNaN(this.x1) || isNaN(this.x2)) {
            this.x1 = x;
            this.x2 = x;
        }
        if (x < this.x1) {
            this.x1 = x;
        }
        if (x > this.x2) {
            this.x2 = x;
        }
    }
    if (typeof y === 'number') {
        if (isNaN(this.y1) || isNaN(this.y2)) {
            this.y1 = y;
            this.y2 = y;
        }
        if (y < this.y1) {
            this.y1 = y;
        }
        if (y > this.y2) {
            this.y2 = y;
        }
    }
};

/**
 * Add a X coordinate to the bounding box.
 * This extends the bounding box to include the X coordinate.
 * This function is used internally inside of addBezier.
 * @param {number} x - The X coordinate of the point.
 */
BoundingBox.prototype.addX = function(x) {
    this.addPoint(x, null);
};

/**
 * Add a Y coordinate to the bounding box.
 * This extends the bounding box to include the Y coordinate.
 * This function is used internally inside of addBezier.
 * @param {number} y - The Y coordinate of the point.
 */
BoundingBox.prototype.addY = function(y) {
    this.addPoint(null, y);
};

/**
 * Add a Bzier curve to the bounding box.
 * This extends the bounding box to include the entire Bzier.
 * @param {number} x0 - The starting X coordinate.
 * @param {number} y0 - The starting Y coordinate.
 * @param {number} x1 - The X coordinate of the first control point.
 * @param {number} y1 - The Y coordinate of the first control point.
 * @param {number} x2 - The X coordinate of the second control point.
 * @param {number} y2 - The Y coordinate of the second control point.
 * @param {number} x - The ending X coordinate.
 * @param {number} y - The ending Y coordinate.
 */
BoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {
    var this$1 = this;

    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html
    // and https://github.com/icons8/svg-path-bounding-box

    var p0 = [x0, y0];
    var p1 = [x1, y1];
    var p2 = [x2, y2];
    var p3 = [x, y];

    this.addPoint(x0, y0);
    this.addPoint(x, y);

    for (var i = 0; i <= 1; i++) {
        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
        var c = 3 * p1[i] - 3 * p0[i];

        if (a === 0) {
            if (b === 0) { continue; }
            var t = -c / b;
            if (0 < t && t < 1) {
                if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t)); }
                if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t)); }
            }
            continue;
        }

        var b2ac = Math.pow(b, 2) - 4 * c * a;
        if (b2ac < 0) { continue; }
        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
        if (0 < t1 && t1 < 1) {
            if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
            if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
        }
        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
        if (0 < t2 && t2 < 1) {
            if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
            if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
        }
    }
};

/**
 * Add a quadratic curve to the bounding box.
 * This extends the bounding box to include the entire quadratic curve.
 * @param {number} x0 - The starting X coordinate.
 * @param {number} y0 - The starting Y coordinate.
 * @param {number} x1 - The X coordinate of the control point.
 * @param {number} y1 - The Y coordinate of the control point.
 * @param {number} x - The ending X coordinate.
 * @param {number} y - The ending Y coordinate.
 */
BoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {
    var cp1x = x0 + 2 / 3 * (x1 - x0);
    var cp1y = y0 + 2 / 3 * (y1 - y0);
    var cp2x = cp1x + 1 / 3 * (x - x0);
    var cp2y = cp1y + 1 / 3 * (y - y0);
    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
};

// Geometric objects

function Path() {
    this.commands = [];
    this.fill = 'black';
    this.stroke = null;
    this.strokeWidth = 1;
}

/**
 * @param  {number} x
 * @param  {number} y
 */
Path.prototype.moveTo = function(x, y) {
    this.commands.push({
        type: 'M',
        x: x,
        y: y
    });
};

/**
 * @param  {number} x
 * @param  {number} y
 */
Path.prototype.lineTo = function(x, y) {
    this.commands.push({
        type: 'L',
        x: x,
        y: y
    });
};

/**
 * Draws cubic curve
 * @function
 * curveTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control 1
 * @param  {number} y1 - y of control 1
 * @param  {number} x2 - x of control 2
 * @param  {number} y2 - y of control 2
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 */

/**
 * Draws cubic curve
 * @function
 * bezierCurveTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control 1
 * @param  {number} y1 - y of control 1
 * @param  {number} x2 - x of control 2
 * @param  {number} y2 - y of control 2
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 * @see curveTo
 */
Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
    this.commands.push({
        type: 'C',
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        x: x,
        y: y
    });
};

/**
 * Draws quadratic curve
 * @function
 * quadraticCurveTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control
 * @param  {number} y1 - y of control
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 */

/**
 * Draws quadratic curve
 * @function
 * quadTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control
 * @param  {number} y1 - y of control
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 */
Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
    this.commands.push({
        type: 'Q',
        x1: x1,
        y1: y1,
        x: x,
        y: y
    });
};

/**
 * Closes the path
 * @function closePath
 * @memberof opentype.Path.prototype
 */

/**
 * Close the path
 * @function close
 * @memberof opentype.Path.prototype
 */
Path.prototype.close = Path.prototype.closePath = function() {
    this.commands.push({
        type: 'Z'
    });
};

/**
 * Add the given path or list of commands to the commands of this path.
 * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.
 */
Path.prototype.extend = function(pathOrCommands) {
    if (pathOrCommands.commands) {
        pathOrCommands = pathOrCommands.commands;
    } else if (pathOrCommands instanceof BoundingBox) {
        var box = pathOrCommands;
        this.moveTo(box.x1, box.y1);
        this.lineTo(box.x2, box.y1);
        this.lineTo(box.x2, box.y2);
        this.lineTo(box.x1, box.y2);
        this.close();
        return;
    }

    Array.prototype.push.apply(this.commands, pathOrCommands);
};

/**
 * Calculate the bounding box of the path.
 * @returns {opentype.BoundingBox}
 */
Path.prototype.getBoundingBox = function() {
    var this$1 = this;

    var box = new BoundingBox();

    var startX = 0;
    var startY = 0;
    var prevX = 0;
    var prevY = 0;
    for (var i = 0; i < this.commands.length; i++) {
        var cmd = this$1.commands[i];
        switch (cmd.type) {
            case 'M':
                box.addPoint(cmd.x, cmd.y);
                startX = prevX = cmd.x;
                startY = prevY = cmd.y;
                break;
            case 'L':
                box.addPoint(cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'Q':
                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'C':
                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'Z':
                prevX = startX;
                prevY = startY;
                break;
            default:
                throw new Error('Unexpected path command ' + cmd.type);
        }
    }
    if (box.isEmpty()) {
        box.addPoint(0, 0);
    }
    return box;
};

/**
 * Draw the path to a 2D context.
 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.
 */
Path.prototype.draw = function(ctx) {
    var this$1 = this;

    ctx.beginPath();
    for (var i = 0; i < this.commands.length; i += 1) {
        var cmd = this$1.commands[i];
        if (cmd.type === 'M') {
            ctx.moveTo(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            ctx.lineTo(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            ctx.closePath();
        }
    }

    if (this.fill) {
        ctx.fillStyle = this.fill;
        ctx.fill();
    }

    if (this.stroke) {
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth;
        ctx.stroke();
    }
};

/**
 * Convert the Path to a string of path data instructions
 * See http://www.w3.org/TR/SVG/paths.html#PathData
 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
 * @return {string}
 */
Path.prototype.toPathData = function(decimalPlaces) {
    var this$1 = this;

    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;

    function floatToString(v) {
        if (Math.round(v) === v) {
            return '' + Math.round(v);
        } else {
            return v.toFixed(decimalPlaces);
        }
    }

    function packValues() {
        var arguments$1 = arguments;

        var s = '';
        for (var i = 0; i < arguments.length; i += 1) {
            var v = arguments$1[i];
            if (v >= 0 && i > 0) {
                s += ' ';
            }

            s += floatToString(v);
        }

        return s;
    }

    var d = '';
    for (var i = 0; i < this.commands.length; i += 1) {
        var cmd = this$1.commands[i];
        if (cmd.type === 'M') {
            d += 'M' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            d += 'L' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            d += 'Z';
        }
    }

    return d;
};

/**
 * Convert the path to an SVG <path> element, as a string.
 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
 * @return {string}
 */
Path.prototype.toSVG = function(decimalPlaces) {
    var svg = '<path d="';
    svg += this.toPathData(decimalPlaces);
    svg += '"';
    if (this.fill && this.fill !== 'black') {
        if (this.fill === null) {
            svg += ' fill="none"';
        } else {
            svg += ' fill="' + this.fill + '"';
        }
    }

    if (this.stroke) {
        svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
    }

    svg += '/>';
    return svg;
};

/**
 * Convert the path to a DOM element.
 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
 * @return {SVGPathElement}
 */
Path.prototype.toDOMElement = function(decimalPlaces) {
    var temporaryPath = this.toPathData(decimalPlaces);
    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');

    newPath.setAttribute('d', temporaryPath);

    return newPath;
};

// Run-time checking of preconditions.

function fail(message) {
    throw new Error(message);
}

// Precondition function that checks if the given predicate is true.
// If not, it will throw an error.
function argument(predicate, message) {
    if (!predicate) {
        fail(message);
    }
}

var check = { fail: fail, argument: argument, assert: argument };

// Data types used in the OpenType font file.
// All OpenType fonts use Motorola-style byte ordering (Big Endian)

var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31

/**
 * @exports opentype.decode
 * @class
 */
var decode = {};
/**
 * @exports opentype.encode
 * @class
 */
var encode = {};
/**
 * @exports opentype.sizeOf
 * @class
 */
var sizeOf = {};

// Return a function that always returns the same value.
function constant(v) {
    return function() {
        return v;
    };
}

// OpenType data types //////////////////////////////////////////////////////

/**
 * Convert an 8-bit unsigned integer to a list of 1 byte.
 * @param {number}
 * @returns {Array}
 */
encode.BYTE = function(v) {
    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
    return [v];
};
/**
 * @constant
 * @type {number}
 */
sizeOf.BYTE = constant(1);

/**
 * Convert a 8-bit signed integer to a list of 1 byte.
 * @param {string}
 * @returns {Array}
 */
encode.CHAR = function(v) {
    return [v.charCodeAt(0)];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.CHAR = constant(1);

/**
 * Convert an ASCII string to a list of bytes.
 * @param {string}
 * @returns {Array}
 */
encode.CHARARRAY = function(v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        b[i] = v.charCodeAt(i);
    }

    return b;
};

/**
 * @param {Array}
 * @returns {number}
 */
sizeOf.CHARARRAY = function(v) {
    return v.length;
};

/**
 * Convert a 16-bit unsigned integer to a list of 2 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.USHORT = function(v) {
    return [(v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.USHORT = constant(2);

/**
 * Convert a 16-bit signed integer to a list of 2 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.SHORT = function(v) {
    // Two's complement
    if (v >= LIMIT16) {
        v = -(2 * LIMIT16 - v);
    }

    return [(v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.SHORT = constant(2);

/**
 * Convert a 24-bit unsigned integer to a list of 3 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.UINT24 = function(v) {
    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.UINT24 = constant(3);

/**
 * Convert a 32-bit unsigned integer to a list of 4 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.ULONG = function(v) {
    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.ULONG = constant(4);

/**
 * Convert a 32-bit unsigned integer to a list of 4 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.LONG = function(v) {
    // Two's complement
    if (v >= LIMIT32) {
        v = -(2 * LIMIT32 - v);
    }

    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.LONG = constant(4);

encode.FIXED = encode.ULONG;
sizeOf.FIXED = sizeOf.ULONG;

encode.FWORD = encode.SHORT;
sizeOf.FWORD = sizeOf.SHORT;

encode.UFWORD = encode.USHORT;
sizeOf.UFWORD = sizeOf.USHORT;

/**
 * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.
 * @param {number}
 * @returns {Array}
 */
encode.LONGDATETIME = function(v) {
    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.LONGDATETIME = constant(8);

/**
 * Convert a 4-char tag to a list of 4 bytes.
 * @param {string}
 * @returns {Array}
 */
encode.TAG = function(v) {
    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
    return [v.charCodeAt(0),
            v.charCodeAt(1),
            v.charCodeAt(2),
            v.charCodeAt(3)];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.TAG = constant(4);

// CFF data types ///////////////////////////////////////////////////////////

encode.Card8 = encode.BYTE;
sizeOf.Card8 = sizeOf.BYTE;

encode.Card16 = encode.USHORT;
sizeOf.Card16 = sizeOf.USHORT;

encode.OffSize = encode.BYTE;
sizeOf.OffSize = sizeOf.BYTE;

encode.SID = encode.USHORT;
sizeOf.SID = sizeOf.USHORT;

// Convert a numeric operand or charstring number to a variable-size list of bytes.
/**
 * Convert a numeric operand or charstring number to a variable-size list of bytes.
 * @param {number}
 * @returns {Array}
 */
encode.NUMBER = function(v) {
    if (v >= -107 && v <= 107) {
        return [v + 139];
    } else if (v >= 108 && v <= 1131) {
        v = v - 108;
        return [(v >> 8) + 247, v & 0xFF];
    } else if (v >= -1131 && v <= -108) {
        v = -v - 108;
        return [(v >> 8) + 251, v & 0xFF];
    } else if (v >= -32768 && v <= 32767) {
        return encode.NUMBER16(v);
    } else {
        return encode.NUMBER32(v);
    }
};

/**
 * @param {number}
 * @returns {number}
 */
sizeOf.NUMBER = function(v) {
    return encode.NUMBER(v).length;
};

/**
 * Convert a signed number between -32768 and +32767 to a three-byte value.
 * This ensures we always use three bytes, but is not the most compact format.
 * @param {number}
 * @returns {Array}
 */
encode.NUMBER16 = function(v) {
    return [28, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.NUMBER16 = constant(3);

/**
 * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.
 * This is useful if you want to be sure you always use four bytes,
 * at the expense of wasting a few bytes for smaller numbers.
 * @param {number}
 * @returns {Array}
 */
encode.NUMBER32 = function(v) {
    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.NUMBER32 = constant(5);

/**
 * @param {number}
 * @returns {Array}
 */
encode.REAL = function(v) {
    var value = v.toString();

    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)
    // This code converts it back to a number without the epsilon.
    var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
    if (m) {
        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
        value = (Math.round(v * epsilon) / epsilon).toString();
    }

    var nibbles = '';
    for (var i = 0, ii = value.length; i < ii; i += 1) {
        var c = value[i];
        if (c === 'e') {
            nibbles += value[++i] === '-' ? 'c' : 'b';
        } else if (c === '.') {
            nibbles += 'a';
        } else if (c === '-') {
            nibbles += 'e';
        } else {
            nibbles += c;
        }
    }

    nibbles += (nibbles.length & 1) ? 'f' : 'ff';
    var out = [30];
    for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {
        out.push(parseInt(nibbles.substr(i$1, 2), 16));
    }

    return out;
};

/**
 * @param {number}
 * @returns {number}
 */
sizeOf.REAL = function(v) {
    return encode.REAL(v).length;
};

encode.NAME = encode.CHARARRAY;
sizeOf.NAME = sizeOf.CHARARRAY;

encode.STRING = encode.CHARARRAY;
sizeOf.STRING = sizeOf.CHARARRAY;

/**
 * @param {DataView} data
 * @param {number} offset
 * @param {number} numBytes
 * @returns {string}
 */
decode.UTF8 = function(data, offset, numBytes) {
    var codePoints = [];
    var numChars = numBytes;
    for (var j = 0; j < numChars; j++, offset += 1) {
        codePoints[j] = data.getUint8(offset);
    }

    return String.fromCharCode.apply(null, codePoints);
};

/**
 * @param {DataView} data
 * @param {number} offset
 * @param {number} numBytes
 * @returns {string}
 */
decode.UTF16 = function(data, offset, numBytes) {
    var codePoints = [];
    var numChars = numBytes / 2;
    for (var j = 0; j < numChars; j++, offset += 2) {
        codePoints[j] = data.getUint16(offset);
    }

    return String.fromCharCode.apply(null, codePoints);
};

/**
 * Convert a JavaScript string to UTF16-BE.
 * @param {string}
 * @returns {Array}
 */
encode.UTF16 = function(v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        var codepoint = v.charCodeAt(i);
        b[b.length] = (codepoint >> 8) & 0xFF;
        b[b.length] = codepoint & 0xFF;
    }

    return b;
};

/**
 * @param {string}
 * @returns {number}
 */
sizeOf.UTF16 = function(v) {
    return v.length * 2;
};

// Data for converting old eight-bit Macintosh encodings to Unicode.
// This representation is optimized for decoding; encoding is slower
// and needs more memory. The assumption is that all opentype.js users
// want to open fonts, but saving a font will be comparatively rare
// so it can be more expensive. Keyed by IANA character set name.
//
// Python script for generating these strings:
//
//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])
//     print(s.encode('utf-8'))
/**
 * @private
 */
var eightBitMacEncodings = {
    'x-mac-croatian':  // Python: 'mac_croatian'
    '' +
    '',
    'x-mac-cyrillic':  // Python: 'mac_cyrillic'
    '' +
    '',
    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
    '' +
    '',
    'x-mac-greek':  // Python: 'mac_greek'
    '' +
    '\u00AD',
    'x-mac-icelandic':  // Python: 'mac_iceland'
    '' +
    '',
    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
    '' +
    '',
    'x-mac-ce':  // Python: 'mac_latin2'
    '' +
    '',
    macintosh:  // Python: 'mac_roman'
    '' +
    '',
    'x-mac-romanian':  // Python: 'mac_romanian'
    '' +
    '',
    'x-mac-turkish':  // Python: 'mac_turkish'
    '' +
    ''
};

/**
 * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript
 * string, or 'undefined' if the encoding is unsupported. For example, we do
 * not support Chinese, Japanese or Korean because these would need large
 * mapping tables.
 * @param {DataView} dataView
 * @param {number} offset
 * @param {number} dataLength
 * @param {string} encoding
 * @returns {string}
 */
decode.MACSTRING = function(dataView, offset, dataLength, encoding) {
    var table = eightBitMacEncodings[encoding];
    if (table === undefined) {
        return undefined;
    }

    var result = '';
    for (var i = 0; i < dataLength; i++) {
        var c = dataView.getUint8(offset + i);
        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
        // mapped to U+0000..U+007F; we only need to look up the others.
        if (c <= 0x7F) {
            result += String.fromCharCode(c);
        } else {
            result += table[c & 0x7F];
        }
    }

    return result;
};

// Helper function for encode.MACSTRING. Returns a dictionary for mapping
// Unicode character codes to their 8-bit MacOS equivalent. This table
// is not exactly a super cheap data structure, but we do not care because
// encoding Macintosh strings is only rarely needed in typical applications.
var macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();
var macEncodingCacheKeys;
var getMacEncodingTable = function (encoding) {
    // Since we use encoding as a cache key for WeakMap, it has to be
    // a String object and not a literal. And at least on NodeJS 2.10.1,
    // WeakMap requires that the same String instance is passed for cache hits.
    if (!macEncodingCacheKeys) {
        macEncodingCacheKeys = {};
        for (var e in eightBitMacEncodings) {
            /*jshint -W053 */  // Suppress "Do not use String as a constructor."
            macEncodingCacheKeys[e] = new String(e);
        }
    }

    var cacheKey = macEncodingCacheKeys[encoding];
    if (cacheKey === undefined) {
        return undefined;
    }

    // We can't do "if (cache.has(key)) {return cache.get(key)}" here:
    // since garbage collection may run at any time, it could also kick in
    // between the calls to cache.has() and cache.get(). In that case,
    // we would return 'undefined' even though we do support the encoding.
    if (macEncodingTableCache) {
        var cachedTable = macEncodingTableCache.get(cacheKey);
        if (cachedTable !== undefined) {
            return cachedTable;
        }
    }

    var decodingTable = eightBitMacEncodings[encoding];
    if (decodingTable === undefined) {
        return undefined;
    }

    var encodingTable = {};
    for (var i = 0; i < decodingTable.length; i++) {
        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;
    }

    if (macEncodingTableCache) {
        macEncodingTableCache.set(cacheKey, encodingTable);
    }

    return encodingTable;
};

/**
 * Encodes an old-style Macintosh string. Returns a byte array upon success.
 * If the requested encoding is unsupported, or if the input string contains
 * a character that cannot be expressed in the encoding, the function returns
 * 'undefined'.
 * @param {string} str
 * @param {string} encoding
 * @returns {Array}
 */
encode.MACSTRING = function(str, encoding) {
    var table = getMacEncodingTable(encoding);
    if (table === undefined) {
        return undefined;
    }

    var result = [];
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);

        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
        // mapped to U+0000..U+007F; we only need to look up the others.
        if (c >= 0x80) {
            c = table[c];
            if (c === undefined) {
                // str contains a Unicode character that cannot be encoded
                // in the requested encoding.
                return undefined;
            }
        }
        result[i] = c;
        // result.push(c);
    }

    return result;
};

/**
 * @param {string} str
 * @param {string} encoding
 * @returns {number}
 */
sizeOf.MACSTRING = function(str, encoding) {
    var b = encode.MACSTRING(str, encoding);
    if (b !== undefined) {
        return b.length;
    } else {
        return 0;
    }
};

// Helper for encode.VARDELTAS
function isByteEncodable(value) {
    return value >= -128 && value <= 127;
}

// Helper for encode.VARDELTAS
function encodeVarDeltaRunAsZeroes(deltas, pos, result) {
    var runLength = 0;
    var numDeltas = deltas.length;
    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {
        ++pos;
        ++runLength;
    }
    result.push(0x80 | (runLength - 1));
    return pos;
}

// Helper for encode.VARDELTAS
function encodeVarDeltaRunAsBytes(deltas, offset, result) {
    var runLength = 0;
    var numDeltas = deltas.length;
    var pos = offset;
    while (pos < numDeltas && runLength < 64) {
        var value = deltas[pos];
        if (!isByteEncodable(value)) {
            break;
        }

        // Within a byte-encoded run of deltas, a single zero is best
        // stored literally as 0x00 value. However, if we have two or
        // more zeroes in a sequence, it is better to start a new run.
        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]
        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero
        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)
        // when starting a new run.
        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {
            break;
        }

        ++pos;
        ++runLength;
    }
    result.push(runLength - 1);
    for (var i = offset; i < pos; ++i) {
        result.push((deltas[i] + 256) & 0xff);
    }
    return pos;
}

// Helper for encode.VARDELTAS
function encodeVarDeltaRunAsWords(deltas, offset, result) {
    var runLength = 0;
    var numDeltas = deltas.length;
    var pos = offset;
    while (pos < numDeltas && runLength < 64) {
        var value = deltas[pos];

        // Within a word-encoded run of deltas, it is easiest to start
        // a new run (with a different encoding) whenever we encounter
        // a zero value. For example, the sequence [0x6666, 0, 0x7777]
        // needs 7 bytes when storing the zero inside the current run
        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a
        // new run (40 66 66 80 40 77 77).
        if (value === 0) {
            break;
        }

        // Within a word-encoded run of deltas, a single value in the
        // range (-128..127) should be encoded within the current run
        // because it is more compact. For example, the sequence
        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value
        // literally (42 66 66 00 02 77 77), but 8 bytes when starting
        // a new run (40 66 66 00 02 40 77 77).
        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {
            break;
        }

        ++pos;
        ++runLength;
    }
    result.push(0x40 | (runLength - 1));
    for (var i = offset; i < pos; ++i) {
        var val = deltas[i];
        result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);
    }
    return pos;
}

/**
 * Encode a list of variation adjustment deltas.
 *
 * Variation adjustment deltas are used in gvar and cvar tables.
 * They indicate how points (in gvar) or values (in cvar) get adjusted
 * when generating instances of variation fonts.
 *
 * @see https://www.microsoft.com/typography/otspec/gvar.htm
 * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html
 * @param {Array}
 * @return {Array}
 */
encode.VARDELTAS = function(deltas) {
    var pos = 0;
    var result = [];
    while (pos < deltas.length) {
        var value = deltas[pos];
        if (value === 0) {
            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);
        } else if (value >= -128 && value <= 127) {
            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);
        } else {
            pos = encodeVarDeltaRunAsWords(deltas, pos, result);
        }
    }
    return result;
};

// Convert a list of values to a CFF INDEX structure.
// The values should be objects containing name / type / value.
/**
 * @param {Array} l
 * @returns {Array}
 */
encode.INDEX = function(l) {
    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
    //    i, v;
    // Because we have to know which data type to use to encode the offsets,
    // we have to go through the values twice: once to encode the data and
    // calculate the offsets, then again to encode the offsets using the fitting data type.
    var offset = 1; // First offset is always 1.
    var offsets = [offset];
    var data = [];
    for (var i = 0; i < l.length; i += 1) {
        var v = encode.OBJECT(l[i]);
        Array.prototype.push.apply(data, v);
        offset += v.length;
        offsets.push(offset);
    }

    if (data.length === 0) {
        return [0, 0];
    }

    var encodedOffsets = [];
    var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;
    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
    for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {
        var encodedOffset = offsetEncoder(offsets[i$1]);
        Array.prototype.push.apply(encodedOffsets, encodedOffset);
    }

    return Array.prototype.concat(encode.Card16(l.length),
                           encode.OffSize(offSize),
                           encodedOffsets,
                           data);
};

/**
 * @param {Array}
 * @returns {number}
 */
sizeOf.INDEX = function(v) {
    return encode.INDEX(v).length;
};

/**
 * Convert an object to a CFF DICT structure.
 * The keys should be numeric.
 * The values should be objects containing name / type / value.
 * @param {Object} m
 * @returns {Array}
 */
encode.DICT = function(m) {
    var d = [];
    var keys = Object.keys(m);
    var length = keys.length;

    for (var i = 0; i < length; i += 1) {
        // Object.keys() return string keys, but our keys are always numeric.
        var k = parseInt(keys[i], 0);
        var v = m[k];
        // Value comes before the key.
        d = d.concat(encode.OPERAND(v.value, v.type));
        d = d.concat(encode.OPERATOR(k));
    }

    return d;
};

/**
 * @param {Object}
 * @returns {number}
 */
sizeOf.DICT = function(m) {
    return encode.DICT(m).length;
};

/**
 * @param {number}
 * @returns {Array}
 */
encode.OPERATOR = function(v) {
    if (v < 1200) {
        return [v];
    } else {
        return [12, v - 1200];
    }
};

/**
 * @param {Array} v
 * @param {string}
 * @returns {Array}
 */
encode.OPERAND = function(v, type) {
    var d = [];
    if (Array.isArray(type)) {
        for (var i = 0; i < type.length; i += 1) {
            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);
            d = d.concat(encode.OPERAND(v[i], type[i]));
        }
    } else {
        if (type === 'SID') {
            d = d.concat(encode.NUMBER(v));
        } else if (type === 'offset') {
            // We make it easy for ourselves and always encode offsets as
            // 4 bytes. This makes offset calculation for the top dict easier.
            d = d.concat(encode.NUMBER32(v));
        } else if (type === 'number') {
            d = d.concat(encode.NUMBER(v));
        } else if (type === 'real') {
            d = d.concat(encode.REAL(v));
        } else {
            throw new Error('Unknown operand type ' + type);
            // FIXME Add support for booleans
        }
    }

    return d;
};

encode.OP = encode.BYTE;
sizeOf.OP = sizeOf.BYTE;

// memoize charstring encoding using WeakMap if available
var wmm = typeof WeakMap === 'function' && new WeakMap();

/**
 * Convert a list of CharString operations to bytes.
 * @param {Array}
 * @returns {Array}
 */
encode.CHARSTRING = function(ops) {
    // See encode.MACSTRING for why we don't do "if (wmm && wmm.has(ops))".
    if (wmm) {
        var cachedValue = wmm.get(ops);
        if (cachedValue !== undefined) {
            return cachedValue;
        }
    }

    var d = [];
    var length = ops.length;

    for (var i = 0; i < length; i += 1) {
        var op = ops[i];
        d = d.concat(encode[op.type](op.value));
    }

    if (wmm) {
        wmm.set(ops, d);
    }

    return d;
};

/**
 * @param {Array}
 * @returns {number}
 */
sizeOf.CHARSTRING = function(ops) {
    return encode.CHARSTRING(ops).length;
};

// Utility functions ////////////////////////////////////////////////////////

/**
 * Convert an object containing name / type / value to bytes.
 * @param {Object}
 * @returns {Array}
 */
encode.OBJECT = function(v) {
    var encodingFunction = encode[v.type];
    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
    return encodingFunction(v.value);
};

/**
 * @param {Object}
 * @returns {number}
 */
sizeOf.OBJECT = function(v) {
    var sizeOfFunction = sizeOf[v.type];
    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);
    return sizeOfFunction(v.value);
};

/**
 * Convert a table object to bytes.
 * A table contains a list of fields containing the metadata (name, type and default value).
 * The table itself has the field values set as attributes.
 * @param {opentype.Table}
 * @returns {Array}
 */
encode.TABLE = function(table) {
    var d = [];
    var length = table.fields.length;
    var subtables = [];
    var subtableOffsets = [];

    for (var i = 0; i < length; i += 1) {
        var field = table.fields[i];
        var encodingFunction = encode[field.type];
        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');
        var value = table[field.name];
        if (value === undefined) {
            value = field.value;
        }

        var bytes = encodingFunction(value);

        if (field.type === 'TABLE') {
            subtableOffsets.push(d.length);
            d = d.concat([0, 0]);
            subtables.push(bytes);
        } else {
            d = d.concat(bytes);
        }
    }

    for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {
        var o = subtableOffsets[i$1];
        var offset = d.length;
        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');
        d[o] = offset >> 8;
        d[o + 1] = offset & 0xff;
        d = d.concat(subtables[i$1]);
    }

    return d;
};

/**
 * @param {opentype.Table}
 * @returns {number}
 */
sizeOf.TABLE = function(table) {
    var numBytes = 0;
    var length = table.fields.length;

    for (var i = 0; i < length; i += 1) {
        var field = table.fields[i];
        var sizeOfFunction = sizeOf[field.type];
        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');
        var value = table[field.name];
        if (value === undefined) {
            value = field.value;
        }

        numBytes += sizeOfFunction(value);

        // Subtables take 2 more bytes for offsets.
        if (field.type === 'TABLE') {
            numBytes += 2;
        }
    }

    return numBytes;
};

encode.RECORD = encode.TABLE;
sizeOf.RECORD = sizeOf.TABLE;

// Merge in a list of bytes.
encode.LITERAL = function(v) {
    return v;
};

sizeOf.LITERAL = function(v) {
    return v.length;
};

// Table metadata

function Table(tableName, fields, options) {
    var this$1 = this;

    for (var i = 0; i < fields.length; i += 1) {
        var field = fields[i];
        this$1[field.name] = field.value;
    }

    this.tableName = tableName;
    this.fields = fields;
    if (options) {
        var optionKeys = Object.keys(options);
        for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {
            var k = optionKeys[i$1];
            var v = options[k];
            if (this$1[k] !== undefined) {
                this$1[k] = v;
            }
        }
    }
}

/**
 * Encodes the table and returns an array of bytes
 * @return {Array}
 */
Table.prototype.encode = function() {
    return encode.TABLE(this);
};

/**
 * Get the size of the table.
 * @return {number}
 */
Table.prototype.sizeOf = function() {
    return sizeOf.TABLE(this);
};

/**
 * @private
 */
function ushortList(itemName, list, count) {
    if (count === undefined) {
        count = list.length;
    }
    var fields = new Array(list.length + 1);
    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
    for (var i = 0; i < list.length; i++) {
        fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};
    }
    return fields;
}

/**
 * @private
 */
function tableList(itemName, records, itemCallback) {
    var count = records.length;
    var fields = new Array(count + 1);
    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
    for (var i = 0; i < count; i++) {
        fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};
    }
    return fields;
}

/**
 * @private
 */
function recordList(itemName, records, itemCallback) {
    var count = records.length;
    var fields = [];
    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
    for (var i = 0; i < count; i++) {
        fields = fields.concat(itemCallback(records[i], i));
    }
    return fields;
}

// Common Layout Tables

/**
 * @exports opentype.Coverage
 * @class
 * @param {opentype.Table}
 * @constructor
 * @extends opentype.Table
 */
function Coverage(coverageTable) {
    if (coverageTable.format === 1) {
        Table.call(this, 'coverageTable',
            [{name: 'coverageFormat', type: 'USHORT', value: 1}]
            .concat(ushortList('glyph', coverageTable.glyphs))
        );
    } else {
        check.assert(false, 'Can\'t create coverage table format 2 yet.');
    }
}
Coverage.prototype = Object.create(Table.prototype);
Coverage.prototype.constructor = Coverage;

function ScriptList(scriptListTable) {
    Table.call(this, 'scriptListTable',
        recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {
            var script = scriptRecord.script;
            var defaultLangSys = script.defaultLangSys;
            check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');
            return [
                {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},
                {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [
                    {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [
                        {name: 'lookupOrder', type: 'USHORT', value: 0},
                        {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]
                        .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}
                    ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {
                        var langSys = langSysRecord.langSys;
                        return [
                            {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},
                            {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [
                                {name: 'lookupOrder', type: 'USHORT', value: 0},
                                {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}
                                ].concat(ushortList('featureIndex', langSys.featureIndexes)))}
                        ];
                    })))}
            ];
        })
    );
}
ScriptList.prototype = Object.create(Table.prototype);
ScriptList.prototype.constructor = ScriptList;

/**
 * @exports opentype.FeatureList
 * @class
 * @param {opentype.Table}
 * @constructor
 * @extends opentype.Table
 */
function FeatureList(featureListTable) {
    Table.call(this, 'featureListTable',
        recordList('featureRecord', featureListTable, function(featureRecord, i) {
            var feature = featureRecord.feature;
            return [
                {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},
                {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [
                    {name: 'featureParams', type: 'USHORT', value: feature.featureParams} ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}
            ];
        })
    );
}
FeatureList.prototype = Object.create(Table.prototype);
FeatureList.prototype.constructor = FeatureList;

/**
 * @exports opentype.LookupList
 * @class
 * @param {opentype.Table}
 * @param {Object}
 * @constructor
 * @extends opentype.Table
 */
function LookupList(lookupListTable, subtableMakers) {
    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {
        var subtableCallback = subtableMakers[lookupTable.lookupType];
        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');
        return new Table('lookupTable', [
            {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},
            {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}
        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));
    }));
}
LookupList.prototype = Object.create(Table.prototype);
LookupList.prototype.constructor = LookupList;

// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)
// Don't use offsets inside Records (probable bug), only in Tables.
var table = {
    Table: Table,
    Record: Table,
    Coverage: Coverage,
    ScriptList: ScriptList,
    FeatureList: FeatureList,
    LookupList: LookupList,
    ushortList: ushortList,
    tableList: tableList,
    recordList: recordList,
};

// Parsing utility functions

function getByte(dataView, offset) {
    return dataView.getUint8(offset);
}

// Retrieve an unsigned 16-bit short from the DataView.
// The value is stored in big endian.
function getUShort(dataView, offset) {
    return dataView.getUint16(offset, false);
}

// Retrieve a signed 16-bit short from the DataView.
// The value is stored in big endian.
function getShort(dataView, offset) {
    return dataView.getInt16(offset, false);
}

// Retrieve an unsigned 32-bit long from the DataView.
// The value is stored in big endian.
function getULong(dataView, offset) {
    return dataView.getUint32(offset, false);
}

// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
// The value is stored in big endian.
function getFixed(dataView, offset) {
    var decimal = dataView.getInt16(offset, false);
    var fraction = dataView.getUint16(offset + 2, false);
    return decimal + fraction / 65535;
}

// Retrieve a 4-character tag from the DataView.
// Tags are used to identify tables.
function getTag(dataView, offset) {
    var tag = '';
    for (var i = offset; i < offset + 4; i += 1) {
        tag += String.fromCharCode(dataView.getInt8(i));
    }

    return tag;
}

// Retrieve an offset from the DataView.
// Offsets are 1 to 4 bytes in length, depending on the offSize argument.
function getOffset(dataView, offset, offSize) {
    var v = 0;
    for (var i = 0; i < offSize; i += 1) {
        v <<= 8;
        v += dataView.getUint8(offset + i);
    }

    return v;
}

// Retrieve a number of bytes from start offset to the end offset from the DataView.
function getBytes(dataView, startOffset, endOffset) {
    var bytes = [];
    for (var i = startOffset; i < endOffset; i += 1) {
        bytes.push(dataView.getUint8(i));
    }

    return bytes;
}

// Convert the list of bytes to a string.
function bytesToString(bytes) {
    var s = '';
    for (var i = 0; i < bytes.length; i += 1) {
        s += String.fromCharCode(bytes[i]);
    }

    return s;
}

var typeOffsets = {
    byte: 1,
    uShort: 2,
    short: 2,
    uLong: 4,
    fixed: 4,
    longDateTime: 8,
    tag: 4
};

// A stateful parser that changes the offset whenever a value is retrieved.
// The data is a DataView.
function Parser(data, offset) {
    this.data = data;
    this.offset = offset;
    this.relativeOffset = 0;
}

Parser.prototype.parseByte = function() {
    var v = this.data.getUint8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseChar = function() {
    var v = this.data.getInt8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseCard8 = Parser.prototype.parseByte;

Parser.prototype.parseUShort = function() {
    var v = this.data.getUint16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
Parser.prototype.parseSID = Parser.prototype.parseUShort;
Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;

Parser.prototype.parseShort = function() {
    var v = this.data.getInt16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseF2Dot14 = function() {
    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseULong = function() {
    var v = getULong(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseFixed = function() {
    var v = getFixed(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseString = function(length) {
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    var string = '';
    this.relativeOffset += length;
    for (var i = 0; i < length; i++) {
        string += String.fromCharCode(dataView.getUint8(offset + i));
    }

    return string;
};

Parser.prototype.parseTag = function() {
    return this.parseString(4);
};

// LONGDATETIME is a 64-bit integer.
// JavaScript and unix timestamps traditionally use 32 bits, so we
// only take the last 32 bits.
// + Since until 2038 those bits will be filled by zeros we can ignore them.
Parser.prototype.parseLongDateTime = function() {
    var v = getULong(this.data, this.offset + this.relativeOffset + 4);
    // Subtract seconds between 01/01/1904 and 01/01/1970
    // to convert Apple Mac timestamp to Standard Unix timestamp
    v -= 2082844800;
    this.relativeOffset += 8;
    return v;
};

Parser.prototype.parseVersion = function() {
    var major = getUShort(this.data, this.offset + this.relativeOffset);

    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
    // This returns the correct number if minor = 0xN000 where N is 0-9
    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
    this.relativeOffset += 4;
    return major + minor / 0x1000 / 10;
};

Parser.prototype.skip = function(type, amount) {
    if (amount === undefined) {
        amount = 1;
    }

    this.relativeOffset += typeOffsets[type] * amount;
};

///// Parsing lists and records ///////////////////////////////

// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream
// or provided as an argument.
Parser.prototype.parseOffset16List =
Parser.prototype.parseUShortList = function(count) {
    if (count === undefined) { count = this.parseUShort(); }
    var offsets = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        offsets[i] = dataView.getUint16(offset);
        offset += 2;
    }

    this.relativeOffset += count * 2;
    return offsets;
};

// Parses a list of 16 bit signed integers.
Parser.prototype.parseShortList = function(count) {
    var list = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        list[i] = dataView.getInt16(offset);
        offset += 2;
    }

    this.relativeOffset += count * 2;
    return list;
};

// Parses a list of bytes.
Parser.prototype.parseByteList = function(count) {
    var list = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        list[i] = dataView.getUint8(offset++);
    }

    this.relativeOffset += count;
    return list;
};

/**
 * Parse a list of items.
 * Record count is optional, if omitted it is read from the stream.
 * itemCallback is one of the Parser methods.
 */
Parser.prototype.parseList = function(count, itemCallback) {
    var this$1 = this;

    if (!itemCallback) {
        itemCallback = count;
        count = this.parseUShort();
    }
    var list = new Array(count);
    for (var i = 0; i < count; i++) {
        list[i] = itemCallback.call(this$1);
    }
    return list;
};

/**
 * Parse a list of records.
 * Record count is optional, if omitted it is read from the stream.
 * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
 */
Parser.prototype.parseRecordList = function(count, recordDescription) {
    var this$1 = this;

    // If the count argument is absent, read it in the stream.
    if (!recordDescription) {
        recordDescription = count;
        count = this.parseUShort();
    }
    var records = new Array(count);
    var fields = Object.keys(recordDescription);
    for (var i = 0; i < count; i++) {
        var rec = {};
        for (var j = 0; j < fields.length; j++) {
            var fieldName = fields[j];
            var fieldType = recordDescription[fieldName];
            rec[fieldName] = fieldType.call(this$1);
        }
        records[i] = rec;
    }
    return records;
};

// Parse a data structure into an object
// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
Parser.prototype.parseStruct = function(description) {
    var this$1 = this;

    if (typeof description === 'function') {
        return description.call(this);
    } else {
        var fields = Object.keys(description);
        var struct = {};
        for (var j = 0; j < fields.length; j++) {
            var fieldName = fields[j];
            var fieldType = description[fieldName];
            struct[fieldName] = fieldType.call(this$1);
        }
        return struct;
    }
};

Parser.prototype.parsePointer = function(description) {
    var structOffset = this.parseOffset16();
    if (structOffset > 0) {                         // NULL offset => return undefined
        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
    }
    return undefined;
};

/**
 * Parse a list of offsets to lists of 16-bit integers,
 * or a list of offsets to lists of offsets to any kind of items.
 * If itemCallback is not provided, a list of list of UShort is assumed.
 * If provided, itemCallback is called on each item and must parse the item.
 * See examples in tables/gsub.js
 */
Parser.prototype.parseListOfLists = function(itemCallback) {
    var this$1 = this;

    var offsets = this.parseOffset16List();
    var count = offsets.length;
    var relativeOffset = this.relativeOffset;
    var list = new Array(count);
    for (var i = 0; i < count; i++) {
        var start = offsets[i];
        if (start === 0) {                  // NULL offset
            list[i] = undefined;            // Add i as owned property to list. Convenient with assert.
            continue;
        }
        this$1.relativeOffset = start;
        if (itemCallback) {
            var subOffsets = this$1.parseOffset16List();
            var subList = new Array(subOffsets.length);
            for (var j = 0; j < subOffsets.length; j++) {
                this$1.relativeOffset = start + subOffsets[j];
                subList[j] = itemCallback.call(this$1);
            }
            list[i] = subList;
        } else {
            list[i] = this$1.parseUShortList();
        }
    }
    this.relativeOffset = relativeOffset;
    return list;
};

///// Complex tables parsing //////////////////////////////////

// Parse a coverage table in a GSUB, GPOS or GDEF table.
// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
// parser.offset must point to the start of the table containing the coverage.
Parser.prototype.parseCoverage = function() {
    var this$1 = this;

    var startOffset = this.offset + this.relativeOffset;
    var format = this.parseUShort();
    var count = this.parseUShort();
    if (format === 1) {
        return {
            format: 1,
            glyphs: this.parseUShortList(count)
        };
    } else if (format === 2) {
        var ranges = new Array(count);
        for (var i = 0; i < count; i++) {
            ranges[i] = {
                start: this$1.parseUShort(),
                end: this$1.parseUShort(),
                index: this$1.parseUShort()
            };
        }
        return {
            format: 2,
            ranges: ranges
        };
    }
    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');
};

// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
Parser.prototype.parseClassDef = function() {
    var startOffset = this.offset + this.relativeOffset;
    var format = this.parseUShort();
    if (format === 1) {
        return {
            format: 1,
            startGlyph: this.parseUShort(),
            classes: this.parseUShortList()
        };
    } else if (format === 2) {
        return {
            format: 2,
            ranges: this.parseRecordList({
                start: Parser.uShort,
                end: Parser.uShort,
                classId: Parser.uShort
            })
        };
    }
    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');
};

///// Static methods ///////////////////////////////////
// These convenience methods can be used as callbacks and should be called with "this" context set to a Parser instance.

Parser.list = function(count, itemCallback) {
    return function() {
        return this.parseList(count, itemCallback);
    };
};

Parser.recordList = function(count, recordDescription) {
    return function() {
        return this.parseRecordList(count, recordDescription);
    };
};

Parser.pointer = function(description) {
    return function() {
        return this.parsePointer(description);
    };
};

Parser.tag = Parser.prototype.parseTag;
Parser.byte = Parser.prototype.parseByte;
Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort;
Parser.uShortList = Parser.prototype.parseUShortList;
Parser.struct = Parser.prototype.parseStruct;
Parser.coverage = Parser.prototype.parseCoverage;
Parser.classDef = Parser.prototype.parseClassDef;

///// Script, Feature, Lookup lists ///////////////////////////////////////////////
// https://www.microsoft.com/typography/OTSPEC/chapter2.htm

var langSysTable = {
    reserved: Parser.uShort,
    reqFeatureIndex: Parser.uShort,
    featureIndexes: Parser.uShortList
};

Parser.prototype.parseScriptList = function() {
    return this.parsePointer(Parser.recordList({
        tag: Parser.tag,
        script: Parser.pointer({
            defaultLangSys: Parser.pointer(langSysTable),
            langSysRecords: Parser.recordList({
                tag: Parser.tag,
                langSys: Parser.pointer(langSysTable)
            })
        })
    }));
};

Parser.prototype.parseFeatureList = function() {
    return this.parsePointer(Parser.recordList({
        tag: Parser.tag,
        feature: Parser.pointer({
            featureParams: Parser.offset16,
            lookupListIndexes: Parser.uShortList
        })
    }));
};

Parser.prototype.parseLookupList = function(lookupTableParsers) {
    return this.parsePointer(Parser.list(Parser.pointer(function() {
        var lookupType = this.parseUShort();
        check.argument(1 <= lookupType && lookupType <= 8, 'GSUB lookup type ' + lookupType + ' unknown.');
        var lookupFlag = this.parseUShort();
        var useMarkFilteringSet = lookupFlag & 0x10;
        return {
            lookupType: lookupType,
            lookupFlag: lookupFlag,
            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),
            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined
        };
    })));
};

var parse$1 = {
    getByte: getByte,
    getCard8: getByte,
    getUShort: getUShort,
    getCard16: getUShort,
    getShort: getShort,
    getULong: getULong,
    getFixed: getFixed,
    getTag: getTag,
    getOffset: getOffset,
    getBytes: getBytes,
    bytesToString: bytesToString,
    Parser: Parser,
};

// The `cmap` table stores the mappings from characters to glyphs.
// https://www.microsoft.com/typography/OTSPEC/cmap.htm

function parseCmapTableFormat12(cmap, p) {
    //Skip reserved.
    p.parseUShort();

    // Length in bytes of the sub-tables.
    cmap.length = p.parseULong();
    cmap.language = p.parseULong();

    var groupCount;
    cmap.groupCount = groupCount = p.parseULong();
    cmap.glyphIndexMap = {};

    for (var i = 0; i < groupCount; i += 1) {
        var startCharCode = p.parseULong();
        var endCharCode = p.parseULong();
        var startGlyphId = p.parseULong();

        for (var c = startCharCode; c <= endCharCode; c += 1) {
            cmap.glyphIndexMap[c] = startGlyphId;
            startGlyphId++;
        }
    }
}

function parseCmapTableFormat4(cmap, p, data, start, offset) {
    // Length in bytes of the sub-tables.
    cmap.length = p.parseUShort();
    cmap.language = p.parseUShort();

    // segCount is stored x 2.
    var segCount;
    cmap.segCount = segCount = p.parseUShort() >> 1;

    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);

    // The "unrolled" mapping from character codes to glyph indices.
    cmap.glyphIndexMap = {};
    var endCountParser = new parse$1.Parser(data, start + offset + 14);
    var startCountParser = new parse$1.Parser(data, start + offset + 16 + segCount * 2);
    var idDeltaParser = new parse$1.Parser(data, start + offset + 16 + segCount * 4);
    var idRangeOffsetParser = new parse$1.Parser(data, start + offset + 16 + segCount * 6);
    var glyphIndexOffset = start + offset + 16 + segCount * 8;
    for (var i = 0; i < segCount - 1; i += 1) {
        var glyphIndex = (void 0);
        var endCount = endCountParser.parseUShort();
        var startCount = startCountParser.parseUShort();
        var idDelta = idDeltaParser.parseShort();
        var idRangeOffset = idRangeOffsetParser.parseUShort();
        for (var c = startCount; c <= endCount; c += 1) {
            if (idRangeOffset !== 0) {
                // The idRangeOffset is relative to the current position in the idRangeOffset array.
                // Take the current offset in the idRangeOffset array.
                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);

                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
                glyphIndexOffset += idRangeOffset;

                // Then add the character index of the current segment, multiplied by 2 for USHORTs.
                glyphIndexOffset += (c - startCount) * 2;
                glyphIndex = parse$1.getUShort(data, glyphIndexOffset);
                if (glyphIndex !== 0) {
                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;
                }
            } else {
                glyphIndex = (c + idDelta) & 0xFFFF;
            }

            cmap.glyphIndexMap[c] = glyphIndex;
        }
    }
}

// Parse the `cmap` table. This table stores the mappings from characters to glyphs.
// There are many available formats, but we only support the Windows format 4 and 12.
// This function returns a `CmapEncoding` object or null if no supported format could be found.
function parseCmapTable(data, start) {
    var cmap = {};
    cmap.version = parse$1.getUShort(data, start);
    check.argument(cmap.version === 0, 'cmap table version should be 0.');

    // The cmap table can contain many sub-tables, each with their own format.
    // We're only interested in a "platform 3" table. This is a Windows format.
    cmap.numTables = parse$1.getUShort(data, start + 2);
    var offset = -1;
    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {
        var platformId = parse$1.getUShort(data, start + 4 + (i * 8));
        var encodingId = parse$1.getUShort(data, start + 4 + (i * 8) + 2);
        if (platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) {
            offset = parse$1.getULong(data, start + 4 + (i * 8) + 4);
            break;
        }
    }

    if (offset === -1) {
        // There is no cmap table in the font that we support.
        throw new Error('No valid cmap sub-tables found.');
    }

    var p = new parse$1.Parser(data, start + offset);
    cmap.format = p.parseUShort();

    if (cmap.format === 12) {
        parseCmapTableFormat12(cmap, p);
    } else if (cmap.format === 4) {
        parseCmapTableFormat4(cmap, p, data, start, offset);
    } else {
        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');
    }

    return cmap;
}

function addSegment(t, code, glyphIndex) {
    t.segments.push({
        end: code,
        start: code,
        delta: -(code - glyphIndex),
        offset: 0
    });
}

function addTerminatorSegment(t) {
    t.segments.push({
        end: 0xFFFF,
        start: 0xFFFF,
        delta: 1,
        offset: 0
    });
}

function makeCmapTable(glyphs) {
    var t = new table.Table('cmap', [
        {name: 'version', type: 'USHORT', value: 0},
        {name: 'numTables', type: 'USHORT', value: 1},
        {name: 'platformID', type: 'USHORT', value: 3},
        {name: 'encodingID', type: 'USHORT', value: 1},
        {name: 'offset', type: 'ULONG', value: 12},
        {name: 'format', type: 'USHORT', value: 4},
        {name: 'length', type: 'USHORT', value: 0},
        {name: 'language', type: 'USHORT', value: 0},
        {name: 'segCountX2', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);

    t.segments = [];
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        for (var j = 0; j < glyph.unicodes.length; j += 1) {
            addSegment(t, glyph.unicodes[j], i);
        }

        t.segments = t.segments.sort(function(a, b) {
            return a.start - b.start;
        });
    }

    addTerminatorSegment(t);

    var segCount;
    segCount = t.segments.length;
    t.segCountX2 = segCount * 2;
    t.searchRange = Math.pow(2, Math.floor(Math.log(segCount) / Math.log(2))) * 2;
    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
    t.rangeShift = t.segCountX2 - t.searchRange;

    // Set up parallel segment arrays.
    var endCounts = [];
    var startCounts = [];
    var idDeltas = [];
    var idRangeOffsets = [];
    var glyphIds = [];

    for (var i$1 = 0; i$1 < segCount; i$1 += 1) {
        var segment = t.segments[i$1];
        endCounts = endCounts.concat({name: 'end_' + i$1, type: 'USHORT', value: segment.end});
        startCounts = startCounts.concat({name: 'start_' + i$1, type: 'USHORT', value: segment.start});
        idDeltas = idDeltas.concat({name: 'idDelta_' + i$1, type: 'SHORT', value: segment.delta});
        idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i$1, type: 'USHORT', value: segment.offset});
        if (segment.glyphId !== undefined) {
            glyphIds = glyphIds.concat({name: 'glyph_' + i$1, type: 'USHORT', value: segment.glyphId});
        }
    }

    t.fields = t.fields.concat(endCounts);
    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});
    t.fields = t.fields.concat(startCounts);
    t.fields = t.fields.concat(idDeltas);
    t.fields = t.fields.concat(idRangeOffsets);
    t.fields = t.fields.concat(glyphIds);

    t.length = 14 + // Subtable header
        endCounts.length * 2 +
        2 + // reservedPad
        startCounts.length * 2 +
        idDeltas.length * 2 +
        idRangeOffsets.length * 2 +
        glyphIds.length * 2;

    return t;
}

var cmap = { parse: parseCmapTable, make: makeCmapTable };

// Glyph encoding

var cffStandardStrings = [
    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',
    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',
    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',
    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',
    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',
    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',
    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',
    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',
    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',
    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',
    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',
    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',
    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',
    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',
    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',
    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',
    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',
    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',
    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',
    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',
    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',
    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',
    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',
    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',
    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',
    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',
    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',
    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',
    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',
    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',
    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',
    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];

var cffStandardEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',
    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',
    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',
    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',
    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',
    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',
    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',
    'lslash', 'oslash', 'oe', 'germandbls'];

var cffExpertEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',
    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',
    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',
    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',
    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',
    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',
    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',
    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',
    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',
    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',
    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',
    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',
    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',
    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',
    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',
    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',
    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',
    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];

var standardNames = [
    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',
    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',
    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',
    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',
    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',
    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',
    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',
    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',
    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',
    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',
    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',
    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',
    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',
    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',
    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',
    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',
    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',
    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',
    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',
    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',
    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',
    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',
    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];

/**
 * This is the encoding used for fonts created from scratch.
 * It loops through all glyphs and finds the appropriate unicode value.
 * Since it's linear time, other encodings will be faster.
 * @exports opentype.DefaultEncoding
 * @class
 * @constructor
 * @param {opentype.Font}
 */
function DefaultEncoding(font) {
    this.font = font;
}

DefaultEncoding.prototype.charToGlyphIndex = function(c) {
    var code = c.charCodeAt(0);
    var glyphs = this.font.glyphs;
    if (glyphs) {
        for (var i = 0; i < glyphs.length; i += 1) {
            var glyph = glyphs.get(i);
            for (var j = 0; j < glyph.unicodes.length; j += 1) {
                if (glyph.unicodes[j] === code) {
                    return i;
                }
            }
        }
    }
    return null;
};

/**
 * @exports opentype.CmapEncoding
 * @class
 * @constructor
 * @param {Object} cmap - a object with the cmap encoded data
 */
function CmapEncoding(cmap) {
    this.cmap = cmap;
}

/**
 * @param  {string} c - the character
 * @return {number} The glyph index.
 */
CmapEncoding.prototype.charToGlyphIndex = function(c) {
    return this.cmap.glyphIndexMap[c.charCodeAt(0)] || 0;
};

/**
 * @exports opentype.CffEncoding
 * @class
 * @constructor
 * @param {string} encoding - The encoding
 * @param {Array} charset - The character set.
 */
function CffEncoding(encoding, charset) {
    this.encoding = encoding;
    this.charset = charset;
}

/**
 * @param  {string} s - The character
 * @return {number} The index.
 */
CffEncoding.prototype.charToGlyphIndex = function(s) {
    var code = s.charCodeAt(0);
    var charName = this.encoding[code];
    return this.charset.indexOf(charName);
};

/**
 * @exports opentype.GlyphNames
 * @class
 * @constructor
 * @param {Object} post
 */
function GlyphNames(post) {
    var this$1 = this;

    switch (post.version) {
        case 1:
            this.names = standardNames.slice();
            break;
        case 2:
            this.names = new Array(post.numberOfGlyphs);
            for (var i = 0; i < post.numberOfGlyphs; i++) {
                if (post.glyphNameIndex[i] < standardNames.length) {
                    this$1.names[i] = standardNames[post.glyphNameIndex[i]];
                } else {
                    this$1.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];
                }
            }

            break;
        case 2.5:
            this.names = new Array(post.numberOfGlyphs);
            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
                this$1.names[i$1] = standardNames[i$1 + post.glyphNameIndex[i$1]];
            }

            break;
        case 3:
            this.names = [];
            break;
        default:
            this.names = [];
            break;
    }
}

/**
 * Gets the index of a glyph by name.
 * @param  {string} name - The glyph name
 * @return {number} The index
 */
GlyphNames.prototype.nameToGlyphIndex = function(name) {
    return this.names.indexOf(name);
};

/**
 * @param  {number} gid
 * @return {string}
 */
GlyphNames.prototype.glyphIndexToName = function(gid) {
    return this.names[gid];
};

/**
 * @alias opentype.addGlyphNames
 * @param {opentype.Font}
 */
function addGlyphNames(font) {
    var glyph;
    var glyphIndexMap = font.tables.cmap.glyphIndexMap;
    var charCodes = Object.keys(glyphIndexMap);

    for (var i = 0; i < charCodes.length; i += 1) {
        var c = charCodes[i];
        var glyphIndex = glyphIndexMap[c];
        glyph = font.glyphs.get(glyphIndex);
        glyph.addUnicode(parseInt(c));
    }

    for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {
        glyph = font.glyphs.get(i$1);
        if (font.cffEncoding) {
            if (font.isCIDFont) {
                glyph.name = 'gid' + i$1;
            } else {
                glyph.name = font.cffEncoding.charset[i$1];
            }
        } else if (font.glyphNames.names) {
            glyph.name = font.glyphNames.glyphIndexToName(i$1);
        }
    }
}

// Drawing utility functions.

// Draw a line on the given context from point `x1,y1` to point `x2,y2`.
function line$2(ctx, x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
}

var draw = { line: line$2 };

// The `glyf` table describes the glyphs in TrueType outline format.
// http://www.microsoft.com/typography/otspec/glyf.htm

function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
    var v;
    if ((flag & shortVectorBitMask) > 0) {
        // The coordinate is 1 byte long.
        v = p.parseByte();
        // The `same` bit is re-used for short values to signify the sign of the value.
        if ((flag & sameBitMask) === 0) {
            v = -v;
        }

        v = previousValue + v;
    } else {
        //  The coordinate is 2 bytes long.
        // If the `same` bit is set, the coordinate is the same as the previous coordinate.
        if ((flag & sameBitMask) > 0) {
            v = previousValue;
        } else {
            // Parse the coordinate as a signed 16-bit delta value.
            v = previousValue + p.parseShort();
        }
    }

    return v;
}

// Parse a TrueType glyph.
function parseGlyph(glyph, data, start) {
    var p = new parse$1.Parser(data, start);
    glyph.numberOfContours = p.parseShort();
    glyph._xMin = p.parseShort();
    glyph._yMin = p.parseShort();
    glyph._xMax = p.parseShort();
    glyph._yMax = p.parseShort();
    var flags;
    var flag;

    if (glyph.numberOfContours > 0) {
        // This glyph is not a composite.
        var endPointIndices = glyph.endPointIndices = [];
        for (var i = 0; i < glyph.numberOfContours; i += 1) {
            endPointIndices.push(p.parseUShort());
        }

        glyph.instructionLength = p.parseUShort();
        glyph.instructions = [];
        for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {
            glyph.instructions.push(p.parseByte());
        }

        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
        flags = [];
        for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {
            flag = p.parseByte();
            flags.push(flag);
            // If bit 3 is set, we repeat this flag n times, where n is the next byte.
            if ((flag & 8) > 0) {
                var repeatCount = p.parseByte();
                for (var j = 0; j < repeatCount; j += 1) {
                    flags.push(flag);
                    i$2 += 1;
                }
            }
        }

        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');

        if (endPointIndices.length > 0) {
            var points = [];
            var point;
            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
            if (numberOfCoordinates > 0) {
                for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {
                    flag = flags[i$3];
                    point = {};
                    point.onCurve = !!(flag & 1);
                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;
                    points.push(point);
                }

                var px = 0;
                for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {
                    flag = flags[i$4];
                    point = points[i$4];
                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
                    px = point.x;
                }

                var py = 0;
                for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {
                    flag = flags[i$5];
                    point = points[i$5];
                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
                    py = point.y;
                }
            }

            glyph.points = points;
        } else {
            glyph.points = [];
        }
    } else if (glyph.numberOfContours === 0) {
        glyph.points = [];
    } else {
        glyph.isComposite = true;
        glyph.points = [];
        glyph.components = [];
        var moreComponents = true;
        while (moreComponents) {
            flags = p.parseUShort();
            var component = {
                glyphIndex: p.parseUShort(),
                xScale: 1,
                scale01: 0,
                scale10: 0,
                yScale: 1,
                dx: 0,
                dy: 0
            };
            if ((flags & 1) > 0) {
                // The arguments are words
                if ((flags & 2) > 0) {
                    // values are offset
                    component.dx = p.parseShort();
                    component.dy = p.parseShort();
                } else {
                    // values are matched points
                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];
                }

            } else {
                // The arguments are bytes
                if ((flags & 2) > 0) {
                    // values are offset
                    component.dx = p.parseChar();
                    component.dy = p.parseChar();
                } else {
                    // values are matched points
                    component.matchedPoints = [p.parseByte(), p.parseByte()];
                }
            }

            if ((flags & 8) > 0) {
                // We have a scale
                component.xScale = component.yScale = p.parseF2Dot14();
            } else if ((flags & 64) > 0) {
                // We have an X / Y scale
                component.xScale = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            } else if ((flags & 128) > 0) {
                // We have a 2x2 transformation
                component.xScale = p.parseF2Dot14();
                component.scale01 = p.parseF2Dot14();
                component.scale10 = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            }

            glyph.components.push(component);
            moreComponents = !!(flags & 32);
        }
        if (flags & 0x100) {
            // We have instructions
            glyph.instructionLength = p.parseUShort();
            glyph.instructions = [];
            for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {
                glyph.instructions.push(p.parseByte());
            }
        }
    }
}

// Transform an array of points and return a new array.
function transformPoints(points, transform) {
    var newPoints = [];
    for (var i = 0; i < points.length; i += 1) {
        var pt = points[i];
        var newPt = {
            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
            onCurve: pt.onCurve,
            lastPointOfContour: pt.lastPointOfContour
        };
        newPoints.push(newPt);
    }

    return newPoints;
}

function getContours(points) {
    var contours = [];
    var currentContour = [];
    for (var i = 0; i < points.length; i += 1) {
        var pt = points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }

    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
}

// Convert the TrueType glyph outline to a Path.
function getPath(points) {
    var p = new Path();
    if (!points) {
        return p;
    }

    var contours = getContours(points);

    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {
        var contour = contours[contourIndex];

        var prev = null;
        var curr = contour[contour.length - 1];
        var next = contour[0];

        if (curr.onCurve) {
            p.moveTo(curr.x, curr.y);
        } else {
            if (next.onCurve) {
                p.moveTo(next.x, next.y);
            } else {
                // If both first and last points are off-curve, start at their middle.
                var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};
                p.moveTo(start.x, start.y);
            }
        }

        for (var i = 0; i < contour.length; ++i) {
            prev = curr;
            curr = next;
            next = contour[(i + 1) % contour.length];

            if (curr.onCurve) {
                // This is a straight line.
                p.lineTo(curr.x, curr.y);
            } else {
                var prev2 = prev;
                var next2 = next;

                if (!prev.onCurve) {
                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };
                    p.lineTo(prev2.x, prev2.y);
                }

                if (!next.onCurve) {
                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
                }

                p.lineTo(prev2.x, prev2.y);
                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);
            }
        }

        p.closePath();
    }
    return p;
}

function buildPath(glyphs, glyph) {
    if (glyph.isComposite) {
        for (var j = 0; j < glyph.components.length; j += 1) {
            var component = glyph.components[j];
            var componentGlyph = glyphs.get(component.glyphIndex);
            // Force the ttfGlyphLoader to parse the glyph.
            componentGlyph.getPath();
            if (componentGlyph.points) {
                var transformedPoints = (void 0);
                if (component.matchedPoints === undefined) {
                    // component positioned by offset
                    transformedPoints = transformPoints(componentGlyph.points, component);
                } else {
                    // component positioned by matched points
                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||
                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {
                        throw Error('Matched points out of range in ' + glyph.name);
                    }
                    var firstPt = glyph.points[component.matchedPoints[0]];
                    var secondPt = componentGlyph.points[component.matchedPoints[1]];
                    var transform = {
                        xScale: component.xScale, scale01: component.scale01,
                        scale10: component.scale10, yScale: component.yScale,
                        dx: 0, dy: 0
                    };
                    secondPt = transformPoints([secondPt], transform)[0];
                    transform.dx = firstPt.x - secondPt.x;
                    transform.dy = firstPt.y - secondPt.y;
                    transformedPoints = transformPoints(componentGlyph.points, transform);
                }
                glyph.points = glyph.points.concat(transformedPoints);
            }
        }
    }

    return getPath(glyph.points);
}

// Parse all the glyphs according to the offsets from the `loca` table.
function parseGlyfTable(data, start, loca, font) {
    var glyphs = new glyphset.GlyphSet(font);

    // The last element of the loca table is invalid.
    for (var i = 0; i < loca.length - 1; i += 1) {
        var offset = loca[i];
        var nextOffset = loca[i + 1];
        if (offset !== nextOffset) {
            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
        } else {
            glyphs.push(i, glyphset.glyphLoader(font, i));
        }
    }

    return glyphs;
}

var glyf = { getPath: getPath, parse: parseGlyfTable };

// The Glyph object

function getPathDefinition(glyph, path) {
    var _path = path || {commands: []};
    return {
        configurable: true,

        get: function() {
            if (typeof _path === 'function') {
                _path = _path();
            }

            return _path;
        },

        set: function(p) {
            _path = p;
        }
    };
}
/**
 * @typedef GlyphOptions
 * @type Object
 * @property {string} [name] - The glyph name
 * @property {number} [unicode]
 * @property {Array} [unicodes]
 * @property {number} [xMin]
 * @property {number} [yMin]
 * @property {number} [xMax]
 * @property {number} [yMax]
 * @property {number} [advanceWidth]
 */

// A Glyph is an individual mark that often corresponds to a character.
// Some glyphs, such as ligatures, are a combination of many characters.
// Glyphs are the basic building blocks of a font.
//
// The `Glyph` class contains utility methods for drawing the path and its points.
/**
 * @exports opentype.Glyph
 * @class
 * @param {GlyphOptions}
 * @constructor
 */
function Glyph(options) {
    // By putting all the code on a prototype function (which is only declared once)
    // we reduce the memory requirements for larger fonts by some 2%
    this.bindConstructorValues(options);
}

/**
 * @param  {GlyphOptions}
 */
Glyph.prototype.bindConstructorValues = function(options) {
    this.index = options.index || 0;

    // These three values cannot be deferred for memory optimization:
    this.name = options.name || null;
    this.unicode = options.unicode || undefined;
    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];

    // But by binding these values only when necessary, we reduce can
    // the memory requirements by almost 3% for larger fonts.
    if (options.xMin) {
        this.xMin = options.xMin;
    }

    if (options.yMin) {
        this.yMin = options.yMin;
    }

    if (options.xMax) {
        this.xMax = options.xMax;
    }

    if (options.yMax) {
        this.yMax = options.yMax;
    }

    if (options.advanceWidth) {
        this.advanceWidth = options.advanceWidth;
    }

    // The path for a glyph is the most memory intensive, and is bound as a value
    // with a getter/setter to ensure we actually do path parsing only once the
    // path is actually needed by anything.
    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));
};

/**
 * @param {number}
 */
Glyph.prototype.addUnicode = function(unicode) {
    if (this.unicodes.length === 0) {
        this.unicode = unicode;
    }

    this.unicodes.push(unicode);
};

/**
 * Calculate the minimum bounding box for this glyph.
 * @return {opentype.BoundingBox}
 */
Glyph.prototype.getBoundingBox = function() {
    return this.path.getBoundingBox();
};

/**
 * Convert the glyph to a Path we can draw on a drawing context.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {Object=} options - xScale, yScale to stretch the glyph.
 * @param  {opentype.Font} if hinting is to be used, the font
 * @return {opentype.Path}
 */
Glyph.prototype.getPath = function(x, y, fontSize, options, font) {
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    var commands;
    var hPoints;
    if (!options) { options = { }; }
    var xScale = options.xScale;
    var yScale = options.yScale;

    if (options.hinting && font && font.hinting) {
        // in case of hinting, the hinting engine takes care
        // of scaling the points (not the path) before hinting.
        hPoints = this.path && font.hinting.exec(this, fontSize);
        // in case the hinting engine failed hPoints is undefined
        // and thus reverts to plain rending
    }

    if (hPoints) {
        commands = glyf.getPath(hPoints).commands;
        x = Math.round(x);
        y = Math.round(y);
        // TODO in case of hinting xyScaling is not yet supported
        xScale = yScale = 1;
    } else {
        commands = this.path.commands;
        var scale = 1 / this.path.unitsPerEm * fontSize;
        if (xScale === undefined) { xScale = scale; }
        if (yScale === undefined) { yScale = scale; }
    }

    var p = new Path();
    for (var i = 0; i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type === 'M') {
            p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'L') {
            p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'Q') {
            p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
                               x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'C') {
            p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
                      x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),
                      x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'Z') {
            p.closePath();
        }
    }

    return p;
};

/**
 * Split the glyph into contours.
 * This function is here for backwards compatibility, and to
 * provide raw access to the TrueType glyph outlines.
 * @return {Array}
 */
Glyph.prototype.getContours = function() {
    var this$1 = this;

    if (this.points === undefined) {
        return [];
    }

    var contours = [];
    var currentContour = [];
    for (var i = 0; i < this.points.length; i += 1) {
        var pt = this$1.points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }

    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
};

/**
 * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
 * @return {Object}
 */
Glyph.prototype.getMetrics = function() {
    var commands = this.path.commands;
    var xCoords = [];
    var yCoords = [];
    for (var i = 0; i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type !== 'Z') {
            xCoords.push(cmd.x);
            yCoords.push(cmd.y);
        }

        if (cmd.type === 'Q' || cmd.type === 'C') {
            xCoords.push(cmd.x1);
            yCoords.push(cmd.y1);
        }

        if (cmd.type === 'C') {
            xCoords.push(cmd.x2);
            yCoords.push(cmd.y2);
        }
    }

    var metrics = {
        xMin: Math.min.apply(null, xCoords),
        yMin: Math.min.apply(null, yCoords),
        xMax: Math.max.apply(null, xCoords),
        yMax: Math.max.apply(null, yCoords),
        leftSideBearing: this.leftSideBearing
    };

    if (!isFinite(metrics.xMin)) {
        metrics.xMin = 0;
    }

    if (!isFinite(metrics.xMax)) {
        metrics.xMax = this.advanceWidth;
    }

    if (!isFinite(metrics.yMin)) {
        metrics.yMin = 0;
    }

    if (!isFinite(metrics.yMax)) {
        metrics.yMax = 0;
    }

    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
    return metrics;
};

/**
 * Draw the glyph on the given context.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {Object=} options - xScale, yScale to stretch the glyph.
 */
Glyph.prototype.draw = function(ctx, x, y, fontSize, options) {
    this.getPath(x, y, fontSize, options).draw(ctx);
};

/**
 * Draw the points of the glyph.
 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 */
Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
    function drawCircles(l, x, y, scale) {
        var PI_SQ = Math.PI * 2;
        ctx.beginPath();
        for (var j = 0; j < l.length; j += 1) {
            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));
            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, PI_SQ, false);
        }

        ctx.closePath();
        ctx.fill();
    }

    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    var scale = 1 / this.path.unitsPerEm * fontSize;

    var blueCircles = [];
    var redCircles = [];
    var path = this.path;
    for (var i = 0; i < path.commands.length; i += 1) {
        var cmd = path.commands[i];
        if (cmd.x !== undefined) {
            blueCircles.push({x: cmd.x, y: -cmd.y});
        }

        if (cmd.x1 !== undefined) {
            redCircles.push({x: cmd.x1, y: -cmd.y1});
        }

        if (cmd.x2 !== undefined) {
            redCircles.push({x: cmd.x2, y: -cmd.y2});
        }
    }

    ctx.fillStyle = 'blue';
    drawCircles(blueCircles, x, y, scale);
    ctx.fillStyle = 'red';
    drawCircles(redCircles, x, y, scale);
};

/**
 * Draw lines indicating important font measurements.
 * Black lines indicate the origin of the coordinate system (point 0,0).
 * Blue lines indicate the glyph bounding box.
 * Green line indicates the advance width of the glyph.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 */
Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
    var scale;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    scale = 1 / this.path.unitsPerEm * fontSize;
    ctx.lineWidth = 1;

    // Draw the origin
    ctx.strokeStyle = 'black';
    draw.line(ctx, x, -10000, x, 10000);
    draw.line(ctx, -10000, y, 10000, y);

    // This code is here due to memory optimization: by not using
    // defaults in the constructor, we save a notable amount of memory.
    var xMin = this.xMin || 0;
    var yMin = this.yMin || 0;
    var xMax = this.xMax || 0;
    var yMax = this.yMax || 0;
    var advanceWidth = this.advanceWidth || 0;

    // Draw the glyph box
    ctx.strokeStyle = 'blue';
    draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);
    draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);
    draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));
    draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));

    // Draw the advance width
    ctx.strokeStyle = 'green';
    draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);
};

// The GlyphSet object

function defineDependentProperty(glyph, externalName, internalName) {
    Object.defineProperty(glyph, externalName, {
        get: function() {
            // Request the path property to make sure the path is loaded.
            glyph.path; // jshint ignore:line
            return glyph[internalName];
        },
        set: function(newValue) {
            glyph[internalName] = newValue;
        },
        enumerable: true,
        configurable: true
    });
}

/**
 * A GlyphSet represents all glyphs available in the font, but modelled using
 * a deferred glyph loader, for retrieving glyphs only once they are absolutely
 * necessary, to keep the memory footprint down.
 * @exports opentype.GlyphSet
 * @class
 * @param {opentype.Font}
 * @param {Array}
 */
function GlyphSet(font, glyphs) {
    var this$1 = this;

    this.font = font;
    this.glyphs = {};
    if (Array.isArray(glyphs)) {
        for (var i = 0; i < glyphs.length; i++) {
            this$1.glyphs[i] = glyphs[i];
        }
    }

    this.length = (glyphs && glyphs.length) || 0;
}

/**
 * @param  {number} index
 * @return {opentype.Glyph}
 */
GlyphSet.prototype.get = function(index) {
    if (typeof this.glyphs[index] === 'function') {
        this.glyphs[index] = this.glyphs[index]();
    }

    return this.glyphs[index];
};

/**
 * @param  {number} index
 * @param  {Object}
 */
GlyphSet.prototype.push = function(index, loader) {
    this.glyphs[index] = loader;
    this.length++;
};

/**
 * @alias opentype.glyphLoader
 * @param  {opentype.Font} font
 * @param  {number} index
 * @return {opentype.Glyph}
 */
function glyphLoader(font, index) {
    return new Glyph({index: index, font: font});
}

/**
 * Generate a stub glyph that can be filled with all metadata *except*
 * the "points" and "path" properties, which must be loaded only once
 * the glyph's path is actually requested for text shaping.
 * @alias opentype.ttfGlyphLoader
 * @param  {opentype.Font} font
 * @param  {number} index
 * @param  {Function} parseGlyph
 * @param  {Object} data
 * @param  {number} position
 * @param  {Function} buildPath
 * @return {opentype.Glyph}
 */
function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {
    return function() {
        var glyph = new Glyph({index: index, font: font});

        glyph.path = function() {
            parseGlyph(glyph, data, position);
            var path = buildPath(font.glyphs, glyph);
            path.unitsPerEm = font.unitsPerEm;
            return path;
        };

        defineDependentProperty(glyph, 'xMin', '_xMin');
        defineDependentProperty(glyph, 'xMax', '_xMax');
        defineDependentProperty(glyph, 'yMin', '_yMin');
        defineDependentProperty(glyph, 'yMax', '_yMax');

        return glyph;
    };
}
/**
 * @alias opentype.cffGlyphLoader
 * @param  {opentype.Font} font
 * @param  {number} index
 * @param  {Function} parseCFFCharstring
 * @param  {string} charstring
 * @return {opentype.Glyph}
 */
function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {
    return function() {
        var glyph = new Glyph({index: index, font: font});

        glyph.path = function() {
            var path = parseCFFCharstring(font, glyph, charstring);
            path.unitsPerEm = font.unitsPerEm;
            return path;
        };

        return glyph;
    };
}

var glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };

// The `CFF` table contains the glyph outlines in PostScript format.
// https://www.microsoft.com/typography/OTSPEC/cff.htm
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/cff.pdf
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/type2.pdf

function equals$1(a, b) {
    if (a === b) {
        return true;
    } else if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return false;
        }

        for (var i = 0; i < a.length; i += 1) {
            if (!equals$1(a[i], b[i])) {
                return false;
            }
        }

        return true;
    } else {
        return false;
    }
}

// Subroutines are encoded using the negative half of the number space.
// See type 2 chapter 4.7 "Subroutine operators".
function calcCFFSubroutineBias(subrs) {
    var bias;
    if (subrs.length < 1240) {
        bias = 107;
    } else if (subrs.length < 33900) {
        bias = 1131;
    } else {
        bias = 32768;
    }

    return bias;
}

// Parse a `CFF` INDEX array.
// An index array consists of a list of offsets, then a list of objects at those offsets.
function parseCFFIndex(data, start, conversionFn) {
    var offsets = [];
    var objects = [];
    var count = parse$1.getCard16(data, start);
    var objectOffset;
    var endOffset;
    if (count !== 0) {
        var offsetSize = parse$1.getByte(data, start + 2);
        objectOffset = start + ((count + 1) * offsetSize) + 2;
        var pos = start + 3;
        for (var i = 0; i < count + 1; i += 1) {
            offsets.push(parse$1.getOffset(data, pos, offsetSize));
            pos += offsetSize;
        }

        // The total size of the index array is 4 header bytes + the value of the last offset.
        endOffset = objectOffset + offsets[count];
    } else {
        endOffset = start + 2;
    }

    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {
        var value = parse$1.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);
        if (conversionFn) {
            value = conversionFn(value);
        }

        objects.push(value);
    }

    return {objects: objects, startOffset: start, endOffset: endOffset};
}

// Parse a `CFF` DICT real value.
function parseFloatOperand(parser) {
    var s = '';
    var eof = 15;
    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
    while (true) {
        var b = parser.parseByte();
        var n1 = b >> 4;
        var n2 = b & 15;

        if (n1 === eof) {
            break;
        }

        s += lookup[n1];

        if (n2 === eof) {
            break;
        }

        s += lookup[n2];
    }

    return parseFloat(s);
}

// Parse a `CFF` DICT operand.
function parseOperand(parser, b0) {
    var b1;
    var b2;
    var b3;
    var b4;
    if (b0 === 28) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        return b1 << 8 | b2;
    }

    if (b0 === 29) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        b3 = parser.parseByte();
        b4 = parser.parseByte();
        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
    }

    if (b0 === 30) {
        return parseFloatOperand(parser);
    }

    if (b0 >= 32 && b0 <= 246) {
        return b0 - 139;
    }

    if (b0 >= 247 && b0 <= 250) {
        b1 = parser.parseByte();
        return (b0 - 247) * 256 + b1 + 108;
    }

    if (b0 >= 251 && b0 <= 254) {
        b1 = parser.parseByte();
        return -(b0 - 251) * 256 - b1 - 108;
    }

    throw new Error('Invalid b0 ' + b0);
}

// Convert the entries returned by `parseDict` to a proper dictionary.
// If a value is a list of one, it is unpacked.
function entriesToObject(entries) {
    var o = {};
    for (var i = 0; i < entries.length; i += 1) {
        var key = entries[i][0];
        var values = entries[i][1];
        var value = (void 0);
        if (values.length === 1) {
            value = values[0];
        } else {
            value = values;
        }

        if (o.hasOwnProperty(key) && !isNaN(o[key])) {
            throw new Error('Object ' + o + ' already has key ' + key);
        }

        o[key] = value;
    }

    return o;
}

// Parse a `CFF` DICT object.
// A dictionary contains key-value pairs in a compact tokenized format.
function parseCFFDict(data, start, size) {
    start = start !== undefined ? start : 0;
    var parser = new parse$1.Parser(data, start);
    var entries = [];
    var operands = [];
    size = size !== undefined ? size : data.length;

    while (parser.relativeOffset < size) {
        var op = parser.parseByte();

        // The first byte for each dict item distinguishes between operator (key) and operand (value).
        // Values <= 21 are operators.
        if (op <= 21) {
            // Two-byte operators have an initial escape byte of 12.
            if (op === 12) {
                op = 1200 + parser.parseByte();
            }

            entries.push([op, operands]);
            operands = [];
        } else {
            // Since the operands (values) come before the operators (keys), we store all operands in a list
            // until we encounter an operator.
            operands.push(parseOperand(parser, op));
        }
    }

    return entriesToObject(entries);
}

// Given a String Index (SID), return the value of the string.
// Strings below index 392 are standard CFF strings and are not encoded in the font.
function getCFFString(strings, index) {
    if (index <= 390) {
        index = cffStandardStrings[index];
    } else {
        index = strings[index - 391];
    }

    return index;
}

// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
function interpretDict(dict, meta, strings) {
    var newDict = {};
    var value;

    // Because we also want to include missing values, we start out from the meta list
    // and lookup values in the dict.
    for (var i = 0; i < meta.length; i += 1) {
        var m = meta[i];

        if (Array.isArray(m.type)) {
            var values = [];
            values.length = m.type.length;
            for (var j = 0; j < m.type.length; j++) {
                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;
                if (value === undefined) {
                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;
                }
                if (m.type[j] === 'SID') {
                    value = getCFFString(strings, value);
                }
                values[j] = value;
            }
            newDict[m.name] = values;
        } else {
            value = dict[m.op];
            if (value === undefined) {
                value = m.value !== undefined ? m.value : null;
            }

            if (m.type === 'SID') {
                value = getCFFString(strings, value);
            }
            newDict[m.name] = value;
        }
    }

    return newDict;
}

// Parse the CFF header.
function parseCFFHeader(data, start) {
    var header = {};
    header.formatMajor = parse$1.getCard8(data, start);
    header.formatMinor = parse$1.getCard8(data, start + 1);
    header.size = parse$1.getCard8(data, start + 2);
    header.offsetSize = parse$1.getCard8(data, start + 3);
    header.startOffset = start;
    header.endOffset = start + 4;
    return header;
}

var TOP_DICT_META = [
    {name: 'version', op: 0, type: 'SID'},
    {name: 'notice', op: 1, type: 'SID'},
    {name: 'copyright', op: 1200, type: 'SID'},
    {name: 'fullName', op: 2, type: 'SID'},
    {name: 'familyName', op: 3, type: 'SID'},
    {name: 'weight', op: 4, type: 'SID'},
    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},
    {name: 'italicAngle', op: 1202, type: 'number', value: 0},
    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},
    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},
    {name: 'paintType', op: 1205, type: 'number', value: 0},
    {name: 'charstringType', op: 1206, type: 'number', value: 2},
    {
        name: 'fontMatrix',
        op: 1207,
        type: ['real', 'real', 'real', 'real', 'real', 'real'],
        value: [0.001, 0, 0, 0.001, 0, 0]
    },
    {name: 'uniqueId', op: 13, type: 'number'},
    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},
    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},
    {name: 'xuid', op: 14, type: [], value: null},
    {name: 'charset', op: 15, type: 'offset', value: 0},
    {name: 'encoding', op: 16, type: 'offset', value: 0},
    {name: 'charStrings', op: 17, type: 'offset', value: 0},
    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},
    {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},
    {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},
    {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},
    {name: 'cidFontType', op: 1233, type: 'number', value: 0},
    {name: 'cidCount', op: 1234, type: 'number', value: 8720},
    {name: 'uidBase', op: 1235, type: 'number'},
    {name: 'fdArray', op: 1236, type: 'offset'},
    {name: 'fdSelect', op: 1237, type: 'offset'},
    {name: 'fontName', op: 1238, type: 'SID'}
];

var PRIVATE_DICT_META = [
    {name: 'subrs', op: 19, type: 'offset', value: 0},
    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},
    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}
];

// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
// The top dictionary contains the essential metadata for the font, together with the private dictionary.
function parseCFFTopDict(data, strings) {
    var dict = parseCFFDict(data, 0, data.byteLength);
    return interpretDict(dict, TOP_DICT_META, strings);
}

// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
function parseCFFPrivateDict(data, start, size, strings) {
    var dict = parseCFFDict(data, start, size);
    return interpretDict(dict, PRIVATE_DICT_META, strings);
}

// Returns a list of "Top DICT"s found using an INDEX list.
// Used to read both the usual high-level Top DICTs and also the FDArray
// discovered inside CID-keyed fonts.  When a Top DICT has a reference to
// a Private DICT that is read and saved into the Top DICT.
//
// In addition to the expected/optional values as outlined in TOP_DICT_META
// the following values might be saved into the Top DICT.
//
//    _subrs []        array of local CFF subroutines from Private DICT
//    _subrsBias       bias value computed from number of subroutines
//                      (see calcCFFSubroutineBias() and parseCFFCharstring())
//    _defaultWidthX   default widths for CFF characters
//    _nominalWidthX   bias added to width embedded within glyph description
//
//    _privateDict     saved copy of parsed Private DICT from Top DICT
function gatherCFFTopDicts(data, start, cffIndex, strings) {
    var topDictArray = [];
    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {
        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);
        var topDict = parseCFFTopDict(topDictData, strings);
        topDict._subrs = [];
        topDict._subrsBias = 0;
        var privateSize = topDict.private[0];
        var privateOffset = topDict.private[1];
        if (privateSize !== 0 && privateOffset !== 0) {
            var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);
            topDict._defaultWidthX = privateDict.defaultWidthX;
            topDict._nominalWidthX = privateDict.nominalWidthX;
            if (privateDict.subrs !== 0) {
                var subrOffset = privateOffset + privateDict.subrs;
                var subrIndex = parseCFFIndex(data, subrOffset + start);
                topDict._subrs = subrIndex.objects;
                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);
            }
            topDict._privateDict = privateDict;
        }
        topDictArray.push(topDict);
    }
    return topDictArray;
}

// Parse the CFF charset table, which contains internal names for all the glyphs.
// This function will return a list of glyph names.
// See Adobe TN #5176 chapter 13, "Charsets".
function parseCFFCharset(data, start, nGlyphs, strings) {
    var sid;
    var count;
    var parser = new parse$1.Parser(data, start);

    // The .notdef glyph is not included, so subtract 1.
    nGlyphs -= 1;
    var charset = ['.notdef'];

    var format = parser.parseCard8();
    if (format === 0) {
        for (var i = 0; i < nGlyphs; i += 1) {
            sid = parser.parseSID();
            charset.push(getCFFString(strings, sid));
        }
    } else if (format === 1) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard8();
            for (var i$1 = 0; i$1 <= count; i$1 += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else if (format === 2) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard16();
            for (var i$2 = 0; i$2 <= count; i$2 += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else {
        throw new Error('Unknown charset format ' + format);
    }

    return charset;
}

// Parse the CFF encoding data. Only one encoding can be specified per font.
// See Adobe TN #5176 chapter 12, "Encodings".
function parseCFFEncoding(data, start, charset) {
    var code;
    var enc = {};
    var parser = new parse$1.Parser(data, start);
    var format = parser.parseCard8();
    if (format === 0) {
        var nCodes = parser.parseCard8();
        for (var i = 0; i < nCodes; i += 1) {
            code = parser.parseCard8();
            enc[code] = i;
        }
    } else if (format === 1) {
        var nRanges = parser.parseCard8();
        code = 1;
        for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {
            var first = parser.parseCard8();
            var nLeft = parser.parseCard8();
            for (var j = first; j <= first + nLeft; j += 1) {
                enc[j] = code;
                code += 1;
            }
        }
    } else {
        throw new Error('Unknown encoding format ' + format);
    }

    return new CffEncoding(enc, charset);
}

// Take in charstring code and return a Glyph object.
// The encoding is described in the Type 2 Charstring Format
// https://www.microsoft.com/typography/OTSPEC/charstr2.htm
function parseCFFCharstring(font, glyph, code) {
    var c1x;
    var c1y;
    var c2x;
    var c2y;
    var p = new Path();
    var stack = [];
    var nStems = 0;
    var haveWidth = false;
    var open = false;
    var x = 0;
    var y = 0;
    var subrs;
    var subrsBias;
    var defaultWidthX;
    var nominalWidthX;
    if (font.isCIDFont) {
        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];
        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];
        subrs = fdDict._subrs;
        subrsBias = fdDict._subrsBias;
        defaultWidthX = fdDict._defaultWidthX;
        nominalWidthX = fdDict._nominalWidthX;
    } else {
        subrs = font.tables.cff.topDict._subrs;
        subrsBias = font.tables.cff.topDict._subrsBias;
        defaultWidthX = font.tables.cff.topDict._defaultWidthX;
        nominalWidthX = font.tables.cff.topDict._nominalWidthX;
    }
    var width = defaultWidthX;

    function newContour(x, y) {
        if (open) {
            p.closePath();
        }

        p.moveTo(x, y);
        open = true;
    }

    function parseStems() {
        var hasWidthArg;

        // The number of stem operators on the stack is always even.
        // If the value is uneven, that means a width is specified.
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
            width = stack.shift() + nominalWidthX;
        }

        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
    }

    function parse(code) {
        var b1;
        var b2;
        var b3;
        var b4;
        var codeIndex;
        var subrCode;
        var jpx;
        var jpy;
        var c3x;
        var c3y;
        var c4x;
        var c4y;

        var i = 0;
        while (i < code.length) {
            var v = code[i];
            i += 1;
            switch (v) {
                case 1: // hstem
                    parseStems();
                    break;
                case 3: // vstem
                    parseStems();
                    break;
                case 4: // vmoveto
                    if (stack.length > 1 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }

                    y += stack.pop();
                    newContour(x, y);
                    break;
                case 5: // rlineto
                    while (stack.length > 0) {
                        x += stack.shift();
                        y += stack.shift();
                        p.lineTo(x, y);
                    }

                    break;
                case 6: // hlineto
                    while (stack.length > 0) {
                        x += stack.shift();
                        p.lineTo(x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        y += stack.shift();
                        p.lineTo(x, y);
                    }

                    break;
                case 7: // vlineto
                    while (stack.length > 0) {
                        y += stack.shift();
                        p.lineTo(x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        x += stack.shift();
                        p.lineTo(x, y);
                    }

                    break;
                case 8: // rrcurveto
                    while (stack.length > 0) {
                        c1x = x + stack.shift();
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 10: // callsubr
                    codeIndex = stack.pop() + subrsBias;
                    subrCode = subrs[codeIndex];
                    if (subrCode) {
                        parse(subrCode);
                    }

                    break;
                case 11: // return
                    return;
                case 12: // flex operators
                    v = code[i];
                    i += 1;
                    switch (v) {
                        case 35: // flex
                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-
                            c1x = x   + stack.shift();    // dx1
                            c1y = y   + stack.shift();    // dy1
                            c2x = c1x + stack.shift();    // dx2
                            c2y = c1y + stack.shift();    // dy2
                            jpx = c2x + stack.shift();    // dx3
                            jpy = c2y + stack.shift();    // dy3
                            c3x = jpx + stack.shift();    // dx4
                            c3y = jpy + stack.shift();    // dy4
                            c4x = c3x + stack.shift();    // dx5
                            c4y = c3y + stack.shift();    // dy5
                            x = c4x   + stack.shift();    // dx6
                            y = c4y   + stack.shift();    // dy6
                            stack.shift();                // flex depth
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 34: // hflex
                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-
                            c1x = x   + stack.shift();    // dx1
                            c1y = y;                      // dy1
                            c2x = c1x + stack.shift();    // dx2
                            c2y = c1y + stack.shift();    // dy2
                            jpx = c2x + stack.shift();    // dx3
                            jpy = c2y;                    // dy3
                            c3x = jpx + stack.shift();    // dx4
                            c3y = c2y;                    // dy4
                            c4x = c3x + stack.shift();    // dx5
                            c4y = y;                      // dy5
                            x = c4x + stack.shift();      // dx6
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 36: // hflex1
                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-
                            c1x = x   + stack.shift();    // dx1
                            c1y = y   + stack.shift();    // dy1
                            c2x = c1x + stack.shift();    // dx2
                            c2y = c1y + stack.shift();    // dy2
                            jpx = c2x + stack.shift();    // dx3
                            jpy = c2y;                    // dy3
                            c3x = jpx + stack.shift();    // dx4
                            c3y = c2y;                    // dy4
                            c4x = c3x + stack.shift();    // dx5
                            c4y = c3y + stack.shift();    // dy5
                            x = c4x + stack.shift();      // dx6
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 37: // flex1
                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-
                            c1x = x   + stack.shift();    // dx1
                            c1y = y   + stack.shift();    // dy1
                            c2x = c1x + stack.shift();    // dx2
                            c2y = c1y + stack.shift();    // dy2
                            jpx = c2x + stack.shift();    // dx3
                            jpy = c2y + stack.shift();    // dy3
                            c3x = jpx + stack.shift();    // dx4
                            c3y = jpy + stack.shift();    // dy4
                            c4x = c3x + stack.shift();    // dx5
                            c4y = c3y + stack.shift();    // dy5
                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
                                x = c4x + stack.shift();
                            } else {
                                y = c4y + stack.shift();
                            }

                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        default:
                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);
                            stack.length = 0;
                    }
                    break;
                case 14: // endchar
                    if (stack.length > 0 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }

                    if (open) {
                        p.closePath();
                        open = false;
                    }

                    break;
                case 18: // hstemhm
                    parseStems();
                    break;
                case 19: // hintmask
                case 20: // cntrmask
                    parseStems();
                    i += (nStems + 7) >> 3;
                    break;
                case 21: // rmoveto
                    if (stack.length > 2 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }

                    y += stack.pop();
                    x += stack.pop();
                    newContour(x, y);
                    break;
                case 22: // hmoveto
                    if (stack.length > 1 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }

                    x += stack.pop();
                    newContour(x, y);
                    break;
                case 23: // vstemhm
                    parseStems();
                    break;
                case 24: // rcurveline
                    while (stack.length > 2) {
                        c1x = x + stack.shift();
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    x += stack.shift();
                    y += stack.shift();
                    p.lineTo(x, y);
                    break;
                case 25: // rlinecurve
                    while (stack.length > 6) {
                        x += stack.shift();
                        y += stack.shift();
                        p.lineTo(x, y);
                    }

                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    break;
                case 26: // vvcurveto
                    if (stack.length % 2) {
                        x += stack.shift();
                    }

                    while (stack.length > 0) {
                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x;
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 27: // hhcurveto
                    if (stack.length % 2) {
                        y += stack.shift();
                    }

                    while (stack.length > 0) {
                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y;
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 28: // shortint
                    b1 = code[i];
                    b2 = code[i + 1];
                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);
                    i += 2;
                    break;
                case 29: // callgsubr
                    codeIndex = stack.pop() + font.gsubrsBias;
                    subrCode = font.gsubrs[codeIndex];
                    if (subrCode) {
                        parse(subrCode);
                    }

                    break;
                case 30: // vhcurveto
                    while (stack.length > 0) {
                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        y = c2y + stack.shift();
                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 31: // hvcurveto
                    while (stack.length > 0) {
                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        y = c2y + stack.shift();
                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                default:
                    if (v < 32) {
                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);
                    } else if (v < 247) {
                        stack.push(v - 139);
                    } else if (v < 251) {
                        b1 = code[i];
                        i += 1;
                        stack.push((v - 247) * 256 + b1 + 108);
                    } else if (v < 255) {
                        b1 = code[i];
                        i += 1;
                        stack.push(-(v - 251) * 256 - b1 - 108);
                    } else {
                        b1 = code[i];
                        b2 = code[i + 1];
                        b3 = code[i + 2];
                        b4 = code[i + 3];
                        i += 4;
                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);
                    }
            }
        }
    }

    parse(code);

    glyph.advanceWidth = width;
    return p;
}

function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {
    var fdSelect = [];
    var fdIndex;
    var parser = new parse$1.Parser(data, start);
    var format = parser.parseCard8();
    if (format === 0) {
        // Simple list of nGlyphs elements
        for (var iGid = 0; iGid < nGlyphs; iGid++) {
            fdIndex = parser.parseCard8();
            if (fdIndex >= fdArrayCount) {
                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
            }
            fdSelect.push(fdIndex);
        }
    } else if (format === 3) {
        // Ranges
        var nRanges = parser.parseCard16();
        var first = parser.parseCard16();
        if (first !== 0) {
            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);
        }
        var next;
        for (var iRange = 0; iRange < nRanges; iRange++) {
            fdIndex = parser.parseCard8();
            next = parser.parseCard16();
            if (fdIndex >= fdArrayCount) {
                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
            }
            if (next > nGlyphs) {
                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);
            }
            for (; first < next; first++) {
                fdSelect.push(fdIndex);
            }
            first = next;
        }
        if (next !== nGlyphs) {
            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);
        }
    } else {
        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);
    }
    return fdSelect;
}

// Parse the `CFF` table, which contains the glyph outlines in PostScript format.
function parseCFFTable(data, start, font) {
    font.tables.cff = {};
    var header = parseCFFHeader(data, start);
    var nameIndex = parseCFFIndex(data, header.endOffset, parse$1.bytesToString);
    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse$1.bytesToString);
    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
    font.gsubrs = globalSubrIndex.objects;
    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);

    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);
    if (topDictArray.length !== 1) {
        throw new Error('CFF table has too many fonts in \'FontSet\' - count of fonts NameIndex.length = ' + topDictArray.length);
    }

    var topDict = topDictArray[0];
    font.tables.cff.topDict = topDict;

    if (topDict._privateDict) {
        font.defaultWidthX = topDict._privateDict.defaultWidthX;
        font.nominalWidthX = topDict._privateDict.nominalWidthX;
    }

    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {
        font.isCIDFont = true;
    }

    if (font.isCIDFont) {
        var fdArrayOffset = topDict.fdArray;
        var fdSelectOffset = topDict.fdSelect;
        if (fdArrayOffset === 0 || fdSelectOffset === 0) {
            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');
        }
        fdArrayOffset += start;
        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);
        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);
        topDict._fdArray = fdArray;
        fdSelectOffset += start;
        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);
    }

    var privateDictOffset = start + topDict.private[1];
    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);
    font.defaultWidthX = privateDict.defaultWidthX;
    font.nominalWidthX = privateDict.nominalWidthX;

    if (privateDict.subrs !== 0) {
        var subrOffset = privateDictOffset + privateDict.subrs;
        var subrIndex = parseCFFIndex(data, subrOffset);
        font.subrs = subrIndex.objects;
        font.subrsBias = calcCFFSubroutineBias(font.subrs);
    } else {
        font.subrs = [];
        font.subrsBias = 0;
    }

    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
    var charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.objects.length;

    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
    if (topDict.encoding === 0) { // Standard encoding
        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);
    } else if (topDict.encoding === 1) { // Expert encoding
        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);
    } else {
        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
    }

    // Prefer the CMAP encoding to the CFF encoding.
    font.encoding = font.encoding || font.cffEncoding;

    font.glyphs = new glyphset.GlyphSet(font);
    for (var i = 0; i < font.nGlyphs; i += 1) {
        var charString = charStringsIndex.objects[i];
        font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
    }
}

// Convert a string to a String ID (SID).
// The list of strings is modified in place.
function encodeString(s, strings) {
    var sid;

    // Is the string in the CFF standard strings?
    var i = cffStandardStrings.indexOf(s);
    if (i >= 0) {
        sid = i;
    }

    // Is the string already in the string index?
    i = strings.indexOf(s);
    if (i >= 0) {
        sid = i + cffStandardStrings.length;
    } else {
        sid = cffStandardStrings.length + strings.length;
        strings.push(s);
    }

    return sid;
}

function makeHeader() {
    return new table.Record('Header', [
        {name: 'major', type: 'Card8', value: 1},
        {name: 'minor', type: 'Card8', value: 0},
        {name: 'hdrSize', type: 'Card8', value: 4},
        {name: 'major', type: 'Card8', value: 1}
    ]);
}

function makeNameIndex(fontNames) {
    var t = new table.Record('Name INDEX', [
        {name: 'names', type: 'INDEX', value: []}
    ]);
    t.names = [];
    for (var i = 0; i < fontNames.length; i += 1) {
        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});
    }

    return t;
}

// Given a dictionary's metadata, create a DICT structure.
function makeDict(meta, attrs, strings) {
    var m = {};
    for (var i = 0; i < meta.length; i += 1) {
        var entry = meta[i];
        var value = attrs[entry.name];
        if (value !== undefined && !equals$1(value, entry.value)) {
            if (entry.type === 'SID') {
                value = encodeString(value, strings);
            }

            m[entry.op] = {name: entry.name, type: entry.type, value: value};
        }
    }

    return m;
}

// The Top DICT houses the global font attributes.
function makeTopDict(attrs, strings) {
    var t = new table.Record('Top DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(TOP_DICT_META, attrs, strings);
    return t;
}

function makeTopDictIndex(topDict) {
    var t = new table.Record('Top DICT INDEX', [
        {name: 'topDicts', type: 'INDEX', value: []}
    ]);
    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];
    return t;
}

function makeStringIndex(strings) {
    var t = new table.Record('String INDEX', [
        {name: 'strings', type: 'INDEX', value: []}
    ]);
    t.strings = [];
    for (var i = 0; i < strings.length; i += 1) {
        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});
    }

    return t;
}

function makeGlobalSubrIndex() {
    // Currently we don't use subroutines.
    return new table.Record('Global Subr INDEX', [
        {name: 'subrs', type: 'INDEX', value: []}
    ]);
}

function makeCharsets(glyphNames, strings) {
    var t = new table.Record('Charsets', [
        {name: 'format', type: 'Card8', value: 0}
    ]);
    for (var i = 0; i < glyphNames.length; i += 1) {
        var glyphName = glyphNames[i];
        var glyphSID = encodeString(glyphName, strings);
        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});
    }

    return t;
}

function glyphToOps(glyph) {
    var ops = [];
    var path = glyph.path;
    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});
    var x = 0;
    var y = 0;
    for (var i = 0; i < path.commands.length; i += 1) {
        var dx = (void 0);
        var dy = (void 0);
        var cmd = path.commands[i];
        if (cmd.type === 'Q') {
            // CFF only supports bzier curves, so convert the quad to a bzier.
            var _13 = 1 / 3;
            var _23 = 2 / 3;

            // We're going to create a new command so we don't change the original path.
            cmd = {
                type: 'C',
                x: cmd.x,
                y: cmd.y,
                x1: _13 * x + _23 * cmd.x1,
                y1: _13 * y + _23 * cmd.y1,
                x2: _13 * cmd.x + _23 * cmd.x1,
                y2: _13 * cmd.y + _23 * cmd.y1
            };
        }

        if (cmd.type === 'M') {
            dx = Math.round(cmd.x - x);
            dy = Math.round(cmd.y - y);
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rmoveto', type: 'OP', value: 21});
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        } else if (cmd.type === 'L') {
            dx = Math.round(cmd.x - x);
            dy = Math.round(cmd.y - y);
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rlineto', type: 'OP', value: 5});
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        } else if (cmd.type === 'C') {
            var dx1 = Math.round(cmd.x1 - x);
            var dy1 = Math.round(cmd.y1 - y);
            var dx2 = Math.round(cmd.x2 - cmd.x1);
            var dy2 = Math.round(cmd.y2 - cmd.y1);
            dx = Math.round(cmd.x - cmd.x2);
            dy = Math.round(cmd.y - cmd.y2);
            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});
            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});
            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});
            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rrcurveto', type: 'OP', value: 8});
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        }

        // Contours are closed automatically.
    }

    ops.push({name: 'endchar', type: 'OP', value: 14});
    return ops;
}

function makeCharStringsIndex(glyphs) {
    var t = new table.Record('CharStrings INDEX', [
        {name: 'charStrings', type: 'INDEX', value: []}
    ]);

    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        var ops = glyphToOps(glyph);
        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});
    }

    return t;
}

function makePrivateDict(attrs, strings) {
    var t = new table.Record('Private DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
    return t;
}

function makeCFFTable(glyphs, options) {
    var t = new table.Table('CFF ', [
        {name: 'header', type: 'RECORD'},
        {name: 'nameIndex', type: 'RECORD'},
        {name: 'topDictIndex', type: 'RECORD'},
        {name: 'stringIndex', type: 'RECORD'},
        {name: 'globalSubrIndex', type: 'RECORD'},
        {name: 'charsets', type: 'RECORD'},
        {name: 'charStringsIndex', type: 'RECORD'},
        {name: 'privateDict', type: 'RECORD'}
    ]);

    var fontScale = 1 / options.unitsPerEm;
    // We use non-zero values for the offsets so that the DICT encodes them.
    // This is important because the size of the Top DICT plays a role in offset calculation,
    // and the size shouldn't change after we've written correct offsets.
    var attrs = {
        version: options.version,
        fullName: options.fullName,
        familyName: options.familyName,
        weight: options.weightName,
        fontBBox: options.fontBBox || [0, 0, 0, 0],
        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
        charset: 999,
        encoding: 0,
        charStrings: 999,
        private: [0, 999]
    };

    var privateAttrs = {};

    var glyphNames = [];
    var glyph;

    // Skip first glyph (.notdef)
    for (var i = 1; i < glyphs.length; i += 1) {
        glyph = glyphs.get(i);
        glyphNames.push(glyph.name);
    }

    var strings = [];

    t.header = makeHeader();
    t.nameIndex = makeNameIndex([options.postScriptName]);
    var topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);
    t.globalSubrIndex = makeGlobalSubrIndex();
    t.charsets = makeCharsets(glyphNames, strings);
    t.charStringsIndex = makeCharStringsIndex(glyphs);
    t.privateDict = makePrivateDict(privateAttrs, strings);

    // Needs to come at the end, to encode all custom strings used in the font.
    t.stringIndex = makeStringIndex(strings);

    var startOffset = t.header.sizeOf() +
        t.nameIndex.sizeOf() +
        t.topDictIndex.sizeOf() +
        t.stringIndex.sizeOf() +
        t.globalSubrIndex.sizeOf();
    attrs.charset = startOffset;

    // We use the CFF standard encoding; proper encoding will be handled in cmap.
    attrs.encoding = 0;
    attrs.charStrings = attrs.charset + t.charsets.sizeOf();
    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();

    // Recreate the Top DICT INDEX with the correct offsets.
    topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);

    return t;
}

var cff = { parse: parseCFFTable, make: makeCFFTable };

// The `head` table contains global information about the font.
// https://www.microsoft.com/typography/OTSPEC/head.htm

function parseHeadTable(data, start) {
    var head = {};
    var p = new parse$1.Parser(data, start);
    head.version = p.parseVersion();
    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
    head.checkSumAdjustment = p.parseULong();
    head.magicNumber = p.parseULong();
    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
    head.flags = p.parseUShort();
    head.unitsPerEm = p.parseUShort();
    head.created = p.parseLongDateTime();
    head.modified = p.parseLongDateTime();
    head.xMin = p.parseShort();
    head.yMin = p.parseShort();
    head.xMax = p.parseShort();
    head.yMax = p.parseShort();
    head.macStyle = p.parseUShort();
    head.lowestRecPPEM = p.parseUShort();
    head.fontDirectionHint = p.parseShort();
    head.indexToLocFormat = p.parseShort();
    head.glyphDataFormat = p.parseShort();
    return head;
}

function makeHeadTable(options) {
    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970
    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;
    var createdTimestamp = timestamp;

    if (options.createdTimestamp) {
        createdTimestamp = options.createdTimestamp + 2082844800;
    }

    return new table.Table('head', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},
        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},
        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},
        {name: 'flags', type: 'USHORT', value: 0},
        {name: 'unitsPerEm', type: 'USHORT', value: 1000},
        {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},
        {name: 'modified', type: 'LONGDATETIME', value: timestamp},
        {name: 'xMin', type: 'SHORT', value: 0},
        {name: 'yMin', type: 'SHORT', value: 0},
        {name: 'xMax', type: 'SHORT', value: 0},
        {name: 'yMax', type: 'SHORT', value: 0},
        {name: 'macStyle', type: 'USHORT', value: 0},
        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},
        {name: 'fontDirectionHint', type: 'SHORT', value: 2},
        {name: 'indexToLocFormat', type: 'SHORT', value: 0},
        {name: 'glyphDataFormat', type: 'SHORT', value: 0}
    ], options);
}

var head = { parse: parseHeadTable, make: makeHeadTable };

// The `hhea` table contains information for horizontal layout.
// https://www.microsoft.com/typography/OTSPEC/hhea.htm

function parseHheaTable(data, start) {
    var hhea = {};
    var p = new parse$1.Parser(data, start);
    hhea.version = p.parseVersion();
    hhea.ascender = p.parseShort();
    hhea.descender = p.parseShort();
    hhea.lineGap = p.parseShort();
    hhea.advanceWidthMax = p.parseUShort();
    hhea.minLeftSideBearing = p.parseShort();
    hhea.minRightSideBearing = p.parseShort();
    hhea.xMaxExtent = p.parseShort();
    hhea.caretSlopeRise = p.parseShort();
    hhea.caretSlopeRun = p.parseShort();
    hhea.caretOffset = p.parseShort();
    p.relativeOffset += 8;
    hhea.metricDataFormat = p.parseShort();
    hhea.numberOfHMetrics = p.parseUShort();
    return hhea;
}

function makeHheaTable(options) {
    return new table.Table('hhea', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'ascender', type: 'FWORD', value: 0},
        {name: 'descender', type: 'FWORD', value: 0},
        {name: 'lineGap', type: 'FWORD', value: 0},
        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},
        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},
        {name: 'minRightSideBearing', type: 'FWORD', value: 0},
        {name: 'xMaxExtent', type: 'FWORD', value: 0},
        {name: 'caretSlopeRise', type: 'SHORT', value: 1},
        {name: 'caretSlopeRun', type: 'SHORT', value: 0},
        {name: 'caretOffset', type: 'SHORT', value: 0},
        {name: 'reserved1', type: 'SHORT', value: 0},
        {name: 'reserved2', type: 'SHORT', value: 0},
        {name: 'reserved3', type: 'SHORT', value: 0},
        {name: 'reserved4', type: 'SHORT', value: 0},
        {name: 'metricDataFormat', type: 'SHORT', value: 0},
        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}
    ], options);
}

var hhea = { parse: parseHheaTable, make: makeHheaTable };

// The `hmtx` table contains the horizontal metrics for all glyphs.
// https://www.microsoft.com/typography/OTSPEC/hmtx.htm

function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {
    var advanceWidth;
    var leftSideBearing;
    var p = new parse$1.Parser(data, start);
    for (var i = 0; i < numGlyphs; i += 1) {
        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
        if (i < numMetrics) {
            advanceWidth = p.parseUShort();
            leftSideBearing = p.parseShort();
        }

        var glyph = glyphs.get(i);
        glyph.advanceWidth = advanceWidth;
        glyph.leftSideBearing = leftSideBearing;
    }
}

function makeHmtxTable(glyphs) {
    var t = new table.Table('hmtx', []);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        var advanceWidth = glyph.advanceWidth || 0;
        var leftSideBearing = glyph.leftSideBearing || 0;
        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});
        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});
    }

    return t;
}

var hmtx = { parse: parseHmtxTable, make: makeHmtxTable };

// The `ltag` table stores IETF BCP-47 language tags. It allows supporting
// languages for which TrueType does not assign a numeric code.
// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6ltag.html
// http://www.w3.org/International/articles/language-tags/
// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry

function makeLtagTable(tags) {
    var result = new table.Table('ltag', [
        {name: 'version', type: 'ULONG', value: 1},
        {name: 'flags', type: 'ULONG', value: 0},
        {name: 'numTags', type: 'ULONG', value: tags.length}
    ]);

    var stringPool = '';
    var stringPoolOffset = 12 + tags.length * 4;
    for (var i = 0; i < tags.length; ++i) {
        var pos = stringPool.indexOf(tags[i]);
        if (pos < 0) {
            pos = stringPool.length;
            stringPool += tags[i];
        }

        result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});
        result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});
    }

    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});
    return result;
}

function parseLtagTable(data, start) {
    var p = new parse$1.Parser(data, start);
    var tableVersion = p.parseULong();
    check.argument(tableVersion === 1, 'Unsupported ltag table version.');
    // The 'ltag' specification does not define any flags; skip the field.
    p.skip('uLong', 1);
    var numTags = p.parseULong();

    var tags = [];
    for (var i = 0; i < numTags; i++) {
        var tag = '';
        var offset = start + p.parseUShort();
        var length = p.parseUShort();
        for (var j = offset; j < offset + length; ++j) {
            tag += String.fromCharCode(data.getInt8(j));
        }

        tags.push(tag);
    }

    return tags;
}

var ltag = { make: makeLtagTable, parse: parseLtagTable };

// The `maxp` table establishes the memory requirements for the font.
// We need it just to get the number of glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/maxp.htm

function parseMaxpTable(data, start) {
    var maxp = {};
    var p = new parse$1.Parser(data, start);
    maxp.version = p.parseVersion();
    maxp.numGlyphs = p.parseUShort();
    if (maxp.version === 1.0) {
        maxp.maxPoints = p.parseUShort();
        maxp.maxContours = p.parseUShort();
        maxp.maxCompositePoints = p.parseUShort();
        maxp.maxCompositeContours = p.parseUShort();
        maxp.maxZones = p.parseUShort();
        maxp.maxTwilightPoints = p.parseUShort();
        maxp.maxStorage = p.parseUShort();
        maxp.maxFunctionDefs = p.parseUShort();
        maxp.maxInstructionDefs = p.parseUShort();
        maxp.maxStackElements = p.parseUShort();
        maxp.maxSizeOfInstructions = p.parseUShort();
        maxp.maxComponentElements = p.parseUShort();
        maxp.maxComponentDepth = p.parseUShort();
    }

    return maxp;
}

function makeMaxpTable(numGlyphs) {
    return new table.Table('maxp', [
        {name: 'version', type: 'FIXED', value: 0x00005000},
        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}
    ]);
}

var maxp = { parse: parseMaxpTable, make: makeMaxpTable };

// The `name` naming table.
// https://www.microsoft.com/typography/OTSPEC/name.htm

var nameTableNames = [
    'copyright',              // 0
    'fontFamily',             // 1
    'fontSubfamily',          // 2
    'uniqueID',               // 3
    'fullName',               // 4
    'version',                // 5
    'postScriptName',         // 6
    'trademark',              // 7
    'manufacturer',           // 8
    'designer',               // 9
    'description',            // 10
    'manufacturerURL',        // 11
    'designerURL',            // 12
    'license',                // 13
    'licenseURL',             // 14
    'reserved',               // 15
    'preferredFamily',        // 16
    'preferredSubfamily',     // 17
    'compatibleFullName',     // 18
    'sampleText',             // 19
    'postScriptFindFontName', // 20
    'wwsFamily',              // 21
    'wwsSubfamily'            // 22
];

var macLanguages = {
    0: 'en',
    1: 'fr',
    2: 'de',
    3: 'it',
    4: 'nl',
    5: 'sv',
    6: 'es',
    7: 'da',
    8: 'pt',
    9: 'no',
    10: 'he',
    11: 'ja',
    12: 'ar',
    13: 'fi',
    14: 'el',
    15: 'is',
    16: 'mt',
    17: 'tr',
    18: 'hr',
    19: 'zh-Hant',
    20: 'ur',
    21: 'hi',
    22: 'th',
    23: 'ko',
    24: 'lt',
    25: 'pl',
    26: 'hu',
    27: 'es',
    28: 'lv',
    29: 'se',
    30: 'fo',
    31: 'fa',
    32: 'ru',
    33: 'zh',
    34: 'nl-BE',
    35: 'ga',
    36: 'sq',
    37: 'ro',
    38: 'cz',
    39: 'sk',
    40: 'si',
    41: 'yi',
    42: 'sr',
    43: 'mk',
    44: 'bg',
    45: 'uk',
    46: 'be',
    47: 'uz',
    48: 'kk',
    49: 'az-Cyrl',
    50: 'az-Arab',
    51: 'hy',
    52: 'ka',
    53: 'mo',
    54: 'ky',
    55: 'tg',
    56: 'tk',
    57: 'mn-CN',
    58: 'mn',
    59: 'ps',
    60: 'ks',
    61: 'ku',
    62: 'sd',
    63: 'bo',
    64: 'ne',
    65: 'sa',
    66: 'mr',
    67: 'bn',
    68: 'as',
    69: 'gu',
    70: 'pa',
    71: 'or',
    72: 'ml',
    73: 'kn',
    74: 'ta',
    75: 'te',
    76: 'si',
    77: 'my',
    78: 'km',
    79: 'lo',
    80: 'vi',
    81: 'id',
    82: 'tl',
    83: 'ms',
    84: 'ms-Arab',
    85: 'am',
    86: 'ti',
    87: 'om',
    88: 'so',
    89: 'sw',
    90: 'rw',
    91: 'rn',
    92: 'ny',
    93: 'mg',
    94: 'eo',
    128: 'cy',
    129: 'eu',
    130: 'ca',
    131: 'la',
    132: 'qu',
    133: 'gn',
    134: 'ay',
    135: 'tt',
    136: 'ug',
    137: 'dz',
    138: 'jv',
    139: 'su',
    140: 'gl',
    141: 'af',
    142: 'br',
    143: 'iu',
    144: 'gd',
    145: 'gv',
    146: 'ga',
    147: 'to',
    148: 'el-polyton',
    149: 'kl',
    150: 'az',
    151: 'nn'
};

// MacOS language ID  MacOS script ID
//
// Note that the script ID is not sufficient to determine what encoding
// to use in TrueType files. For some languages, MacOS used a modification
// of a mainstream script. For example, an Icelandic name would be stored
// with smRoman in the TrueType naming table, but the actual encoding
// is a special Icelandic version of the normal Macintosh Roman encoding.
// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal
// Syllables but MacOS had run out of available script codes, so this was
// done as a (pretty radical) "modification" of Ethiopic.
//
// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
var macLanguageToScript = {
    0: 0,  // langEnglish  smRoman
    1: 0,  // langFrench  smRoman
    2: 0,  // langGerman  smRoman
    3: 0,  // langItalian  smRoman
    4: 0,  // langDutch  smRoman
    5: 0,  // langSwedish  smRoman
    6: 0,  // langSpanish  smRoman
    7: 0,  // langDanish  smRoman
    8: 0,  // langPortuguese  smRoman
    9: 0,  // langNorwegian  smRoman
    10: 5,  // langHebrew  smHebrew
    11: 1,  // langJapanese  smJapanese
    12: 4,  // langArabic  smArabic
    13: 0,  // langFinnish  smRoman
    14: 6,  // langGreek  smGreek
    15: 0,  // langIcelandic  smRoman (modified)
    16: 0,  // langMaltese  smRoman
    17: 0,  // langTurkish  smRoman (modified)
    18: 0,  // langCroatian  smRoman (modified)
    19: 2,  // langTradChinese  smTradChinese
    20: 4,  // langUrdu  smArabic
    21: 9,  // langHindi  smDevanagari
    22: 21,  // langThai  smThai
    23: 3,  // langKorean  smKorean
    24: 29,  // langLithuanian  smCentralEuroRoman
    25: 29,  // langPolish  smCentralEuroRoman
    26: 29,  // langHungarian  smCentralEuroRoman
    27: 29,  // langEstonian  smCentralEuroRoman
    28: 29,  // langLatvian  smCentralEuroRoman
    29: 0,  // langSami  smRoman
    30: 0,  // langFaroese  smRoman (modified)
    31: 4,  // langFarsi  smArabic (modified)
    32: 7,  // langRussian  smCyrillic
    33: 25,  // langSimpChinese  smSimpChinese
    34: 0,  // langFlemish  smRoman
    35: 0,  // langIrishGaelic  smRoman (modified)
    36: 0,  // langAlbanian  smRoman
    37: 0,  // langRomanian  smRoman (modified)
    38: 29,  // langCzech  smCentralEuroRoman
    39: 29,  // langSlovak  smCentralEuroRoman
    40: 0,  // langSlovenian  smRoman (modified)
    41: 5,  // langYiddish  smHebrew
    42: 7,  // langSerbian  smCyrillic
    43: 7,  // langMacedonian  smCyrillic
    44: 7,  // langBulgarian  smCyrillic
    45: 7,  // langUkrainian  smCyrillic (modified)
    46: 7,  // langByelorussian  smCyrillic
    47: 7,  // langUzbek  smCyrillic
    48: 7,  // langKazakh  smCyrillic
    49: 7,  // langAzerbaijani  smCyrillic
    50: 4,  // langAzerbaijanAr  smArabic
    51: 24,  // langArmenian  smArmenian
    52: 23,  // langGeorgian  smGeorgian
    53: 7,  // langMoldavian  smCyrillic
    54: 7,  // langKirghiz  smCyrillic
    55: 7,  // langTajiki  smCyrillic
    56: 7,  // langTurkmen  smCyrillic
    57: 27,  // langMongolian  smMongolian
    58: 7,  // langMongolianCyr  smCyrillic
    59: 4,  // langPashto  smArabic
    60: 4,  // langKurdish  smArabic
    61: 4,  // langKashmiri  smArabic
    62: 4,  // langSindhi  smArabic
    63: 26,  // langTibetan  smTibetan
    64: 9,  // langNepali  smDevanagari
    65: 9,  // langSanskrit  smDevanagari
    66: 9,  // langMarathi  smDevanagari
    67: 13,  // langBengali  smBengali
    68: 13,  // langAssamese  smBengali
    69: 11,  // langGujarati  smGujarati
    70: 10,  // langPunjabi  smGurmukhi
    71: 12,  // langOriya  smOriya
    72: 17,  // langMalayalam  smMalayalam
    73: 16,  // langKannada  smKannada
    74: 14,  // langTamil  smTamil
    75: 15,  // langTelugu  smTelugu
    76: 18,  // langSinhalese  smSinhalese
    77: 19,  // langBurmese  smBurmese
    78: 20,  // langKhmer  smKhmer
    79: 22,  // langLao  smLao
    80: 30,  // langVietnamese  smVietnamese
    81: 0,  // langIndonesian  smRoman
    82: 0,  // langTagalog  smRoman
    83: 0,  // langMalayRoman  smRoman
    84: 4,  // langMalayArabic  smArabic
    85: 28,  // langAmharic  smEthiopic
    86: 28,  // langTigrinya  smEthiopic
    87: 28,  // langOromo  smEthiopic
    88: 0,  // langSomali  smRoman
    89: 0,  // langSwahili  smRoman
    90: 0,  // langKinyarwanda  smRoman
    91: 0,  // langRundi  smRoman
    92: 0,  // langNyanja  smRoman
    93: 0,  // langMalagasy  smRoman
    94: 0,  // langEsperanto  smRoman
    128: 0,  // langWelsh  smRoman (modified)
    129: 0,  // langBasque  smRoman
    130: 0,  // langCatalan  smRoman
    131: 0,  // langLatin  smRoman
    132: 0,  // langQuechua  smRoman
    133: 0,  // langGuarani  smRoman
    134: 0,  // langAymara  smRoman
    135: 7,  // langTatar  smCyrillic
    136: 4,  // langUighur  smArabic
    137: 26,  // langDzongkha  smTibetan
    138: 0,  // langJavaneseRom  smRoman
    139: 0,  // langSundaneseRom  smRoman
    140: 0,  // langGalician  smRoman
    141: 0,  // langAfrikaans  smRoman
    142: 0,  // langBreton  smRoman (modified)
    143: 28,  // langInuktitut  smEthiopic (modified)
    144: 0,  // langScottishGaelic  smRoman (modified)
    145: 0,  // langManxGaelic  smRoman (modified)
    146: 0,  // langIrishGaelicScript  smRoman (modified)
    147: 0,  // langTongan  smRoman
    148: 6,  // langGreekAncient  smRoman
    149: 0,  // langGreenlandic  smRoman
    150: 0,  // langAzerbaijanRoman  smRoman
    151: 0   // langNynorsk  smRoman
};

// While Microsoft indicates a region/country for all its language
// IDs, we omit the region code if it's equal to the "most likely
// region subtag" according to Unicode CLDR. For scripts, we omit
// the subtag if it is equal to the Suppress-Script entry in the
// IANA language subtag registry for IETF BCP 47.
//
// For example, Microsoft states that its language code 0x041A is
// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'
// and not 'hr-HR' because Croatia is the default country for Croatian,
// according to Unicode CLDR. As another example, Microsoft states
// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform
// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script
// for the Croatian language, according to IANA.
//
// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html
// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
var windowsLanguages = {
    0x0436: 'af',
    0x041C: 'sq',
    0x0484: 'gsw',
    0x045E: 'am',
    0x1401: 'ar-DZ',
    0x3C01: 'ar-BH',
    0x0C01: 'ar',
    0x0801: 'ar-IQ',
    0x2C01: 'ar-JO',
    0x3401: 'ar-KW',
    0x3001: 'ar-LB',
    0x1001: 'ar-LY',
    0x1801: 'ary',
    0x2001: 'ar-OM',
    0x4001: 'ar-QA',
    0x0401: 'ar-SA',
    0x2801: 'ar-SY',
    0x1C01: 'aeb',
    0x3801: 'ar-AE',
    0x2401: 'ar-YE',
    0x042B: 'hy',
    0x044D: 'as',
    0x082C: 'az-Cyrl',
    0x042C: 'az',
    0x046D: 'ba',
    0x042D: 'eu',
    0x0423: 'be',
    0x0845: 'bn',
    0x0445: 'bn-IN',
    0x201A: 'bs-Cyrl',
    0x141A: 'bs',
    0x047E: 'br',
    0x0402: 'bg',
    0x0403: 'ca',
    0x0C04: 'zh-HK',
    0x1404: 'zh-MO',
    0x0804: 'zh',
    0x1004: 'zh-SG',
    0x0404: 'zh-TW',
    0x0483: 'co',
    0x041A: 'hr',
    0x101A: 'hr-BA',
    0x0405: 'cs',
    0x0406: 'da',
    0x048C: 'prs',
    0x0465: 'dv',
    0x0813: 'nl-BE',
    0x0413: 'nl',
    0x0C09: 'en-AU',
    0x2809: 'en-BZ',
    0x1009: 'en-CA',
    0x2409: 'en-029',
    0x4009: 'en-IN',
    0x1809: 'en-IE',
    0x2009: 'en-JM',
    0x4409: 'en-MY',
    0x1409: 'en-NZ',
    0x3409: 'en-PH',
    0x4809: 'en-SG',
    0x1C09: 'en-ZA',
    0x2C09: 'en-TT',
    0x0809: 'en-GB',
    0x0409: 'en',
    0x3009: 'en-ZW',
    0x0425: 'et',
    0x0438: 'fo',
    0x0464: 'fil',
    0x040B: 'fi',
    0x080C: 'fr-BE',
    0x0C0C: 'fr-CA',
    0x040C: 'fr',
    0x140C: 'fr-LU',
    0x180C: 'fr-MC',
    0x100C: 'fr-CH',
    0x0462: 'fy',
    0x0456: 'gl',
    0x0437: 'ka',
    0x0C07: 'de-AT',
    0x0407: 'de',
    0x1407: 'de-LI',
    0x1007: 'de-LU',
    0x0807: 'de-CH',
    0x0408: 'el',
    0x046F: 'kl',
    0x0447: 'gu',
    0x0468: 'ha',
    0x040D: 'he',
    0x0439: 'hi',
    0x040E: 'hu',
    0x040F: 'is',
    0x0470: 'ig',
    0x0421: 'id',
    0x045D: 'iu',
    0x085D: 'iu-Latn',
    0x083C: 'ga',
    0x0434: 'xh',
    0x0435: 'zu',
    0x0410: 'it',
    0x0810: 'it-CH',
    0x0411: 'ja',
    0x044B: 'kn',
    0x043F: 'kk',
    0x0453: 'km',
    0x0486: 'quc',
    0x0487: 'rw',
    0x0441: 'sw',
    0x0457: 'kok',
    0x0412: 'ko',
    0x0440: 'ky',
    0x0454: 'lo',
    0x0426: 'lv',
    0x0427: 'lt',
    0x082E: 'dsb',
    0x046E: 'lb',
    0x042F: 'mk',
    0x083E: 'ms-BN',
    0x043E: 'ms',
    0x044C: 'ml',
    0x043A: 'mt',
    0x0481: 'mi',
    0x047A: 'arn',
    0x044E: 'mr',
    0x047C: 'moh',
    0x0450: 'mn',
    0x0850: 'mn-CN',
    0x0461: 'ne',
    0x0414: 'nb',
    0x0814: 'nn',
    0x0482: 'oc',
    0x0448: 'or',
    0x0463: 'ps',
    0x0415: 'pl',
    0x0416: 'pt',
    0x0816: 'pt-PT',
    0x0446: 'pa',
    0x046B: 'qu-BO',
    0x086B: 'qu-EC',
    0x0C6B: 'qu',
    0x0418: 'ro',
    0x0417: 'rm',
    0x0419: 'ru',
    0x243B: 'smn',
    0x103B: 'smj-NO',
    0x143B: 'smj',
    0x0C3B: 'se-FI',
    0x043B: 'se',
    0x083B: 'se-SE',
    0x203B: 'sms',
    0x183B: 'sma-NO',
    0x1C3B: 'sms',
    0x044F: 'sa',
    0x1C1A: 'sr-Cyrl-BA',
    0x0C1A: 'sr',
    0x181A: 'sr-Latn-BA',
    0x081A: 'sr-Latn',
    0x046C: 'nso',
    0x0432: 'tn',
    0x045B: 'si',
    0x041B: 'sk',
    0x0424: 'sl',
    0x2C0A: 'es-AR',
    0x400A: 'es-BO',
    0x340A: 'es-CL',
    0x240A: 'es-CO',
    0x140A: 'es-CR',
    0x1C0A: 'es-DO',
    0x300A: 'es-EC',
    0x440A: 'es-SV',
    0x100A: 'es-GT',
    0x480A: 'es-HN',
    0x080A: 'es-MX',
    0x4C0A: 'es-NI',
    0x180A: 'es-PA',
    0x3C0A: 'es-PY',
    0x280A: 'es-PE',
    0x500A: 'es-PR',

    // Microsoft has defined two different language codes for
    // Spanish with modern sorting and Spanish with traditional
    // sorting. This makes sense for collation APIs, and it would be
    // possible to express this in BCP 47 language tags via Unicode
    // extensions (eg., es-u-co-trad is Spanish with traditional
    // sorting). However, for storing names in fonts, the distinction
    // does not make sense, so we give es in both cases.
    0x0C0A: 'es',
    0x040A: 'es',

    0x540A: 'es-US',
    0x380A: 'es-UY',
    0x200A: 'es-VE',
    0x081D: 'sv-FI',
    0x041D: 'sv',
    0x045A: 'syr',
    0x0428: 'tg',
    0x085F: 'tzm',
    0x0449: 'ta',
    0x0444: 'tt',
    0x044A: 'te',
    0x041E: 'th',
    0x0451: 'bo',
    0x041F: 'tr',
    0x0442: 'tk',
    0x0480: 'ug',
    0x0422: 'uk',
    0x042E: 'hsb',
    0x0420: 'ur',
    0x0843: 'uz-Cyrl',
    0x0443: 'uz',
    0x042A: 'vi',
    0x0452: 'cy',
    0x0488: 'wo',
    0x0485: 'sah',
    0x0478: 'ii',
    0x046A: 'yo'
};

// Returns a IETF BCP 47 language code, for example 'zh-Hant'
// for 'Chinese in the traditional script'.
function getLanguageCode(platformID, languageID, ltag) {
    switch (platformID) {
        case 0:  // Unicode
            if (languageID === 0xFFFF) {
                return 'und';
            } else if (ltag) {
                return ltag[languageID];
            }

            break;

        case 1:  // Macintosh
            return macLanguages[languageID];

        case 3:  // Windows
            return windowsLanguages[languageID];
    }

    return undefined;
}

var utf16 = 'utf-16';

// MacOS script ID  encoding. This table stores the default case,
// which can be overridden by macLanguageEncodings.
var macScriptEncodings = {
    0: 'macintosh',           // smRoman
    1: 'x-mac-japanese',      // smJapanese
    2: 'x-mac-chinesetrad',   // smTradChinese
    3: 'x-mac-korean',        // smKorean
    6: 'x-mac-greek',         // smGreek
    7: 'x-mac-cyrillic',      // smCyrillic
    9: 'x-mac-devanagai',     // smDevanagari
    10: 'x-mac-gurmukhi',     // smGurmukhi
    11: 'x-mac-gujarati',     // smGujarati
    12: 'x-mac-oriya',        // smOriya
    13: 'x-mac-bengali',      // smBengali
    14: 'x-mac-tamil',        // smTamil
    15: 'x-mac-telugu',       // smTelugu
    16: 'x-mac-kannada',      // smKannada
    17: 'x-mac-malayalam',    // smMalayalam
    18: 'x-mac-sinhalese',    // smSinhalese
    19: 'x-mac-burmese',      // smBurmese
    20: 'x-mac-khmer',        // smKhmer
    21: 'x-mac-thai',         // smThai
    22: 'x-mac-lao',          // smLao
    23: 'x-mac-georgian',     // smGeorgian
    24: 'x-mac-armenian',     // smArmenian
    25: 'x-mac-chinesesimp',  // smSimpChinese
    26: 'x-mac-tibetan',      // smTibetan
    27: 'x-mac-mongolian',    // smMongolian
    28: 'x-mac-ethiopic',     // smEthiopic
    29: 'x-mac-ce',           // smCentralEuroRoman
    30: 'x-mac-vietnamese',   // smVietnamese
    31: 'x-mac-extarabic'     // smExtArabic
};

// MacOS language ID  encoding. This table stores the exceptional
// cases, which override macScriptEncodings. For writing MacOS naming
// tables, we need to emit a MacOS script ID. Therefore, we cannot
// merge macScriptEncodings into macLanguageEncodings.
//
// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
var macLanguageEncodings = {
    15: 'x-mac-icelandic',    // langIcelandic
    17: 'x-mac-turkish',      // langTurkish
    18: 'x-mac-croatian',     // langCroatian
    24: 'x-mac-ce',           // langLithuanian
    25: 'x-mac-ce',           // langPolish
    26: 'x-mac-ce',           // langHungarian
    27: 'x-mac-ce',           // langEstonian
    28: 'x-mac-ce',           // langLatvian
    30: 'x-mac-icelandic',    // langFaroese
    37: 'x-mac-romanian',     // langRomanian
    38: 'x-mac-ce',           // langCzech
    39: 'x-mac-ce',           // langSlovak
    40: 'x-mac-ce',           // langSlovenian
    143: 'x-mac-inuit',       // langInuktitut
    146: 'x-mac-gaelic'       // langIrishGaelicScript
};

function getEncoding(platformID, encodingID, languageID) {
    switch (platformID) {
        case 0:  // Unicode
            return utf16;

        case 1:  // Apple Macintosh
            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];

        case 3:  // Microsoft Windows
            if (encodingID === 1 || encodingID === 10) {
                return utf16;
            }

            break;
    }

    return undefined;
}

// Parse the naming `name` table.
// FIXME: Format 1 additional fields are not supported yet.
// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].
function parseNameTable(data, start, ltag) {
    var name = {};
    var p = new parse$1.Parser(data, start);
    var format = p.parseUShort();
    var count = p.parseUShort();
    var stringOffset = p.offset + p.parseUShort();
    for (var i = 0; i < count; i++) {
        var platformID = p.parseUShort();
        var encodingID = p.parseUShort();
        var languageID = p.parseUShort();
        var nameID = p.parseUShort();
        var property = nameTableNames[nameID] || nameID;
        var byteLength = p.parseUShort();
        var offset = p.parseUShort();
        var language = getLanguageCode(platformID, languageID, ltag);
        var encoding = getEncoding(platformID, encodingID, languageID);
        if (encoding !== undefined && language !== undefined) {
            var text = (void 0);
            if (encoding === utf16) {
                text = decode.UTF16(data, stringOffset + offset, byteLength);
            } else {
                text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);
            }

            if (text) {
                var translations = name[property];
                if (translations === undefined) {
                    translations = name[property] = {};
                }

                translations[language] = text;
            }
        }
    }

    var langTagCount = 0;
    if (format === 1) {
        // FIXME: Also handle Microsoft's 'name' table 1.
        langTagCount = p.parseUShort();
    }

    return name;
}

// {23: 'foo'}  {'foo': 23}
// ['bar', 'baz']  {'bar': 0, 'baz': 1}
function reverseDict(dict) {
    var result = {};
    for (var key in dict) {
        result[dict[key]] = parseInt(key);
    }

    return result;
}

function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
    return new table.Record('NameRecord', [
        {name: 'platformID', type: 'USHORT', value: platformID},
        {name: 'encodingID', type: 'USHORT', value: encodingID},
        {name: 'languageID', type: 'USHORT', value: languageID},
        {name: 'nameID', type: 'USHORT', value: nameID},
        {name: 'length', type: 'USHORT', value: length},
        {name: 'offset', type: 'USHORT', value: offset}
    ]);
}

// Finds the position of needle in haystack, or -1 if not there.
// Like String.indexOf(), but for arrays.
function findSubArray(needle, haystack) {
    var needleLength = needle.length;
    var limit = haystack.length - needleLength + 1;

    loop:
    for (var pos = 0; pos < limit; pos++) {
        for (; pos < limit; pos++) {
            for (var k = 0; k < needleLength; k++) {
                if (haystack[pos + k] !== needle[k]) {
                    continue loop;
                }
            }

            return pos;
        }
    }

    return -1;
}

function addStringToPool(s, pool) {
    var offset = findSubArray(s, pool);
    if (offset < 0) {
        offset = pool.length;
        var i = 0;
        var len = s.length;
        for (; i < len; ++i) {
            pool.push(s[i]);
        }

    }

    return offset;
}

function makeNameTable(names, ltag) {
    var nameID;
    var nameIDs = [];

    var namesWithNumericKeys = {};
    var nameTableIds = reverseDict(nameTableNames);
    for (var key in names) {
        var id = nameTableIds[key];
        if (id === undefined) {
            id = key;
        }

        nameID = parseInt(id);

        if (isNaN(nameID)) {
            throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
        }

        namesWithNumericKeys[nameID] = names[key];
        nameIDs.push(nameID);
    }

    var macLanguageIds = reverseDict(macLanguages);
    var windowsLanguageIds = reverseDict(windowsLanguages);

    var nameRecords = [];
    var stringPool = [];

    for (var i = 0; i < nameIDs.length; i++) {
        nameID = nameIDs[i];
        var translations = namesWithNumericKeys[nameID];
        for (var lang in translations) {
            var text = translations[lang];

            // For MacOS, we try to emit the name in the form that was introduced
            // in the initial version of the TrueType spec (in the late 1980s).
            // However, this can fail for various reasons: the requested BCP 47
            // language code might not have an old-style Mac equivalent;
            // we might not have a codec for the needed character encoding;
            // or the name might contain characters that cannot be expressed
            // in the old-style Macintosh encoding. In case of failure, we emit
            // the name in a more modern fashion (Unicode encoding with BCP 47
            // language tags) that is recognized by MacOS 10.5, released in 2009.
            // If fonts were only read by operating systems, we could simply
            // emit all names in the modern form; this would be much easier.
            // However, there are many applications and libraries that read
            // 'name' tables directly, and these will usually only recognize
            // the ancient form (silently skipping the unrecognized names).
            var macPlatform = 1;  // Macintosh
            var macLanguage = macLanguageIds[lang];
            var macScript = macLanguageToScript[macLanguage];
            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
            var macName = encode.MACSTRING(text, macEncoding);
            if (macName === undefined) {
                macPlatform = 0;  // Unicode
                macLanguage = ltag.indexOf(lang);
                if (macLanguage < 0) {
                    macLanguage = ltag.length;
                    ltag.push(lang);
                }

                macScript = 4;  // Unicode 2.0 and later
                macName = encode.UTF16(text);
            }

            var macNameOffset = addStringToPool(macName, stringPool);
            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,
                                            nameID, macName.length, macNameOffset));

            var winLanguage = windowsLanguageIds[lang];
            if (winLanguage !== undefined) {
                var winName = encode.UTF16(text);
                var winNameOffset = addStringToPool(winName, stringPool);
                nameRecords.push(makeNameRecord(3, 1, winLanguage,
                                                nameID, winName.length, winNameOffset));
            }
        }
    }

    nameRecords.sort(function(a, b) {
        return ((a.platformID - b.platformID) ||
                (a.encodingID - b.encodingID) ||
                (a.languageID - b.languageID) ||
                (a.nameID - b.nameID));
    });

    var t = new table.Table('name', [
        {name: 'format', type: 'USHORT', value: 0},
        {name: 'count', type: 'USHORT', value: nameRecords.length},
        {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}
    ]);

    for (var r = 0; r < nameRecords.length; r++) {
        t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});
    }

    t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});
    return t;
}

var _name = { parse: parseNameTable, make: makeNameTable };

// The `OS/2` table contains metrics required in OpenType fonts.
// https://www.microsoft.com/typography/OTSPEC/os2.htm

var unicodeRanges = [
    {begin: 0x0000, end: 0x007F}, // Basic Latin
    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement
    {begin: 0x0100, end: 0x017F}, // Latin Extended-A
    {begin: 0x0180, end: 0x024F}, // Latin Extended-B
    {begin: 0x0250, end: 0x02AF}, // IPA Extensions
    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters
    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks
    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic
    {begin: 0x2C80, end: 0x2CFF}, // Coptic
    {begin: 0x0400, end: 0x04FF}, // Cyrillic
    {begin: 0x0530, end: 0x058F}, // Armenian
    {begin: 0x0590, end: 0x05FF}, // Hebrew
    {begin: 0xA500, end: 0xA63F}, // Vai
    {begin: 0x0600, end: 0x06FF}, // Arabic
    {begin: 0x07C0, end: 0x07FF}, // NKo
    {begin: 0x0900, end: 0x097F}, // Devanagari
    {begin: 0x0980, end: 0x09FF}, // Bengali
    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi
    {begin: 0x0A80, end: 0x0AFF}, // Gujarati
    {begin: 0x0B00, end: 0x0B7F}, // Oriya
    {begin: 0x0B80, end: 0x0BFF}, // Tamil
    {begin: 0x0C00, end: 0x0C7F}, // Telugu
    {begin: 0x0C80, end: 0x0CFF}, // Kannada
    {begin: 0x0D00, end: 0x0D7F}, // Malayalam
    {begin: 0x0E00, end: 0x0E7F}, // Thai
    {begin: 0x0E80, end: 0x0EFF}, // Lao
    {begin: 0x10A0, end: 0x10FF}, // Georgian
    {begin: 0x1B00, end: 0x1B7F}, // Balinese
    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo
    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional
    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended
    {begin: 0x2000, end: 0x206F}, // General Punctuation
    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts
    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol
    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols
    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols
    {begin: 0x2150, end: 0x218F}, // Number Forms
    {begin: 0x2190, end: 0x21FF}, // Arrows
    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators
    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical
    {begin: 0x2400, end: 0x243F}, // Control Pictures
    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition
    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics
    {begin: 0x2500, end: 0x257F}, // Box Drawing
    {begin: 0x2580, end: 0x259F}, // Block Elements
    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes
    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols
    {begin: 0x2700, end: 0x27BF}, // Dingbats
    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation
    {begin: 0x3040, end: 0x309F}, // Hiragana
    {begin: 0x30A0, end: 0x30FF}, // Katakana
    {begin: 0x3100, end: 0x312F}, // Bopomofo
    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo
    {begin: 0xA840, end: 0xA87F}, // Phags-pa
    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months
    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility
    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables
    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *
    {begin: 0x10900, end: 0x1091F}, // Phoenicia
    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs
    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)
    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes
    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms
    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A
    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks
    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms
    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants
    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B
    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms
    {begin: 0xFFF0, end: 0xFFFF}, // Specials
    {begin: 0x0F00, end: 0x0FFF}, // Tibetan
    {begin: 0x0700, end: 0x074F}, // Syriac
    {begin: 0x0780, end: 0x07BF}, // Thaana
    {begin: 0x0D80, end: 0x0DFF}, // Sinhala
    {begin: 0x1000, end: 0x109F}, // Myanmar
    {begin: 0x1200, end: 0x137F}, // Ethiopic
    {begin: 0x13A0, end: 0x13FF}, // Cherokee
    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics
    {begin: 0x1680, end: 0x169F}, // Ogham
    {begin: 0x16A0, end: 0x16FF}, // Runic
    {begin: 0x1780, end: 0x17FF}, // Khmer
    {begin: 0x1800, end: 0x18AF}, // Mongolian
    {begin: 0x2800, end: 0x28FF}, // Braille Patterns
    {begin: 0xA000, end: 0xA48F}, // Yi Syllables
    {begin: 0x1700, end: 0x171F}, // Tagalog
    {begin: 0x10300, end: 0x1032F}, // Old Italic
    {begin: 0x10330, end: 0x1034F}, // Gothic
    {begin: 0x10400, end: 0x1044F}, // Deseret
    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols
    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols
    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)
    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors
    {begin: 0xE0000, end: 0xE007F}, // Tags
    {begin: 0x1900, end: 0x194F}, // Limbu
    {begin: 0x1950, end: 0x197F}, // Tai Le
    {begin: 0x1980, end: 0x19DF}, // New Tai Lue
    {begin: 0x1A00, end: 0x1A1F}, // Buginese
    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic
    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh
    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols
    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri
    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary
    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers
    {begin: 0x10380, end: 0x1039F}, // Ugaritic
    {begin: 0x103A0, end: 0x103DF}, // Old Persian
    {begin: 0x10450, end: 0x1047F}, // Shavian
    {begin: 0x10480, end: 0x104AF}, // Osmanya
    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary
    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi
    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols
    {begin: 0x12000, end: 0x123FF}, // Cuneiform
    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals
    {begin: 0x1B80, end: 0x1BBF}, // Sundanese
    {begin: 0x1C00, end: 0x1C4F}, // Lepcha
    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki
    {begin: 0xA880, end: 0xA8DF}, // Saurashtra
    {begin: 0xA900, end: 0xA92F}, // Kayah Li
    {begin: 0xA930, end: 0xA95F}, // Rejang
    {begin: 0xAA00, end: 0xAA5F}, // Cham
    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols
    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc
    {begin: 0x102A0, end: 0x102DF}, // Carian
    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles
];

function getUnicodeRange(unicode) {
    for (var i = 0; i < unicodeRanges.length; i += 1) {
        var range = unicodeRanges[i];
        if (unicode >= range.begin && unicode < range.end) {
            return i;
        }
    }

    return -1;
}

// Parse the OS/2 and Windows metrics `OS/2` table
function parseOS2Table(data, start) {
    var os2 = {};
    var p = new parse$1.Parser(data, start);
    os2.version = p.parseUShort();
    os2.xAvgCharWidth = p.parseShort();
    os2.usWeightClass = p.parseUShort();
    os2.usWidthClass = p.parseUShort();
    os2.fsType = p.parseUShort();
    os2.ySubscriptXSize = p.parseShort();
    os2.ySubscriptYSize = p.parseShort();
    os2.ySubscriptXOffset = p.parseShort();
    os2.ySubscriptYOffset = p.parseShort();
    os2.ySuperscriptXSize = p.parseShort();
    os2.ySuperscriptYSize = p.parseShort();
    os2.ySuperscriptXOffset = p.parseShort();
    os2.ySuperscriptYOffset = p.parseShort();
    os2.yStrikeoutSize = p.parseShort();
    os2.yStrikeoutPosition = p.parseShort();
    os2.sFamilyClass = p.parseShort();
    os2.panose = [];
    for (var i = 0; i < 10; i++) {
        os2.panose[i] = p.parseByte();
    }

    os2.ulUnicodeRange1 = p.parseULong();
    os2.ulUnicodeRange2 = p.parseULong();
    os2.ulUnicodeRange3 = p.parseULong();
    os2.ulUnicodeRange4 = p.parseULong();
    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
    os2.fsSelection = p.parseUShort();
    os2.usFirstCharIndex = p.parseUShort();
    os2.usLastCharIndex = p.parseUShort();
    os2.sTypoAscender = p.parseShort();
    os2.sTypoDescender = p.parseShort();
    os2.sTypoLineGap = p.parseShort();
    os2.usWinAscent = p.parseUShort();
    os2.usWinDescent = p.parseUShort();
    if (os2.version >= 1) {
        os2.ulCodePageRange1 = p.parseULong();
        os2.ulCodePageRange2 = p.parseULong();
    }

    if (os2.version >= 2) {
        os2.sxHeight = p.parseShort();
        os2.sCapHeight = p.parseShort();
        os2.usDefaultChar = p.parseUShort();
        os2.usBreakChar = p.parseUShort();
        os2.usMaxContent = p.parseUShort();
    }

    return os2;
}

function makeOS2Table(options) {
    return new table.Table('OS/2', [
        {name: 'version', type: 'USHORT', value: 0x0003},
        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},
        {name: 'usWeightClass', type: 'USHORT', value: 0},
        {name: 'usWidthClass', type: 'USHORT', value: 0},
        {name: 'fsType', type: 'USHORT', value: 0},
        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},
        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},
        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},
        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},
        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},
        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},
        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},
        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},
        {name: 'sFamilyClass', type: 'SHORT', value: 0},
        {name: 'bFamilyType', type: 'BYTE', value: 0},
        {name: 'bSerifStyle', type: 'BYTE', value: 0},
        {name: 'bWeight', type: 'BYTE', value: 0},
        {name: 'bProportion', type: 'BYTE', value: 0},
        {name: 'bContrast', type: 'BYTE', value: 0},
        {name: 'bStrokeVariation', type: 'BYTE', value: 0},
        {name: 'bArmStyle', type: 'BYTE', value: 0},
        {name: 'bLetterform', type: 'BYTE', value: 0},
        {name: 'bMidline', type: 'BYTE', value: 0},
        {name: 'bXHeight', type: 'BYTE', value: 0},
        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},
        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},
        {name: 'fsSelection', type: 'USHORT', value: 0},
        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},
        {name: 'usLastCharIndex', type: 'USHORT', value: 0},
        {name: 'sTypoAscender', type: 'SHORT', value: 0},
        {name: 'sTypoDescender', type: 'SHORT', value: 0},
        {name: 'sTypoLineGap', type: 'SHORT', value: 0},
        {name: 'usWinAscent', type: 'USHORT', value: 0},
        {name: 'usWinDescent', type: 'USHORT', value: 0},
        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},
        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},
        {name: 'sxHeight', type: 'SHORT', value: 0},
        {name: 'sCapHeight', type: 'SHORT', value: 0},
        {name: 'usDefaultChar', type: 'USHORT', value: 0},
        {name: 'usBreakChar', type: 'USHORT', value: 0},
        {name: 'usMaxContext', type: 'USHORT', value: 0}
    ], options);
}

var os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange };

// The `post` table stores additional PostScript information, such as glyph names.
// https://www.microsoft.com/typography/OTSPEC/post.htm

function parsePostTable(data, start) {
    var post = {};
    var p = new parse$1.Parser(data, start);
    post.version = p.parseVersion();
    post.italicAngle = p.parseFixed();
    post.underlinePosition = p.parseShort();
    post.underlineThickness = p.parseShort();
    post.isFixedPitch = p.parseULong();
    post.minMemType42 = p.parseULong();
    post.maxMemType42 = p.parseULong();
    post.minMemType1 = p.parseULong();
    post.maxMemType1 = p.parseULong();
    switch (post.version) {
        case 1:
            post.names = standardNames.slice();
            break;
        case 2:
            post.numberOfGlyphs = p.parseUShort();
            post.glyphNameIndex = new Array(post.numberOfGlyphs);
            for (var i = 0; i < post.numberOfGlyphs; i++) {
                post.glyphNameIndex[i] = p.parseUShort();
            }

            post.names = [];
            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
                if (post.glyphNameIndex[i$1] >= standardNames.length) {
                    var nameLength = p.parseChar();
                    post.names.push(p.parseString(nameLength));
                }
            }

            break;
        case 2.5:
            post.numberOfGlyphs = p.parseUShort();
            post.offset = new Array(post.numberOfGlyphs);
            for (var i$2 = 0; i$2 < post.numberOfGlyphs; i$2++) {
                post.offset[i$2] = p.parseChar();
            }

            break;
    }
    return post;
}

function makePostTable() {
    return new table.Table('post', [
        {name: 'version', type: 'FIXED', value: 0x00030000},
        {name: 'italicAngle', type: 'FIXED', value: 0},
        {name: 'underlinePosition', type: 'FWORD', value: 0},
        {name: 'underlineThickness', type: 'FWORD', value: 0},
        {name: 'isFixedPitch', type: 'ULONG', value: 0},
        {name: 'minMemType42', type: 'ULONG', value: 0},
        {name: 'maxMemType42', type: 'ULONG', value: 0},
        {name: 'minMemType1', type: 'ULONG', value: 0},
        {name: 'maxMemType1', type: 'ULONG', value: 0}
    ]);
}

var post = { parse: parsePostTable, make: makePostTable };

// The `GSUB` table contains ligatures, among other things.
// https://www.microsoft.com/typography/OTSPEC/gsub.htm

var subtableParsers = new Array(9);         // subtableParsers[0] is unused

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS
subtableParsers[1] = function parseLookup1() {
    var start = this.offset + this.relativeOffset;
    var substFormat = this.parseUShort();
    if (substFormat === 1) {
        return {
            substFormat: 1,
            coverage: this.parsePointer(Parser.coverage),
            deltaGlyphId: this.parseUShort()
        };
    } else if (substFormat === 2) {
        return {
            substFormat: 2,
            coverage: this.parsePointer(Parser.coverage),
            substitute: this.parseOffset16List()
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS
subtableParsers[2] = function parseLookup2() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        sequences: this.parseListOfLists()
    };
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS
subtableParsers[3] = function parseLookup3() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        alternateSets: this.parseListOfLists()
    };
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS
subtableParsers[4] = function parseLookup4() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        ligatureSets: this.parseListOfLists(function() {
            return {
                ligGlyph: this.parseUShort(),
                components: this.parseUShortList(this.parseUShort() - 1)
            };
        })
    };
};

var lookupRecordDesc = {
    sequenceIndex: Parser.uShort,
    lookupListIndex: Parser.uShort
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF
subtableParsers[5] = function parseLookup5() {
    var start = this.offset + this.relativeOffset;
    var substFormat = this.parseUShort();

    if (substFormat === 1) {
        return {
            substFormat: substFormat,
            coverage: this.parsePointer(Parser.coverage),
            ruleSets: this.parseListOfLists(function() {
                var glyphCount = this.parseUShort();
                var substCount = this.parseUShort();
                return {
                    input: this.parseUShortList(glyphCount - 1),
                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 2) {
        return {
            substFormat: substFormat,
            coverage: this.parsePointer(Parser.coverage),
            classDef: this.parsePointer(Parser.classDef),
            classSets: this.parseListOfLists(function() {
                var glyphCount = this.parseUShort();
                var substCount = this.parseUShort();
                return {
                    classes: this.parseUShortList(glyphCount - 1),
                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 3) {
        var glyphCount = this.parseUShort();
        var substCount = this.parseUShort();
        return {
            substFormat: substFormat,
            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),
            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC
subtableParsers[6] = function parseLookup6() {
    var start = this.offset + this.relativeOffset;
    var substFormat = this.parseUShort();
    if (substFormat === 1) {
        return {
            substFormat: 1,
            coverage: this.parsePointer(Parser.coverage),
            chainRuleSets: this.parseListOfLists(function() {
                return {
                    backtrack: this.parseUShortList(),
                    input: this.parseUShortList(this.parseShort() - 1),
                    lookahead: this.parseUShortList(),
                    lookupRecords: this.parseRecordList(lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 2) {
        return {
            substFormat: 2,
            coverage: this.parsePointer(Parser.coverage),
            backtrackClassDef: this.parsePointer(Parser.classDef),
            inputClassDef: this.parsePointer(Parser.classDef),
            lookaheadClassDef: this.parsePointer(Parser.classDef),
            chainClassSet: this.parseListOfLists(function() {
                return {
                    backtrack: this.parseUShortList(),
                    input: this.parseUShortList(this.parseShort() - 1),
                    lookahead: this.parseUShortList(),
                    lookupRecords: this.parseRecordList(lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 3) {
        return {
            substFormat: 3,
            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            lookupRecords: this.parseRecordList(lookupRecordDesc)
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES
subtableParsers[7] = function parseLookup7() {
    // Extension Substitution subtable
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');
    var extensionLookupType = this.parseUShort();
    var extensionParser = new Parser(this.data, this.offset + this.parseULong());
    return {
        substFormat: 1,
        lookupType: extensionLookupType,
        extension: subtableParsers[extensionLookupType].call(extensionParser)
    };
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS
subtableParsers[8] = function parseLookup8() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
        substitutes: this.parseUShortList()
    };
};

// https://www.microsoft.com/typography/OTSPEC/gsub.htm
function parseGsubTable(data, start) {
    start = start || 0;
    var p = new Parser(data, start);
    var tableVersion = p.parseVersion();
    check.argument(tableVersion === 1, 'Unsupported GSUB table version.');
    return {
        version: tableVersion,
        scripts: p.parseScriptList(),
        features: p.parseFeatureList(),
        lookups: p.parseLookupList(subtableParsers)
    };
}

// GSUB Writing //////////////////////////////////////////////
var subtableMakers = new Array(9);

subtableMakers[1] = function makeLookup1(subtable) {
    if (subtable.substFormat === 1) {
        return new table.Table('substitutionTable', [
            {name: 'substFormat', type: 'USHORT', value: 1},
            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)},
            {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}
        ]);
    } else {
        return new table.Table('substitutionTable', [
            {name: 'substFormat', type: 'USHORT', value: 2},
            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
        ].concat(table.ushortList('substitute', subtable.substitute)));
    }
    check.fail('Lookup type 1 substFormat must be 1 or 2.');
};

subtableMakers[3] = function makeLookup3(subtable) {
    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');
    return new table.Table('substitutionTable', [
        {name: 'substFormat', type: 'USHORT', value: 1},
        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
    ].concat(table.tableList('altSet', subtable.alternateSets, function(alternateSet) {
        return new table.Table('alternateSetTable', table.ushortList('alternate', alternateSet));
    })));
};

subtableMakers[4] = function makeLookup4(subtable) {
    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');
    return new table.Table('substitutionTable', [
        {name: 'substFormat', type: 'USHORT', value: 1},
        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
    ].concat(table.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {
        return new table.Table('ligatureSetTable', table.tableList('ligature', ligatureSet, function(ligature) {
            return new table.Table('ligatureTable',
                [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]
                .concat(table.ushortList('component', ligature.components, ligature.components.length + 1))
            );
        }));
    })));
};

function makeGsubTable(gsub) {
    return new table.Table('GSUB', [
        {name: 'version', type: 'ULONG', value: 0x10000},
        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gsub.scripts)},
        {name: 'features', type: 'TABLE', value: new table.FeatureList(gsub.features)},
        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gsub.lookups, subtableMakers)}
    ]);
}

var gsub = { parse: parseGsubTable, make: makeGsubTable };

// The `GPOS` table contains kerning pairs, among other things.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm

function parseMetaTable(data, start) {
    var p = new parse$1.Parser(data, start);
    var tableVersion = p.parseULong();
    check.argument(tableVersion === 1, 'Unsupported META table version.');
    p.parseULong(); // flags - currently unused and set to 0
    p.parseULong(); // tableOffset
    var numDataMaps = p.parseULong();

    var tags = {};
    for (var i = 0; i < numDataMaps; i++) {
        var tag = p.parseTag();
        var dataOffset = p.parseULong();
        var dataLength = p.parseULong();
        var text = decode.UTF8(data, start + dataOffset, dataLength);

        tags[tag] = text;
    }
    return tags;
}

function makeMetaTable(tags) {
    var numTags = Object.keys(tags).length;
    var stringPool = '';
    var stringPoolOffset = 16 + numTags * 12;

    var result = new table.Table('meta', [
        {name: 'version', type: 'ULONG', value: 1},
        {name: 'flags', type: 'ULONG', value: 0},
        {name: 'offset', type: 'ULONG', value: stringPoolOffset},
        {name: 'numTags', type: 'ULONG', value: numTags}
    ]);

    for (var tag in tags) {
        var pos = stringPool.length;
        stringPool += tags[tag];

        result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});
        result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});
        result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});
    }

    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});

    return result;
}

var meta = { parse: parseMetaTable, make: makeMetaTable };

// The `sfnt` wrapper provides organization for the tables in the font.
// It is the top-level data structure in a font.
// https://www.microsoft.com/typography/OTSPEC/otff.htm
// Recommendations for creating OpenType Fonts:
// http://www.microsoft.com/typography/otspec140/recom.htm

function log2$1(v) {
    return Math.log(v) / Math.log(2) | 0;
}

function computeCheckSum(bytes) {
    while (bytes.length % 4 !== 0) {
        bytes.push(0);
    }

    var sum = 0;
    for (var i = 0; i < bytes.length; i += 4) {
        sum += (bytes[i] << 24) +
            (bytes[i + 1] << 16) +
            (bytes[i + 2] << 8) +
            (bytes[i + 3]);
    }

    sum %= Math.pow(2, 32);
    return sum;
}

function makeTableRecord(tag, checkSum, offset, length) {
    return new table.Record('Table Record', [
        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},
        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},
        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},
        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}
    ]);
}

function makeSfntTable(tables) {
    var sfnt = new table.Table('sfnt', [
        {name: 'version', type: 'TAG', value: 'OTTO'},
        {name: 'numTables', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);
    sfnt.tables = tables;
    sfnt.numTables = tables.length;
    var highestPowerOf2 = Math.pow(2, log2$1(sfnt.numTables));
    sfnt.searchRange = 16 * highestPowerOf2;
    sfnt.entrySelector = log2$1(highestPowerOf2);
    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;

    var recordFields = [];
    var tableFields = [];

    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);
    while (offset % 4 !== 0) {
        offset += 1;
        tableFields.push({name: 'padding', type: 'BYTE', value: 0});
    }

    for (var i = 0; i < tables.length; i += 1) {
        var t = tables[i];
        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
        var tableLength = t.sizeOf();
        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});
        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});
        offset += tableLength;
        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');
        while (offset % 4 !== 0) {
            offset += 1;
            tableFields.push({name: 'padding', type: 'BYTE', value: 0});
        }
    }

    // Table records need to be sorted alphabetically.
    recordFields.sort(function(r1, r2) {
        if (r1.value.tag > r2.value.tag) {
            return 1;
        } else {
            return -1;
        }
    });

    sfnt.fields = sfnt.fields.concat(recordFields);
    sfnt.fields = sfnt.fields.concat(tableFields);
    return sfnt;
}

// Get the metrics for a character. If the string has more than one character
// this function returns metrics for the first available character.
// You can provide optional fallback metrics if no characters are available.
function metricsForChar(font, chars, notFoundMetrics) {
    for (var i = 0; i < chars.length; i += 1) {
        var glyphIndex = font.charToGlyphIndex(chars[i]);
        if (glyphIndex > 0) {
            var glyph = font.glyphs.get(glyphIndex);
            return glyph.getMetrics();
        }
    }

    return notFoundMetrics;
}

function average(vs) {
    var sum = 0;
    for (var i = 0; i < vs.length; i += 1) {
        sum += vs[i];
    }

    return sum / vs.length;
}

// Convert the font object to a SFNT data structure.
// This structure contains all the necessary tables and metadata to create a binary OTF file.
function fontToSfntTable(font) {
    var xMins = [];
    var yMins = [];
    var xMaxs = [];
    var yMaxs = [];
    var advanceWidths = [];
    var leftSideBearings = [];
    var rightSideBearings = [];
    var firstCharIndex;
    var lastCharIndex = 0;
    var ulUnicodeRange1 = 0;
    var ulUnicodeRange2 = 0;
    var ulUnicodeRange3 = 0;
    var ulUnicodeRange4 = 0;

    for (var i = 0; i < font.glyphs.length; i += 1) {
        var glyph = font.glyphs.get(i);
        var unicode = glyph.unicode | 0;

        if (isNaN(glyph.advanceWidth)) {
            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');
        }

        if (firstCharIndex > unicode || firstCharIndex === undefined) {
            // ignore .notdef char
            if (unicode > 0) {
                firstCharIndex = unicode;
            }
        }

        if (lastCharIndex < unicode) {
            lastCharIndex = unicode;
        }

        var position = os2.getUnicodeRange(unicode);
        if (position < 32) {
            ulUnicodeRange1 |= 1 << position;
        } else if (position < 64) {
            ulUnicodeRange2 |= 1 << position - 32;
        } else if (position < 96) {
            ulUnicodeRange3 |= 1 << position - 64;
        } else if (position < 123) {
            ulUnicodeRange4 |= 1 << position - 96;
        } else {
            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');
        }
        // Skip non-important characters.
        if (glyph.name === '.notdef') { continue; }
        var metrics = glyph.getMetrics();
        xMins.push(metrics.xMin);
        yMins.push(metrics.yMin);
        xMaxs.push(metrics.xMax);
        yMaxs.push(metrics.yMax);
        leftSideBearings.push(metrics.leftSideBearing);
        rightSideBearings.push(metrics.rightSideBearing);
        advanceWidths.push(glyph.advanceWidth);
    }

    var globals = {
        xMin: Math.min.apply(null, xMins),
        yMin: Math.min.apply(null, yMins),
        xMax: Math.max.apply(null, xMaxs),
        yMax: Math.max.apply(null, yMaxs),
        advanceWidthMax: Math.max.apply(null, advanceWidths),
        advanceWidthAvg: average(advanceWidths),
        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
        minRightSideBearing: Math.min.apply(null, rightSideBearings)
    };
    globals.ascender = font.ascender;
    globals.descender = font.descender;

    var headTable = head.make({
        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)
        unitsPerEm: font.unitsPerEm,
        xMin: globals.xMin,
        yMin: globals.yMin,
        xMax: globals.xMax,
        yMax: globals.yMax,
        lowestRecPPEM: 3,
        createdTimestamp: font.createdTimestamp
    });

    var hheaTable = hhea.make({
        ascender: globals.ascender,
        descender: globals.descender,
        advanceWidthMax: globals.advanceWidthMax,
        minLeftSideBearing: globals.minLeftSideBearing,
        minRightSideBearing: globals.minRightSideBearing,
        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
        numberOfHMetrics: font.glyphs.length
    });

    var maxpTable = maxp.make(font.glyphs.length);

    var os2Table = os2.make({
        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
        usWeightClass: font.tables.os2.usWeightClass,
        usWidthClass: font.tables.os2.usWidthClass,
        usFirstCharIndex: firstCharIndex,
        usLastCharIndex: lastCharIndex,
        ulUnicodeRange1: ulUnicodeRange1,
        ulUnicodeRange2: ulUnicodeRange2,
        ulUnicodeRange3: ulUnicodeRange3,
        ulUnicodeRange4: ulUnicodeRange4,
        fsSelection: font.tables.os2.fsSelection, // REGULAR
        // See http://typophile.com/node/13081 for more info on vertical metrics.
        // We get metrics for typical characters (such as "x" for xHeight).
        // We provide some fallback characters if characters are unavailable: their
        // ordering was chosen experimentally.
        sTypoAscender: globals.ascender,
        sTypoDescender: globals.descender,
        sTypoLineGap: 0,
        usWinAscent: globals.yMax,
        usWinDescent: Math.abs(globals.yMin),
        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now
        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,
        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.
        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.
    });

    var hmtxTable = hmtx.make(font.glyphs);
    var cmapTable = cmap.make(font.glyphs);

    var englishFamilyName = font.getEnglishName('fontFamily');
    var englishStyleName = font.getEnglishName('fontSubfamily');
    var englishFullName = englishFamilyName + ' ' + englishStyleName;
    var postScriptName = font.getEnglishName('postScriptName');
    if (!postScriptName) {
        postScriptName = englishFamilyName.replace(/\s/g, '') + '-' + englishStyleName;
    }

    var names = {};
    for (var n in font.names) {
        names[n] = font.names[n];
    }

    if (!names.uniqueID) {
        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};
    }

    if (!names.postScriptName) {
        names.postScriptName = {en: postScriptName};
    }

    if (!names.preferredFamily) {
        names.preferredFamily = font.names.fontFamily;
    }

    if (!names.preferredSubfamily) {
        names.preferredSubfamily = font.names.fontSubfamily;
    }

    var languageTags = [];
    var nameTable = _name.make(names, languageTags);
    var ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);

    var postTable = post.make();
    var cffTable = cff.make(font.glyphs, {
        version: font.getEnglishName('version'),
        fullName: englishFullName,
        familyName: englishFamilyName,
        weightName: englishStyleName,
        postScriptName: postScriptName,
        unitsPerEm: font.unitsPerEm,
        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]
    });

    var metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;

    // The order does not matter because makeSfntTable() will sort them.
    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
    if (ltagTable) {
        tables.push(ltagTable);
    }
    // Optional tables
    if (font.tables.gsub) {
        tables.push(gsub.make(font.tables.gsub));
    }
    if (metaTable) {
        tables.push(metaTable);
    }

    var sfntTable = makeSfntTable(tables);

    // Compute the font's checkSum and store it in head.checkSumAdjustment.
    var bytes = sfntTable.encode();
    var checkSum = computeCheckSum(bytes);
    var tableFields = sfntTable.fields;
    var checkSumAdjusted = false;
    for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {
        if (tableFields[i$1].name === 'head table') {
            tableFields[i$1].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;
            checkSumAdjusted = true;
            break;
        }
    }

    if (!checkSumAdjusted) {
        throw new Error('Could not find head table with checkSum to adjust.');
    }

    return sfntTable;
}

var sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum };

// The Layout object is the prototype of Substitution objects, and provides
// utility methods to manipulate common layout tables (GPOS, GSUB, GDEF...)

function searchTag(arr, tag) {
    /* jshint bitwise: false */
    var imin = 0;
    var imax = arr.length - 1;
    while (imin <= imax) {
        var imid = (imin + imax) >>> 1;
        var val = arr[imid].tag;
        if (val === tag) {
            return imid;
        } else if (val < tag) {
            imin = imid + 1;
        } else { imax = imid - 1; }
    }
    // Not found: return -1-insertion point
    return -imin - 1;
}

function binSearch(arr, value) {
    /* jshint bitwise: false */
    var imin = 0;
    var imax = arr.length - 1;
    while (imin <= imax) {
        var imid = (imin + imax) >>> 1;
        var val = arr[imid];
        if (val === value) {
            return imid;
        } else if (val < value) {
            imin = imid + 1;
        } else { imax = imid - 1; }
    }
    // Not found: return -1-insertion point
    return -imin - 1;
}

/**
 * @exports opentype.Layout
 * @class
 */
function Layout(font, tableName) {
    this.font = font;
    this.tableName = tableName;
}

Layout.prototype = {

    /**
     * Binary search an object by "tag" property
     * @instance
     * @function searchTag
     * @memberof opentype.Layout
     * @param  {Array} arr
     * @param  {string} tag
     * @return {number}
     */
    searchTag: searchTag,

    /**
     * Binary search in a list of numbers
     * @instance
     * @function binSearch
     * @memberof opentype.Layout
     * @param  {Array} arr
     * @param  {number} value
     * @return {number}
     */
    binSearch: binSearch,

    /**
     * Get or create the Layout table (GSUB, GPOS etc).
     * @param  {boolean} create - Whether to create a new one.
     * @return {Object} The GSUB or GPOS table.
     */
    getTable: function(create) {
        var layout = this.font.tables[this.tableName];
        if (!layout && create) {
            layout = this.font.tables[this.tableName] = this.createDefaultTable();
        }
        return layout;
    },

    /**
     * Returns all scripts in the substitution table.
     * @instance
     * @return {Array}
     */
    getScriptNames: function() {
        var layout = this.getTable();
        if (!layout) { return []; }
        return layout.scripts.map(function(script) {
            return script.tag;
        });
    },

    /**
     * Returns the best bet for a script name.
     * Returns 'DFLT' if it exists.
     * If not, returns 'latn' if it exists.
     * If neither exist, returns undefined.
     */
    getDefaultScriptName: function() {
        var layout = this.getTable();
        if (!layout) { return; }
        var hasLatn = false;
        for (var i = 0; i < layout.scripts.length; i++) {
            var name = layout.scripts[i].tag;
            if (name === 'DFLT') { return name; }
            if (name === 'latn') { hasLatn = true; }
        }
        if (hasLatn) { return 'latn'; }
    },

    /**
     * Returns all LangSysRecords in the given script.
     * @instance
     * @param {string} [script='DFLT']
     * @param {boolean} create - forces the creation of this script table if it doesn't exist.
     * @return {Object} An object with tag and script properties.
     */
    getScriptTable: function(script, create) {
        var layout = this.getTable(create);
        if (layout) {
            script = script || 'DFLT';
            var scripts = layout.scripts;
            var pos = searchTag(layout.scripts, script);
            if (pos >= 0) {
                return scripts[pos].script;
            } else if (create) {
                var scr = {
                    tag: script,
                    script: {
                        defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},
                        langSysRecords: []
                    }
                };
                scripts.splice(-1 - pos, 0, scr);
                return scr.script;
            }
        }
    },

    /**
     * Returns a language system table
     * @instance
     * @param {string} [script='DFLT']
     * @param {string} [language='dlft']
     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.
     * @return {Object}
     */
    getLangSysTable: function(script, language, create) {
        var scriptTable = this.getScriptTable(script, create);
        if (scriptTable) {
            if (!language || language === 'dflt' || language === 'DFLT') {
                return scriptTable.defaultLangSys;
            }
            var pos = searchTag(scriptTable.langSysRecords, language);
            if (pos >= 0) {
                return scriptTable.langSysRecords[pos].langSys;
            } else if (create) {
                var langSysRecord = {
                    tag: language,
                    langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}
                };
                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
                return langSysRecord.langSys;
            }
        }
    },

    /**
     * Get a specific feature table.
     * @instance
     * @param {string} [script='DFLT']
     * @param {string} [language='dlft']
     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm
     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.
     * @return {Object}
     */
    getFeatureTable: function(script, language, feature, create) {
        var langSysTable = this.getLangSysTable(script, language, create);
        if (langSysTable) {
            var featureRecord;
            var featIndexes = langSysTable.featureIndexes;
            var allFeatures = this.font.tables[this.tableName].features;
            // The FeatureIndex array of indices is in arbitrary order,
            // even if allFeatures is sorted alphabetically by feature tag.
            for (var i = 0; i < featIndexes.length; i++) {
                featureRecord = allFeatures[featIndexes[i]];
                if (featureRecord.tag === feature) {
                    return featureRecord.feature;
                }
            }
            if (create) {
                var index = allFeatures.length;
                // Automatic ordering of features would require to shift feature indexes in the script list.
                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');
                featureRecord = {
                    tag: feature,
                    feature: { params: 0, lookupListIndexes: [] }
                };
                allFeatures.push(featureRecord);
                featIndexes.push(index);
                return featureRecord.feature;
            }
        }
    },

    /**
     * Get the lookup tables of a given type for a script/language/feature.
     * @instance
     * @param {string} [script='DFLT']
     * @param {string} [language='dlft']
     * @param {string} feature - 4-letter feature code
     * @param {number} lookupType - 1 to 8
     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.
     * @return {Object[]}
     */
    getLookupTables: function(script, language, feature, lookupType, create) {
        var featureTable = this.getFeatureTable(script, language, feature, create);
        var tables = [];
        if (featureTable) {
            var lookupTable;
            var lookupListIndexes = featureTable.lookupListIndexes;
            var allLookups = this.font.tables[this.tableName].lookups;
            // lookupListIndexes are in no particular order, so use naive search.
            for (var i = 0; i < lookupListIndexes.length; i++) {
                lookupTable = allLookups[lookupListIndexes[i]];
                if (lookupTable.lookupType === lookupType) {
                    tables.push(lookupTable);
                }
            }
            if (tables.length === 0 && create) {
                lookupTable = {
                    lookupType: lookupType,
                    lookupFlag: 0,
                    subtables: [],
                    markFilteringSet: undefined
                };
                var index = allLookups.length;
                allLookups.push(lookupTable);
                lookupListIndexes.push(index);
                return [lookupTable];
            }
        }
        return tables;
    },

    /**
     * Returns the list of glyph indexes of a coverage table.
     * Format 1: the list is stored raw
     * Format 2: compact list as range records.
     * @instance
     * @param  {Object} coverageTable
     * @return {Array}
     */
    expandCoverage: function(coverageTable) {
        if (coverageTable.format === 1) {
            return coverageTable.glyphs;
        } else {
            var glyphs = [];
            var ranges = coverageTable.ranges;
            for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                var start = range.start;
                var end = range.end;
                for (var j = start; j <= end; j++) {
                    glyphs.push(j);
                }
            }
            return glyphs;
        }
    }

};

// The Substitution object provides utility methods to manipulate
// the GSUB substitution table.

function Substitution(font) {
    Layout.call(this, font, 'gsub');
}

// Check if 2 arrays of primitives are equal.
function arraysEqual(ar1, ar2) {
    var n = ar1.length;
    if (n !== ar2.length) { return false; }
    for (var i = 0; i < n; i++) {
        if (ar1[i] !== ar2[i]) { return false; }
    }
    return true;
}

// Find the first subtable of a lookup table in a particular format.
function getSubstFormat(lookupTable, format, defaultSubtable) {
    var subtables = lookupTable.subtables;
    for (var i = 0; i < subtables.length; i++) {
        var subtable = subtables[i];
        if (subtable.substFormat === format) {
            return subtable;
        }
    }
    if (defaultSubtable) {
        subtables.push(defaultSubtable);
        return defaultSubtable;
    }
    return undefined;
}

Substitution.prototype = Layout.prototype;

/**
 * Create a default GSUB table.
 * @return {Object} gsub - The GSUB table.
 */
Substitution.prototype.createDefaultTable = function() {
    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.
    return {
        version: 1,
        scripts: [{
            tag: 'DFLT',
            script: {
                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },
                langSysRecords: []
            }
        }],
        features: [],
        lookups: []
    };
};

/**
 * List all single substitutions (lookup type 1) for a given script, language, and feature.
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)
 * @return {Array} substitutions - The list of substitutions.
 */
Substitution.prototype.getSingle = function(feature, script, language) {
    var this$1 = this;

    var substitutions = [];
    var lookupTables = this.getLookupTables(script, language, feature, 1);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this$1.expandCoverage(subtable.coverage);
            var j = (void 0);
            if (subtable.substFormat === 1) {
                var delta = subtable.deltaGlyphId;
                for (j = 0; j < glyphs.length; j++) {
                    var glyph = glyphs[j];
                    substitutions.push({ sub: glyph, by: glyph + delta });
                }
            } else {
                var substitute = subtable.substitute;
                for (j = 0; j < glyphs.length; j++) {
                    substitutions.push({ sub: glyphs[j], by: substitute[j] });
                }
            }
        }
    }
    return substitutions;
};

/**
 * List all alternates (lookup type 3) for a given script, language, and feature.
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @param {string} feature - 4-character feature name ('aalt', 'salt'...)
 * @return {Array} alternates - The list of alternates
 */
Substitution.prototype.getAlternates = function(feature, script, language) {
    var this$1 = this;

    var alternates = [];
    var lookupTables = this.getLookupTables(script, language, feature, 3);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this$1.expandCoverage(subtable.coverage);
            var alternateSets = subtable.alternateSets;
            for (var j = 0; j < glyphs.length; j++) {
                alternates.push({ sub: glyphs[j], by: alternateSets[j] });
            }
        }
    }
    return alternates;
};

/**
 * List all ligatures (lookup type 4) for a given script, language, and feature.
 * The result is an array of ligature objects like { sub: [ids], by: id }
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @return {Array} ligatures - The list of ligatures.
 */
Substitution.prototype.getLigatures = function(feature, script, language) {
    var this$1 = this;

    var ligatures = [];
    var lookupTables = this.getLookupTables(script, language, feature, 4);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this$1.expandCoverage(subtable.coverage);
            var ligatureSets = subtable.ligatureSets;
            for (var j = 0; j < glyphs.length; j++) {
                var startGlyph = glyphs[j];
                var ligSet = ligatureSets[j];
                for (var k = 0; k < ligSet.length; k++) {
                    var lig = ligSet[k];
                    ligatures.push({
                        sub: [startGlyph].concat(lig.components),
                        by: lig.ligGlyph
                    });
                }
            }
        }
    }
    return ligatures;
};

/**
 * Add or modify a single substitution (lookup type 1)
 * Format 2, more flexible, is always used.
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {Object} substitution - { sub: id, delta: number } for format 1 or { sub: id, by: id } for format 2.
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.addSingle = function(feature, substitution, script, language) {
    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];
    var subtable = getSubstFormat(lookupTable, 2, {                // lookup type 1 subtable, format 2, coverage format 1
        substFormat: 2,
        coverage: {format: 1, glyphs: []},
        substitute: []
    });
    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = substitution.sub;
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos < 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.substitute.splice(pos, 0, 0);
    }
    subtable.substitute[pos] = substitution.by;
};

/**
 * Add or modify an alternate substitution (lookup type 1)
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {Object} substitution - { sub: id, by: [ids] }
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.addAlternate = function(feature, substitution, script, language) {
    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];
    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 3 subtable, format 1, coverage format 1
        substFormat: 1,
        coverage: {format: 1, glyphs: []},
        alternateSets: []
    });
    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = substitution.sub;
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos < 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.alternateSets.splice(pos, 0, 0);
    }
    subtable.alternateSets[pos] = substitution.by;
};

/**
 * Add a ligature (lookup type 4)
 * Ligatures with more components must be stored ahead of those with fewer components in order to be found
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {Object} ligature - { sub: [ids], by: id }
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.addLigature = function(feature, ligature, script, language) {
    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];
    var subtable = lookupTable.subtables[0];
    if (!subtable) {
        subtable = {                // lookup type 4 subtable, format 1, coverage format 1
            substFormat: 1,
            coverage: { format: 1, glyphs: [] },
            ligatureSets: []
        };
        lookupTable.subtables[0] = subtable;
    }
    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = ligature.sub[0];
    var ligComponents = ligature.sub.slice(1);
    var ligatureTable = {
        ligGlyph: ligature.by,
        components: ligComponents
    };
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos >= 0) {
        // ligatureSet already exists
        var ligatureSet = subtable.ligatureSets[pos];
        for (var i = 0; i < ligatureSet.length; i++) {
            // If ligature already exists, return.
            if (arraysEqual(ligatureSet[i].components, ligComponents)) {
                return;
            }
        }
        // ligature does not exist: add it.
        ligatureSet.push(ligatureTable);
    } else {
        // Create a new ligatureSet and add coverage for the first glyph.
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
    }
};

/**
 * List all feature data for a given script and language.
 * @param {string} feature - 4-letter feature name
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @return {Array} substitutions - The list of substitutions.
 */
Substitution.prototype.getFeature = function(feature, script, language) {
    if (/ss\d\d/.test(feature)) {               // ss01 - ss20
        return this.getSingle(feature, script, language);
    }
    switch (feature) {
        case 'aalt':
        case 'salt':
            return this.getSingle(feature, script, language)
                    .concat(this.getAlternates(feature, script, language));
        case 'dlig':
        case 'liga':
        case 'rlig': return this.getLigatures(feature, script, language);
    }
    return undefined;
};

/**
 * Add a substitution to a feature for a given script and language.
 * @param {string} feature - 4-letter feature name
 * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.add = function(feature, sub, script, language) {
    if (/ss\d\d/.test(feature)) {               // ss01 - ss20
        return this.addSingle(feature, sub, script, language);
    }
    switch (feature) {
        case 'aalt':
        case 'salt':
            if (typeof sub.by === 'number') {
                return this.addSingle(feature, sub, script, language);
            }
            return this.addAlternate(feature, sub, script, language);
        case 'dlig':
        case 'liga':
        case 'rlig':
            return this.addLigature(feature, sub, script, language);
    }
    return undefined;
};

function isBrowser() {
    return typeof window !== 'undefined';
}

function arrayBufferToNodeBuffer(ab) {
    var buffer = new Buffer(ab.byteLength);
    var view = new Uint8Array(ab);
    for (var i = 0; i < buffer.length; ++i) {
        buffer[i] = view[i];
    }

    return buffer;
}

function checkArgument(expression, message) {
    if (!expression) {
        throw message;
    }
}

/* A TrueType font hinting interpreter.
*
* (c) 2017 Axel Kittenberger
*
* This interpreter has been implemented according to this documentation:
* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html
*
* According to the documentation F24DOT6 values are used for pixels.
* That means calculation is 1/64 pixel accurate and uses integer operations.
* However, Javascript has floating point operations by default and only
* those are available. One could make a case to simulate the 1/64 accuracy
* exactly by truncating after every division operation
* (for example with << 0) to get pixel exactly results as other TrueType
* implementations. It may make sense since some fonts are pixel optimized
* by hand using DELTAP instructions. The current implementation doesn't
* and rather uses full floating point precision.
*
* xScale, yScale and rotation is currently ignored.
*
* A few non-trivial instructions are missing as I didn't encounter yet
* a font that used them to test a possible implementation.
*
* Some fonts seem to use undocumented features regarding the twilight zone.
* Only some of them are implemented as they were encountered.
*
* The exports.DEBUG statements are removed on the minified distribution file.
*/
var instructionTable;
var exec;
var execGlyph;
var execComponent;

/*
* Creates a hinting object.
*
* There ought to be exactly one
* for each truetype font that is used for hinting.
*/
function Hinting(font) {
    // the font this hinting object is for
    this.font = font;

    // cached states
    this._fpgmState  =
    this._prepState  =
        undefined;

    // errorState
    // 0 ... all okay
    // 1 ... had an error in a glyf,
    //       continue working but stop spamming
    //       the console
    // 2 ... error at prep, stop hinting at this ppem
    // 3 ... error at fpeg, stop hinting for this font at all
    this._errorState = 0;
}

/*
* Not rounding.
*/
function roundOff(v) {
    return v;
}

/*
* Rounding to grid.
*/
function roundToGrid(v) {
    //Rounding in TT is supposed to "symmetrical around zero"
    return Math.sign(v) * Math.round(Math.abs(v));
}

/*
* Rounding to double grid.
*/
function roundToDoubleGrid(v) {
    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;
}

/*
* Rounding to half grid.
*/
function roundToHalfGrid(v) {
    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);
}

/*
* Rounding to up to grid.
*/
function roundUpToGrid(v) {
    return Math.sign(v) * Math.ceil(Math.abs(v));
}

/*
* Rounding to down to grid.
*/
function roundDownToGrid(v) {
    return Math.sign(v) * Math.floor(Math.abs(v));
}

/*
* Super rounding.
*/
var roundSuper = function (v) {
    var period = this.srPeriod;
    var phase = this.srPhase;
    var threshold = this.srThreshold;
    var sign = 1;

    if (v < 0) {
        v = -v;
        sign = -1;
    }

    v += threshold - phase;

    v = Math.trunc(v / period) * period;

    v += phase;

    // according to http://xgridfit.sourceforge.net/round.html
    if (sign > 0 && v < 0) { return phase; }
    if (sign < 0 && v > 0) { return -phase; }

    return v * sign;
};

/*
* Unit vector of x-axis.
*/
var xUnitVector = {
    x: 1,

    y: 0,

    axis: 'x',

    // Gets the projected distance between two points.
    // o1/o2 ... if true, respective original position is used.
    distance: function (p1, p2, o1, o2) {
        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);
    },

    // Moves point p so the moved position has the same relative
    // position to the moved positions of rp1 and rp2 than the
    // original positions had.
    //
    // See APPENDIX on INTERPOLATE at the bottom of this file.
    interpolate: function (p, rp1, rp2, pv) {
        var do1;
        var do2;
        var doa1;
        var doa2;
        var dm1;
        var dm2;
        var dt;

        if (!pv || pv === this) {
            do1 = p.xo - rp1.xo;
            do2 = p.xo - rp2.xo;
            dm1 = rp1.x - rp1.xo;
            dm2 = rp2.x - rp2.xo;
            doa1 = Math.abs(do1);
            doa2 = Math.abs(do2);
            dt = doa1 + doa2;

            if (dt === 0) {
                p.x = p.xo + (dm1 + dm2) / 2;
                return;
            }

            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;
            return;
        }

        do1 = pv.distance(p, rp1, true, true);
        do2 = pv.distance(p, rp2, true, true);
        dm1 = pv.distance(rp1, rp1, false, true);
        dm2 = pv.distance(rp2, rp2, false, true);
        doa1 = Math.abs(do1);
        doa2 = Math.abs(do2);
        dt = doa1 + doa2;

        if (dt === 0) {
            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
            return;
        }

        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
    },

    // Slope of line normal to this
    normalSlope: Number.NEGATIVE_INFINITY,

    // Sets the point 'p' relative to point 'rp'
    // by the distance 'd'.
    //
    // See APPENDIX on SETRELATIVE at the bottom of this file.
    //
    // p   ... point to set
    // rp  ... reference point
    // d   ... distance on projection vector
    // pv  ... projection vector (undefined = this)
    // org ... if true, uses the original position of rp as reference.
    setRelative: function (p, rp, d, pv, org) {
        if (!pv || pv === this) {
            p.x = (org ? rp.xo : rp.x) + d;
            return;
        }

        var rpx = org ? rp.xo : rp.x;
        var rpy = org ? rp.yo : rp.y;
        var rpdx = rpx + d * pv.x;
        var rpdy = rpy + d * pv.y;

        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;
    },

    // Slope of vector line.
    slope: 0,

    // Touches the point p.
    touch: function (p) {
        p.xTouched = true;
    },

    // Tests if a point p is touched.
    touched: function (p) {
        return p.xTouched;
    },

    // Untouches the point p.
    untouch: function (p) {
        p.xTouched = false;
    }
};

/*
* Unit vector of y-axis.
*/
var yUnitVector = {
    x: 0,

    y: 1,

    axis: 'y',

    // Gets the projected distance between two points.
    // o1/o2 ... if true, respective original position is used.
    distance: function (p1, p2, o1, o2) {
        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);
    },

    // Moves point p so the moved position has the same relative
    // position to the moved positions of rp1 and rp2 than the
    // original positions had.
    //
    // See APPENDIX on INTERPOLATE at the bottom of this file.
    interpolate: function (p, rp1, rp2, pv) {
        var do1;
        var do2;
        var doa1;
        var doa2;
        var dm1;
        var dm2;
        var dt;

        if (!pv || pv === this) {
            do1 = p.yo - rp1.yo;
            do2 = p.yo - rp2.yo;
            dm1 = rp1.y - rp1.yo;
            dm2 = rp2.y - rp2.yo;
            doa1 = Math.abs(do1);
            doa2 = Math.abs(do2);
            dt = doa1 + doa2;

            if (dt === 0) {
                p.y = p.yo + (dm1 + dm2) / 2;
                return;
            }

            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;
            return;
        }

        do1 = pv.distance(p, rp1, true, true);
        do2 = pv.distance(p, rp2, true, true);
        dm1 = pv.distance(rp1, rp1, false, true);
        dm2 = pv.distance(rp2, rp2, false, true);
        doa1 = Math.abs(do1);
        doa2 = Math.abs(do2);
        dt = doa1 + doa2;

        if (dt === 0) {
            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
            return;
        }

        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
    },

    // Slope of line normal to this.
    normalSlope: 0,

    // Sets the point 'p' relative to point 'rp'
    // by the distance 'd'
    //
    // See APPENDIX on SETRELATIVE at the bottom of this file.
    //
    // p   ... point to set
    // rp  ... reference point
    // d   ... distance on projection vector
    // pv  ... projection vector (undefined = this)
    // org ... if true, uses the original position of rp as reference.
    setRelative: function (p, rp, d, pv, org) {
        if (!pv || pv === this) {
            p.y = (org ? rp.yo : rp.y) + d;
            return;
        }

        var rpx = org ? rp.xo : rp.x;
        var rpy = org ? rp.yo : rp.y;
        var rpdx = rpx + d * pv.x;
        var rpdy = rpy + d * pv.y;

        p.y = rpdy + pv.normalSlope * (p.x - rpdx);
    },

    // Slope of vector line.
    slope: Number.POSITIVE_INFINITY,

    // Touches the point p.
    touch: function (p) {
        p.yTouched = true;
    },

    // Tests if a point p is touched.
    touched: function (p) {
        return p.yTouched;
    },

    // Untouches the point p.
    untouch: function (p) {
        p.yTouched = false;
    }
};

Object.freeze(xUnitVector);
Object.freeze(yUnitVector);

/*
* Creates a unit vector that is not x- or y-axis.
*/
function UnitVector(x, y) {
    this.x = x;
    this.y = y;
    this.axis = undefined;
    this.slope = y / x;
    this.normalSlope = -x / y;
    Object.freeze(this);
}

/*
* Gets the projected distance between two points.
* o1/o2 ... if true, respective original position is used.
*/
UnitVector.prototype.distance = function(p1, p2, o1, o2) {
    return (
        this.x * xUnitVector.distance(p1, p2, o1, o2) +
        this.y * yUnitVector.distance(p1, p2, o1, o2)
    );
};

/*
* Moves point p so the moved position has the same relative
* position to the moved positions of rp1 and rp2 than the
* original positions had.
*
* See APPENDIX on INTERPOLATE at the bottom of this file.
*/
UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {
    var dm1;
    var dm2;
    var do1;
    var do2;
    var doa1;
    var doa2;
    var dt;

    do1 = pv.distance(p, rp1, true, true);
    do2 = pv.distance(p, rp2, true, true);
    dm1 = pv.distance(rp1, rp1, false, true);
    dm2 = pv.distance(rp2, rp2, false, true);
    doa1 = Math.abs(do1);
    doa2 = Math.abs(do2);
    dt = doa1 + doa2;

    if (dt === 0) {
        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
        return;
    }

    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
};

/*
* Sets the point 'p' relative to point 'rp'
* by the distance 'd'
*
* See APPENDIX on SETRELATIVE at the bottom of this file.
*
* p   ...  point to set
* rp  ... reference point
* d   ... distance on projection vector
* pv  ... projection vector (undefined = this)
* org ... if true, uses the original position of rp as reference.
*/
UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {
    pv = pv || this;

    var rpx = org ? rp.xo : rp.x;
    var rpy = org ? rp.yo : rp.y;
    var rpdx = rpx + d * pv.x;
    var rpdy = rpy + d * pv.y;

    var pvns = pv.normalSlope;
    var fvs = this.slope;

    var px = p.x;
    var py = p.y;

    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);
    p.y = fvs * (p.x - px) + py;
};

/*
* Touches the point p.
*/
UnitVector.prototype.touch = function(p) {
    p.xTouched = true;
    p.yTouched = true;
};

/*
* Returns a unit vector with x/y coordinates.
*/
function getUnitVector(x, y) {
    var d = Math.sqrt(x * x + y * y);

    x /= d;
    y /= d;

    if (x === 1 && y === 0) { return xUnitVector; }
    else if (x === 0 && y === 1) { return yUnitVector; }
    else { return new UnitVector(x, y); }
}

/*
* Creates a point in the hinting engine.
*/
function HPoint(
    x,
    y,
    lastPointOfContour,
    onCurve
) {
    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value
    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value

    this.lastPointOfContour = lastPointOfContour;
    this.onCurve = onCurve;
    this.prevPointOnContour = undefined;
    this.nextPointOnContour = undefined;
    this.xTouched = false;
    this.yTouched = false;

    Object.preventExtensions(this);
}

/*
* Returns the next touched point on the contour.
*
* v  ... unit vector to test touch axis.
*/
HPoint.prototype.nextTouched = function(v) {
    var p = this.nextPointOnContour;

    while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }

    return p;
};

/*
* Returns the previous touched point on the contour
*
* v  ... unit vector to test touch axis.
*/
HPoint.prototype.prevTouched = function(v) {
    var p = this.prevPointOnContour;

    while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }

    return p;
};

/*
* The zero point.
*/
var HPZero = Object.freeze(new HPoint(0, 0));

/*
* The default state of the interpreter.
*
* Note: Freezing the defaultState and then deriving from it
* makes the V8 Javascript engine going awkward,
* so this is avoided, albeit the defaultState shouldn't
* ever change.
*/
var defaultState = {
    cvCutIn: 17 / 16,    // control value cut in
    deltaBase: 9,
    deltaShift: 0.125,
    loop: 1,             // loops some instructions
    minDis: 1,           // minimum distance
    autoFlip: true
};

/*
* The current state of the interpreter.
*
* env  ... 'fpgm' or 'prep' or 'glyf'
* prog ... the program
*/
function State$2(env, prog) {
    this.env = env;
    this.stack = [];
    this.prog = prog;

    switch (env) {
        case 'glyf' :
            this.zp0 = this.zp1 = this.zp2 = 1;
            this.rp0 = this.rp1 = this.rp2 = 0;
            /* fall through */
        case 'prep' :
            this.fv = this.pv = this.dpv = xUnitVector;
            this.round = roundToGrid;
    }
}

/*
* Executes a glyph program.
*
* This does the hinting for each glyph.
*
* Returns an array of moved points.
*
* glyph: the glyph to hint
* ppem: the size the glyph is rendered for
*/
Hinting.prototype.exec = function(glyph, ppem) {
    if (typeof ppem !== 'number') {
        throw new Error('Point size is not a number!');
    }

    // Received a fatal error, don't do any hinting anymore.
    if (this._errorState > 2) { return; }

    var font = this.font;
    var prepState = this._prepState;

    if (!prepState || prepState.ppem !== ppem) {
        var fpgmState = this._fpgmState;

        if (!fpgmState) {
            // Executes the fpgm state.
            // This is used by fonts to define functions.
            State$2.prototype = defaultState;

            fpgmState =
            this._fpgmState =
                new State$2('fpgm', font.tables.fpgm);

            fpgmState.funcs = [ ];
            fpgmState.font = font;

            if (exports.DEBUG) {
                console.log('---EXEC FPGM---');
                fpgmState.step = -1;
            }

            try {
                exec(fpgmState);
            } catch (e) {
                console.log('Hinting error in FPGM:' + e);
                this._errorState = 3;
                return;
            }
        }

        // Executes the prep program for this ppem setting.
        // This is used by fonts to set cvt values
        // depending on to be rendered font size.

        State$2.prototype = fpgmState;
        prepState =
        this._prepState =
            new State$2('prep', font.tables.prep);

        prepState.ppem = ppem;

        // Creates a copy of the cvt table
        // and scales it to the current ppem setting.
        var oCvt = font.tables.cvt;
        if (oCvt) {
            var cvt = prepState.cvt = new Array(oCvt.length);
            var scale = ppem / font.unitsPerEm;
            for (var c = 0; c < oCvt.length; c++) {
                cvt[c] = oCvt[c] * scale;
            }
        } else {
            prepState.cvt = [];
        }

        if (exports.DEBUG) {
            console.log('---EXEC PREP---');
            prepState.step = -1;
        }

        try {
            exec(prepState);
        } catch (e) {
            if (this._errorState < 2) {
                console.log('Hinting error in PREP:' + e);
            }
            this._errorState = 2;
        }
    }

    if (this._errorState > 1) { return; }

    try {
        return execGlyph(glyph, prepState);
    } catch (e) {
        if (this._errorState < 1) {
            console.log('Hinting error:' + e);
            console.log('Note: further hinting errors are silenced');
        }
        this._errorState = 1;
        return undefined;
    }
};

/*
* Executes the hinting program for a glyph.
*/
execGlyph = function(glyph, prepState) {
    // original point positions
    var xScale = prepState.ppem / prepState.font.unitsPerEm;
    var yScale = xScale;
    var components = glyph.components;
    var contours;
    var gZone;
    var state;

    State$2.prototype = prepState;
    if (!components) {
        state = new State$2('glyf', glyph.instructions);
        if (exports.DEBUG) {
            console.log('---EXEC GLYPH---');
            state.step = -1;
        }
        execComponent(glyph, state, xScale, yScale);
        gZone = state.gZone;
    } else {
        var font = prepState.font;
        gZone = [];
        contours = [];
        for (var i = 0; i < components.length; i++) {
            var c = components[i];
            var cg = font.glyphs.get(c.glyphIndex);

            state = new State$2('glyf', cg.instructions);

            if (exports.DEBUG) {
                console.log('---EXEC COMP ' + i + '---');
                state.step = -1;
            }

            execComponent(cg, state, xScale, yScale);
            // appends the computed points to the result array
            // post processes the component points
            var dx = Math.round(c.dx * xScale);
            var dy = Math.round(c.dy * yScale);
            var gz = state.gZone;
            var cc = state.contours;
            for (var pi = 0; pi < gz.length; pi++) {
                var p = gz[pi];
                p.xTouched = p.yTouched = false;
                p.xo = p.x = p.x + dx;
                p.yo = p.y = p.y + dy;
            }

            var gLen = gZone.length;
            gZone.push.apply(gZone, gz);
            for (var j = 0; j < cc.length; j++) {
                contours.push(cc[j] + gLen);
            }
        }

        if (glyph.instructions && !state.inhibitGridFit) {
            // the composite has instructions on its own
            state = new State$2('glyf', glyph.instructions);

            state.gZone = state.z0 = state.z1 = state.z2 = gZone;

            state.contours = contours;

            // note: HPZero cannot be used here, since
            //       the point might be modified
            gZone.push(
                new HPoint(0, 0),
                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
            );

            if (exports.DEBUG) {
                console.log('---EXEC COMPOSITE---');
                state.step = -1;
            }

            exec(state);

            gZone.length -= 2;
        }
    }

    return gZone;
};

/*
* Executes the hinting program for a component of a multi-component glyph
* or of the glyph itself by a non-component glyph.
*/
execComponent = function(glyph, state, xScale, yScale)
{
    var points = glyph.points || [];
    var pLen = points.length;
    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];
    var contours = state.contours = [];

    // Scales the original points and
    // makes copies for the hinted points.
    var cp; // current point
    for (var i = 0; i < pLen; i++) {
        cp = points[i];

        gZone[i] = new HPoint(
            cp.x * xScale,
            cp.y * yScale,
            cp.lastPointOfContour,
            cp.onCurve
        );
    }

    // Chain links the contours.
    var sp; // start point
    var np; // next point

    for (var i$1 = 0; i$1 < pLen; i$1++) {
        cp = gZone[i$1];

        if (!sp) {
            sp = cp;
            contours.push(i$1);
        }

        if (cp.lastPointOfContour) {
            cp.nextPointOnContour = sp;
            sp.prevPointOnContour = cp;
            sp = undefined;
        } else {
            np = gZone[i$1 + 1];
            cp.nextPointOnContour = np;
            np.prevPointOnContour = cp;
        }
    }

    if (state.inhibitGridFit) { return; }

    gZone.push(
        new HPoint(0, 0),
        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
    );

    exec(state);

    // Removes the extra points.
    gZone.length -= 2;

    if (exports.DEBUG) {
        console.log('FINISHED GLYPH', state.stack);
        for (var i$2 = 0; i$2 < pLen; i$2++) {
            console.log(i$2, gZone[i$2].x, gZone[i$2].y);
        }
    }
};

/*
* Executes the program loaded in state.
*/
exec = function(state) {
    var prog = state.prog;

    if (!prog) { return; }

    var pLen = prog.length;
    var ins;

    for (state.ip = 0; state.ip < pLen; state.ip++) {
        if (exports.DEBUG) { state.step++; }
        ins = instructionTable[prog[state.ip]];

        if (!ins) {
            throw new Error(
                'unknown instruction: 0x' +
                Number(prog[state.ip]).toString(16)
            );
        }

        ins(state);

        // very extensive debugging for each step
        /*
        if (exports.DEBUG) {
            var da;
            if (state.gZone) {
                da = [];
                for (let i = 0; i < state.gZone.length; i++)
                {
                    da.push(i + ' ' +
                        state.gZone[i].x * 64 + ' ' +
                        state.gZone[i].y * 64 + ' ' +
                        (state.gZone[i].xTouched ? 'x' : '') +
                        (state.gZone[i].yTouched ? 'y' : '')
                    );
                }
                console.log('GZ', da);
            }

            if (state.tZone) {
                da = [];
                for (let i = 0; i < state.tZone.length; i++) {
                    da.push(i + ' ' +
                        state.tZone[i].x * 64 + ' ' +
                        state.tZone[i].y * 64 + ' ' +
                        (state.tZone[i].xTouched ? 'x' : '') +
                        (state.tZone[i].yTouched ? 'y' : '')
                    );
                }
                console.log('TZ', da);
            }

            if (state.stack.length > 10) {
                console.log(
                    state.stack.length,
                    '...', state.stack.slice(state.stack.length - 10)
                );
            } else {
                console.log(state.stack.length, state.stack);
            }
        }
        */
    }
};

/*
* Initializes the twilight zone.
*
* This is only done if a SZPx instruction
* refers to the twilight zone.
*/
function initTZone(state)
{
    var tZone = state.tZone = new Array(state.gZone.length);

    // no idea if this is actually correct...
    for (var i = 0; i < tZone.length; i++)
    {
        tZone[i] = new HPoint(0, 0);
    }
}

/*
* Skips the instruction pointer ahead over an IF/ELSE block.
* handleElse .. if true breaks on matching ELSE
*/
function skip(state, handleElse)
{
    var prog = state.prog;
    var ip = state.ip;
    var nesting = 1;
    var ins;

    do {
        ins = prog[++ip];
        if (ins === 0x58) // IF
            { nesting++; }
        else if (ins === 0x59) // EIF
            { nesting--; }
        else if (ins === 0x40) // NPUSHB
            { ip += prog[ip + 1] + 1; }
        else if (ins === 0x41) // NPUSHW
            { ip += 2 * prog[ip + 1] + 1; }
        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB
            { ip += ins - 0xB0 + 1; }
        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW
            { ip += (ins - 0xB8 + 1) * 2; }
        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE
            { break; }
    } while (nesting > 0);

    state.ip = ip;
}

/*----------------------------------------------------------*
*          And then a lot of instructions...                *
*----------------------------------------------------------*/

// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis
// 0x00-0x01
function SVTCA(v, state) {
    if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }

    state.fv = state.pv = state.dpv = v;
}

// SPVTCA[a] Set Projection Vector to Coordinate Axis
// 0x02-0x03
function SPVTCA(v, state) {
    if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }

    state.pv = state.dpv = v;
}

// SFVTCA[a] Set Freedom Vector to Coordinate Axis
// 0x04-0x05
function SFVTCA(v, state) {
    if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }

    state.fv = v;
}

// SPVTL[a] Set Projection Vector To Line
// 0x06-0x07
function SPVTL(a, state) {
    var stack = state.stack;
    var p2i = stack.pop();
    var p1i = stack.pop();
    var p2 = state.z2[p2i];
    var p1 = state.z1[p1i];

    if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }

    var dx;
    var dy;

    if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
    } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
    }

    state.pv = state.dpv = getUnitVector(dx, dy);
}

// SFVTL[a] Set Freedom Vector To Line
// 0x08-0x09
function SFVTL(a, state) {
    var stack = state.stack;
    var p2i = stack.pop();
    var p1i = stack.pop();
    var p2 = state.z2[p2i];
    var p1 = state.z1[p1i];

    if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }

    var dx;
    var dy;

    if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
    } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
    }

    state.fv = getUnitVector(dx, dy);
}

// SPVFS[] Set Projection Vector From Stack
// 0x0A
function SPVFS(state) {
    var stack = state.stack;
    var y = stack.pop();
    var x = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }

    state.pv = state.dpv = getUnitVector(x, y);
}

// SFVFS[] Set Freedom Vector From Stack
// 0x0B
function SFVFS(state) {
    var stack = state.stack;
    var y = stack.pop();
    var x = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }

    state.fv = getUnitVector(x, y);
}

// GPV[] Get Projection Vector
// 0x0C
function GPV(state) {
    var stack = state.stack;
    var pv = state.pv;

    if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }

    stack.push(pv.x * 0x4000);
    stack.push(pv.y * 0x4000);
}

// GFV[] Get Freedom Vector
// 0x0C
function GFV(state) {
    var stack = state.stack;
    var fv = state.fv;

    if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }

    stack.push(fv.x * 0x4000);
    stack.push(fv.y * 0x4000);
}

// SFVTPV[] Set Freedom Vector To Projection Vector
// 0x0E
function SFVTPV(state) {
    state.fv = state.pv;

    if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }
}

// ISECT[] moves point p to the InterSECTion of two lines
// 0x0F
function ISECT(state)
{
    var stack = state.stack;
    var pa0i = stack.pop();
    var pa1i = stack.pop();
    var pb0i = stack.pop();
    var pb1i = stack.pop();
    var pi = stack.pop();
    var z0 = state.z0;
    var z1 = state.z1;
    var pa0 = z0[pa0i];
    var pa1 = z0[pa1i];
    var pb0 = z1[pb0i];
    var pb1 = z1[pb1i];
    var p = state.z2[pi];

    if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }

    // math from
    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line

    var x1 = pa0.x;
    var y1 = pa0.y;
    var x2 = pa1.x;
    var y2 = pa1.y;
    var x3 = pb0.x;
    var y3 = pb0.y;
    var x4 = pb1.x;
    var y4 = pb1.y;

    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    var f1 = x1 * y2 - y1 * x2;
    var f2 = x3 * y4 - y3 * x4;

    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;
    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;
}

// SRP0[] Set Reference Point 0
// 0x10
function SRP0(state) {
    state.rp0 = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }
}

// SRP1[] Set Reference Point 1
// 0x11
function SRP1(state) {
    state.rp1 = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }
}

// SRP1[] Set Reference Point 2
// 0x12
function SRP2(state) {
    state.rp2 = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }
}

// SZP0[] Set Zone Pointer 0
// 0x13
function SZP0(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }

    state.zp0 = n;

    switch (n) {
        case 0:
            if (!state.tZone) { initTZone(state); }
            state.z0 = state.tZone;
            break;
        case 1 :
            state.z0 = state.gZone;
            break;
        default :
            throw new Error('Invalid zone pointer');
    }
}

// SZP1[] Set Zone Pointer 1
// 0x14
function SZP1(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }

    state.zp1 = n;

    switch (n) {
        case 0:
            if (!state.tZone) { initTZone(state); }
            state.z1 = state.tZone;
            break;
        case 1 :
            state.z1 = state.gZone;
            break;
        default :
            throw new Error('Invalid zone pointer');
    }
}

// SZP2[] Set Zone Pointer 2
// 0x15
function SZP2(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }

    state.zp2 = n;

    switch (n) {
        case 0:
            if (!state.tZone) { initTZone(state); }
            state.z2 = state.tZone;
            break;
        case 1 :
            state.z2 = state.gZone;
            break;
        default :
            throw new Error('Invalid zone pointer');
    }
}

// SZPS[] Set Zone PointerS
// 0x16
function SZPS(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }

    state.zp0 = state.zp1 = state.zp2 = n;

    switch (n) {
        case 0:
            if (!state.tZone) { initTZone(state); }
            state.z0 = state.z1 = state.z2 = state.tZone;
            break;
        case 1 :
            state.z0 = state.z1 = state.z2 = state.gZone;
            break;
        default :
            throw new Error('Invalid zone pointer');
    }
}

// SLOOP[] Set LOOP variable
// 0x17
function SLOOP(state) {
    state.loop = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }
}

// RTG[] Round To Grid
// 0x18
function RTG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }

    state.round = roundToGrid;
}

// RTHG[] Round To Half Grid
// 0x19
function RTHG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }

    state.round = roundToHalfGrid;
}

// SMD[] Set Minimum Distance
// 0x1A
function SMD(state) {
    var d = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }

    state.minDis = d / 0x40;
}

// ELSE[] ELSE clause
// 0x1B
function ELSE(state) {
    // This instruction has been reached by executing a then branch
    // so it just skips ahead until matching EIF.
    //
    // In case the IF was negative the IF[] instruction already
    // skipped forward over the ELSE[]

    if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }

    skip(state, false);
}

// JMPR[] JuMP Relative
// 0x1C
function JMPR(state) {
    var o = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }

    // A jump by 1 would do nothing.
    state.ip += o - 1;
}

// SCVTCI[] Set Control Value Table Cut-In
// 0x1D
function SCVTCI(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }

    state.cvCutIn = n / 0x40;
}

// DUP[] DUPlicate top stack element
// 0x20
function DUP(state) {
    var stack = state.stack;

    if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }

    stack.push(stack[stack.length - 1]);
}

// POP[] POP top stack element
// 0x21
function POP(state) {
    if (exports.DEBUG) { console.log(state.step, 'POP[]'); }

    state.stack.pop();
}

// CLEAR[] CLEAR the stack
// 0x22
function CLEAR(state) {
    if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }

    state.stack.length = 0;
}

// SWAP[] SWAP the top two elements on the stack
// 0x23
function SWAP(state) {
    var stack = state.stack;

    var a = stack.pop();
    var b = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }

    stack.push(a);
    stack.push(b);
}

// DEPTH[] DEPTH of the stack
// 0x24
function DEPTH(state) {
    var stack = state.stack;

    if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }

    stack.push(stack.length);
}

// LOOPCALL[] LOOPCALL function
// 0x2A
function LOOPCALL(state) {
    var stack = state.stack;
    var fn = stack.pop();
    var c = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }

    // saves callers program
    var cip = state.ip;
    var cprog = state.prog;

    state.prog = state.funcs[fn];

    // executes the function
    for (var i = 0; i < c; i++) {
        exec(state);

        if (exports.DEBUG) { console.log(
            ++state.step,
            i + 1 < c ? 'next loopcall' : 'done loopcall',
            i
        ); }
    }

    // restores the callers program
    state.ip = cip;
    state.prog = cprog;
}

// CALL[] CALL function
// 0x2B
function CALL(state) {
    var fn = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }

    // saves callers program
    var cip = state.ip;
    var cprog = state.prog;

    state.prog = state.funcs[fn];

    // executes the function
    exec(state);

    // restores the callers program
    state.ip = cip;
    state.prog = cprog;

    if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }
}

// CINDEX[] Copy the INDEXed element to the top of the stack
// 0x25
function CINDEX(state) {
    var stack = state.stack;
    var k = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }

    // In case of k == 1, it copies the last element after popping
    // thus stack.length - k.
    stack.push(stack[stack.length - k]);
}

// MINDEX[] Move the INDEXed element to the top of the stack
// 0x26
function MINDEX(state) {
    var stack = state.stack;
    var k = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }

    stack.push(stack.splice(stack.length - k, 1)[0]);
}

// FDEF[] Function DEFinition
// 0x2C
function FDEF(state) {
    if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }
    var stack = state.stack;
    var prog = state.prog;
    var ip = state.ip;

    var fn = stack.pop();
    var ipBegin = ip;

    if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }

    while (prog[++ip] !== 0x2D){  }

    state.ip = ip;
    state.funcs[fn] = prog.slice(ipBegin + 1, ip);
}

// MDAP[a] Move Direct Absolute Point
// 0x2E-0x2F
function MDAP(round, state) {
    var pi = state.stack.pop();
    var p = state.z0[pi];
    var fv = state.fv;
    var pv = state.pv;

    if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }

    var d = pv.distance(p, HPZero);

    if (round) { d = state.round(d); }

    fv.setRelative(p, HPZero, d, pv);
    fv.touch(p);

    state.rp0 = state.rp1 = pi;
}

// IUP[a] Interpolate Untouched Points through the outline
// 0x30
function IUP(v, state) {
    var z2 = state.z2;
    var pLen = z2.length - 2;
    var cp;
    var pp;
    var np;

    if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }

    for (var i = 0; i < pLen; i++) {
        cp = z2[i]; // current point

        // if this point has been touched go on
        if (v.touched(cp)) { continue; }

        pp = cp.prevTouched(v);

        // no point on the contour has been touched?
        if (pp === cp) { continue; }

        np = cp.nextTouched(v);

        if (pp === np) {
            // only one point on the contour has been touched
            // so simply moves the point like that

            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);
        }

        v.interpolate(cp, pp, np, v);
    }
}

// SHP[] SHift Point using reference point
// 0x32-0x33
function SHP(a, state) {
    var stack = state.stack;
    var rpi = a ? state.rp1 : state.rp2;
    var rp = (a ? state.z0 : state.z1)[rpi];
    var fv = state.fv;
    var pv = state.pv;
    var loop = state.loop;
    var z2 = state.z2;

    while (loop--)
    {
        var pi = stack.pop();
        var p = z2[pi];

        var d = pv.distance(rp, rp, false, true);
        fv.setRelative(p, p, d, pv);
        fv.touch(p);

        if (exports.DEBUG) {
            console.log(
                state.step,
                (state.loop > 1 ?
                   'loop ' + (state.loop - loop) + ': ' :
                   ''
                ) +
                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi
            );
        }
    }

    state.loop = 1;
}

// SHC[] SHift Contour using reference point
// 0x36-0x37
function SHC(a, state) {
    var stack = state.stack;
    var rpi = a ? state.rp1 : state.rp2;
    var rp = (a ? state.z0 : state.z1)[rpi];
    var fv = state.fv;
    var pv = state.pv;
    var ci = stack.pop();
    var sp = state.z2[state.contours[ci]];
    var p = sp;

    if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }

    var d = pv.distance(rp, rp, false, true);

    do {
        if (p !== rp) { fv.setRelative(p, p, d, pv); }
        p = p.nextPointOnContour;
    } while (p !== sp);
}

// SHZ[] SHift Zone using reference point
// 0x36-0x37
function SHZ(a, state) {
    var stack = state.stack;
    var rpi = a ? state.rp1 : state.rp2;
    var rp = (a ? state.z0 : state.z1)[rpi];
    var fv = state.fv;
    var pv = state.pv;

    var e = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }

    var z;
    switch (e) {
        case 0 : z = state.tZone; break;
        case 1 : z = state.gZone; break;
        default : throw new Error('Invalid zone');
    }

    var p;
    var d = pv.distance(rp, rp, false, true);
    var pLen = z.length - 2;
    for (var i = 0; i < pLen; i++)
    {
        p = z[i];
        if (p !== rp) { fv.setRelative(p, p, d, pv); }
    }
}

// SHPIX[] SHift point by a PIXel amount
// 0x38
function SHPIX(state) {
    var stack = state.stack;
    var loop = state.loop;
    var fv = state.fv;
    var d = stack.pop() / 0x40;
    var z2 = state.z2;

    while (loop--) {
        var pi = stack.pop();
        var p = z2[pi];

        if (exports.DEBUG) {
            console.log(
                state.step,
                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
                'SHPIX[]', pi, d
            );
        }

        fv.setRelative(p, p, d);
        fv.touch(p);
    }

    state.loop = 1;
}

// IP[] Interpolate Point
// 0x39
function IP(state) {
    var stack = state.stack;
    var rp1i = state.rp1;
    var rp2i = state.rp2;
    var loop = state.loop;
    var rp1 = state.z0[rp1i];
    var rp2 = state.z1[rp2i];
    var fv = state.fv;
    var pv = state.dpv;
    var z2 = state.z2;

    while (loop--) {
        var pi = stack.pop();
        var p = z2[pi];

        if (exports.DEBUG) {
            console.log(
                state.step,
                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
                'IP[]', pi, rp1i, '<->', rp2i
            );
        }

        fv.interpolate(p, rp1, rp2, pv);

        fv.touch(p);
    }

    state.loop = 1;
}

// MSIRP[a] Move Stack Indirect Relative Point
// 0x3A-0x3B
function MSIRP(a, state) {
    var stack = state.stack;
    var d = stack.pop() / 64;
    var pi = stack.pop();
    var p = state.z1[pi];
    var rp0 = state.z0[state.rp0];
    var fv = state.fv;
    var pv = state.pv;

    fv.setRelative(p, rp0, d, pv);
    fv.touch(p);

    if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }

    state.rp1 = state.rp0;
    state.rp2 = pi;
    if (a) { state.rp0 = pi; }
}

// ALIGNRP[] Align to reference point.
// 0x3C
function ALIGNRP(state) {
    var stack = state.stack;
    var rp0i = state.rp0;
    var rp0 = state.z0[rp0i];
    var loop = state.loop;
    var fv = state.fv;
    var pv = state.pv;
    var z1 = state.z1;

    while (loop--) {
        var pi = stack.pop();
        var p = z1[pi];

        if (exports.DEBUG) {
            console.log(
                state.step,
                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
                'ALIGNRP[]', pi
            );
        }

        fv.setRelative(p, rp0, 0, pv);
        fv.touch(p);
    }

    state.loop = 1;
}

// RTG[] Round To Double Grid
// 0x3D
function RTDG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }

    state.round = roundToDoubleGrid;
}

// MIAP[a] Move Indirect Absolute Point
// 0x3E-0x3F
function MIAP(round, state) {
    var stack = state.stack;
    var n = stack.pop();
    var pi = stack.pop();
    var p = state.z0[pi];
    var fv = state.fv;
    var pv = state.pv;
    var cv = state.cvt[n];

    // TODO cvtcutin should be considered here
    if (round) { cv = state.round(cv); }

    if (exports.DEBUG) {
        console.log(
            state.step,
            'MIAP[' + round + ']',
            n, '(', cv, ')', pi
        );
    }

    fv.setRelative(p, HPZero, cv, pv);

    if (state.zp0 === 0) {
        p.xo = p.x;
        p.yo = p.y;
    }

    fv.touch(p);

    state.rp0 = state.rp1 = pi;
}

// NPUSB[] PUSH N Bytes
// 0x40
function NPUSHB(state) {
    var prog = state.prog;
    var ip = state.ip;
    var stack = state.stack;

    var n = prog[++ip];

    if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }

    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }

    state.ip = ip;
}

// NPUSHW[] PUSH N Words
// 0x41
function NPUSHW(state) {
    var ip = state.ip;
    var prog = state.prog;
    var stack = state.stack;
    var n = prog[++ip];

    if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }

    for (var i = 0; i < n; i++) {
        var w = (prog[++ip] << 8) | prog[++ip];
        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
        stack.push(w);
    }

    state.ip = ip;
}

// WS[] Write Store
// 0x42
function WS(state) {
    var stack = state.stack;
    var store = state.store;

    if (!store) { store = state.store = []; }

    var v = stack.pop();
    var l = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }

    store[l] = v;
}

// RS[] Read Store
// 0x43
function RS(state) {
    var stack = state.stack;
    var store = state.store;

    var l = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'RS', l); }

    var v = (store && store[l]) || 0;

    stack.push(v);
}

// WCVTP[] Write Control Value Table in Pixel units
// 0x44
function WCVTP(state) {
    var stack = state.stack;

    var v = stack.pop();
    var l = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }

    state.cvt[l] = v / 0x40;
}

// RCVT[] Read Control Value Table entry
// 0x45
function RCVT(state) {
    var stack = state.stack;
    var cvte = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }

    stack.push(state.cvt[cvte] * 0x40);
}

// GC[] Get Coordinate projected onto the projection vector
// 0x46-0x47
function GC(a, state) {
    var stack = state.stack;
    var pi = stack.pop();
    var p = state.z2[pi];

    if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }

    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);
}

// MD[a] Measure Distance
// 0x49-0x4A
function MD(a, state) {
    var stack = state.stack;
    var pi2 = stack.pop();
    var pi1 = stack.pop();
    var p2 = state.z1[pi2];
    var p1 = state.z0[pi1];
    var d = state.dpv.distance(p1, p2, a, a);

    if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }

    state.stack.push(Math.round(d * 64));
}

// MPPEM[] Measure Pixels Per EM
// 0x4B
function MPPEM(state) {
    if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }
    state.stack.push(state.ppem);
}

// FLIPON[] set the auto FLIP Boolean to ON
// 0x4D
function FLIPON(state) {
    if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }
    state.autoFlip = true;
}

// LT[] Less Than
// 0x50
function LT(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }

    stack.push(e1 < e2 ? 1 : 0);
}

// LTEQ[] Less Than or EQual
// 0x53
function LTEQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }

    stack.push(e1 <= e2 ? 1 : 0);
}

// GTEQ[] Greater Than
// 0x52
function GT(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }

    stack.push(e1 > e2 ? 1 : 0);
}

// GTEQ[] Greater Than or EQual
// 0x53
function GTEQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }

    stack.push(e1 >= e2 ? 1 : 0);
}

// EQ[] EQual
// 0x54
function EQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }

    stack.push(e2 === e1 ? 1 : 0);
}

// NEQ[] Not EQual
// 0x55
function NEQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }

    stack.push(e2 !== e1 ? 1 : 0);
}

// ODD[] ODD
// 0x56
function ODD(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }

    stack.push(Math.trunc(n) % 2 ? 1 : 0);
}

// EVEN[] EVEN
// 0x57
function EVEN(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }

    stack.push(Math.trunc(n) % 2 ? 0 : 1);
}

// IF[] IF test
// 0x58
function IF(state) {
    var test = state.stack.pop();
    var ins;

    if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }

    // if test is true it just continues
    // if not the ip is skipped until matching ELSE or EIF
    if (!test) {
        skip(state, true);

        if (exports.DEBUG) { console.log(state.step, ins === 0x1B ? 'ELSE[]' : 'EIF[]'); }
    }
}

// EIF[] End IF
// 0x59
function EIF(state) {
    // this can be reached normally when
    // executing an else branch.
    // -> just ignore it

    if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }
}

// AND[] logical AND
// 0x5A
function AND(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }

    stack.push(e2 && e1 ? 1 : 0);
}

// OR[] logical OR
// 0x5B
function OR(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }

    stack.push(e2 || e1 ? 1 : 0);
}

// NOT[] logical NOT
// 0x5C
function NOT(state) {
    var stack = state.stack;
    var e = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }

    stack.push(e ? 0 : 1);
}

// DELTAP1[] DELTA exception P1
// DELTAP2[] DELTA exception P2
// DELTAP3[] DELTA exception P3
// 0x5D, 0x71, 0x72
function DELTAP123(b, state) {
    var stack = state.stack;
    var n = stack.pop();
    var fv = state.fv;
    var pv = state.pv;
    var ppem = state.ppem;
    var base = state.deltaBase + (b - 1) * 16;
    var ds = state.deltaShift;
    var z0 = state.z0;

    if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }

    for (var i = 0; i < n; i++)
    {
        var pi = stack.pop();
        var arg = stack.pop();
        var appem = base + ((arg & 0xF0) >> 4);
        if (appem !== ppem) { continue; }

        var mag = (arg & 0x0F) - 8;
        if (mag >= 0) { mag++; }
        if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }

        var p = z0[pi];
        fv.setRelative(p, p, mag * ds, pv);
    }
}

// SDB[] Set Delta Base in the graphics state
// 0x5E
function SDB(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }

    state.deltaBase = n;
}

// SDS[] Set Delta Shift in the graphics state
// 0x5F
function SDS(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }

    state.deltaShift = Math.pow(0.5, n);
}

// ADD[] ADD
// 0x60
function ADD(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }

    stack.push(n1 + n2);
}

// SUB[] SUB
// 0x61
function SUB(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }

    stack.push(n1 - n2);
}

// DIV[] DIV
// 0x62
function DIV(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }

    stack.push(n1 * 64 / n2);
}

// MUL[] MUL
// 0x63
function MUL(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }

    stack.push(n1 * n2 / 64);
}

// ABS[] ABSolute value
// 0x64
function ABS(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }

    stack.push(Math.abs(n));
}

// NEG[] NEGate
// 0x65
function NEG(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }

    stack.push(-n);
}

// FLOOR[] FLOOR
// 0x66
function FLOOR(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }

    stack.push(Math.floor(n / 0x40) * 0x40);
}

// CEILING[] CEILING
// 0x67
function CEILING(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }

    stack.push(Math.ceil(n / 0x40) * 0x40);
}

// ROUND[ab] ROUND value
// 0x68-0x6B
function ROUND(dt, state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }

    stack.push(state.round(n / 0x40) * 0x40);
}

// WCVTF[] Write Control Value Table in Funits
// 0x70
function WCVTF(state) {
    var stack = state.stack;
    var v = stack.pop();
    var l = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }

    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;
}

// DELTAC1[] DELTA exception C1
// DELTAC2[] DELTA exception C2
// DELTAC3[] DELTA exception C3
// 0x73, 0x74, 0x75
function DELTAC123(b, state) {
    var stack = state.stack;
    var n = stack.pop();
    var ppem = state.ppem;
    var base = state.deltaBase + (b - 1) * 16;
    var ds = state.deltaShift;

    if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }

    for (var i = 0; i < n; i++) {
        var c = stack.pop();
        var arg = stack.pop();
        var appem = base + ((arg & 0xF0) >> 4);
        if (appem !== ppem) { continue; }

        var mag = (arg & 0x0F) - 8;
        if (mag >= 0) { mag++; }

        var delta = mag * ds;

        if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }

        state.cvt[c] += delta;
    }
}

// SROUND[] Super ROUND
// 0x76
function SROUND(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }

    state.round = roundSuper;

    var period;

    switch (n & 0xC0) {
        case 0x00:
            period = 0.5;
            break;
        case 0x40:
            period = 1;
            break;
        case 0x80:
            period = 2;
            break;
        default:
            throw new Error('invalid SROUND value');
    }

    state.srPeriod = period;

    switch (n & 0x30) {
        case 0x00:
            state.srPhase = 0;
            break;
        case 0x10:
            state.srPhase = 0.25 * period;
            break;
        case 0x20:
            state.srPhase = 0.5  * period;
            break;
        case 0x30:
            state.srPhase = 0.75 * period;
            break;
        default: throw new Error('invalid SROUND value');
    }

    n &= 0x0F;

    if (n === 0) { state.srThreshold = 0; }
    else { state.srThreshold = (n / 8 - 0.5) * period; }
}

// S45ROUND[] Super ROUND 45 degrees
// 0x77
function S45ROUND(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }

    state.round = roundSuper;

    var period;

    switch (n & 0xC0) {
        case 0x00:
            period = Math.sqrt(2) / 2;
            break;
        case 0x40:
            period = Math.sqrt(2);
            break;
        case 0x80:
            period = 2 * Math.sqrt(2);
            break;
        default:
            throw new Error('invalid S45ROUND value');
    }

    state.srPeriod = period;

    switch (n & 0x30) {
        case 0x00:
            state.srPhase = 0;
            break;
        case 0x10:
            state.srPhase = 0.25 * period;
            break;
        case 0x20:
            state.srPhase = 0.5  * period;
            break;
        case 0x30:
            state.srPhase = 0.75 * period;
            break;
        default:
            throw new Error('invalid S45ROUND value');
    }

    n &= 0x0F;

    if (n === 0) { state.srThreshold = 0; }
    else { state.srThreshold = (n / 8 - 0.5) * period; }
}

// ROFF[] Round Off
// 0x7A
function ROFF(state) {
    if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }

    state.round = roundOff;
}

// RUTG[] Round Up To Grid
// 0x7C
function RUTG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }

    state.round = roundUpToGrid;
}

// RDTG[] Round Down To Grid
// 0x7D
function RDTG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }

    state.round = roundDownToGrid;
}

// SCANCTRL[] SCAN conversion ConTRoL
// 0x85
function SCANCTRL(state) {
    var n = state.stack.pop();

    // ignored by opentype.js

    if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }
}

// SDPVTL[a] Set Dual Projection Vector To Line
// 0x86-0x87
function SDPVTL(a, state) {
    var stack = state.stack;
    var p2i = stack.pop();
    var p1i = stack.pop();
    var p2 = state.z2[p2i];
    var p1 = state.z1[p1i];

    if (exports.DEBUG) { console.log('SDPVTL[' + a + ']', p2i, p1i); }

    var dx;
    var dy;

    if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
    } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
    }

    state.dpv = getUnitVector(dx, dy);
}

// GETINFO[] GET INFOrmation
// 0x88
function GETINFO(state) {
    var stack = state.stack;
    var sel = stack.pop();
    var r = 0;

    if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }

    // v35 as in no subpixel hinting
    if (sel & 0x01) { r = 35; }

    // TODO rotation and stretch currently not supported
    // and thus those GETINFO are always 0.

    // opentype.js is always gray scaling
    if (sel & 0x20) { r |= 0x1000; }

    stack.push(r);
}

// ROLL[] ROLL the top three stack elements
// 0x8A
function ROLL(state) {
    var stack = state.stack;
    var a = stack.pop();
    var b = stack.pop();
    var c = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }

    stack.push(b);
    stack.push(a);
    stack.push(c);
}

// MAX[] MAXimum of top two stack elements
// 0x8B
function MAX(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }

    stack.push(Math.max(e1, e2));
}

// MIN[] MINimum of top two stack elements
// 0x8C
function MIN(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }

    stack.push(Math.min(e1, e2));
}

// SCANTYPE[] SCANTYPE
// 0x8D
function SCANTYPE(state) {
    var n = state.stack.pop();
    // ignored by opentype.js
    if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }
}

// INSTCTRL[] INSTCTRL
// 0x8D
function INSTCTRL(state) {
    var s = state.stack.pop();
    var v = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }

    switch (s) {
        case 1 : state.inhibitGridFit = !!v; return;
        case 2 : state.ignoreCvt = !!v; return;
        default: throw new Error('invalid INSTCTRL[] selector');
    }
}

// PUSHB[abc] PUSH Bytes
// 0xB0-0xB7
function PUSHB(n, state) {
    var stack = state.stack;
    var prog = state.prog;
    var ip = state.ip;

    if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }

    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }

    state.ip = ip;
}

// PUSHW[abc] PUSH Words
// 0xB8-0xBF
function PUSHW(n, state) {
    var ip = state.ip;
    var prog = state.prog;
    var stack = state.stack;

    if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }

    for (var i = 0; i < n; i++) {
        var w = (prog[++ip] << 8) | prog[++ip];
        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
        stack.push(w);
    }

    state.ip = ip;
}

// MDRP[abcde] Move Direct Relative Point
// 0xD0-0xEF
// (if indirect is 0)
//
// and
//
// MIRP[abcde] Move Indirect Relative Point
// 0xE0-0xFF
// (if indirect is 1)

function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {
    var stack = state.stack;
    var cvte = indirect && stack.pop();
    var pi = stack.pop();
    var rp0i = state.rp0;
    var rp = state.z0[rp0i];
    var p = state.z1[pi];

    var md = state.minDis;
    var fv = state.fv;
    var pv = state.dpv;
    var od; // original distance
    var d; // moving distance
    var sign; // sign of distance
    var cv;

    d = od = pv.distance(p, rp, true, true);
    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0

    // TODO consider autoFlip
    d = Math.abs(d);

    if (indirect) {
        cv = state.cvt[cvte];

        if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }
    }

    if (keepD && d < md) { d = md; }

    if (ro) { d = state.round(d); }

    fv.setRelative(p, rp, sign * d, pv);
    fv.touch(p);

    if (exports.DEBUG) {
        console.log(
            state.step,
            (indirect ? 'MIRP[' : 'MDRP[') +
            (setRp0 ? 'M' : 'm') +
            (keepD ? '>' : '_') +
            (ro ? 'R' : '_') +
            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +
            ']',
            indirect ?
                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :
                '',
            pi,
            '(d =', od, '->', sign * d, ')'
        );
    }

    state.rp1 = state.rp0;
    state.rp2 = pi;
    if (setRp0) { state.rp0 = pi; }
}

/*
* The instruction table.
*/
instructionTable = [
    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),
    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),
    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),
    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),
    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),
    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),
    /* 0x06 */ SPVTL.bind(undefined, 0),
    /* 0x07 */ SPVTL.bind(undefined, 1),
    /* 0x08 */ SFVTL.bind(undefined, 0),
    /* 0x09 */ SFVTL.bind(undefined, 1),
    /* 0x0A */ SPVFS,
    /* 0x0B */ SFVFS,
    /* 0x0C */ GPV,
    /* 0x0D */ GFV,
    /* 0x0E */ SFVTPV,
    /* 0x0F */ ISECT,
    /* 0x10 */ SRP0,
    /* 0x11 */ SRP1,
    /* 0x12 */ SRP2,
    /* 0x13 */ SZP0,
    /* 0x14 */ SZP1,
    /* 0x15 */ SZP2,
    /* 0x16 */ SZPS,
    /* 0x17 */ SLOOP,
    /* 0x18 */ RTG,
    /* 0x19 */ RTHG,
    /* 0x1A */ SMD,
    /* 0x1B */ ELSE,
    /* 0x1C */ JMPR,
    /* 0x1D */ SCVTCI,
    /* 0x1E */ undefined,   // TODO SSWCI
    /* 0x1F */ undefined,   // TODO SSW
    /* 0x20 */ DUP,
    /* 0x21 */ POP,
    /* 0x22 */ CLEAR,
    /* 0x23 */ SWAP,
    /* 0x24 */ DEPTH,
    /* 0x25 */ CINDEX,
    /* 0x26 */ MINDEX,
    /* 0x27 */ undefined,   // TODO ALIGNPTS
    /* 0x28 */ undefined,
    /* 0x29 */ undefined,   // TODO UTP
    /* 0x2A */ LOOPCALL,
    /* 0x2B */ CALL,
    /* 0x2C */ FDEF,
    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)
    /* 0x2E */ MDAP.bind(undefined, 0),
    /* 0x2F */ MDAP.bind(undefined, 1),
    /* 0x30 */ IUP.bind(undefined, yUnitVector),
    /* 0x31 */ IUP.bind(undefined, xUnitVector),
    /* 0x32 */ SHP.bind(undefined, 0),
    /* 0x33 */ SHP.bind(undefined, 1),
    /* 0x34 */ SHC.bind(undefined, 0),
    /* 0x35 */ SHC.bind(undefined, 1),
    /* 0x36 */ SHZ.bind(undefined, 0),
    /* 0x37 */ SHZ.bind(undefined, 1),
    /* 0x38 */ SHPIX,
    /* 0x39 */ IP,
    /* 0x3A */ MSIRP.bind(undefined, 0),
    /* 0x3B */ MSIRP.bind(undefined, 1),
    /* 0x3C */ ALIGNRP,
    /* 0x3D */ RTDG,
    /* 0x3E */ MIAP.bind(undefined, 0),
    /* 0x3F */ MIAP.bind(undefined, 1),
    /* 0x40 */ NPUSHB,
    /* 0x41 */ NPUSHW,
    /* 0x42 */ WS,
    /* 0x43 */ RS,
    /* 0x44 */ WCVTP,
    /* 0x45 */ RCVT,
    /* 0x46 */ GC.bind(undefined, 0),
    /* 0x47 */ GC.bind(undefined, 1),
    /* 0x48 */ undefined,   // TODO SCFS
    /* 0x49 */ MD.bind(undefined, 0),
    /* 0x4A */ MD.bind(undefined, 1),
    /* 0x4B */ MPPEM,
    /* 0x4C */ undefined,   // TODO MPS
    /* 0x4D */ FLIPON,
    /* 0x4E */ undefined,   // TODO FLIPOFF
    /* 0x4F */ undefined,   // TODO DEBUG
    /* 0x50 */ LT,
    /* 0x51 */ LTEQ,
    /* 0x52 */ GT,
    /* 0x53 */ GTEQ,
    /* 0x54 */ EQ,
    /* 0x55 */ NEQ,
    /* 0x56 */ ODD,
    /* 0x57 */ EVEN,
    /* 0x58 */ IF,
    /* 0x59 */ EIF,
    /* 0x5A */ AND,
    /* 0x5B */ OR,
    /* 0x5C */ NOT,
    /* 0x5D */ DELTAP123.bind(undefined, 1),
    /* 0x5E */ SDB,
    /* 0x5F */ SDS,
    /* 0x60 */ ADD,
    /* 0x61 */ SUB,
    /* 0x62 */ DIV,
    /* 0x63 */ MUL,
    /* 0x64 */ ABS,
    /* 0x65 */ NEG,
    /* 0x66 */ FLOOR,
    /* 0x67 */ CEILING,
    /* 0x68 */ ROUND.bind(undefined, 0),
    /* 0x69 */ ROUND.bind(undefined, 1),
    /* 0x6A */ ROUND.bind(undefined, 2),
    /* 0x6B */ ROUND.bind(undefined, 3),
    /* 0x6C */ undefined,   // TODO NROUND[ab]
    /* 0x6D */ undefined,   // TODO NROUND[ab]
    /* 0x6E */ undefined,   // TODO NROUND[ab]
    /* 0x6F */ undefined,   // TODO NROUND[ab]
    /* 0x70 */ WCVTF,
    /* 0x71 */ DELTAP123.bind(undefined, 2),
    /* 0x72 */ DELTAP123.bind(undefined, 3),
    /* 0x73 */ DELTAC123.bind(undefined, 1),
    /* 0x74 */ DELTAC123.bind(undefined, 2),
    /* 0x75 */ DELTAC123.bind(undefined, 3),
    /* 0x76 */ SROUND,
    /* 0x77 */ S45ROUND,
    /* 0x78 */ undefined,   // TODO JROT[]
    /* 0x79 */ undefined,   // TODO JROF[]
    /* 0x7A */ ROFF,
    /* 0x7B */ undefined,
    /* 0x7C */ RUTG,
    /* 0x7D */ RDTG,
    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though
    /* 0x7F */ POP, // actually AA, supposed to do only a pop though
    /* 0x80 */ undefined,   // TODO FLIPPT
    /* 0x81 */ undefined,   // TODO FLIPRGON
    /* 0x82 */ undefined,   // TODO FLIPRGOFF
    /* 0x83 */ undefined,
    /* 0x84 */ undefined,
    /* 0x85 */ SCANCTRL,
    /* 0x86 */ SDPVTL.bind(undefined, 0),
    /* 0x87 */ SDPVTL.bind(undefined, 1),
    /* 0x88 */ GETINFO,
    /* 0x89 */ undefined,   // TODO IDEF
    /* 0x8A */ ROLL,
    /* 0x8B */ MAX,
    /* 0x8C */ MIN,
    /* 0x8D */ SCANTYPE,
    /* 0x8E */ INSTCTRL,
    /* 0x8F */ undefined,
    /* 0x90 */ undefined,
    /* 0x91 */ undefined,
    /* 0x92 */ undefined,
    /* 0x93 */ undefined,
    /* 0x94 */ undefined,
    /* 0x95 */ undefined,
    /* 0x96 */ undefined,
    /* 0x97 */ undefined,
    /* 0x98 */ undefined,
    /* 0x99 */ undefined,
    /* 0x9A */ undefined,
    /* 0x9B */ undefined,
    /* 0x9C */ undefined,
    /* 0x9D */ undefined,
    /* 0x9E */ undefined,
    /* 0x9F */ undefined,
    /* 0xA0 */ undefined,
    /* 0xA1 */ undefined,
    /* 0xA2 */ undefined,
    /* 0xA3 */ undefined,
    /* 0xA4 */ undefined,
    /* 0xA5 */ undefined,
    /* 0xA6 */ undefined,
    /* 0xA7 */ undefined,
    /* 0xA8 */ undefined,
    /* 0xA9 */ undefined,
    /* 0xAA */ undefined,
    /* 0xAB */ undefined,
    /* 0xAC */ undefined,
    /* 0xAD */ undefined,
    /* 0xAE */ undefined,
    /* 0xAF */ undefined,
    /* 0xB0 */ PUSHB.bind(undefined, 1),
    /* 0xB1 */ PUSHB.bind(undefined, 2),
    /* 0xB2 */ PUSHB.bind(undefined, 3),
    /* 0xB3 */ PUSHB.bind(undefined, 4),
    /* 0xB4 */ PUSHB.bind(undefined, 5),
    /* 0xB5 */ PUSHB.bind(undefined, 6),
    /* 0xB6 */ PUSHB.bind(undefined, 7),
    /* 0xB7 */ PUSHB.bind(undefined, 8),
    /* 0xB8 */ PUSHW.bind(undefined, 1),
    /* 0xB9 */ PUSHW.bind(undefined, 2),
    /* 0xBA */ PUSHW.bind(undefined, 3),
    /* 0xBB */ PUSHW.bind(undefined, 4),
    /* 0xBC */ PUSHW.bind(undefined, 5),
    /* 0xBD */ PUSHW.bind(undefined, 6),
    /* 0xBE */ PUSHW.bind(undefined, 7),
    /* 0xBF */ PUSHW.bind(undefined, 8),
    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),
    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),
    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),
    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),
    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),
    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),
    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),
    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),
    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),
    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),
    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),
    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),
    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),
    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),
    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),
    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),
    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),
    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),
    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),
    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),
    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),
    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),
    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),
    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),
    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),
    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),
    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),
    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),
    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),
    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),
    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),
    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),
    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),
    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),
    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),
    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),
    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),
    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),
    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),
    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),
    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),
    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),
    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),
    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),
    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),
    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),
    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),
    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),
    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),
    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),
    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),
    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),
    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),
    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),
    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),
    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),
    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),
    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),
    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),
    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),
    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),
    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),
    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),
    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)
];



/*****************************
  Mathematical Considerations
******************************

fv ... refers to freedom vector
pv ... refers to projection vector
rp ... refers to reference point
p  ... refers to to point being operated on
d  ... refers to distance

SETRELATIVE:
============

case freedom vector == x-axis:
------------------------------

                        (pv)
                     .-'
              rpd .-'
               .-*
          d .-'90'
         .-'       '
      .-'           '
   *-'               ' b
  rp                  '
                       '
                        '
            p *----------*-------------- (fv)
                          pm

  rpdx = rpx + d * pv.x
  rpdy = rpy + d * pv.y

  equation of line b

   y - rpdy = pvns * (x- rpdx)

   y = p.y

   x = rpdx + ( p.y - rpdy ) / pvns


case freedom vector == y-axis:
------------------------------

    * pm
    |\
    | \
    |  \
    |   \
    |    \
    |     \
    |      \
    |       \
    |        \
    |         \ b
    |          \
    |           \
    |            \    .-' (pv)
    |         90 \.-'
    |           .-'* rpd
    |        .-'
    *     *-'  d
    p     rp

  rpdx = rpx + d * pv.x
  rpdy = rpy + d * pv.y

  equation of line b:
           pvns ... normal slope to pv

   y - rpdy = pvns * (x - rpdx)

   x = p.x

   y = rpdy +  pvns * (p.x - rpdx)



generic case:
-------------


                              .'(fv)
                            .'
                          .* pm
                        .' !
                      .'    .
                    .'      !
                  .'         . b
                .'           !
               *              .
              p               !
                         90   .    ... (pv)
                           ...-*-'''
                  ...---'''    rpd
         ...---'''   d
   *--'''
  rp

    rpdx = rpx + d * pv.x
    rpdy = rpy + d * pv.y

 equation of line b:
    pvns... normal slope to pv

    y - rpdy = pvns * (x - rpdx)

 equation of freedom vector line:
    fvs ... slope of freedom vector (=fy/fx)

    y - py = fvs * (x - px)


  on pm both equations are true for same x/y

    y - rpdy = pvns * (x - rpdx)

    y - py = fvs * (x - px)

  form to y and set equal:

    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py

  expand:

    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py

  switch:

    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy

  solve for x:

    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy



          fvs * px - pvns * rpdx + rpdy - py
    x =  -----------------------------------
                 fvs - pvns

  and:

    y = fvs * (x - px) + py



INTERPOLATE:
============

Examples of point interpolation.

The weight of the movement of the reference point gets bigger
the further the other reference point is away, thus the safest
option (that is avoiding 0/0 divisions) is to weight the
original distance of the other point by the sum of both distances.

If the sum of both distances is 0, then move the point by the
arithmetic average of the movement of both reference points.




           (+6)
    rp1o *---->*rp1
         .     .                          (+12)
         .     .                  rp2o *---------->* rp2
         .     .                       .           .
         .     .                       .           .
         .    10          20           .           .
         |.........|...................|           .
               .   .                               .
               .   . (+8)                          .
                po *------>*p                      .
               .           .                       .
               .    12     .          24           .
               |...........|.......................|
                                  36


-------



           (+10)
    rp1o *-------->*rp1
         .         .                      (-10)
         .         .              rp2 *<---------* rpo2
         .         .                   .         .
         .         .                   .         .
         .    10   .          30       .         .
         |.........|.............................|
                   .                   .
                   . (+5)              .
                po *--->* p            .
                   .    .              .
                   .    .   20         .
                   |....|..............|
                     5        15


-------


           (+10)
    rp1o *-------->*rp1
         .         .
         .         .
    rp2o *-------->*rp2


                               (+10)
                          po *-------->* p

-------


           (+10)
    rp1o *-------->*rp1
         .         .
         .         .(+30)
    rp2o *---------------------------->*rp2


                                        (+25)
                          po *----------------------->* p



vim: set ts=4 sw=4 expandtab:
*****/

// The Font object

function Font$2(options) {
    options = options || {};

    if (!options.empty) {
        // Check that we've provided the minimum set of names.
        checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');
        checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');
        checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');
        checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');
        checkArgument(options.descender, 'When creating a new Font object, descender is required.');
        checkArgument(options.descender < 0, 'Descender should be negative (e.g. -512).');

        // OS X will complain if the names are empty, so we put a single space everywhere by default.
        this.names = {
            fontFamily: {en: options.familyName || ' '},
            fontSubfamily: {en: options.styleName || ' '},
            fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},
            postScriptName: {en: options.postScriptName || options.familyName + options.styleName},
            designer: {en: options.designer || ' '},
            designerURL: {en: options.designerURL || ' '},
            manufacturer: {en: options.manufacturer || ' '},
            manufacturerURL: {en: options.manufacturerURL || ' '},
            license: {en: options.license || ' '},
            licenseURL: {en: options.licenseURL || ' '},
            version: {en: options.version || 'Version 0.1'},
            description: {en: options.description || ' '},
            copyright: {en: options.copyright || ' '},
            trademark: {en: options.trademark || ' '}
        };
        this.unitsPerEm = options.unitsPerEm || 1000;
        this.ascender = options.ascender;
        this.descender = options.descender;
        this.createdTimestamp = options.createdTimestamp;
        this.tables = { os2: {
            usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
            usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
            fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR
        } };
    }

    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.
    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
    this.encoding = new DefaultEncoding(this);
    this.substitution = new Substitution(this);
    this.tables = this.tables || {};

    Object.defineProperty(this, 'hinting', {
        get: function() {
            if (this._hinting) { return this._hinting; }
            if (this.outlinesFormat === 'truetype') {
                return (this._hinting = new Hinting(this));
            }
        }
    });
}

/**
 * Check if the font has a glyph for the given character.
 * @param  {string}
 * @return {Boolean}
 */
Font$2.prototype.hasChar = function(c) {
    return this.encoding.charToGlyphIndex(c) !== null;
};

/**
 * Convert the given character to a single glyph index.
 * Note that this function assumes that there is a one-to-one mapping between
 * the given character and a glyph; for complex scripts this might not be the case.
 * @param  {string}
 * @return {Number}
 */
Font$2.prototype.charToGlyphIndex = function(s) {
    return this.encoding.charToGlyphIndex(s);
};

/**
 * Convert the given character to a single Glyph object.
 * Note that this function assumes that there is a one-to-one mapping between
 * the given character and a glyph; for complex scripts this might not be the case.
 * @param  {string}
 * @return {opentype.Glyph}
 */
Font$2.prototype.charToGlyph = function(c) {
    var glyphIndex = this.charToGlyphIndex(c);
    var glyph = this.glyphs.get(glyphIndex);
    if (!glyph) {
        // .notdef
        glyph = this.glyphs.get(0);
    }

    return glyph;
};

/**
 * Convert the given text to a list of Glyph objects.
 * Note that there is no strict one-to-one mapping between characters and
 * glyphs, so the list of returned glyphs can be larger or smaller than the
 * length of the given string.
 * @param  {string}
 * @param  {GlyphRenderOptions} [options]
 * @return {opentype.Glyph[]}
 */
Font$2.prototype.stringToGlyphs = function(s, options) {
    var this$1 = this;

    options = options || this.defaultRenderOptions;
    // Get glyph indexes
    var indexes = [];
    for (var i = 0; i < s.length; i += 1) {
        var c = s[i];
        indexes.push(this$1.charToGlyphIndex(c));
    }
    var length = indexes.length;

    // Apply substitutions on glyph indexes
    if (options.features) {
        var script = options.script || this.substitution.getDefaultScriptName();
        var manyToOne = [];
        if (options.features.liga) { manyToOne = manyToOne.concat(this.substitution.getFeature('liga', script, options.language)); }
        if (options.features.rlig) { manyToOne = manyToOne.concat(this.substitution.getFeature('rlig', script, options.language)); }
        for (var i$1 = 0; i$1 < length; i$1 += 1) {
            for (var j = 0; j < manyToOne.length; j++) {
                var ligature = manyToOne[j];
                var components = ligature.sub;
                var compCount = components.length;
                var k = 0;
                while (k < compCount && components[k] === indexes[i$1 + k]) { k++; }
                if (k === compCount) {
                    indexes.splice(i$1, compCount, ligature.by);
                    length = length - compCount + 1;
                }
            }
        }
    }

    // convert glyph indexes to glyph objects
    var glyphs = new Array(length);
    var notdef = this.glyphs.get(0);
    for (var i$2 = 0; i$2 < length; i$2 += 1) {
        glyphs[i$2] = this$1.glyphs.get(indexes[i$2]) || notdef;
    }
    return glyphs;
};

/**
 * @param  {string}
 * @return {Number}
 */
Font$2.prototype.nameToGlyphIndex = function(name) {
    return this.glyphNames.nameToGlyphIndex(name);
};

/**
 * @param  {string}
 * @return {opentype.Glyph}
 */
Font$2.prototype.nameToGlyph = function(name) {
    var glyphIndex = this.nameToGlyphIndex(name);
    var glyph = this.glyphs.get(glyphIndex);
    if (!glyph) {
        // .notdef
        glyph = this.glyphs.get(0);
    }

    return glyph;
};

/**
 * @param  {Number}
 * @return {String}
 */
Font$2.prototype.glyphIndexToName = function(gid) {
    if (!this.glyphNames.glyphIndexToName) {
        return '';
    }

    return this.glyphNames.glyphIndexToName(gid);
};

/**
 * Retrieve the value of the kerning pair between the left glyph (or its index)
 * and the right glyph (or its index). If no kerning pair is found, return 0.
 * The kerning value gets added to the advance width when calculating the spacing
 * between glyphs.
 * @param  {opentype.Glyph} leftGlyph
 * @param  {opentype.Glyph} rightGlyph
 * @return {Number}
 */
Font$2.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
    leftGlyph = leftGlyph.index || leftGlyph;
    rightGlyph = rightGlyph.index || rightGlyph;
    var gposKerning = this.getGposKerningValue;
    return gposKerning ? gposKerning(leftGlyph, rightGlyph) :
        (this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0);
};

/**
 * @typedef GlyphRenderOptions
 * @type Object
 * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.
 *                               See https://www.microsoft.com/typography/otspec/scripttags.htm
 * @property {string} [language='dflt'] - language system used to determine which features to apply.
 *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx
 * @property {boolean} [kerning=true] - whether to include kerning values
 * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.
 *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm
 */
Font$2.prototype.defaultRenderOptions = {
    kerning: true,
    features: {
        liga: true,
        rlig: true
    }
};

/**
 * Helper function that invokes the given callback for each glyph in the given text.
 * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text
 * @param {string} text - The text to apply.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @param  {Function} callback
 */
Font$2.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
    var this$1 = this;

    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    options = options || this.defaultRenderOptions;
    var fontScale = 1 / this.unitsPerEm * fontSize;
    var glyphs = this.stringToGlyphs(text, options);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        callback.call(this$1, glyph, x, y, fontSize, options);
        if (glyph.advanceWidth) {
            x += glyph.advanceWidth * fontScale;
        }

        if (options.kerning && i < glyphs.length - 1) {
            var kerningValue = this$1.getKerningValue(glyph, glyphs[i + 1]);
            x += kerningValue * fontScale;
        }

        if (options.letterSpacing) {
            x += options.letterSpacing * fontSize;
        } else if (options.tracking) {
            x += (options.tracking / 1000) * fontSize;
        }
    }
    return x;
};

/**
 * Create a Path object that represents the given text.
 * @param  {string} text - The text to create.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @return {opentype.Path}
 */
Font$2.prototype.getPath = function(text, x, y, fontSize, options) {
    var fullPath = new Path();
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
        fullPath.extend(glyphPath);
    });
    return fullPath;
};

/**
 * Create an array of Path objects that represent the glyphs of a given text.
 * @param  {string} text - The text to create.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @return {opentype.Path[]}
 */
Font$2.prototype.getPaths = function(text, x, y, fontSize, options) {
    var glyphPaths = [];
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
        glyphPaths.push(glyphPath);
    });

    return glyphPaths;
};

/**
 * Returns the advance width of a text.
 *
 * This is something different than Path.getBoundingBox() as for example a
 * suffixed whitespace increases the advanceWidth but not the bounding box
 * or an overhanging letter like a calligraphic 'f' might have a quite larger
 * bounding box than its advance width.
 *
 * This corresponds to canvas2dContext.measureText(text).width
 *
 * @param  {string} text - The text to create.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @return advance width
 */
Font$2.prototype.getAdvanceWidth = function(text, fontSize, options) {
    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});
};

/**
 * Draw the text on the given drawing context.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {string} text - The text to create.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 */
Font$2.prototype.draw = function(ctx, text, x, y, fontSize, options) {
    this.getPath(text, x, y, fontSize, options).draw(ctx);
};

/**
 * Draw the points of all glyphs in the text.
 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param {string} text - The text to create.
 * @param {number} [x=0] - Horizontal position of the beginning of the text.
 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param {GlyphRenderOptions=} options
 */
Font$2.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        glyph.drawPoints(ctx, gX, gY, gFontSize);
    });
};

/**
 * Draw lines indicating important font measurements for all glyphs in the text.
 * Black lines indicate the origin of the coordinate system (point 0,0).
 * Blue lines indicate the glyph bounding box.
 * Green line indicates the advance width of the glyph.
 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param {string} text - The text to create.
 * @param {number} [x=0] - Horizontal position of the beginning of the text.
 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param {GlyphRenderOptions=} options
 */
Font$2.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        glyph.drawMetrics(ctx, gX, gY, gFontSize);
    });
};

/**
 * @param  {string}
 * @return {string}
 */
Font$2.prototype.getEnglishName = function(name) {
    var translations = this.names[name];
    if (translations) {
        return translations.en;
    }
};

/**
 * Validate
 */
Font$2.prototype.validate = function() {
    var warnings = [];
    var _this = this;

    function assert(predicate, message) {
        if (!predicate) {
            warnings.push(message);
        }
    }

    function assertNamePresent(name) {
        var englishName = _this.getEnglishName(name);
        assert(englishName && englishName.trim().length > 0,
               'No English ' + name + ' specified.');
    }

    // Identification information
    assertNamePresent('fontFamily');
    assertNamePresent('weightName');
    assertNamePresent('manufacturer');
    assertNamePresent('copyright');
    assertNamePresent('version');

    // Dimension information
    assert(this.unitsPerEm > 0, 'No unitsPerEm specified.');
};

/**
 * Convert the font object to a SFNT data structure.
 * This structure contains all the necessary tables and metadata to create a binary OTF file.
 * @return {opentype.Table}
 */
Font$2.prototype.toTables = function() {
    return sfnt.fontToTable(this);
};
/**
 * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.
 */
Font$2.prototype.toBuffer = function() {
    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');
    return this.toArrayBuffer();
};
/**
 * Converts a `opentype.Font` into an `ArrayBuffer`
 * @return {ArrayBuffer}
 */
Font$2.prototype.toArrayBuffer = function() {
    var sfntTable = this.toTables();
    var bytes = sfntTable.encode();
    var buffer = new ArrayBuffer(bytes.length);
    var intArray = new Uint8Array(buffer);
    for (var i = 0; i < bytes.length; i++) {
        intArray[i] = bytes[i];
    }

    return buffer;
};

/**
 * Initiate a download of the OpenType font.
 */
Font$2.prototype.download = function(fileName) {
    var familyName = this.getEnglishName('fontFamily');
    var styleName = this.getEnglishName('fontSubfamily');
    fileName = fileName || familyName.replace(/\s/g, '') + '-' + styleName + '.otf';
    var arrayBuffer = this.toArrayBuffer();

    if (isBrowser()) {
        window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
        window.requestFileSystem(window.TEMPORARY, arrayBuffer.byteLength, function(fs) {
            fs.root.getFile(fileName, {create: true}, function(fileEntry) {
                fileEntry.createWriter(function(writer) {
                    var dataView = new DataView(arrayBuffer);
                    var blob = new Blob([dataView], {type: 'font/opentype'});
                    writer.write(blob);

                    writer.addEventListener('writeend', function() {
                        // Navigating to the file will download it.
                        location.href = fileEntry.toURL();
                    }, false);
                });
            });
        },
        function(err) {
            throw new Error(err.name + ': ' + err.message);
        });
    } else {
        var fs = require('fs');
        var buffer = arrayBufferToNodeBuffer(arrayBuffer);
        fs.writeFileSync(fileName, buffer);
    }
};
/**
 * @private
 */
Font$2.prototype.fsSelectionValues = {
    ITALIC:              0x001, //1
    UNDERSCORE:          0x002, //2
    NEGATIVE:            0x004, //4
    OUTLINED:            0x008, //8
    STRIKEOUT:           0x010, //16
    BOLD:                0x020, //32
    REGULAR:             0x040, //64
    USER_TYPO_METRICS:   0x080, //128
    WWS:                 0x100, //256
    OBLIQUE:             0x200  //512
};

/**
 * @private
 */
Font$2.prototype.usWidthClasses = {
    ULTRA_CONDENSED: 1,
    EXTRA_CONDENSED: 2,
    CONDENSED: 3,
    SEMI_CONDENSED: 4,
    MEDIUM: 5,
    SEMI_EXPANDED: 6,
    EXPANDED: 7,
    EXTRA_EXPANDED: 8,
    ULTRA_EXPANDED: 9
};

/**
 * @private
 */
Font$2.prototype.usWeightClasses = {
    THIN: 100,
    EXTRA_LIGHT: 200,
    LIGHT: 300,
    NORMAL: 400,
    MEDIUM: 500,
    SEMI_BOLD: 600,
    BOLD: 700,
    EXTRA_BOLD: 800,
    BLACK:    900
};

// The `fvar` table stores font variation axes and instances.
// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6fvar.html

function addName(name, names) {
    var nameString = JSON.stringify(name);
    var nameID = 256;
    for (var nameKey in names) {
        var n = parseInt(nameKey);
        if (!n || n < 256) {
            continue;
        }

        if (JSON.stringify(names[nameKey]) === nameString) {
            return n;
        }

        if (nameID <= n) {
            nameID = n + 1;
        }
    }

    names[nameID] = name;
    return nameID;
}

function makeFvarAxis(n, axis, names) {
    var nameID = addName(axis.name, names);
    return [
        {name: 'tag_' + n, type: 'TAG', value: axis.tag},
        {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},
        {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},
        {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},
        {name: 'flags_' + n, type: 'USHORT', value: 0},
        {name: 'nameID_' + n, type: 'USHORT', value: nameID}
    ];
}

function parseFvarAxis(data, start, names) {
    var axis = {};
    var p = new parse$1.Parser(data, start);
    axis.tag = p.parseTag();
    axis.minValue = p.parseFixed();
    axis.defaultValue = p.parseFixed();
    axis.maxValue = p.parseFixed();
    p.skip('uShort', 1);  // reserved for flags; no values defined
    axis.name = names[p.parseUShort()] || {};
    return axis;
}

function makeFvarInstance(n, inst, axes, names) {
    var nameID = addName(inst.name, names);
    var fields = [
        {name: 'nameID_' + n, type: 'USHORT', value: nameID},
        {name: 'flags_' + n, type: 'USHORT', value: 0}
    ];

    for (var i = 0; i < axes.length; ++i) {
        var axisTag = axes[i].tag;
        fields.push({
            name: 'axis_' + n + ' ' + axisTag,
            type: 'FIXED',
            value: inst.coordinates[axisTag] << 16
        });
    }

    return fields;
}

function parseFvarInstance(data, start, axes, names) {
    var inst = {};
    var p = new parse$1.Parser(data, start);
    inst.name = names[p.parseUShort()] || {};
    p.skip('uShort', 1);  // reserved for flags; no values defined

    inst.coordinates = {};
    for (var i = 0; i < axes.length; ++i) {
        inst.coordinates[axes[i].tag] = p.parseFixed();
    }

    return inst;
}

function makeFvarTable(fvar, names) {
    var result = new table.Table('fvar', [
        {name: 'version', type: 'ULONG', value: 0x10000},
        {name: 'offsetToData', type: 'USHORT', value: 0},
        {name: 'countSizePairs', type: 'USHORT', value: 2},
        {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},
        {name: 'axisSize', type: 'USHORT', value: 20},
        {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},
        {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}
    ]);
    result.offsetToData = result.sizeOf();

    for (var i = 0; i < fvar.axes.length; i++) {
        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));
    }

    for (var j = 0; j < fvar.instances.length; j++) {
        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));
    }

    return result;
}

function parseFvarTable(data, start, names) {
    var p = new parse$1.Parser(data, start);
    var tableVersion = p.parseULong();
    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');
    var offsetToData = p.parseOffset16();
    // Skip countSizePairs.
    p.skip('uShort', 1);
    var axisCount = p.parseUShort();
    var axisSize = p.parseUShort();
    var instanceCount = p.parseUShort();
    var instanceSize = p.parseUShort();

    var axes = [];
    for (var i = 0; i < axisCount; i++) {
        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));
    }

    var instances = [];
    var instanceStart = start + offsetToData + axisCount * axisSize;
    for (var j = 0; j < instanceCount; j++) {
        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));
    }

    return {axes: axes, instances: instances};
}

var fvar = { make: makeFvarTable, parse: parseFvarTable };

// The `GPOS` table contains kerning pairs, among other things.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm

function parseTaggedListTable(data, start) {
    var p = new parse$1.Parser(data, start);
    var n = p.parseUShort();
    var list = [];
    for (var i = 0; i < n; i++) {
        list[p.parseTag()] = { offset: p.parseUShort() };
    }

    return list;
}

// Parse a coverage table in a GSUB, GPOS or GDEF table.
// Format 1 is a simple list of glyph ids,
// Format 2 is a list of ranges. It is expanded in a list of glyphs, maybe not the best idea.
function parseCoverageTable(data, start) {
    var p = new parse$1.Parser(data, start);
    var format = p.parseUShort();
    var count = p.parseUShort();
    if (format === 1) {
        return p.parseUShortList(count);
    } else if (format === 2) {
        var coverage = [];
        for (; count--;) {
            var begin = p.parseUShort();
            var end = p.parseUShort();
            var index = p.parseUShort();
            for (var i = begin; i <= end; i++) {
                coverage[index++] = i;
            }
        }

        return coverage;
    }
}

// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
// Returns a function that gets a class value from a glyph ID.
function parseClassDefTable(data, start) {
    var p = new parse$1.Parser(data, start);
    var format = p.parseUShort();
    if (format === 1) {
        // Format 1 specifies a range of consecutive glyph indices, one class per glyph ID.
        var startGlyph = p.parseUShort();
        var glyphCount = p.parseUShort();
        var classes = p.parseUShortList(glyphCount);
        return function(glyphID) {
            return classes[glyphID - startGlyph] || 0;
        };
    } else if (format === 2) {
        // Format 2 defines multiple groups of glyph indices that belong to the same class.
        var rangeCount = p.parseUShort();
        var startGlyphs = [];
        var endGlyphs = [];
        var classValues = [];
        for (var i = 0; i < rangeCount; i++) {
            startGlyphs[i] = p.parseUShort();
            endGlyphs[i] = p.parseUShort();
            classValues[i] = p.parseUShort();
        }

        return function(glyphID) {
            var l = 0;
            var r = startGlyphs.length - 1;
            while (l < r) {
                var c = (l + r + 1) >> 1;
                if (glyphID < startGlyphs[c]) {
                    r = c - 1;
                } else {
                    l = c;
                }
            }

            if (startGlyphs[l] <= glyphID && glyphID <= endGlyphs[l]) {
                return classValues[l] || 0;
            }

            return 0;
        };
    }
}

// Parse a pair adjustment positioning subtable, format 1 or format 2
// The subtable is returned in the form of a lookup function.
function parsePairPosSubTable(data, start) {
    var p = new parse$1.Parser(data, start);
    // This part is common to format 1 and format 2 subtables
    var format = p.parseUShort();
    var coverageOffset = p.parseUShort();
    var coverage = parseCoverageTable(data, start + coverageOffset);
    // valueFormat 4: XAdvance only, 1: XPlacement only, 0: no ValueRecord for second glyph
    // Only valueFormat1=4 and valueFormat2=0 is supported.
    var valueFormat1 = p.parseUShort();
    var valueFormat2 = p.parseUShort();
    var value1;
    var value2;
    if (valueFormat1 !== 4 || valueFormat2 !== 0) { return; }
    var sharedPairSets = {};
    if (format === 1) {
        // Pair Positioning Adjustment: Format 1
        var pairSetCount = p.parseUShort();
        var pairSet = [];
        // Array of offsets to PairSet tables-from beginning of PairPos subtable-ordered by Coverage Index
        var pairSetOffsets = p.parseOffset16List(pairSetCount);
        for (var firstGlyph = 0; firstGlyph < pairSetCount; firstGlyph++) {
            var pairSetOffset = pairSetOffsets[firstGlyph];
            var sharedPairSet = sharedPairSets[pairSetOffset];
            if (!sharedPairSet) {
                // Parse a pairset table in a pair adjustment subtable format 1
                sharedPairSet = {};
                p.relativeOffset = pairSetOffset;
                var pairValueCount = p.parseUShort();
                for (; pairValueCount--;) {
                    var secondGlyph = p.parseUShort();
                    if (valueFormat1) { value1 = p.parseShort(); }
                    if (valueFormat2) { value2 = p.parseShort(); }
                    // We only support valueFormat1 = 4 and valueFormat2 = 0,
                    // so value1 is the XAdvance and value2 is empty.
                    sharedPairSet[secondGlyph] = value1;
                }
            }

            pairSet[coverage[firstGlyph]] = sharedPairSet;
        }

        return function(leftGlyph, rightGlyph) {
            var pairs = pairSet[leftGlyph];
            if (pairs) { return pairs[rightGlyph]; }
        };
    } else if (format === 2) {
        // Pair Positioning Adjustment: Format 2
        var classDef1Offset = p.parseUShort();
        var classDef2Offset = p.parseUShort();
        var class1Count = p.parseUShort();
        var class2Count = p.parseUShort();
        var getClass1 = parseClassDefTable(data, start + classDef1Offset);
        var getClass2 = parseClassDefTable(data, start + classDef2Offset);

        // Parse kerning values by class pair.
        var kerningMatrix = [];
        for (var i = 0; i < class1Count; i++) {
            var kerningRow = kerningMatrix[i] = [];
            for (var j = 0; j < class2Count; j++) {
                if (valueFormat1) { value1 = p.parseShort(); }
                if (valueFormat2) { value2 = p.parseShort(); }
                // We only support valueFormat1 = 4 and valueFormat2 = 0,
                // so value1 is the XAdvance and value2 is empty.
                kerningRow[j] = value1;
            }
        }

        // Convert coverage list to a hash
        var covered = {};
        for (var i$1 = 0; i$1 < coverage.length; i$1++) {
            covered[coverage[i$1]] = 1;
        }

        // Get the kerning value for a specific glyph pair.
        return function(leftGlyph, rightGlyph) {
            if (!covered[leftGlyph]) { return; }
            var class1 = getClass1(leftGlyph);
            var class2 = getClass2(rightGlyph);
            var kerningRow = kerningMatrix[class1];

            if (kerningRow) {
                return kerningRow[class2];
            }
        };
    }
}

// Parse a LookupTable (present in of GPOS, GSUB, GDEF, BASE, JSTF tables).
function parseLookupTable(data, start) {
    var p = new parse$1.Parser(data, start);
    var lookupType = p.parseUShort();
    var lookupFlag = p.parseUShort();
    var useMarkFilteringSet = lookupFlag & 0x10;
    var subTableCount = p.parseUShort();
    var subTableOffsets = p.parseOffset16List(subTableCount);
    var table = {
        lookupType: lookupType,
        lookupFlag: lookupFlag,
        markFilteringSet: useMarkFilteringSet ? p.parseUShort() : -1
    };
    // LookupType 2, Pair adjustment
    if (lookupType === 2) {
        var subtables = [];
        for (var i = 0; i < subTableCount; i++) {
            var pairPosSubTable = parsePairPosSubTable(data, start + subTableOffsets[i]);
            if (pairPosSubTable) { subtables.push(pairPosSubTable); }
        }
        // Return a function which finds the kerning values in the subtables.
        table.getKerningValue = function(leftGlyph, rightGlyph) {
            for (var i = subtables.length; i--;) {
                var value = subtables[i](leftGlyph, rightGlyph);
                if (value !== undefined) { return value; }
            }

            return 0;
        };
    }

    return table;
}

// Parse the `GPOS` table which contains, among other things, kerning pairs.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm
function parseGposTable(data, start, font) {
    var p = new parse$1.Parser(data, start);
    var tableVersion = p.parseFixed();
    check.argument(tableVersion === 1, 'Unsupported GPOS table version.');

    // ScriptList and FeatureList - ignored for now
    parseTaggedListTable(data, start + p.parseUShort());
    // 'kern' is the feature we are looking for.
    parseTaggedListTable(data, start + p.parseUShort());

    // LookupList
    var lookupListOffset = p.parseUShort();
    p.relativeOffset = lookupListOffset;
    var lookupCount = p.parseUShort();
    var lookupTableOffsets = p.parseOffset16List(lookupCount);
    var lookupListAbsoluteOffset = start + lookupListOffset;
    for (var i = 0; i < lookupCount; i++) {
        var table = parseLookupTable(data, lookupListAbsoluteOffset + lookupTableOffsets[i]);
        if (table.lookupType === 2 && !font.getGposKerningValue) { font.getGposKerningValue = table.getKerningValue; }
    }
}

var gpos = { parse: parseGposTable };

// The `kern` table contains kerning pairs.
// Note that some fonts use the GPOS OpenType layout table to specify kerning.
// https://www.microsoft.com/typography/OTSPEC/kern.htm

function parseWindowsKernTable(p) {
    var pairs = {};
    // Skip nTables.
    p.skip('uShort');
    var subtableVersion = p.parseUShort();
    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');
    // Skip subtableLength, subtableCoverage
    p.skip('uShort', 2);
    var nPairs = p.parseUShort();
    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);
    for (var i = 0; i < nPairs; i += 1) {
        var leftIndex = p.parseUShort();
        var rightIndex = p.parseUShort();
        var value = p.parseShort();
        pairs[leftIndex + ',' + rightIndex] = value;
    }
    return pairs;
}

function parseMacKernTable(p) {
    var pairs = {};
    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.
    // Skip the rest.
    p.skip('uShort');
    var nTables = p.parseULong();
    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');
    if (nTables > 1) {
        console.warn('Only the first kern subtable is supported.');
    }
    p.skip('uLong');
    var coverage = p.parseUShort();
    var subtableVersion = coverage & 0xFF;
    p.skip('uShort');
    if (subtableVersion === 0) {
        var nPairs = p.parseUShort();
        // Skip searchRange, entrySelector, rangeShift.
        p.skip('uShort', 3);
        for (var i = 0; i < nPairs; i += 1) {
            var leftIndex = p.parseUShort();
            var rightIndex = p.parseUShort();
            var value = p.parseShort();
            pairs[leftIndex + ',' + rightIndex] = value;
        }
    }
    return pairs;
}

// Parse the `kern` table which contains kerning pairs.
function parseKernTable(data, start) {
    var p = new parse$1.Parser(data, start);
    var tableVersion = p.parseUShort();
    if (tableVersion === 0) {
        return parseWindowsKernTable(p);
    } else if (tableVersion === 1) {
        return parseMacKernTable(p);
    } else {
        throw new Error('Unsupported kern table version (' + tableVersion + ').');
    }
}

var kern = { parse: parseKernTable };

// The `loca` table stores the offsets to the locations of the glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/loca.htm

function parseLocaTable(data, start, numGlyphs, shortVersion) {
    var p = new parse$1.Parser(data, start);
    var parseFn = shortVersion ? p.parseUShort : p.parseULong;
    // There is an extra entry after the last index element to compute the length of the last glyph.
    // That's why we use numGlyphs + 1.
    var glyphOffsets = [];
    for (var i = 0; i < numGlyphs + 1; i += 1) {
        var glyphOffset = parseFn.call(p);
        if (shortVersion) {
            // The short table version stores the actual offset divided by 2.
            glyphOffset *= 2;
        }

        glyphOffsets.push(glyphOffset);
    }

    return glyphOffsets;
}

var loca = { parse: parseLocaTable };

// opentype.js
// https://github.com/nodebox/opentype.js
// (c) 2015 Frederik De Bleser
// opentype.js may be freely distributed under the MIT license.

/* global DataView, Uint8Array, XMLHttpRequest  */

function parseOpenTypeTableEntries(data, numTables) {
    var tableEntries = [];
    var p = 12;
    for (var i = 0; i < numTables; i += 1) {
        var tag = parse$1.getTag(data, p);
        var checksum = parse$1.getULong(data, p + 4);
        var offset = parse$1.getULong(data, p + 8);
        var length = parse$1.getULong(data, p + 12);
        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});
        p += 16;
    }

    return tableEntries;
}

/**
 * Parses WOFF table entries.
 * @param  {DataView}
 * @param  {Number}
 * @return {Object[]}
 */
function parseWOFFTableEntries(data, numTables) {
    var tableEntries = [];
    var p = 44; // offset to the first table directory entry.
    for (var i = 0; i < numTables; i += 1) {
        var tag = parse$1.getTag(data, p);
        var offset = parse$1.getULong(data, p + 4);
        var compLength = parse$1.getULong(data, p + 8);
        var origLength = parse$1.getULong(data, p + 12);
        var compression = (void 0);
        if (compLength < origLength) {
            compression = 'WOFF';
        } else {
            compression = false;
        }

        tableEntries.push({tag: tag, offset: offset, compression: compression,
            compressedLength: compLength, length: origLength});
        p += 20;
    }

    return tableEntries;
}

/**
 * @typedef TableData
 * @type Object
 * @property {DataView} data - The DataView
 * @property {number} offset - The data offset.
 */

/**
 * @param  {DataView}
 * @param  {Object}
 * @return {TableData}
 */
function uncompressTable(data, tableEntry) {
    if (tableEntry.compression === 'WOFF') {
        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
        var outBuffer = new Uint8Array(tableEntry.length);
        tinyInflate(inBuffer, outBuffer);
        if (outBuffer.byteLength !== tableEntry.length) {
            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\'t match recorded length');
        }

        var view = new DataView(outBuffer.buffer, 0);
        return {data: view, offset: 0};
    } else {
        return {data: data, offset: tableEntry.offset};
    }
}

// Public API ///////////////////////////////////////////////////////////

/**
 * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
 * Throws an error if the font could not be parsed.
 * @param  {ArrayBuffer}
 * @return {opentype.Font}
 */
function parseBuffer(buffer) {
    var indexToLocFormat;
    var ltagTable;

    // Since the constructor can also be called to create new fonts from scratch, we indicate this
    // should be an empty font that we'll fill with our own data.
    var font = new Font$2({empty: true});

    // OpenType fonts use big endian byte ordering.
    // We can't rely on typed array view types, because they operate with the endianness of the host computer.
    // Instead we use DataViews where we can specify endianness.
    var data = new DataView(buffer, 0);
    var numTables;
    var tableEntries = [];
    var signature = parse$1.getTag(data, 0);
    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {
        font.outlinesFormat = 'truetype';
        numTables = parse$1.getUShort(data, 4);
        tableEntries = parseOpenTypeTableEntries(data, numTables);
    } else if (signature === 'OTTO') {
        font.outlinesFormat = 'cff';
        numTables = parse$1.getUShort(data, 4);
        tableEntries = parseOpenTypeTableEntries(data, numTables);
    } else if (signature === 'wOFF') {
        var flavor = parse$1.getTag(data, 4);
        if (flavor === String.fromCharCode(0, 1, 0, 0)) {
            font.outlinesFormat = 'truetype';
        } else if (flavor === 'OTTO') {
            font.outlinesFormat = 'cff';
        } else {
            throw new Error('Unsupported OpenType flavor ' + signature);
        }

        numTables = parse$1.getUShort(data, 12);
        tableEntries = parseWOFFTableEntries(data, numTables);
    } else {
        throw new Error('Unsupported OpenType signature ' + signature);
    }

    var cffTableEntry;
    var fvarTableEntry;
    var glyfTableEntry;
    var gposTableEntry;
    var gsubTableEntry;
    var hmtxTableEntry;
    var kernTableEntry;
    var locaTableEntry;
    var nameTableEntry;
    var metaTableEntry;
    var p;

    for (var i = 0; i < numTables; i += 1) {
        var tableEntry = tableEntries[i];
        var table = (void 0);
        switch (tableEntry.tag) {
            case 'cmap':
                table = uncompressTable(data, tableEntry);
                font.tables.cmap = cmap.parse(table.data, table.offset);
                font.encoding = new CmapEncoding(font.tables.cmap);
                break;
            case 'cvt ' :
                table = uncompressTable(data, tableEntry);
                p = new parse$1.Parser(table.data, table.offset);
                font.tables.cvt = p.parseShortList(tableEntry.length / 2);
                break;
            case 'fvar':
                fvarTableEntry = tableEntry;
                break;
            case 'fpgm' :
                table = uncompressTable(data, tableEntry);
                p = new parse$1.Parser(table.data, table.offset);
                font.tables.fpgm = p.parseByteList(tableEntry.length);
                break;
            case 'head':
                table = uncompressTable(data, tableEntry);
                font.tables.head = head.parse(table.data, table.offset);
                font.unitsPerEm = font.tables.head.unitsPerEm;
                indexToLocFormat = font.tables.head.indexToLocFormat;
                break;
            case 'hhea':
                table = uncompressTable(data, tableEntry);
                font.tables.hhea = hhea.parse(table.data, table.offset);
                font.ascender = font.tables.hhea.ascender;
                font.descender = font.tables.hhea.descender;
                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
                break;
            case 'hmtx':
                hmtxTableEntry = tableEntry;
                break;
            case 'ltag':
                table = uncompressTable(data, tableEntry);
                ltagTable = ltag.parse(table.data, table.offset);
                break;
            case 'maxp':
                table = uncompressTable(data, tableEntry);
                font.tables.maxp = maxp.parse(table.data, table.offset);
                font.numGlyphs = font.tables.maxp.numGlyphs;
                break;
            case 'name':
                nameTableEntry = tableEntry;
                break;
            case 'OS/2':
                table = uncompressTable(data, tableEntry);
                font.tables.os2 = os2.parse(table.data, table.offset);
                break;
            case 'post':
                table = uncompressTable(data, tableEntry);
                font.tables.post = post.parse(table.data, table.offset);
                font.glyphNames = new GlyphNames(font.tables.post);
                break;
            case 'prep' :
                table = uncompressTable(data, tableEntry);
                p = new parse$1.Parser(table.data, table.offset);
                font.tables.prep = p.parseByteList(tableEntry.length);
                break;
            case 'glyf':
                glyfTableEntry = tableEntry;
                break;
            case 'loca':
                locaTableEntry = tableEntry;
                break;
            case 'CFF ':
                cffTableEntry = tableEntry;
                break;
            case 'kern':
                kernTableEntry = tableEntry;
                break;
            case 'GPOS':
                gposTableEntry = tableEntry;
                break;
            case 'GSUB':
                gsubTableEntry = tableEntry;
                break;
            case 'meta':
                metaTableEntry = tableEntry;
                break;
        }
    }

    var nameTable = uncompressTable(data, nameTableEntry);
    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);
    font.names = font.tables.name;

    if (glyfTableEntry && locaTableEntry) {
        var shortVersion = indexToLocFormat === 0;
        var locaTable = uncompressTable(data, locaTableEntry);
        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
        var glyfTable = uncompressTable(data, glyfTableEntry);
        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font);
    } else if (cffTableEntry) {
        var cffTable = uncompressTable(data, cffTableEntry);
        cff.parse(cffTable.data, cffTable.offset, font);
    } else {
        throw new Error('Font doesn\'t contain TrueType or CFF outlines.');
    }

    var hmtxTable = uncompressTable(data, hmtxTableEntry);
    hmtx.parse(hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);
    addGlyphNames(font);

    if (kernTableEntry) {
        var kernTable = uncompressTable(data, kernTableEntry);
        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);
    } else {
        font.kerningPairs = {};
    }

    if (gposTableEntry) {
        var gposTable = uncompressTable(data, gposTableEntry);
        gpos.parse(gposTable.data, gposTable.offset, font);
    }

    if (gsubTableEntry) {
        var gsubTable = uncompressTable(data, gsubTableEntry);
        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);
    }

    if (fvarTableEntry) {
        var fvarTable = uncompressTable(data, fvarTableEntry);
        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);
    }

    if (metaTableEntry) {
        var metaTable = uncompressTable(data, metaTableEntry);
        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);
        font.metas = font.tables.meta;
    }

    return font;
}

/**
 * Asynchronously load the font from a URL or a filesystem. When done, call the callback
 * with two arguments `(err, font)`. The `err` will be null on success,
 * the `font` is a Font object.
 * We use the node.js callback convention so that
 * opentype.js can integrate with frameworks like async.js.
 * @alias opentype.load
 * @param  {string} url - The URL of the font to load.
 * @param  {Function} callback - The callback.
 */

function ShelfPack$1(w, h, options) {
    options = options || {};
    this.w = w || 64;
    this.h = h || 64;
    this.autoResize = !!options.autoResize;
    this.shelves = [];
    this.freebins = [];
    this.stats = {};
    this.bins = {};
    this.maxId = 0;
}


/**
 * Batch pack multiple bins into the sprite.
 *
 * @param   {Object[]} bins       Array of requested bins - each object should have `width`, `height` (or `w`, `h`) properties
 * @param   {number}   bins[].w   Requested bin width
 * @param   {number}   bins[].h   Requested bin height
 * @param   {Object}   [options]
 * @param   {boolean}  [options.inPlace=false] If `true`, the supplied bin objects will be updated inplace with `x` and `y` properties
 * @returns {Bin[]}    Array of allocated Bins - each Bin is an object with `id`, `x`, `y`, `w`, `h` properties
 * @example
 * var bins = [
 *     { id: 1, w: 12, h: 12 },
 *     { id: 2, w: 12, h: 16 },
 *     { id: 3, w: 12, h: 24 }
 * ];
 * var results = sprite.pack(bins, { inPlace: false });
 */
ShelfPack$1.prototype.pack = function(bins, options) {
    var this$1 = this;

    bins = [].concat(bins);
    options = options || {};

    var results = [],
        w, h, id, allocation;

    for (var i = 0; i < bins.length; i++) {
        w  = bins[i].w || bins[i].width;
        h  = bins[i].h || bins[i].height;
        id = bins[i].id;

        if (w && h) {
            allocation = this$1.packOne(w, h, id);
            if (!allocation) {
                continue;
            }
            if (options.inPlace) {
                bins[i].x  = allocation.x;
                bins[i].y  = allocation.y;
                bins[i].id = allocation.id;
            }
            results.push(allocation);
        }
    }

    this.shrink();

    return results;
};


/**
 * Pack a single bin into the sprite.
 *
 * Each bin will have a unique identitifer.
 * If no identifier is supplied in the `id` parameter, one will be created.
 * Note: The supplied `id` is used as an object index, so numeric values are fastest!
 *
 * Bins are automatically refcounted (i.e. a newly packed Bin will have a refcount of 1).
 * When a bin is no longer needed, use the `ShelfPack.unref` function to mark it
 *   as unused.  When a Bin's refcount decrements to 0, the Bin will be marked
 *   as free and its space may be reused by the packing code.
 *
 * @param    {number}         w      Width of the bin to allocate
 * @param    {number}         h      Height of the bin to allocate
 * @param    {number|string}  [id]   Unique identifier for this bin, (if unsupplied, assume it's a new bin and create an id)
 * @returns  {Bin}            Bin object with `id`, `x`, `y`, `w`, `h` properties, or `null` if allocation failed
 * @example
 * var results = sprite.packOne(12, 16, 'a');
 */
ShelfPack$1.prototype.packOne = function(w, h, id) {
    var this$1 = this;

    var best = { freebin: -1, shelf: -1, waste: Infinity },
        y = 0,
        bin, shelf, waste, i;

    // if id was supplied, attempt a lookup..
    if (typeof id === 'string' || typeof id === 'number') {
        bin = this.getBin(id);
        if (bin) {              // we packed this bin already
            this.ref(bin);
            return bin;
        }
        if (typeof id === 'number') {
            this.maxId = Math.max(id, this.maxId);
        }
    } else {
        id = ++this.maxId;
    }

    // First try to reuse a free bin..
    for (i = 0; i < this.freebins.length; i++) {
        bin = this$1.freebins[i];

        // exactly the right height and width, use it..
        if (h === bin.maxh && w === bin.maxw) {
            return this$1.allocFreebin(i, w, h, id);
        }
        // not enough height or width, skip it..
        if (h > bin.maxh || w > bin.maxw) {
            continue;
        }
        // extra height or width, minimize wasted area..
        if (h <= bin.maxh && w <= bin.maxw) {
            waste = (bin.maxw * bin.maxh) - (w * h);
            if (waste < best.waste) {
                best.waste = waste;
                best.freebin = i;
            }
        }
    }

    // Next find the best shelf..
    for (i = 0; i < this.shelves.length; i++) {
        shelf = this$1.shelves[i];
        y += shelf.h;

        // not enough width on this shelf, skip it..
        if (w > shelf.free) {
            continue;
        }
        // exactly the right height, pack it..
        if (h === shelf.h) {
            return this$1.allocShelf(i, w, h, id);
        }
        // not enough height, skip it..
        if (h > shelf.h) {
            continue;
        }
        // extra height, minimize wasted area..
        if (h < shelf.h) {
            waste = (shelf.h - h) * w;
            if (waste < best.waste) {
                best.freebin = -1;
                best.waste = waste;
                best.shelf = i;
            }
        }
    }

    if (best.freebin !== -1) {
        return this.allocFreebin(best.freebin, w, h, id);
    }

    if (best.shelf !== -1) {
        return this.allocShelf(best.shelf, w, h, id);
    }

    // No free bins or shelves.. add shelf..
    if (h <= (this.h - y) && w <= this.w) {
        shelf = new Shelf(y, this.w, h);
        return this.allocShelf(this.shelves.push(shelf) - 1, w, h, id);
    }

    // No room for more shelves..
    // If `autoResize` option is set, grow the sprite as follows:
    //  * double whichever sprite dimension is smaller (`w1` or `h1`)
    //  * if sprite dimensions are equal, grow width before height
    //  * accomodate very large bin requests (big `w` or `h`)
    if (this.autoResize) {
        var h1, h2, w1, w2;

        h1 = h2 = this.h;
        w1 = w2 = this.w;

        if (w1 <= h1 || w > w1) {   // grow width..
            w2 = Math.max(w, w1) * 2;
        }
        if (h1 < w1 || h > h1) {    // grow height..
            h2 = Math.max(h, h1) * 2;
        }

        this.resize(w2, h2);
        return this.packOne(w, h, id);  // retry
    }

    return null;
};


/**
 * Called by packOne() to allocate a bin by reusing an existing freebin
 *
 * @private
 * @param    {number}         index  Index into the `this.freebins` array
 * @param    {number}         w      Width of the bin to allocate
 * @param    {number}         h      Height of the bin to allocate
 * @param    {number|string}  id     Unique identifier for this bin
 * @returns  {Bin}            Bin object with `id`, `x`, `y`, `w`, `h` properties
 * @example
 * var bin = sprite.allocFreebin(0, 12, 16, 'a');
 */
ShelfPack$1.prototype.allocFreebin = function (index, w, h, id) {
    var bin = this.freebins.splice(index, 1)[0];
    bin.id = id;
    bin.w = w;
    bin.h = h;
    bin.refcount = 0;
    this.bins[id] = bin;
    this.ref(bin);
    return bin;
};


/**
 * Called by `packOne() to allocate bin on an existing shelf
 *
 * @private
 * @param    {number}         index  Index into the `this.shelves` array
 * @param    {number}         w      Width of the bin to allocate
 * @param    {number}         h      Height of the bin to allocate
 * @param    {number|string}  id     Unique identifier for this bin
 * @returns  {Bin}            Bin object with `id`, `x`, `y`, `w`, `h` properties
 * @example
 * var results = sprite.allocShelf(0, 12, 16, 'a');
 */
ShelfPack$1.prototype.allocShelf = function(index, w, h, id) {
    var shelf = this.shelves[index];
    var bin = shelf.alloc(w, h, id);
    this.bins[id] = bin;
    this.ref(bin);
    return bin;
};


/**
 * Shrink the width/height of the sprite to the bare minimum.
 * Since shelf-pack doubles first width, then height when running out of shelf space
 * this can result in fairly large unused space both in width and height if that happens
 * towards the end of bin packing.
 */
ShelfPack$1.prototype.shrink = function() {
    var this$1 = this;

    if (this.shelves.length > 0) {
        var w2 = 0;
        var h2 = 0;

        for (var j = 0; j < this.shelves.length; j++) {
            var shelf = this$1.shelves[j];
            h2 += shelf.h;
            w2 = Math.max(shelf.w - shelf.free, w2);
        }

        this.resize(w2, h2);
    }
};


/**
 * Return a packed bin given its id, or undefined if the id is not found
 *
 * @param    {number|string}  id  Unique identifier for this bin,
 * @returns  {Bin}            The requested bin, or undefined if not yet packed
 * @example
 * var b = sprite.getBin('a');
 */
ShelfPack$1.prototype.getBin = function(id) {
    return this.bins[id];
};


/**
 * Increment the ref count of a bin and update statistics.
 *
 * @param    {Bin}     bin  Bin instance
 * @returns  {number}  New refcount of the bin
 * @example
 * var bin = sprite.getBin('a');
 * sprite.ref(bin);
 */
ShelfPack$1.prototype.ref = function(bin) {
    if (++bin.refcount === 1) {   // a new Bin.. record height in stats historgram..
        var h = bin.h;
        this.stats[h] = (this.stats[h] | 0) + 1;
    }

    return bin.refcount;
};


/**
 * Decrement the ref count of a bin and update statistics.
 * The bin will be automatically marked as free space once the refcount reaches 0.
 *
 * @param    {Bin}     bin  Bin instance
 * @returns  {number}  New refcount of the bin
 * @example
 * var bin = sprite.getBin('a');
 * sprite.unref(bin);
 */
ShelfPack$1.prototype.unref = function(bin) {
    if (bin.refcount === 0) {
        return 0;
    }

    if (--bin.refcount === 0) {
        this.stats[bin.h]--;
        delete this.bins[bin.id];
        this.freebins.push(bin);
    }

    return bin.refcount;
};


/**
 * Clear the sprite.  Resets everything and resets statistics.
 *
 * @example
 * sprite.clear();
 */
ShelfPack$1.prototype.clear = function() {
    this.shelves = [];
    this.freebins = [];
    this.stats = {};
    this.bins = {};
    this.maxId = 0;
};


/**
 * Resize the sprite.
 *
 * @param   {number}  w  Requested new sprite width
 * @param   {number}  h  Requested new sprite height
 * @returns {boolean} `true` if resize succeeded, `false` if failed
 * @example
 * sprite.resize(256, 256);
 */
ShelfPack$1.prototype.resize = function(w, h) {
    var this$1 = this;

    this.w = w;
    this.h = h;
    for (var i = 0; i < this.shelves.length; i++) {
        this$1.shelves[i].resize(w);
    }
    return true;
};


/**
 * Create a new Shelf.
 *
 * @private
 * @class  Shelf
 * @param  {number}  y   Top coordinate of the new shelf
 * @param  {number}  w   Width of the new shelf
 * @param  {number}  h   Height of the new shelf
 * @example
 * var shelf = new Shelf(64, 512, 24);
 */
function Shelf(y, w, h) {
    this.x = 0;
    this.y = y;
    this.w = this.free = w;
    this.h = h;
}


/**
 * Allocate a single bin into the shelf.
 *
 * @private
 * @param   {number}         w   Width of the bin to allocate
 * @param   {number}         h   Height of the bin to allocate
 * @param   {number|string}  id  Unique id of the bin to allocate
 * @returns {Bin}            Bin object with `id`, `x`, `y`, `w`, `h` properties, or `null` if allocation failed
 * @example
 * shelf.alloc(12, 16, 'a');
 */
Shelf.prototype.alloc = function(w, h, id) {
    if (w > this.free || h > this.h) {
        return null;
    }
    var x = this.x;
    this.x += w;
    this.free -= w;
    return new Bin(id, x, this.y, w, h, w, this.h);
};


/**
 * Resize the shelf.
 *
 * @private
 * @param   {number}  w  Requested new width of the shelf
 * @returns {boolean}    true
 * @example
 * shelf.resize(512);
 */
Shelf.prototype.resize = function(w) {
    this.free += (w - this.w);
    this.w = w;
    return true;
};


/**
 * Create a new Bin object.
 *
 * @class  Bin
 * @param  {number|string}  id      Unique id of the bin
 * @param  {number}         x       Left coordinate of the bin
 * @param  {number}         y       Top coordinate of the bin
 * @param  {number}         w       Width of the bin
 * @param  {number}         h       Height of the bin
 * @param  {number}         [maxw]  Max width of the bin (defaults to `w` if not provided)
 * @param  {number}         [maxh]  Max height of the bin (defaults to `h` if not provided)
 * @example
 * var bin = new Bin('a', 0, 0, 12, 16);
 */
function Bin(id, x, y, w, h, maxw, maxh) {
    this.id = id;
    this.x  = x;
    this.y  = y;
    this.w  = w;
    this.h  = h;
    this.maxw = maxw || w;
    this.maxh = maxh || h;
    this.refcount = 0;
}

var OpenTypeFont = (function (Font$$1) {
  function OpenTypeFont(device, width, height) {
    if ( width === void 0 ) width = 1024;
    if ( height === void 0 ) height = 1024;

    Font$$1.call(this);

    this._font = null; // opentype.Font
    this._padding = 2;
    this._fontScale = 1;
    this._textCache = {};
    // this._face = null; // TODO:
    this._packer = new ShelfPack$1(width, height); // TODO: auto resize
    this._packCanvas = document.createElement('canvas');
    this._packCanvas.width = width;
    this._packCanvas.height = height;
    this._fontAtlas = new Texture2D$2(device, width, height);
    this._fontAtlas.mipmap = false;
    this._fontAtlas.premultiplyAlpha = true;
    this._defaultGlyph = {
      id: 32, // space charCode
      x: 0,
      y: 0,
      width: 16,
      height: 16,
      xoffset: 0,
      yoffset: 0,
      xadvance: 16,
      uvs: [
        vec2.new(0, 0),
        vec2.new(0, 0),
        vec2.new(0, 0),
        vec2.new(0, 0)
      ],
    };
    this._type = 'opentype';
  }

  if ( Font$$1 ) OpenTypeFont.__proto__ = Font$$1;
  OpenTypeFont.prototype = Object.create( Font$$1 && Font$$1.prototype );
  OpenTypeFont.prototype.constructor = OpenTypeFont;

  var prototypeAccessors = { font: { configurable: true },texture: { configurable: true },size: { configurable: true },lineHeight: { configurable: true } };

  prototypeAccessors.font.set = function (val) {
    this._font = val;
    this._fontScale = this._size / this._font.unitsPerEm;
  };
  prototypeAccessors.font.get = function () {
    return this._font;
  };

  prototypeAccessors.texture.get = function () {
    return this._fontAtlas;
  };

  prototypeAccessors.size.set = function (val) {
    if (this._size !== val) {
      this._size = val;
      // when font size changed, we need to clear font atlas.
      this.clear();
    }
  };

  prototypeAccessors.lineHeight.set = function (val) {
    if (this._lineHeight !== val) {
      this._lineHeight = val;
      this.clear();
    }
  };

  OpenTypeFont.prototype.addText = function addText (text) {
    if (this._textCache[text] === undefined) {
      this._textCache[text] = text;
      this._addTextToFontAtlas(text);
    }
  };

  OpenTypeFont.prototype.removeText = function removeText (text) {
    if (this._textCache[text] === undefined) {
      console.warn(("can not remove text: '" + text + "' from font. not exists."));
    } else {
      this._removeTextFromFontAtlas(text);
      delete this._textCache[text];
    }
  };

  OpenTypeFont.prototype.clear = function clear () {
    this._packer.clear();
    var ctx = this._packCanvas.getContext('2d');
    ctx.clearRect(0, 0, this._packCanvas.width, this._packCanvas.height);
    this._fontAtlas.setImages([this._packCanvas]);
    this._fontAtlas.commit();
  };

  OpenTypeFont.prototype._addTextToFontAtlas = function _addTextToFontAtlas (text) {
    var this$1 = this;

    var ctx = this._packCanvas.getContext('2d');
    var fontAtlasDirty = false;

    for (var i = 0; i < text.length; ++i) {
      var char = text[i];
      var charCode = text.charCodeAt(i);
      // get opentype glyph
      var otGlyph = this$1._font.charToGlyph(char);
      if (otGlyph.path.getBoundingBox === undefined) { // opentype's bug ? some glyph such as space do not have getBoundingBox func.
        continue;
      }
      var bbox = otGlyph.getBoundingBox();
      var glyph = {
        id: charCode,
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        xoffset: 0,
        yoffset: 0,
        xadvance: 0,
      };
      glyph.width = (bbox.x2 - bbox.x1) * this$1._fontScale;
      glyph.height = (bbox.y2 - bbox.y1) * this$1._fontScale;
      if (this$1._glyphs[charCode] !== undefined) {
        this$1._packer.packOne(glyph.width, glyph.height, glyph.id); // increment refcount
      } else {
        fontAtlasDirty = true;
        glyph.xadvance = otGlyph.advanceWidth * this$1._fontScale;
        this$1._glyphs[charCode] = glyph;
        var bin = this$1._packer.packOne(glyph.width + this$1._padding, glyph.height + this$1._padding, glyph.id); // pack a new one
        if (bin !== null) {
          glyph.xoffset = bbox.x1 * this$1._fontScale;
          glyph.yoffset = this$1._size - bbox.y2 * this$1._fontScale + this$1._font.descender * this$1._fontScale;

          // compute uvs
          var u0 = (bin.x + this$1._padding / 2) / this$1._packCanvas.width;
          var u1 = (bin.x + this$1._padding / 2 + glyph.width) / this$1._packCanvas.width;
          var v0 = 1.0 - (bin.y + this$1._padding / 2 + glyph.height) / this$1._packCanvas.height;
          var v1 = 1.0 - (bin.y + this$1._padding / 2) / this$1._packCanvas.height;
          glyph.uvs = [
            vec2.new(u0, v0),
            vec2.new(u1, v0),
            vec2.new(u0, v1),
            vec2.new(u1, v1)
          ];
          var path = otGlyph.getPath(bin.x - bbox.x1 * this$1._fontScale + this$1._padding / 2, bin.y + bbox.y2 * this$1._fontScale + this$1._padding / 2, this$1._size, {xScale: this$1._fontScale, yScale: this$1._fontScale});
          path.fill = '#FFFFFF';
          path.draw(ctx);
        } else {
          console.error('font glyph pack failed. font atlas size is not enough.');
        }
      }
    }

    if (fontAtlasDirty) {
      // update font atlas
      this._fontAtlas.setImages([this._packCanvas]);
      this._fontAtlas.commit();
    }
  };

  OpenTypeFont.prototype._removeTextFromFontAtlas = function _removeTextFromFontAtlas (text) {
    var this$1 = this;

    var ctx = this._packCanvas.getContext('2d');
    var fontAtlasDirty = false;

    for (var i = 0; i < text.length; ++i) {
      var charCode = text.charCodeAt(i);
      if (this$1._glyphs[charCode] !== undefined) {
        var bin = this$1._packer.getBin(charCode);
        var refCount = this$1._packer.unref(bin);
        if (refCount === 0) {
          delete this$1._glyphs[charCode];
          ctx.clearRect(bin.x, bin.y, bin.w, bin.h);
          fontAtlasDirty = true;
        }
      } else {
        console.warn('try to remove a no exist glyph.');
      }
    }

    if (fontAtlasDirty) {
      // update font atlas
      this._fontAtlas.setImages([this._packCanvas]);
      this._fontAtlas.commit();
    }
  };

  Object.defineProperties( OpenTypeFont.prototype, prototypeAccessors );

  return OpenTypeFont;
}(Font));

function otfontLoader (app, urls, callback) {
  var manifest = {};
  manifest.bin = {
    type: 'binary',
    src: urls.bin,
  };
  if (urls.json) {
    manifest.json = {
      type: 'text',
      parser: JSON.parse,
      src: urls.json,
    };
  }
  resl({
    manifest: manifest,
    onDone: function onDone(data) {
      var bin = data.bin;
      var json = data.json;
      var fontAsset = null;
      if (json && json.width && json.height) {
        fontAsset = new OpenTypeFont(app.device, json.width, json.height);
      } else {
        fontAsset = new OpenTypeFont(app.device, 512, 512);
      }
      var parsedFont = parseBuffer(bin);
      fontAsset.font = parsedFont;
      fontAsset.size = json.size ? json.size : 32;
      fontAsset.lineHeight = json.lineHeight ? json.lineHeight : 32;

      callback(null, fontAsset);
    }

  });
}

var _typeMap = {
  float: renderer.PARAM_FLOAT,
  float2: renderer.PARAM_FLOAT2,
  float3: renderer.PARAM_FLOAT3,
  float4: renderer.PARAM_FLOAT4,
  color3: renderer.PARAM_COLOR3,
  color4: renderer.PARAM_COLOR4,
  texture2d: renderer.PARAM_TEXTURE_2D,
  textureCube: renderer.PARAM_TEXTURE_CUBE
};

var _passMap = {
  back: gfx.CULL_BACK,
  front: gfx.CULL_FRONT,
  add: gfx.BLEND_FUNC_ADD,
  subtract: gfx.BLEND_FUNC_SUBTRACT,
  reverseSubtract: gfx.BLEND_FUNC_REVERSE_SUBTRACT,
  zero: gfx.BLEND_ZERO,
  one: gfx.BLEND_ONE,
  srcColor: gfx.BLEND_SRC_COLOR,
  oneMinusSrcColor: gfx.BLEND_ONE_MINUS_SRC_COLOR,
  dstColor: gfx.BLEND_DST_COLOR,
  oneMinusDstColor: gfx.BLEND_ONE_MINUS_DST_COLOR,
  srcAlpha: gfx.BLEND_SRC_ALPHA,
  oneMinusSrcAlpha: gfx.BLEND_ONE_MINUS_SRC_ALPHA,
  dstAlpha: gfx.BLEND_DST_ALPHA,
  oneMinusDstAlpha: gfx.BLEND_ONE_MINUS_DST_ALPHA,
  constColor: gfx.BLEND_CONSTANT_COLOR,
  oneMinusConstColor: gfx.BLEND_ONE_MINUS_CONSTANT_COLOR,
  constAlpha: gfx.BLEND_CONSTANT_ALPHA,
  oneMinusConstAlpha: gfx.BLEND_ONE_MINUS_CONSTANT_ALPHA,
  srcAlphaSaturate: gfx.BLEND_SRC_ALPHA_SATURATE
};
_passMap[true] = true;
_passMap[false] = false;

function createEffect(json) {
  var effectAsset = new Effect$2();
  effectAsset._name = json.name;
  effectAsset._uuid = "custom-effect-" + (json.name);
  effectAsset._loaded = true;
  for (var i = 0; i < json.techniques.length; ++i) {
    var jsonTech = json.techniques[i];
    for (var j = 0; j < jsonTech.params.length; ++j) {
      var param = jsonTech.params[j];
      param.type = _typeMap[param.type];
    }
    for (var j$1 = 0; j$1 < jsonTech.passes.length; ++j$1) {
      var jsonPass = jsonTech.passes[j$1];
      for (var key in jsonPass) {
        if (key === 'program') {
          continue;
        }
        jsonPass[key] = _passMap[jsonPass[key]];
      }
    }
  }
  effectAsset.techniques = json.techniques;
  effectAsset.properties = json.properties;
  effectAsset.defines = json.defines;
  effectAsset.dependencies = json.dependencies ? json.dependencies : [];
  return effectAsset;
}

function effectLoader (app, urls, callback) {
  resl({
    manifest: {
      json: {
        type: 'text',
        parser: JSON.parse,
        src: urls.json,
      },
    },

    onDone: function onDone(data) {
      var json = data.json;
      var effectAsset = createEffect(json);
      callback(null, effectAsset);
    }
  });
}

function glslStripComment(code) {
  // block comments don't matter here because
  // the actual compiler will handle them correctly
  return code.replace(/\/\/.*/g, '');
}

function unwindIncludes(str, chunks) {
  var pattern = /#include +<([\w\d\-_.]+)>/gm;
  function replace(match, include) {
    var replace = chunks[include];
    if (replace === undefined) {
      console.error(("can not resolve #include <" + include + ">"));
    }
    return unwindIncludes(replace);
  }
  return str.replace(pattern, replace);
}

function buildTemplates(json, vert, frag, chunks) {
  vert = unwindIncludes(glslStripComment(vert), chunks);
  frag = unwindIncludes(glslStripComment(frag), chunks);

  var defines = [];
  for (var def in json) {
    var define = { name: def };
    if (json[def] && json[def].min !== undefined) {
      define.min = json[def].min;
    }
    if (json[def] && json[def].max !== undefined) {
      define.max = json[def].max;
    }
    defines.push(define);
  }
  return { vert: vert, frag: frag, defines: defines };
}

function programLoader (app, urls) {
  resl({
    manifest: {
      json: {
        type: 'text',
        parser: JSON.parse,
        src: urls.json,
      },
      vert: {
        type: 'text',
        src: urls.vert
      },
      frag: {
        type: 'text',
        src: urls.frag
      }
    },

    onDone: function onDone(data) {
      var json = data.json;
      var vert = data.vert;
      var frag = data.frag;
      var template = buildTemplates(json, vert, frag, app._forward._programLib._chunks);
      app._forward._programLib.define(urls.name, template.vert, template.frag, template.defines);
    }
  });
}

var ScriptComponent = (function (Component) {
  function ScriptComponent() {
    Component.call(this);

    this._startedFlag = 0;
  }

  if ( Component ) ScriptComponent.__proto__ = Component;
  ScriptComponent.prototype = Object.create( Component && Component.prototype );
  ScriptComponent.prototype.constructor = ScriptComponent;

  ScriptComponent.prototype.onInit = function onInit () {
    this._system.add(this);
  };

  ScriptComponent.prototype.onDestroy = function onDestroy () {
    this._system.remove(this);
  };

  ScriptComponent.prototype.awake = function awake () {
  };

  ScriptComponent.prototype.start = function start () {
  };

  ScriptComponent.prototype.tick = function tick () {
  };

  ScriptComponent.prototype.postTick = function postTick () {
  };

  ScriptComponent.prototype.end = function end () {
  };

  return ScriptComponent;
}(Component));

var CameraComponent = (function (Component) {
  function CameraComponent() {
    Component.call(this);

    this._camera = new renderer.Camera();
  }

  if ( Component ) CameraComponent.__proto__ = Component;
  CameraComponent.prototype = Object.create( Component && Component.prototype );
  CameraComponent.prototype.constructor = CameraComponent;
  CameraComponent.prototype.onInit = function onInit () {
    this._camera.setStages([
      'opaque',
      'transparent'
    ]);
    this._camera.setNode(this._entity);

    /**
     * **@schema** The projection type of the camera
     * @type {string}
     */
    this.projection = this._projection;
    /**
     * **@schema** The camera priority
     * @type {number}
     */
    this.priority = this._priority;
    /**
     * **@schema** The camera field of view
     * @type {number}
     */
    this.fov = this._fov;
    /**
     * **@schema** The camera height when in orthogonal mode
     * @type {number}
     */
    this.orthoHeight = this._orthoHeight;
    /**
     * **@schema** The near clipping distance of the camera
     * @type {number}
     */
    this.near = this._near;
    /**
     * **@schema** The far clipping distance of the camera
     * @type {number}
     */
    this.far = this._far;
    /**
     * **@schema** The clearing color of the camera
     * @type {color4}
     */
    this.color = this._color;
    /**
     * **@schema** The clearing depth value of the camera
     * @type {number}
     */
    this.depth = this._depth;
    /**
     * **@schema** The clearing stencil value of the camera
     * @type {number}
     */
    this.stencil = this._stencil;
    /**
     * **@schema** The clearing flags of this camera
     * @type {number}
     */
    this.clearFlags = this._clearFlags;
    /**
     * **@schema** The screen rect of the camera
     * @type {Object}
     */
    this.rect = this._rect;
  };

  CameraComponent.prototype.onEnable = function onEnable () {
    this._app.scene.addCamera(this._camera);
  };

  CameraComponent.prototype.onDisable = function onDisable () {
    this._app.scene.removeCamera(this._camera);
  };

  return CameraComponent;
}(Component));

CameraComponent.schema = {
  projection: {
    type: 'enums',
    default: 'perspective',
    options: ['ortho', 'perspective'],
    set: function set(val) {
      this._projection = val;

      var type = renderer.PROJ_PERSPECTIVE;
      if (this._projection === 'ortho') {
        type = renderer.PROJ_ORTHO;
      }
      this._camera.setType(type);
    }
  },

  priority: {
    type: 'number',
    default: 0,
    set: function set(val) {
      this._priority = val;
      this._camera.setPriority(val);
    }
  },

  // fov (in angle)
  fov: {
    type: 'number',
    default: 45,
    set: function set(val) {
      this._fov = val;
      this._camera.setFov(toRadian(val));
    }
  },

  // orthoHeight
  orthoHeight: {
    type: 'number',
    default: 10,
    set: function set(val) {
      this._orthoHeight = val;
      this._camera.setOrthoHeight(val);
    }
  },

  // near
  near: {
    type: 'number',
    default: 0.01,
    set: function set(val) {
      this._near = val;
      this._camera.setNear(val);
    }
  },

  // far
  far: {
    type: 'number',
    default: 1000.0,
    set: function set(val) {
      this._far = val;
      this._camera.setFar(val);
    }
  },

  // color
  color: {
    type: 'color4',
    default: [0.2, 0.3, 0.47, 1],
    set: function set(val) {
      this._color = val;
      this._camera.setColor(val.r, val.g, val.b, val.a);
    }
  },

  // depth
  depth: {
    type: 'number',
    default: 1,
    set: function set(val) {
      this._depth = val;
      this._camera.setDepth(val);
    }
  },

  // stencil
  stencil: {
    type: 'number',
    default: 0,
    set: function set(val) {
      this._stencil = val;
      this._camera.setStencil(val);
    }
  },

  // clearFlags
  clearFlags: {
    type: 'number',
    default: 3, // enums.CLEAR_COLOR | enums.CLEAR_DEPTH;
    set: function set(val) {
      this._clearFlags = val;
      this._camera.setClearFlags(val);
    }
  },

  // rect
  rect: {
    type: 'rect',
    default: [0, 0, 1, 1],
    set: function set(val) {
      this._rect = val;
      this._camera.setRect(val[0], val[1], val[2], val[3]);
    }
  },
};

var LightComponent = (function (Component) {
  function LightComponent() {
    Component.call(this);

    this._light = new renderer.Light();
  }

  if ( Component ) LightComponent.__proto__ = Component;
  LightComponent.prototype = Object.create( Component && Component.prototype );
  LightComponent.prototype.constructor = LightComponent;

  LightComponent.prototype.onInit = function onInit () {
    this._light.setNode(this._entity);

    /**
     * **@schema** The light source type
     * @type {string}
     */
    this.type = this._type;
    /**
     * **@schema** The light source color
     * @type {color3}
     */
    this.color = this._color;
    /**
     * **@schema** The light source intensity
     * @type {number}
     */
    this.intensity = this._intensity;
    /**
     * **@schema** The light range, used for spot and point light
     * @type {number}
     */
    this.range = this._range;
    /**
     * **@schema** The spot light cone angle
     * @type {number}
     */
    this.spotAngle = this._spotAngle;
    /**
     * **@schema** The spot light exponential
     * @type {number}
     */
    this.spotExp = this._spotExp;
    /**
     * **@schema** The shadow type
     * @type {string}
     */
    this.shadowType = this._shadowType;
    /**
     * **@schema** The shadow resolution
     * @type {number}
     */
    this.shadowResolution = this._shadowResolution;
    /**
     * **@schema** The shadow darkness
     * @type {number}
     */
    this.shadowDarkness = this._shadowDarkness;
    /**
     * **@schema** The shadow min depth
     * @type {number}
     */
    this.shadowMinDepth = this._shadowMinDepth;
    /**
     * **@schema** The shadow max depth
     * @type {number}
     */
    this.shadowMaxDepth = this._shadowMaxDepth;
    /**
     * **@schema** The shadow depth scale
     * @type {number}
     */
    this.shadowDepthScale = this._shadowDepthScale;
    /**
     * **@schema** The shadow frustum size
     * @type {number}
     */
    this.shadowFrustumSize = this._shadowFrustumSize;
    /**
     * **@schema** The shadow bias
     * @type {number}
     */
    this.shadowBias = this._shadowBias;
  };

  LightComponent.prototype.onEnable = function onEnable () {
    this._app.scene.addLight(this._light);
  };

  LightComponent.prototype.onDisable = function onDisable () {
    this._app.scene.removeLight(this._light);
  };

  return LightComponent;
}(Component));

LightComponent.schema = {
  type: {
    type: 'enums',
    default: 'directional',
    options: ['directional', 'point', 'spot'],
    set: function set(val) {
      this._type = val;

      var type = renderer.LIGHT_DIRECTIONAL;
      if (this._type === 'point') {
        type = renderer.LIGHT_POINT;
      } else if (this._type === 'spot') {
        type = renderer.LIGHT_SPOT;
      }
      this._light.setType(type);
    }
  },

  color: {
    type: 'color3',
    default: [1, 1, 1],
    set: function set(val) {
      this._color = val;
      this._light.setColor(val.r, val.g, val.b);
    }
  },

  intensity: {
    type: 'number',
    default: 1,
    set: function set(val) {
      this._intensity = val;
      this._light.setIntensity(val);
    }
  },

  range: {
    type: 'number',
    default: 1,
    set: function set(val) {
      this._range = val;
      this._light.setRange(val);
    }
  },

  spotAngle: {
    type: 'number',
    default: 60,
    set: function set(val) {
      this._spotAngle = val;
      this._light.setSpotAngle(toRadian(val));
    }
  },

  spotExp: {
    type: 'number',
    default: 1,
    set: function set(val) {
      this._spotExp = val;
      this._light.setSpotExp(val);
    }
  },

  shadowType: {
    type: 'enums',
    default: 'none',
    options: ['none', 'hard', 'soft'],
    set: function set(val) {
      this._shadowType = val;

      var type = renderer.SHADOW_NONE;
      if (val === 'hard') {
        type = renderer.SHADOW_HARD;
      } else if (val === 'soft') {
        type = renderer.SHADOW_SOFT;
      }
      this._light.setShadowType(type);
    }
  },

  shadowResolution: {
    type: 'number',
    default: 1024,
    set: function set(val) {
      this._shadowResolution = val;
      this._light.setShadowResolution(val);
    }
  },

  shadowDarkness: {
    type: 'number',
    default: 0.5,
    set: function set(val) {
      this._shadowDarkness = val;
      this._light.setShadowDarkness(val);
    }
  },

  shadowMinDepth: {
    type: 'number',
    default: 1,
    set: function set(val) {
      this._shadowMinDepth = val;
      this._light.setShadowMinDepth(val);
    }
  },

  shadowMaxDepth: {
    type: 'number',
    default: 1000,
    set: function set(val) {
      this._shadowMaxDepth = val;
      this._light.setShadowMaxDepth(val);
    }
  },

  shadowDepthScale: {
    type: 'number',
    default: 250,
    set: function set(val) {
      this._shadowDepthScale = val;
      this._light.setShadowDepthScale(val);
    }
  },

  shadowFrustumSize: {
    type: 'number',
    default: 50,
    set: function set(val) {
      this._shadowFrustumSize = val;
      this._light.setShadowFrustumSize(val);
    }
  },

  shadowBias: {
    type: 'number',
    default: 0.0005,
    set: function set(val) {
      this._shadowBias = val;
      this._light.setShadowBias(val);
    }
  }
};

var ModelComponent = (function (Component) {
  function ModelComponent () {
    Component.apply(this, arguments);
  }

  if ( Component ) ModelComponent.__proto__ = Component;
  ModelComponent.prototype = Object.create( Component && Component.prototype );
  ModelComponent.prototype.constructor = ModelComponent;

  var prototypeAccessors = { material: { configurable: true } };

  ModelComponent.prototype.onInit = function onInit () {
    this._models = [];

    /**
     * **@schema** The material of the model
     * @type {Material}
     */
    this.materials = this._materials;
    /**
     * **@schema** The mesh of the model
     * @type {Mesh}
     */
    this.mesh = this._mesh;
    /**
     * **@schema** The shadow casting mode
     * @type {string}
     */
    this.shadowCastingMode = this._shadowCastingMode;
    /**
     * **@schema** Does this model receive shadows?
     * @type {boolean}
     */
    this.receiveShadows = this._receiveShadows;
  };

  ModelComponent.prototype.onEnable = function onEnable () {
    var this$1 = this;

    for (var i = 0; i < this._models.length; ++i) {
      this$1._app.scene.addModel(this$1._models[i]);
    }
  };

  ModelComponent.prototype.onDisable = function onDisable () {
    var this$1 = this;

    for (var i = 0; i < this._models.length; ++i) {
      this$1._app.scene.removeModel(this$1._models[i]);
    }
  };

  ModelComponent.prototype.getMaterial = function getMaterial (idx) {
    if (this._materials.length === 0) {
      return null;
    }

    if (idx < this._materials.length) {
      return this._materials[idx];
    }

    return this._materials[this._materials.length - 1];
  };

  prototypeAccessors.material.get = function () {
    return this.getMaterial(0);
  };
  prototypeAccessors.material.set = function (val) {
    if (this._materials.length === 1 && this._materials[0] === val) {
      return;
    }

    this._materials[0] = val;

    if (this._models.length > 0) {
      this._models[0].setEffect(val.effectInst);
    }
  };

  ModelComponent.prototype._updateModels = function _updateModels () {
    var this$1 = this;

    var meshCount = this._mesh ? this._mesh.subMeshCount : 0;
    var oldModels = this._models;

    this._models = new Array(meshCount);
    for (var i = 0; i < meshCount; ++i) {
      var model = new renderer.Model();
      model.createBoundingBox(this$1._mesh._minPos, this$1._mesh._maxPos);
      this$1._models[i] = model;
    }

    this._updateModelParams();

    if (this.enabled) {
      for (var i$1 = 0; i$1 < oldModels.length; ++i$1) {
        this$1._app.scene.removeModel(oldModels[i$1]);
      }
      for (var i$2 = 0; i$2 < this._models.length; ++i$2) {
        this$1._app.scene.addModel(this$1._models[i$2]);
      }
    }
  };

  ModelComponent.prototype._updateModelParams = function _updateModelParams () {
    var this$1 = this;

    for (var i = 0; i < this._models.length; ++i) {
      var model = this$1._models[i];
      var material = this$1.getMaterial(i);
      var inputAssembler = this$1._mesh.getSubMesh(i);

      model.setInputAssembler(inputAssembler);
      model.setEffect(material ? material.effectInst : null);
      model.setNode(this$1._entity);
    }
  };

  ModelComponent.prototype._updateCastShadow = function _updateCastShadow () {
    var this$1 = this;

    if (this._shadowCastingMode === 'off') {
      for (var i = 0; i < this._models.length; ++i) {
        var model = this$1._models[i];
        model._castShadow = false;
      }
    } else if (this._shadowCastingMode === 'on') {
      for (var i$1 = 0; i$1 < this._models.length; ++i$1) {
        var model$1 = this$1._models[i$1];
        model$1._castShadow = true;
      }
    } else {
      console.warn(("ShadowCastingMode " + (this._shadowCastingMode) + " is not supported."));
    }
  };

  ModelComponent.prototype._updateReceiveShadow = function _updateReceiveShadow () {
    var this$1 = this;

    for (var i = 0; i < this._models.length; ++i) {
      var model = this$1._models[i];
      if (model._defines['USE_SHADOW_MAP'] != undefined) {
        model._effect.define('USE_SHADOW_MAP', this$1._receiveShadows);
      }
    }
  };

  Object.defineProperties( ModelComponent.prototype, prototypeAccessors );

  return ModelComponent;
}(Component));

ModelComponent.schema = {
  materials: {
    type: 'asset',
    default: [],
    array: true,
    set: function set(val) {
      this._materials = val;
      this._updateModelParams();
    }
  },

  mesh: {
    type: 'asset',
    default: null,
    set: function set(val) {
      this._mesh = val;
      this._updateModels();
    }
  },

  shadowCastingMode: {
    type: 'enums',
    default: 'off',
    options: [
      'off',
      'on',
      'twoSided',
      'shadowsOnly'
    ],
    set: function set(val) {
      this._shadowCastingMode = val;
      this._updateCastShadow();
    }
  },

  receiveShadows: {
    type: 'boolean',
    default: false,
    set: function set(val) {
      this._receiveShadows = val;
      this._updateReceiveShadow();
    }
  }
};

var _m4_tmp$3 = mat4.create();

var SkinningModelComponent = (function (ModelComponent$$1) {
  function SkinningModelComponent () {
    ModelComponent$$1.apply(this, arguments);
  }

  if ( ModelComponent$$1 ) SkinningModelComponent.__proto__ = ModelComponent$$1;
  SkinningModelComponent.prototype = Object.create( ModelComponent$$1 && ModelComponent$$1.prototype );
  SkinningModelComponent.prototype.constructor = SkinningModelComponent;

  SkinningModelComponent.prototype.onInit = function onInit () {
    this._models = [];
    // internal skinning data
    this._jointsTexture = null;
    this._refSkeleton = null;

    this._updateModels();
    this._updateCastShadow();
    this._updateReceiveShadow();

    var rootEnt = this._entity.parent;
    var animComp = rootEnt.getComp('Animation');
    if (animComp) {
      this._refSkeleton = animComp.skeleton;
    } else {
      console.warn('Can not find Animation component in root entity.');
    }

    this._system.add(this);
  };

  SkinningModelComponent.prototype.onDestroy = function onDestroy () {
    this._system.remove(this);
  };

  SkinningModelComponent.prototype._updateMatrices = function _updateMatrices () {
    var this$1 = this;

    if (!this._mesh || !this._mesh.skinning) {
      return;
    }

    var texture = this._jointsTexture;
    var jointIndices = this._mesh.skinning.jointIndices;
    var bindposes = this._mesh.skinning.bindposes;

    for (var i = 0; i < jointIndices.length; ++i) {
      var bindpose = bindposes[i];
      var idx = jointIndices[i];

      var worldMatrix = this$1._refSkeleton.getWorldMatrix(idx);
      mat4.multiply(_m4_tmp$3, worldMatrix, bindpose);

      texture.data[16 * i + 0]  = _m4_tmp$3.m00;
      texture.data[16 * i + 1]  = _m4_tmp$3.m01;
      texture.data[16 * i + 2]  = _m4_tmp$3.m02;
      texture.data[16 * i + 3]  = _m4_tmp$3.m03;
      texture.data[16 * i + 4]  = _m4_tmp$3.m04;
      texture.data[16 * i + 5]  = _m4_tmp$3.m05;
      texture.data[16 * i + 6]  = _m4_tmp$3.m06;
      texture.data[16 * i + 7]  = _m4_tmp$3.m07;
      texture.data[16 * i + 8]  = _m4_tmp$3.m08;
      texture.data[16 * i + 9]  = _m4_tmp$3.m09;
      texture.data[16 * i + 10] = _m4_tmp$3.m10;
      texture.data[16 * i + 11] = _m4_tmp$3.m11;
      texture.data[16 * i + 12] = _m4_tmp$3.m12;
      texture.data[16 * i + 13] = _m4_tmp$3.m13;
      texture.data[16 * i + 14] = _m4_tmp$3.m14;
      texture.data[16 * i + 15] = _m4_tmp$3.m15;
    }

    texture.commit();
  };

  SkinningModelComponent.prototype._updateModels = function _updateModels () {
    var this$1 = this;

    if (this._mesh.skinning) {
      if (this._jointsTexture) {
        this._jointsTexture.unload();
        this._jointsTexture = null;
      }

      this._jointsTexture = utils$1.createJointsTexture(
        this._app,
        this._mesh.skinning
      );
    }

    var meshCount = this._mesh ? this._mesh.subMeshCount : 0;
    var oldModels = this._models;

    this._models = new Array(meshCount);
    for (var i = 0; i < meshCount; ++i) {
      var model = new renderer.SkinningModel();
      model.createBoundingBox(this$1._mesh._minPos, this$1._mesh._maxPos);
      this$1._models[i] = model;
    }

    this. _updateModelParams();

    if (this.enabled) {
      this._entity.emit('skinning-model-changed', this, 'mesh', oldModels);
    }
  };

  SkinningModelComponent.prototype._updateModelParams = function _updateModelParams () {
    var this$1 = this;

    ModelComponent$$1.prototype._updateModelParams.call(this);
    for (var i = 0; i < this._models.length; ++i)
      { this$1._models[i].setJointsTexture(this$1._jointsTexture._texture); }
  };

  return SkinningModelComponent;
}(ModelComponent));

var AnimationState = function AnimationState(clip) {
  this.clip = clip;
  this.blendMode = 'blend'; // 'blend', 'additive'
  this.wrapMode = 'loop'; // 'once', 'loop', 'ping-pong', 'clamp'
  this.speed = 1.0;
  this.time = 0.0;
  this.weight = 1.0;
};

var AnimationCtrl = function AnimationCtrl() {
  this._current = null;
  this._next = null;
  this._blendTime = 0.0;
  this._blendDuration = 0.3;

  this._skeleton = null;
  this._skelFrom = null;
  this._skelTo = null;
};

AnimationCtrl.prototype.setSkeleton = function setSkeleton (skel) {
  this._skeleton = skel;
  this._skelFrom = skel.clone();
  this._skelTo = skel.clone();
};

AnimationCtrl.prototype.crossFade = function crossFade (to, duration) {
  if (this._current && duration > 0.0) {
    this._next = to;
    this._blendTime = 0.0;
    this._blendDuration = duration;
  } else {
    this._current = to;
    this._next = null;
  }
};

AnimationCtrl.prototype.tick = function tick (dt) {
  // handle blend
  if (this._current && this._next) {
    var t0 = this._getTime(this._current);
    var t1 = this._getTime(this._next);

    var alpha = this._blendTime / this._blendDuration;

    this._current.time += dt;
    this._next.time += dt;
    this._blendTime += dt;

    if (alpha > 1.0) {
      this._current = this._next;
      this._next = null;

      this._current.clip.sample(this._skeleton, t1);
    } else {
      this._current.clip.sample(this._skelFrom, t0);
      this._next.clip.sample(this._skelTo, t1);

      this._skeleton.blend(this._skelFrom, this._skelTo, alpha);
      this._skeleton.updateMatrices();
    }

    return;
  }

  // handle playing
  if (this._current) {
    var t0$1 = this._getTime(this._current);
    this._current.clip.sample(this._skeleton, t0$1);

    this._current.time += dt;
  }
};

AnimationCtrl.prototype._getTime = function _getTime (state) {
  var t = state.time;
  var length = state.clip.length;

  if (state.wrapMode === 'once') {
    if (t > length) {
      t = 0.0;
    }
  } else if (state.wrapMode === 'loop') {
    t %= length;
  } else if (state.wrapMode === 'ping-pong') {
    var order = Math.floor(t / length);
    if (order % 2 === 1) {
      t = length - t % length;
    }
  }

  return t;
};

var AnimationComponent = (function (Component) {
  function AnimationComponent () {
    Component.apply(this, arguments);
  }

  if ( Component ) AnimationComponent.__proto__ = Component;
  AnimationComponent.prototype = Object.create( Component && Component.prototype );
  AnimationComponent.prototype.constructor = AnimationComponent;

  var prototypeAccessors = { skeleton: { configurable: true } };

  AnimationComponent.prototype.onInit = function onInit () {
    this._name2states = {};
    this._animCtrl = new AnimationCtrl();

    /**
     * **@schema** The animation clips
     * @type {AnimationClip[]}
     */
    this.clips = this._clips;
    /**
     * **@schema** The animation skeleton
     * @type {Joints}
     */
    this.joints = this._joints;

    this._system.add(this);
  };

  AnimationComponent.prototype.onDestroy = function onDestroy () {
    this._system.remove(this);
  };

  prototypeAccessors.skeleton.get = function () {
    return this._skeleton;
  };

  AnimationComponent.prototype.addClip = function addClip (name, animClip) {
    if (this._name2states[name]) {
      console.warn(("Failed to add clip " + name + ", the name already exsits."));
      return;
    }

    this._clips.push(animClip);
    this._name2states[name] = new AnimationState(animClip);
  };

  AnimationComponent.prototype.getState = function getState (name) {
    return this._name2states[name];
  };

  AnimationComponent.prototype.play = function play (name, fadeDuration) {
    if ( fadeDuration === void 0 ) fadeDuration = 0.3;

    if (!this._name2states[name]) {
      console.warn(("Failed to play animation " + name + ", not found."));
      return;
    }

    var animState = this._name2states[name];
    animState.time = 0.0;

    this._animCtrl.crossFade(animState, fadeDuration);
  };

  AnimationComponent.prototype._updateSkeleton = function _updateSkeleton () {
    this.joints = this._joints;
  };

  Object.defineProperties( AnimationComponent.prototype, prototypeAccessors );

  return AnimationComponent;
}(Component));

AnimationComponent.schema = {
  clips: {
    type: 'asset',
    default: [],
    array: true,
    set: function set (val) {
      var this$1 = this;

      this._clips = val;

      for (var i = 0; i < this._clips.length; ++i) {
        var clip = this$1._clips[i];
        if (this$1._name2states[clip.name]) {
          console.warn(("Failed to add clip " + (clip.name) + ", the name already exsits."));
          continue;
        }
        this$1._name2states[clip.name] = new AnimationState(clip);
      }
    }
  },

  joints: {
    type: 'asset',
    default: null,
    set: function set (val) {
      this._joints = val;

      if (this._joints) {
        this._skeleton = this._joints.instantiate();
        this._animCtrl.setSkeleton(this._skeleton);
      } else {
        this._skeleton = null;
      }
    }
  },
};

var CC_WECHATGAME = false;
var CC_QQPLAY = false;
var touchBinded = false;
var touchPlayList = [
    //{ instance: Audio, offset: 0, audio: audio }
];
var Audio = {};
/**
* !#en Audio state.
* !#zh 
* @enum audioEngine.AudioState
* @memberof cc
*/
// TODO - At present, the state is mixed with two states of users and systems, and it is best to split into two types. A 'loading' should also be added to the system state.
Audio.State = {
  /**
  * @property {Number} ERROR
  */
  ERROR : -1,
  /**
  * @property {Number} INITIALZING
  */
  INITIALZING: 0,
  /**
  * @property {Number} PLAYING
  */
  PLAYING: 1,
  /**
  * @property {Number} PAUSED
  */
  PAUSED: 2
};

/**
 * A representation of a single audio source,
 * contains basic functionalities like play, pause and stop.
 */
var AudioSourceComponent = (function (Component) {
  function AudioSourceComponent() {
    Component.call(this);
    this._element = null;
    this._nextTime = 0;  // playback position to set
    this._state = Audio.State.INITIALZING;
  }

  if ( Component ) AudioSourceComponent.__proto__ = Component;
  AudioSourceComponent.prototype = Object.create( Component && Component.prototype );
  AudioSourceComponent.prototype.constructor = AudioSourceComponent;

  var prototypeAccessors = { currentTime: { configurable: true },duration: { configurable: true },state: { configurable: true },paused: { configurable: true } };

  AudioSourceComponent.prototype.onInit = function onInit () {
    this._system.add(this);
    /**
     * **@schema** The AudioClip to play
     * @type {AudioClip}
     */
    this.clip = this._clip;
    /**
     * **@schema** Is the audio clip looping?
     * @type {boolean}
     */
    this.loop = this._loop;
    /**
     * **@schema** The volume of the audio source (0.0 to 1.0).
     * @type {number}
     */
    this.volume = this._volume;
    /**
     * **@schema** If set to true, the audio source will automatically start playing on awake.
     * @type {boolean}
     */
    this.playOnAwake = this._playOnAwake;
  };

  AudioSourceComponent.prototype.onDestroy = function onDestroy () {
    this._system.remove(this);
  };

  /**
   * Plays the clip
   */
  AudioSourceComponent.prototype.play = function play () {
    // marked as playing so it will playOnLoad
    this._state = Audio.State.PLAYING;

    if (!this._element) {
      return;
    }

    this._bindEnded();
    this._element.play();

    if (!(CC_QQPLAY || CC_WECHATGAME) && this._clip && this._clip.loadMode === AudioClip.DOM_AUDIO && this._element.paused) {
      touchPlayList.push({ instance: this, offset: 0, audio: this._element });
    }

    if (touchBinded) { return; }
    touchBinded = true;

    // Listen to the touchstart body event and play the audio when necessary.
    window.addEventListener('touchstart', function () {
      var item = touchPlayList.pop();
      while (item) {
        item.audio.play(item.offset);
        item = touchPlayList.pop();
      }
    });
  };

  /**
   * Pause the clip
   */
  AudioSourceComponent.prototype.pause = function pause () {
    if (!this._element) { return; }
    this._unbindEnded();
    this._element.pause();
    this._state = Audio.State.PAUSED;
  };

  /**
   * Resume the clip
   */
  AudioSourceComponent.prototype.resume = function resume () {
    if (!this._element || this._state === Audio.State.PLAYING) { return; }
    this._bindEnded();
    this._element.play();
    this._state = Audio.State.PLAYING;
  };

  /**
   * Stop the clip
   */
  AudioSourceComponent.prototype.stop = function stop () {
    var this$1 = this;

    if (!this._element) { return; }
    try {
      this._element.currentTime = 0;
    } catch (error) { console.log(error); }
    this._element.pause();
    // remove touchPlayList
    for (var i=0; i<touchPlayList.length; i++) {
      if (touchPlayList[i].instance === this$1) {
        touchPlayList.splice(i, 1);
        break;
      }
    }
    this._unbindEnded();
    this._state = Audio.State.PAUSED;
  };

  /**
   * set the current time, in seconds
   * @param {number} num time you want to jump to 
   */
  prototypeAccessors.currentTime.set = function (num) {
    if (this._element) {
      this._nextTime = 0;
    }
    else {
      this._nextTime = num;
      return;
    }

    this._unbindEnded();
    if (!(CC_QQPLAY || CC_WECHATGAME)) {
      this._bindEnded(function () {
        this._bindEnded();
      }.bind(this));
    }
    try {
      this._element.currentTime = num;
    }
    catch (err) {
      var _element = this._element;
      if (_element.addEventListener) {
        var func = function () {
          _element.removeEventListener('loadedmetadata', func);
          _element.currentTime = num;
        };
        _element.addEventListener('loadedmetadata', func);
      }
    }
  };

  /**
   * get the current time, in seconds
   * @return {number} time current played time
   */
  prototypeAccessors.currentTime.get = function () {
    return this._element ? this._element.currentTime : 0;
  };

  /**
   * get the audio duration, in seconds
   * @return {number} audio duration
   */
  prototypeAccessors.duration.get = function () {
    return this._element ? this._element.duration : 0;
  };

  /**
   * get the audio duration, in seconds
   * @return {number} audio duration
   */
  prototypeAccessors.state.get = function () {
    if (!CC_WECHATGAME) {
      var elem = this._element;
      if (elem && Audio.State.PLAYING === this._state && elem.paused) {
        this._state = Audio.State.PAUSED;
      }
    }
    return this._state;
  };

  /**
   * is the audio currently paused?
   * @return {boolean} paused?
   */
  prototypeAccessors.paused.get = function () {
    return this._element ? this._element.paused : true;
  };

  AudioSourceComponent.prototype._bindEnded = function _bindEnded (callback) {
    callback = callback || this._onended;
    if (this._clip && this._clip.loadMode === AudioClip.DOM_AUDIO) {
      this._element.addEventListener('ended', callback);
    } else {
      this._element.onended = callback;
    }
  };

  AudioSourceComponent.prototype._unbindEnded = function _unbindEnded () {
    if (this._clip && this._clip.loadMode === AudioClip.DOM_AUDIO) {
      this._element.removeEventListener('ended', this._onended);
    } else {
      this._element.onended = null;
    }
  };

  AudioSourceComponent.prototype._onLoaded = function _onLoaded () {
    var elem = this._clip.nativeAsset;
    if (this._clip.loadMode === AudioClip.DOM_AUDIO || CC_QQPLAY || CC_WECHATGAME) {
      this._element = elem;
    }
    else {
      this._element = new WebAudioElement(elem, this);
    }

    this.volume = this._volume;
    this.loop = this._loop;
    if (this._nextTime !== 0) {
      this.setCurrentTime(this._nextTime);
    }
    if (this._state === Audio.State.PLAYING || this._playOnAwake) {
      this.play();
    }
    else {
      this._state = Audio.State.INITIALZING;
    }
  };

  Object.defineProperties( AudioSourceComponent.prototype, prototypeAccessors );

  return AudioSourceComponent;
}(Component));

AudioSourceComponent.schema = {
  clip: {
    type: 'asset',
    default: null,
    set: function set(val) {
      if (val) {
        this._clip = val;
        if (val._loaded) {
          this._onLoaded();
        }
        else {
          val.once('load', function () {
            if (val === this._clip) {
              this._onLoaded();
            }
          }.bind(this));
        }
      }
      else {
        this._clip = null;
        this._element = null;
        this._state = Audio.State.INITIALZING;
      }
      return val;
    },
  },
  loop: {
    type: 'boolean',
    default: false,
    set: function set(val) {
      this._loop = val;
      if (this._element) {
        this._element.loop = val;
      }
    },
  },
  playOnAwake: {
    type: 'boolean',
    default: true,
    set: function set(val) {
      this._playOnAwake = val;
      if (val) { this._state = Audio.State.PLAYING; }
    },
  },
  volume: {
    type: 'number',
    default: 1,
    set: function set(val) {
      this._volume = val;
      if (this._element) {
        this._element.volume = val;
      }
    },
  },
};

// possible TODO: everything below could be moved into AudioClip
// so that the component could be agnostic about the clip being played
// and behave uniformly across clips. Let AudioClip worry about its LoadMode.

// Encapsulated WebAudio interface
var WebAudioElement = function (buffer, audio) {
  this._audio = audio;
  this._context = this._audio._system.__audioSupport.context;
  this._buffer = buffer;

  this._gainObj = this._context['createGain']();
  this._volume = 1;
  // https://www.chromestatus.com/features/5287995770929152
  if (this._gainObj['gain'].setTargetAtTime) {
    this._gainObj['gain'].setTargetAtTime(this._volume, this._context.currentTime, 0.01);
  } else {
    this._gainObj['gain'].value = this._volume;
  }
  this._gainObj['connect'](this._context['destination']);

  this._loop = false;
  // The time stamp on the audio time axis when the recording begins to play.
  this._startTime = -1;
  // Record the currently playing 'Source'
  this._currentSource = null;
  // Record the time has been played
  this.playedLength = 0;

  this._currextTimer = null;

  this._endCallback = function () {
    if (this.onended) {
      this.onended(this);
    }
  }.bind(this);
};

(function (proto) {
  proto.play = function (offset) {
    // If repeat play, you need to stop before an audio
    if (this._currentSource && !this.paused) {
      this._currentSource.onended = null;
      this._currentSource.stop(0);
      this.playedLength = 0;
    }

    var audio = this._context['createBufferSource']();
    audio.buffer = this._buffer;
    audio['connect'](this._gainObj);
    audio.loop = this._loop;

    this._startTime = this._context.currentTime;
    offset = offset || this.playedLength;
    if (offset) {
      this._startTime -= offset;
    }
    var duration = this._buffer.duration;

    var startTime = offset;
    var endTime;
    if (this._loop) {
      if (audio.start)
        { audio.start(0, startTime); }
      else if (audio['notoGrainOn'])
        { audio['noteGrainOn'](0, startTime); }
      else
        { audio['noteOn'](0, startTime); }
    } else {
      endTime = duration - offset;
      if (audio.start)
        { audio.start(0, startTime, endTime); }
      else if (audio['notoGrainOn'])
        { audio['noteGrainOn'](0, startTime, endTime); }
      else
        { audio['noteOn'](0, startTime, endTime); }
    }

    this._currentSource = audio;

    audio.onended = this._endCallback;

    // If the current audio context time stamp is 0 and audio context state is suspended
    // There may be a need to touch events before you can actually start playing audio
    if ((!audio.context.state || audio.context.state === 'suspended') && this._context.currentTime === 0) {
      var self = this;
      clearTimeout(this._currextTimer);
      this._currextTimer = setTimeout(function () {
        if (!(CC_QQPLAY || CC_WECHATGAME) && self._context.currentTime === 0) {
          touchPlayList.push({
            instance: self._audio,
            offset: offset,
            audio: self
          });
        }
      }, 10);
    }
  };

  proto.pause = function () {
    clearTimeout(this._currextTimer);
    if (this.paused) { return; }
    // Record the time the current has been played
    this.playedLength = this._context.currentTime - this._startTime;
    // If more than the duration of the audio, Need to take the remainder
    this.playedLength %= this._buffer.duration;
    var audio = this._currentSource;
    this._currentSource = null;
    this._startTime = -1;
    if (audio)
      { audio.stop(0); }
  };

  proto.__defineGetter__('paused', function () {
    // If the current audio is a loop, paused is false
    if (this._currentSource && this._currentSource.loop)
      { return false; }

    // startTime default is -1
    if (this._startTime === -1)
      { return true; }

    // Current time -  Start playing time > Audio duration
    return this._context.currentTime - this._startTime > this._buffer.duration;
  });

  proto.__defineGetter__('loop', function () { return this._loop; });
  proto.__defineSetter__('loop', function (bool) {
    if (this._currentSource)
      { this._currentSource.loop = bool; }

    return this._loop = bool;
  });

  proto.__defineGetter__('volume', function () {
    return this._volume;
  });
  proto.__defineSetter__('volume', function (num) {
    this._volume = num;
    if (this._gainObj['gain'].setTargetAtTime) {
      this._gainObj['gain'].setTargetAtTime(this._volume, this._context.currentTime, 0.01);
    } else {
      this._volume['gain'].value = num;
    }
    if (this._audio._system.os === this._audio._system.OS_IOS && !this.paused && this._currentSource) {
      // IOS must be stop webAudio
      this._currentSource.onended = null;
      this.pause();
      this.play();
    }
    return num;
  });

  proto.__defineGetter__('currentTime', function () {
    if (this.paused) {
      return this.playedLength;
    }
    // Record the time the current has been played
    this.playedLength = this._context.currentTime - this._startTime;
    // If more than the duration of the audio, Need to take the remainder
    this.playedLength %= this._buffer.duration;
    return this.playedLength;
  });
  proto.__defineSetter__('currentTime', function (num) {
    if (!this.paused) {
      this.pause();
      this.playedLength = num;
      this.play();
    } else {
      this.playedLength = num;
    }
    return num;
  });

  proto.__defineGetter__('duration', function () {
    return this._buffer.duration;
  });

})(WebAudioElement.prototype);

var CannonWorld = function CannonWorld() {
};
  
CannonWorld.prototype.add = function add (comp) {
};

CannonWorld.prototype.onDestroy = function onDestroy () {
};

CannonWorld.prototype.step = function step (dt) {
};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}



function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var cannon = createCommonjsModule(function (module, exports) {
/*
 * Copyright (c) 2015 cannon.js Authors
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

!function(e){{ module.exports=e(); }}(function(){return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof commonjsRequire=="function"&&commonjsRequire;if(!u&&a){ return a(o,!0); }if(i){ return i(o,!0); }throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r);}return n[o].exports}var i=typeof commonjsRequire=="function"&&commonjsRequire;for(var o=0;o<r.length;o++){ s(r[o]); }return s})({1:[function(_dereq_,module,exports){
module.exports={
  "name": "cannon",
  "version": "0.6.2",
  "description": "A lightweight 3D physics engine written in JavaScript.",
  "homepage": "https://github.com/schteppe/cannon.js",
  "author": "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
  "keywords": [
    "cannon.js",
    "cannon",
    "physics",
    "engine",
    "3d"
  ],
  "main": "./build/cannon.js",
  "engines": {
    "node": "*"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/schteppe/cannon.js.git"
  },
  "bugs": {
    "url": "https://github.com/schteppe/cannon.js/issues"
  },
  "licenses": [
    {
      "type": "MIT"
    }
  ],
  "devDependencies": {
    "jshint": "latest",
    "uglify-js": "latest",
    "nodeunit": "^0.9.0",
    "grunt": "~0.4.0",
    "grunt-contrib-jshint": "~0.1.1",
    "grunt-contrib-nodeunit": "^0.4.1",
    "grunt-contrib-concat": "~0.1.3",
    "grunt-contrib-uglify": "^0.5.1",
    "grunt-browserify": "^2.1.4",
    "grunt-contrib-yuidoc": "^0.5.2",
    "browserify": "*"
  },
  "dependencies": {}
};

},{}],2:[function(_dereq_,module,exports){
// Export classes
module.exports = {
    version :                       _dereq_('../package.json').version,

    AABB :                          _dereq_('./collision/AABB'),
    ArrayCollisionMatrix :          _dereq_('./collision/ArrayCollisionMatrix'),
    Body :                          _dereq_('./objects/Body'),
    Box :                           _dereq_('./shapes/Box'),
    Broadphase :                    _dereq_('./collision/Broadphase'),
    Constraint :                    _dereq_('./constraints/Constraint'),
    ContactEquation :               _dereq_('./equations/ContactEquation'),
    Narrowphase :                   _dereq_('./world/Narrowphase'),
    ConeTwistConstraint :           _dereq_('./constraints/ConeTwistConstraint'),
    ContactMaterial :               _dereq_('./material/ContactMaterial'),
    ConvexPolyhedron :              _dereq_('./shapes/ConvexPolyhedron'),
    Cylinder :                      _dereq_('./shapes/Cylinder'),
    DistanceConstraint :            _dereq_('./constraints/DistanceConstraint'),
    Equation :                      _dereq_('./equations/Equation'),
    EventTarget :                   _dereq_('./utils/EventTarget'),
    FrictionEquation :              _dereq_('./equations/FrictionEquation'),
    GSSolver :                      _dereq_('./solver/GSSolver'),
    GridBroadphase :                _dereq_('./collision/GridBroadphase'),
    Heightfield :                   _dereq_('./shapes/Heightfield'),
    HingeConstraint :               _dereq_('./constraints/HingeConstraint'),
    LockConstraint :                _dereq_('./constraints/LockConstraint'),
    Mat3 :                          _dereq_('./math/Mat3'),
    Material :                      _dereq_('./material/Material'),
    NaiveBroadphase :               _dereq_('./collision/NaiveBroadphase'),
    ObjectCollisionMatrix :         _dereq_('./collision/ObjectCollisionMatrix'),
    Pool :                          _dereq_('./utils/Pool'),
    Particle :                      _dereq_('./shapes/Particle'),
    Plane :                         _dereq_('./shapes/Plane'),
    PointToPointConstraint :        _dereq_('./constraints/PointToPointConstraint'),
    Quaternion :                    _dereq_('./math/Quaternion'),
    Ray :                           _dereq_('./collision/Ray'),
    RaycastVehicle :                _dereq_('./objects/RaycastVehicle'),
    RaycastResult :                 _dereq_('./collision/RaycastResult'),
    RigidVehicle :                  _dereq_('./objects/RigidVehicle'),
    RotationalEquation :            _dereq_('./equations/RotationalEquation'),
    RotationalMotorEquation :       _dereq_('./equations/RotationalMotorEquation'),
    SAPBroadphase :                 _dereq_('./collision/SAPBroadphase'),
    SPHSystem :                     _dereq_('./objects/SPHSystem'),
    Shape :                         _dereq_('./shapes/Shape'),
    Solver :                        _dereq_('./solver/Solver'),
    Sphere :                        _dereq_('./shapes/Sphere'),
    SplitSolver :                   _dereq_('./solver/SplitSolver'),
    Spring :                        _dereq_('./objects/Spring'),
    Trimesh :                       _dereq_('./shapes/Trimesh'),
    Vec3 :                          _dereq_('./math/Vec3'),
    Vec3Pool :                      _dereq_('./utils/Vec3Pool'),
    World :                         _dereq_('./world/World'),
};

},{"../package.json":1,"./collision/AABB":3,"./collision/ArrayCollisionMatrix":4,"./collision/Broadphase":5,"./collision/GridBroadphase":6,"./collision/NaiveBroadphase":7,"./collision/ObjectCollisionMatrix":8,"./collision/Ray":9,"./collision/RaycastResult":10,"./collision/SAPBroadphase":11,"./constraints/ConeTwistConstraint":12,"./constraints/Constraint":13,"./constraints/DistanceConstraint":14,"./constraints/HingeConstraint":15,"./constraints/LockConstraint":16,"./constraints/PointToPointConstraint":17,"./equations/ContactEquation":19,"./equations/Equation":20,"./equations/FrictionEquation":21,"./equations/RotationalEquation":22,"./equations/RotationalMotorEquation":23,"./material/ContactMaterial":24,"./material/Material":25,"./math/Mat3":27,"./math/Quaternion":28,"./math/Vec3":30,"./objects/Body":31,"./objects/RaycastVehicle":32,"./objects/RigidVehicle":33,"./objects/SPHSystem":34,"./objects/Spring":35,"./shapes/Box":37,"./shapes/ConvexPolyhedron":38,"./shapes/Cylinder":39,"./shapes/Heightfield":40,"./shapes/Particle":41,"./shapes/Plane":42,"./shapes/Shape":43,"./shapes/Sphere":44,"./shapes/Trimesh":45,"./solver/GSSolver":46,"./solver/Solver":47,"./solver/SplitSolver":48,"./utils/EventTarget":49,"./utils/Pool":51,"./utils/Vec3Pool":54,"./world/Narrowphase":55,"./world/World":56}],3:[function(_dereq_,module,exports){
var Vec3 = _dereq_('../math/Vec3');
var Utils = _dereq_('../utils/Utils');

module.exports = AABB;

/**
 * Axis aligned bounding box class.
 * @class AABB
 * @constructor
 * @param {Object} [options]
 * @param {Vec3}   [options.upperBound]
 * @param {Vec3}   [options.lowerBound]
 */
function AABB(options){
    options = options || {};

    /**
     * The lower bound of the bounding box.
     * @property lowerBound
     * @type {Vec3}
     */
    this.lowerBound = new Vec3();
    if(options.lowerBound){
        this.lowerBound.copy(options.lowerBound);
    }

    /**
     * The upper bound of the bounding box.
     * @property upperBound
     * @type {Vec3}
     */
    this.upperBound = new Vec3();
    if(options.upperBound){
        this.upperBound.copy(options.upperBound);
    }
}

var tmp = new Vec3();

/**
 * Set the AABB bounds from a set of points.
 * @method setFromPoints
 * @param {Array} points An array of Vec3's.
 * @param {Vec3} position
 * @param {Quaternion} quaternion
 * @param {number} skinSize
 * @return {AABB} The self object
 */
AABB.prototype.setFromPoints = function(points, position, quaternion, skinSize){
    var l = this.lowerBound,
        u = this.upperBound,
        q = quaternion;

    // Set to the first point
    l.copy(points[0]);
    if(q){
        q.vmult(l, l);
    }
    u.copy(l);

    for(var i = 1; i<points.length; i++){
        var p = points[i];

        if(q){
            q.vmult(p, tmp);
            p = tmp;
        }

        if(p.x > u.x){ u.x = p.x; }
        if(p.x < l.x){ l.x = p.x; }
        if(p.y > u.y){ u.y = p.y; }
        if(p.y < l.y){ l.y = p.y; }
        if(p.z > u.z){ u.z = p.z; }
        if(p.z < l.z){ l.z = p.z; }
    }

    // Add offset
    if (position) {
        position.vadd(l, l);
        position.vadd(u, u);
    }

    if(skinSize){
        l.x -= skinSize;
        l.y -= skinSize;
        l.z -= skinSize;
        u.x += skinSize;
        u.y += skinSize;
        u.z += skinSize;
    }

    return this;
};

/**
 * Copy bounds from an AABB to this AABB
 * @method copy
 * @param  {AABB} aabb Source to copy from
 * @return {AABB} The this object, for chainability
 */
AABB.prototype.copy = function(aabb){
    this.lowerBound.copy(aabb.lowerBound);
    this.upperBound.copy(aabb.upperBound);
    return this;
};

/**
 * Clone an AABB
 * @method clone
 */
AABB.prototype.clone = function(){
    return new AABB().copy(this);
};

/**
 * Extend this AABB so that it covers the given AABB too.
 * @method extend
 * @param  {AABB} aabb
 */
AABB.prototype.extend = function(aabb){
    // Extend lower bound
    var l = aabb.lowerBound.x;
    if(this.lowerBound.x > l){
        this.lowerBound.x = l;
    }

    // Upper
    var u = aabb.upperBound.x;
    if(this.upperBound.x < u){
        this.upperBound.x = u;
    }

    // Extend lower bound
    var l = aabb.lowerBound.y;
    if(this.lowerBound.y > l){
        this.lowerBound.y = l;
    }

    // Upper
    var u = aabb.upperBound.y;
    if(this.upperBound.y < u){
        this.upperBound.y = u;
    }

    // Extend lower bound
    var l = aabb.lowerBound.z;
    if(this.lowerBound.z > l){
        this.lowerBound.z = l;
    }

    // Upper
    var u = aabb.upperBound.z;
    if(this.upperBound.z < u){
        this.upperBound.z = u;
    }
};

/**
 * Returns true if the given AABB overlaps this AABB.
 * @method overlaps
 * @param  {AABB} aabb
 * @return {Boolean}
 */
AABB.prototype.overlaps = function(aabb){
    var l1 = this.lowerBound,
        u1 = this.upperBound,
        l2 = aabb.lowerBound,
        u2 = aabb.upperBound;

    //      l2        u2
    //      |---------|
    // |--------|
    // l1       u1

    return ((l2.x <= u1.x && u1.x <= u2.x) || (l1.x <= u2.x && u2.x <= u1.x)) &&
           ((l2.y <= u1.y && u1.y <= u2.y) || (l1.y <= u2.y && u2.y <= u1.y)) &&
           ((l2.z <= u1.z && u1.z <= u2.z) || (l1.z <= u2.z && u2.z <= u1.z));
};

/**
 * Returns true if the given AABB is fully contained in this AABB.
 * @method contains
 * @param {AABB} aabb
 * @return {Boolean}
 */
AABB.prototype.contains = function(aabb){
    var l1 = this.lowerBound,
        u1 = this.upperBound,
        l2 = aabb.lowerBound,
        u2 = aabb.upperBound;

    //      l2        u2
    //      |---------|
    // |---------------|
    // l1              u1

    return (
        (l1.x <= l2.x && u1.x >= u2.x) &&
        (l1.y <= l2.y && u1.y >= u2.y) &&
        (l1.z <= l2.z && u1.z >= u2.z)
    );
};

/**
 * @method getCorners
 * @param {Vec3} a
 * @param {Vec3} b
 * @param {Vec3} c
 * @param {Vec3} d
 * @param {Vec3} e
 * @param {Vec3} f
 * @param {Vec3} g
 * @param {Vec3} h
 */
AABB.prototype.getCorners = function(a, b, c, d, e, f, g, h){
    var l = this.lowerBound,
        u = this.upperBound;

    a.copy(l);
    b.set( u.x, l.y, l.z );
    c.set( u.x, u.y, l.z );
    d.set( l.x, u.y, u.z );
    e.set( u.x, l.y, l.z );
    f.set( l.x, u.y, l.z );
    g.set( l.x, l.y, u.z );
    h.copy(u);
};

var transformIntoFrame_corners = [
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3()
];

/**
 * Get the representation of an AABB in another frame.
 * @method toLocalFrame
 * @param  {Transform} frame
 * @param  {AABB} target
 * @return {AABB} The "target" AABB object.
 */
AABB.prototype.toLocalFrame = function(frame, target){

    var corners = transformIntoFrame_corners;
    var a = corners[0];
    var b = corners[1];
    var c = corners[2];
    var d = corners[3];
    var e = corners[4];
    var f = corners[5];
    var g = corners[6];
    var h = corners[7];

    // Get corners in current frame
    this.getCorners(a, b, c, d, e, f, g, h);

    // Transform them to new local frame
    for(var i=0; i !== 8; i++){
        var corner = corners[i];
        frame.pointToLocal(corner, corner);
    }

    return target.setFromPoints(corners);
};

/**
 * Get the representation of an AABB in the global frame.
 * @method toWorldFrame
 * @param  {Transform} frame
 * @param  {AABB} target
 * @return {AABB} The "target" AABB object.
 */
AABB.prototype.toWorldFrame = function(frame, target){

    var corners = transformIntoFrame_corners;
    var a = corners[0];
    var b = corners[1];
    var c = corners[2];
    var d = corners[3];
    var e = corners[4];
    var f = corners[5];
    var g = corners[6];
    var h = corners[7];

    // Get corners in current frame
    this.getCorners(a, b, c, d, e, f, g, h);

    // Transform them to new local frame
    for(var i=0; i !== 8; i++){
        var corner = corners[i];
        frame.pointToWorld(corner, corner);
    }

    return target.setFromPoints(corners);
};

},{"../math/Vec3":30,"../utils/Utils":53}],4:[function(_dereq_,module,exports){
module.exports = ArrayCollisionMatrix;

/**
 * Collision "matrix". It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
 * @class ArrayCollisionMatrix
 * @constructor
 */
function ArrayCollisionMatrix() {

    /**
     * The matrix storage
     * @property matrix
     * @type {Array}
     */
	this.matrix = [];
}

/**
 * Get an element
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */
ArrayCollisionMatrix.prototype.get = function(i, j) {
	i = i.index;
	j = j.index;
    if (j > i) {
        var temp = j;
        j = i;
        i = temp;
    }
	return this.matrix[(i*(i + 1)>>1) + j-1];
};

/**
 * Set an element
 * @method set
 * @param {Number} i
 * @param {Number} j
 * @param {Number} value
 */
ArrayCollisionMatrix.prototype.set = function(i, j, value) {
	i = i.index;
	j = j.index;
    if (j > i) {
        var temp = j;
        j = i;
        i = temp;
    }
	this.matrix[(i*(i + 1)>>1) + j-1] = value ? 1 : 0;
};

/**
 * Sets all elements to zero
 * @method reset
 */
ArrayCollisionMatrix.prototype.reset = function() {
	var this$1 = this;

	for (var i=0, l=this.matrix.length; i!==l; i++) {
		this$1.matrix[i]=0;
	}
};

/**
 * Sets the max number of objects
 * @method setNumObjects
 * @param {Number} n
 */
ArrayCollisionMatrix.prototype.setNumObjects = function(n) {
	this.matrix.length = n*(n-1)>>1;
};

},{}],5:[function(_dereq_,module,exports){
var Body = _dereq_('../objects/Body');
var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var Shape = _dereq_('../shapes/Shape');
var Plane = _dereq_('../shapes/Plane');

module.exports = Broadphase;

/**
 * Base class for broadphase implementations
 * @class Broadphase
 * @constructor
 * @author schteppe
 */
function Broadphase(){
    /**
    * The world to search for collisions in.
    * @property world
    * @type {World}
    */
    this.world = null;

    /**
     * If set to true, the broadphase uses bounding boxes for intersection test, else it uses bounding spheres.
     * @property useBoundingBoxes
     * @type {Boolean}
     */
    this.useBoundingBoxes = false;

    /**
     * Set to true if the objects in the world moved.
     * @property {Boolean} dirty
     */
    this.dirty = true;
}

/**
 * Get the collision pairs from the world
 * @method collisionPairs
 * @param {World} world The world to search in
 * @param {Array} p1 Empty array to be filled with body objects
 * @param {Array} p2 Empty array to be filled with body objects
 */
Broadphase.prototype.collisionPairs = function(world,p1,p2){
    throw new Error("collisionPairs not implemented for this BroadPhase class!");
};

/**
 * Check if a body pair needs to be intersection tested at all.
 * @method needBroadphaseCollision
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @return {bool}
 */
var Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC = Body.STATIC | Body.KINEMATIC;
Broadphase.prototype.needBroadphaseCollision = function(bodyA,bodyB){

    // Check collision filter masks
    if( (bodyA.collisionFilterGroup & bodyB.collisionFilterMask)===0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask)===0){
        return false;
    }

    // Check types
    if(((bodyA.type & Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC)!==0 || bodyA.sleepState === Body.SLEEPING) &&
       ((bodyB.type & Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC)!==0 || bodyB.sleepState === Body.SLEEPING)) {
        // Both bodies are static, kinematic or sleeping. Skip.
        return false;
    }

    return true;
};

/**
 * Check if the bounding volumes of two bodies intersect.
 * @method intersectionTest
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {array} pairs1
 * @param {array} pairs2
  */
Broadphase.prototype.intersectionTest = function(bodyA, bodyB, pairs1, pairs2){
    if(this.useBoundingBoxes){
        this.doBoundingBoxBroadphase(bodyA,bodyB,pairs1,pairs2);
    } else {
        this.doBoundingSphereBroadphase(bodyA,bodyB,pairs1,pairs2);
    }
};

/**
 * Check if the bounding spheres of two bodies are intersecting.
 * @method doBoundingSphereBroadphase
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Array} pairs1 bodyA is appended to this array if intersection
 * @param {Array} pairs2 bodyB is appended to this array if intersection
 */
var Broadphase_collisionPairs_r = new Vec3(), // Temp objects
    Broadphase_collisionPairs_normal =  new Vec3(),
    Broadphase_collisionPairs_quat =  new Quaternion(),
    Broadphase_collisionPairs_relpos  =  new Vec3();
Broadphase.prototype.doBoundingSphereBroadphase = function(bodyA,bodyB,pairs1,pairs2){
    var r = Broadphase_collisionPairs_r;
    bodyB.position.vsub(bodyA.position,r);
    var boundingRadiusSum2 = Math.pow(bodyA.boundingRadius + bodyB.boundingRadius, 2);
    var norm2 = r.norm2();
    if(norm2 < boundingRadiusSum2){
        pairs1.push(bodyA);
        pairs2.push(bodyB);
    }
};

/**
 * Check if the bounding boxes of two bodies are intersecting.
 * @method doBoundingBoxBroadphase
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Array} pairs1
 * @param {Array} pairs2
 */
Broadphase.prototype.doBoundingBoxBroadphase = function(bodyA,bodyB,pairs1,pairs2){
    if(bodyA.aabbNeedsUpdate){
        bodyA.computeAABB();
    }
    if(bodyB.aabbNeedsUpdate){
        bodyB.computeAABB();
    }

    // Check AABB / AABB
    if(bodyA.aabb.overlaps(bodyB.aabb)){
        pairs1.push(bodyA);
        pairs2.push(bodyB);
    }
};

/**
 * Removes duplicate pairs from the pair arrays.
 * @method makePairsUnique
 * @param {Array} pairs1
 * @param {Array} pairs2
 */
var Broadphase_makePairsUnique_temp = { keys:[] },
    Broadphase_makePairsUnique_p1 = [],
    Broadphase_makePairsUnique_p2 = [];
Broadphase.prototype.makePairsUnique = function(pairs1,pairs2){
    var t = Broadphase_makePairsUnique_temp,
        p1 = Broadphase_makePairsUnique_p1,
        p2 = Broadphase_makePairsUnique_p2,
        N = pairs1.length;

    for(var i=0; i!==N; i++){
        p1[i] = pairs1[i];
        p2[i] = pairs2[i];
    }

    pairs1.length = 0;
    pairs2.length = 0;

    for(var i=0; i!==N; i++){
        var id1 = p1[i].id,
            id2 = p2[i].id;
        var key = id1 < id2 ? id1+","+id2 :  id2+","+id1;
        t[key] = i;
        t.keys.push(key);
    }

    for(var i=0; i!==t.keys.length; i++){
        var key = t.keys.pop(),
            pairIndex = t[key];
        pairs1.push(p1[pairIndex]);
        pairs2.push(p2[pairIndex]);
        delete t[key];
    }
};

/**
 * To be implemented by subcasses
 * @method setWorld
 * @param {World} world
 */
Broadphase.prototype.setWorld = function(world){
};

/**
 * Check if the bounding spheres of two bodies overlap.
 * @method boundingSphereCheck
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @return {boolean}
 */
var bsc_dist = new Vec3();
Broadphase.boundingSphereCheck = function(bodyA,bodyB){
    var dist = bsc_dist;
    bodyA.position.vsub(bodyB.position,dist);
    return Math.pow(bodyA.shape.boundingSphereRadius + bodyB.shape.boundingSphereRadius,2) > dist.norm2();
};

/**
 * Returns all the bodies within the AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param  {array} result An array to store resulting bodies in.
 * @return {array}
 */
Broadphase.prototype.aabbQuery = function(world, aabb, result){
    console.warn('.aabbQuery is not implemented in this Broadphase subclass.');
    return [];
};
},{"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"../shapes/Plane":42,"../shapes/Shape":43}],6:[function(_dereq_,module,exports){
module.exports = GridBroadphase;

var Broadphase = _dereq_('./Broadphase');
var Vec3 = _dereq_('../math/Vec3');
var Shape = _dereq_('../shapes/Shape');

/**
 * Axis aligned uniform grid broadphase.
 * @class GridBroadphase
 * @constructor
 * @extends Broadphase
 * @todo Needs support for more than just planes and spheres.
 * @param {Vec3} aabbMin
 * @param {Vec3} aabbMax
 * @param {Number} nx Number of boxes along x
 * @param {Number} ny Number of boxes along y
 * @param {Number} nz Number of boxes along z
 */
function GridBroadphase(aabbMin,aabbMax,nx,ny,nz){
    var this$1 = this;

    Broadphase.apply(this);
    this.nx = nx || 10;
    this.ny = ny || 10;
    this.nz = nz || 10;
    this.aabbMin = aabbMin || new Vec3(100,100,100);
    this.aabbMax = aabbMax || new Vec3(-100,-100,-100);
	var nbins = this.nx * this.ny * this.nz;
	if (nbins <= 0) {
		throw "GridBroadphase: Each dimension's n must be >0";
	}
    this.bins = [];
	this.binLengths = []; //Rather than continually resizing arrays (thrashing the memory), just record length and allow them to grow
	this.bins.length = nbins;
	this.binLengths.length = nbins;
	for (var i=0;i<nbins;i++) {
		this$1.bins[i]=[];
		this$1.binLengths[i]=0;
	}
}
GridBroadphase.prototype = new Broadphase();
GridBroadphase.prototype.constructor = GridBroadphase;

/**
 * Get all the collision pairs in the physics world
 * @method collisionPairs
 * @param {World} world
 * @param {Array} pairs1
 * @param {Array} pairs2
 */
var GridBroadphase_collisionPairs_d = new Vec3();
var GridBroadphase_collisionPairs_binPos = new Vec3();
GridBroadphase.prototype.collisionPairs = function(world,pairs1,pairs2){
    var this$1 = this;

    var N = world.numObjects(),
        bodies = world.bodies;

    var max = this.aabbMax,
        min = this.aabbMin,
        nx = this.nx,
        ny = this.ny,
        nz = this.nz;

	var xstep = ny*nz;
	var ystep = nz;
	var zstep = 1;

    var xmax = max.x,
        ymax = max.y,
        zmax = max.z,
        xmin = min.x,
        ymin = min.y,
        zmin = min.z;

    var xmult = nx / (xmax-xmin),
        ymult = ny / (ymax-ymin),
        zmult = nz / (zmax-zmin);

    var binsizeX = (xmax - xmin) / nx,
        binsizeY = (ymax - ymin) / ny,
        binsizeZ = (zmax - zmin) / nz;

	var binRadius = Math.sqrt(binsizeX*binsizeX + binsizeY*binsizeY + binsizeZ*binsizeZ) * 0.5;

    var types = Shape.types;
    var SPHERE =            types.SPHERE,
        PLANE =             types.PLANE,
        BOX =               types.BOX,
        COMPOUND =          types.COMPOUND,
        CONVEXPOLYHEDRON =  types.CONVEXPOLYHEDRON;

    var bins=this.bins,
		binLengths=this.binLengths,
        Nbins=this.bins.length;

    // Reset bins
    for(var i=0; i!==Nbins; i++){
        binLengths[i] = 0;
    }

    var ceil = Math.ceil;
	var min = Math.min;
	var max = Math.max;

	function addBoxToBins(x0,y0,z0,x1,y1,z1,bi) {
		var xoff0 = ((x0 - xmin) * xmult)|0,
			yoff0 = ((y0 - ymin) * ymult)|0,
			zoff0 = ((z0 - zmin) * zmult)|0,
			xoff1 = ceil((x1 - xmin) * xmult),
			yoff1 = ceil((y1 - ymin) * ymult),
			zoff1 = ceil((z1 - zmin) * zmult);

		if (xoff0 < 0) { xoff0 = 0; } else if (xoff0 >= nx) { xoff0 = nx - 1; }
		if (yoff0 < 0) { yoff0 = 0; } else if (yoff0 >= ny) { yoff0 = ny - 1; }
		if (zoff0 < 0) { zoff0 = 0; } else if (zoff0 >= nz) { zoff0 = nz - 1; }
		if (xoff1 < 0) { xoff1 = 0; } else if (xoff1 >= nx) { xoff1 = nx - 1; }
		if (yoff1 < 0) { yoff1 = 0; } else if (yoff1 >= ny) { yoff1 = ny - 1; }
		if (zoff1 < 0) { zoff1 = 0; } else if (zoff1 >= nz) { zoff1 = nz - 1; }

		xoff0 *= xstep;
		yoff0 *= ystep;
		zoff0 *= zstep;
		xoff1 *= xstep;
		yoff1 *= ystep;
		zoff1 *= zstep;

		for (var xoff = xoff0; xoff <= xoff1; xoff += xstep) {
			for (var yoff = yoff0; yoff <= yoff1; yoff += ystep) {
				for (var zoff = zoff0; zoff <= zoff1; zoff += zstep) {
					var idx = xoff+yoff+zoff;
					bins[idx][binLengths[idx]++] = bi;
				}
			}
		}
	}

    // Put all bodies into the bins
    for(var i=0; i!==N; i++){
        var bi = bodies[i];
        var si = bi.shape;

        switch(si.type){
        case SPHERE:
            // Put in bin
            // check if overlap with other bins
            var x = bi.position.x,
                y = bi.position.y,
                z = bi.position.z;
            var r = si.radius;

			addBoxToBins(x-r, y-r, z-r, x+r, y+r, z+r, bi);
            break;

        case PLANE:
            if(si.worldNormalNeedsUpdate){
                si.computeWorldNormal(bi.quaternion);
            }
            var planeNormal = si.worldNormal;

			//Relative position from origin of plane object to the first bin
			//Incremented as we iterate through the bins
			var xreset = xmin + binsizeX*0.5 - bi.position.x,
				yreset = ymin + binsizeY*0.5 - bi.position.y,
				zreset = zmin + binsizeZ*0.5 - bi.position.z;

            var d = GridBroadphase_collisionPairs_d;
			d.set(xreset, yreset, zreset);

			for (var xi = 0, xoff = 0; xi !== nx; xi++, xoff += xstep, d.y = yreset, d.x += binsizeX) {
				for (var yi = 0, yoff = 0; yi !== ny; yi++, yoff += ystep, d.z = zreset, d.y += binsizeY) {
					for (var zi = 0, zoff = 0; zi !== nz; zi++, zoff += zstep, d.z += binsizeZ) {
						if (d.dot(planeNormal) < binRadius) {
							var idx = xoff + yoff + zoff;
							bins[idx][binLengths[idx]++] = bi;
						}
					}
				}
			}
            break;

        default:
			if (bi.aabbNeedsUpdate) {
				bi.computeAABB();
			}

			addBoxToBins(
				bi.aabb.lowerBound.x,
				bi.aabb.lowerBound.y,
				bi.aabb.lowerBound.z,
				bi.aabb.upperBound.x,
				bi.aabb.upperBound.y,
				bi.aabb.upperBound.z,
				bi);
            break;
        }
    }

    // Check each bin
    for(var i=0; i!==Nbins; i++){
		var binLength = binLengths[i];
		//Skip bins with no potential collisions
		if (binLength > 1) {
			var bin = bins[i];

			// Do N^2 broadphase inside
			for(var xi=0; xi!==binLength; xi++){
				var bi = bin[xi];
				for(var yi=0; yi!==xi; yi++){
					var bj = bin[yi];
					if(this$1.needBroadphaseCollision(bi,bj)){
						this$1.intersectionTest(bi,bj,pairs1,pairs2);
					}
				}
			}
		}
    }

//	for (var zi = 0, zoff=0; zi < nz; zi++, zoff+= zstep) {
//		console.log("layer "+zi);
//		for (var yi = 0, yoff=0; yi < ny; yi++, yoff += ystep) {
//			var row = '';
//			for (var xi = 0, xoff=0; xi < nx; xi++, xoff += xstep) {
//				var idx = xoff + yoff + zoff;
//				row += ' ' + binLengths[idx];
//			}
//			console.log(row);
//		}
//	}

    this.makePairsUnique(pairs1,pairs2);
};

},{"../math/Vec3":30,"../shapes/Shape":43,"./Broadphase":5}],7:[function(_dereq_,module,exports){
module.exports = NaiveBroadphase;

var Broadphase = _dereq_('./Broadphase');
var AABB = _dereq_('./AABB');

/**
 * Naive broadphase implementation, used in lack of better ones.
 * @class NaiveBroadphase
 * @constructor
 * @description The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 (which is bad)
 * @extends Broadphase
 */
function NaiveBroadphase(){
    Broadphase.apply(this);
}
NaiveBroadphase.prototype = new Broadphase();
NaiveBroadphase.prototype.constructor = NaiveBroadphase;

/**
 * Get all the collision pairs in the physics world
 * @method collisionPairs
 * @param {World} world
 * @param {Array} pairs1
 * @param {Array} pairs2
 */
NaiveBroadphase.prototype.collisionPairs = function(world,pairs1,pairs2){
    var this$1 = this;

    var bodies = world.bodies,
        n = bodies.length,
        i,j,bi,bj;

    // Naive N^2 ftw!
    for(i=0; i!==n; i++){
        for(j=0; j!==i; j++){

            bi = bodies[i];
            bj = bodies[j];

            if(!this$1.needBroadphaseCollision(bi,bj)){
                continue;
            }

            this$1.intersectionTest(bi,bj,pairs1,pairs2);
        }
    }
};

var tmpAABB = new AABB();

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
NaiveBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    for(var i = 0; i < world.bodies.length; i++){
        var b = world.bodies[i];

        if(b.aabbNeedsUpdate){
            b.computeAABB();
        }

        // Ugly hack until Body gets aabb
        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"./AABB":3,"./Broadphase":5}],8:[function(_dereq_,module,exports){
module.exports = ObjectCollisionMatrix;

/**
 * Records what objects are colliding with each other
 * @class ObjectCollisionMatrix
 * @constructor
 */
function ObjectCollisionMatrix() {

    /**
     * The matrix storage
     * @property matrix
     * @type {Object}
     */
	this.matrix = {};
}

/**
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */
ObjectCollisionMatrix.prototype.get = function(i, j) {
	i = i.id;
	j = j.id;
    if (j > i) {
        var temp = j;
        j = i;
        i = temp;
    }
	return i+'-'+j in this.matrix;
};

/**
 * @method set
 * @param  {Number} i
 * @param  {Number} j
 * @param {Number} value
 */
ObjectCollisionMatrix.prototype.set = function(i, j, value) {
	i = i.id;
	j = j.id;
    if (j > i) {
        var temp = j;
        j = i;
        i = temp;
	}
	if (value) {
		this.matrix[i+'-'+j] = true;
	}
	else {
		delete this.matrix[i+'-'+j];
	}
};

/**
 * Empty the matrix
 * @method reset
 */
ObjectCollisionMatrix.prototype.reset = function() {
	this.matrix = {};
};

/**
 * Set max number of objects
 * @method setNumObjects
 * @param {Number} n
 */
ObjectCollisionMatrix.prototype.setNumObjects = function(n) {
};

},{}],9:[function(_dereq_,module,exports){
module.exports = Ray;

var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var Transform = _dereq_('../math/Transform');
var ConvexPolyhedron = _dereq_('../shapes/ConvexPolyhedron');
var Box = _dereq_('../shapes/Box');
var RaycastResult = _dereq_('../collision/RaycastResult');
var Shape = _dereq_('../shapes/Shape');
var AABB = _dereq_('../collision/AABB');

/**
 * A line in 3D space that intersects bodies and return points.
 * @class Ray
 * @constructor
 * @param {Vec3} from
 * @param {Vec3} to
 */
function Ray(from, to){
    /**
     * @property {Vec3} from
     */
    this.from = from ? from.clone() : new Vec3();

    /**
     * @property {Vec3} to
     */
    this.to = to ? to.clone() : new Vec3();

    /**
     * @private
     * @property {Vec3} _direction
     */
    this._direction = new Vec3();

    /**
     * The precision of the ray. Used when checking parallelity etc.
     * @property {Number} precision
     */
    this.precision = 0.0001;

    /**
     * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.
     * @property {Boolean} checkCollisionResponse
     */
    this.checkCollisionResponse = true;

    /**
     * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.
     * @property {Boolean} skipBackfaces
     */
    this.skipBackfaces = false;

    /**
     * @property {number} collisionFilterMask
     * @default -1
     */
    this.collisionFilterMask = -1;

    /**
     * @property {number} collisionFilterGroup
     * @default -1
     */
    this.collisionFilterGroup = -1;

    /**
     * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
     * @property {number} mode
     */
    this.mode = Ray.ANY;

    /**
     * Current result object.
     * @property {RaycastResult} result
     */
    this.result = new RaycastResult();

    /**
     * Will be set to true during intersectWorld() if the ray hit anything.
     * @property {Boolean} hasHit
     */
    this.hasHit = false;

    /**
     * Current, user-provided result callback. Will be used if mode is Ray.ALL.
     * @property {Function} callback
     */
    this.callback = function(result){};
}
Ray.prototype.constructor = Ray;

Ray.CLOSEST = 1;
Ray.ANY = 2;
Ray.ALL = 4;

var tmpAABB = new AABB();
var tmpArray = [];

/**
 * Do itersection against all bodies in the given World.
 * @method intersectWorld
 * @param  {World} world
 * @param  {object} options
 * @return {Boolean} True if the ray hit anything, otherwise false.
 */
Ray.prototype.intersectWorld = function (world, options) {
    this.mode = options.mode || Ray.ANY;
    this.result = options.result || new RaycastResult();
    this.skipBackfaces = !!options.skipBackfaces;
    this.collisionFilterMask = typeof(options.collisionFilterMask) !== 'undefined' ? options.collisionFilterMask : -1;
    this.collisionFilterGroup = typeof(options.collisionFilterGroup) !== 'undefined' ? options.collisionFilterGroup : -1;
    if(options.from){
        this.from.copy(options.from);
    }
    if(options.to){
        this.to.copy(options.to);
    }
    this.callback = options.callback || function(){};
    this.hasHit = false;

    this.result.reset();
    this._updateDirection();

    this.getAABB(tmpAABB);
    tmpArray.length = 0;
    world.broadphase.aabbQuery(world, tmpAABB, tmpArray);
    this.intersectBodies(tmpArray);

    return this.hasHit;
};

var v1 = new Vec3(),
    v2 = new Vec3();

/*
 * As per "Barycentric Technique" as named here http://www.blackpawn.com/texts/pointinpoly/default.html But without the division
 */
Ray.pointInTriangle = pointInTriangle;
function pointInTriangle(p, a, b, c) {
    c.vsub(a,v0);
    b.vsub(a,v1);
    p.vsub(a,v2);

    var dot00 = v0.dot( v0 );
    var dot01 = v0.dot( v1 );
    var dot02 = v0.dot( v2 );
    var dot11 = v1.dot( v1 );
    var dot12 = v1.dot( v2 );

    var u,v;

    return  ( (u = dot11 * dot02 - dot01 * dot12) >= 0 ) &&
            ( (v = dot00 * dot12 - dot01 * dot02) >= 0 ) &&
            ( u + v < ( dot00 * dot11 - dot01 * dot01 ) );
}

/**
 * Shoot a ray at a body, get back information about the hit.
 * @method intersectBody
 * @private
 * @param {Body} body
 * @param {RaycastResult} [result] Deprecated - set the result property of the Ray instead.
 */
var intersectBody_xi = new Vec3();
var intersectBody_qi = new Quaternion();
Ray.prototype.intersectBody = function (body, result) {
    var this$1 = this;

    if(result){
        this.result = result;
        this._updateDirection();
    }
    var checkCollisionResponse = this.checkCollisionResponse;

    if(checkCollisionResponse && !body.collisionResponse){
        return;
    }

    if((this.collisionFilterGroup & body.collisionFilterMask)===0 || (body.collisionFilterGroup & this.collisionFilterMask)===0){
        return;
    }

    var xi = intersectBody_xi;
    var qi = intersectBody_qi;

    for (var i = 0, N = body.shapes.length; i < N; i++) {
        var shape = body.shapes[i];

        if(checkCollisionResponse && !shape.collisionResponse){
            continue; // Skip
        }

        body.quaternion.mult(body.shapeOrientations[i], qi);
        body.quaternion.vmult(body.shapeOffsets[i], xi);
        xi.vadd(body.position, xi);

        this$1.intersectShape(
            shape,
            qi,
            xi,
            body
        );

        if(this$1.result._shouldStop){
            break;
        }
    }
};

/**
 * @method intersectBodies
 * @param {Array} bodies An array of Body objects.
 * @param {RaycastResult} [result] Deprecated
 */
Ray.prototype.intersectBodies = function (bodies, result) {
    var this$1 = this;

    if(result){
        this.result = result;
        this._updateDirection();
    }

    for ( var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i ++ ) {
        this$1.intersectBody(bodies[i]);
    }
};

/**
 * Updates the _direction vector.
 * @private
 * @method _updateDirection
 */
Ray.prototype._updateDirection = function(){
    this.to.vsub(this.from, this._direction);
    this._direction.normalize();
};

/**
 * @method intersectShape
 * @private
 * @param {Shape} shape
 * @param {Quaternion} quat
 * @param {Vec3} position
 * @param {Body} body
 */
Ray.prototype.intersectShape = function(shape, quat, position, body){
    var from = this.from;


    // Checking boundingSphere
    var distance = distanceFromIntersection(from, this._direction, position);
    if ( distance > shape.boundingSphereRadius ) {
        return;
    }

    var intersectMethod = this[shape.type];
    if(intersectMethod){
        intersectMethod.call(this, shape, quat, position, body);
    }
};

var vector = new Vec3();
var normal = new Vec3();
var intersectPoint = new Vec3();

var a = new Vec3();
var b = new Vec3();
var c = new Vec3();
var d = new Vec3();

var tmpRaycastResult = new RaycastResult();

/**
 * @method intersectBox
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 */
Ray.prototype.intersectBox = function(shape, quat, position, body){
    return this.intersectConvex(shape.convexPolyhedronRepresentation, quat, position, body);
};
Ray.prototype[Shape.types.BOX] = Ray.prototype.intersectBox;

/**
 * @method intersectPlane
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 */
Ray.prototype.intersectPlane = function(shape, quat, position, body){
    var from = this.from;
    var to = this.to;
    var direction = this._direction;

    // Get plane normal
    var worldNormal = new Vec3(0, 0, 1);
    quat.vmult(worldNormal, worldNormal);

    var len = new Vec3();
    from.vsub(position, len);
    var planeToFrom = len.dot(worldNormal);
    to.vsub(position, len);
    var planeToTo = len.dot(worldNormal);

    if(planeToFrom * planeToTo > 0){
        // "from" and "to" are on the same side of the plane... bail out
        return;
    }

    if(from.distanceTo(to) < planeToFrom){
        return;
    }

    var n_dot_dir = worldNormal.dot(direction);

    if (Math.abs(n_dot_dir) < this.precision) {
        // No intersection
        return;
    }

    var planePointToFrom = new Vec3();
    var dir_scaled_with_t = new Vec3();
    var hitPointWorld = new Vec3();

    from.vsub(position, planePointToFrom);
    var t = -worldNormal.dot(planePointToFrom) / n_dot_dir;
    direction.scale(t, dir_scaled_with_t);
    from.vadd(dir_scaled_with_t, hitPointWorld);

    this.reportIntersection(worldNormal, hitPointWorld, shape, body, -1);
};
Ray.prototype[Shape.types.PLANE] = Ray.prototype.intersectPlane;

/**
 * Get the world AABB of the ray.
 * @method getAABB
 * @param  {AABB} aabb
 */
Ray.prototype.getAABB = function(result){
    var to = this.to;
    var from = this.from;
    result.lowerBound.x = Math.min(to.x, from.x);
    result.lowerBound.y = Math.min(to.y, from.y);
    result.lowerBound.z = Math.min(to.z, from.z);
    result.upperBound.x = Math.max(to.x, from.x);
    result.upperBound.y = Math.max(to.y, from.y);
    result.upperBound.z = Math.max(to.z, from.z);
};

var intersectConvexOptions = {
    faceList: [0]
};

/**
 * @method intersectHeightfield
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 */
Ray.prototype.intersectHeightfield = function(shape, quat, position, body){
    var this$1 = this;

    var data = shape.data,
        w = shape.elementSize,
        worldPillarOffset = new Vec3();

    // Convert the ray to local heightfield coordinates
    var localRay = new Ray(this.from, this.to);
    Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);
    Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);

    // Get the index of the data points to test against
    var index = [];
    var iMinX = null;
    var iMinY = null;
    var iMaxX = null;
    var iMaxY = null;

    var inside = shape.getIndexOfPosition(localRay.from.x, localRay.from.y, index, false);
    if(inside){
        iMinX = index[0];
        iMinY = index[1];
        iMaxX = index[0];
        iMaxY = index[1];
    }
    inside = shape.getIndexOfPosition(localRay.to.x, localRay.to.y, index, false);
    if(inside){
        if (iMinX === null || index[0] < iMinX) { iMinX = index[0]; }
        if (iMaxX === null || index[0] > iMaxX) { iMaxX = index[0]; }
        if (iMinY === null || index[1] < iMinY) { iMinY = index[1]; }
        if (iMaxY === null || index[1] > iMaxY) { iMaxY = index[1]; }
    }

    if(iMinX === null){
        return;
    }

    var minMax = [];
    shape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
    for(var i = iMinX; i <= iMaxX; i++){
        for(var j = iMinY; j <= iMaxY; j++){

            if(this$1.result._shouldStop){
                return;
            }

            // Lower triangle
            shape.getConvexTrianglePillar(i, j, false);
            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
            this$1.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, intersectConvexOptions);

            if(this$1.result._shouldStop){
                return;
            }

            // Upper triangle
            shape.getConvexTrianglePillar(i, j, true);
            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
            this$1.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, intersectConvexOptions);
        }
    }
};
Ray.prototype[Shape.types.HEIGHTFIELD] = Ray.prototype.intersectHeightfield;

var Ray_intersectSphere_intersectionPoint = new Vec3();
var Ray_intersectSphere_normal = new Vec3();

/**
 * @method intersectSphere
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 */
Ray.prototype.intersectSphere = function(shape, quat, position, body){
    var from = this.from,
        to = this.to,
        r = shape.radius;

    var a = Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2) + Math.pow(to.z - from.z, 2);
    var b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));
    var c = Math.pow(from.x - position.x, 2) + Math.pow(from.y - position.y, 2) + Math.pow(from.z - position.z, 2) - Math.pow(r, 2);

    var delta = Math.pow(b, 2) - 4 * a * c;

    var intersectionPoint = Ray_intersectSphere_intersectionPoint;
    var normal = Ray_intersectSphere_normal;

    if(delta < 0){
        // No intersection
        return;

    } else if(delta === 0){
        // single intersection point
        from.lerp(to, delta, intersectionPoint);

        intersectionPoint.vsub(position, normal);
        normal.normalize();

        this.reportIntersection(normal, intersectionPoint, shape, body, -1);

    } else {
        var d1 = (- b - Math.sqrt(delta)) / (2 * a);
        var d2 = (- b + Math.sqrt(delta)) / (2 * a);

        if(d1 >= 0 && d1 <= 1){
            from.lerp(to, d1, intersectionPoint);
            intersectionPoint.vsub(position, normal);
            normal.normalize();
            this.reportIntersection(normal, intersectionPoint, shape, body, -1);
        }

        if(this.result._shouldStop){
            return;
        }

        if(d2 >= 0 && d2 <= 1){
            from.lerp(to, d2, intersectionPoint);
            intersectionPoint.vsub(position, normal);
            normal.normalize();
            this.reportIntersection(normal, intersectionPoint, shape, body, -1);
        }
    }
};
Ray.prototype[Shape.types.SPHERE] = Ray.prototype.intersectSphere;


var intersectConvex_normal = new Vec3();
var intersectConvex_minDistNormal = new Vec3();
var intersectConvex_minDistIntersect = new Vec3();
var intersectConvex_vector = new Vec3();

/**
 * @method intersectConvex
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 * @param {object} [options]
 * @param {array} [options.faceList]
 */
Ray.prototype.intersectConvex = function intersectConvex(
    shape,
    quat,
    position,
    body,
    options
){
    var this$1 = this;

    var normal = intersectConvex_normal;
    var vector = intersectConvex_vector;
    var faceList = (options && options.faceList) || null;

    // Checking faces
    var faces = shape.faces,
        vertices = shape.vertices,
        normals = shape.faceNormals;
    var direction = this._direction;

    var from = this.from;
    var to = this.to;
    var fromToDistance = from.distanceTo(to);

    var Nfaces = faceList ? faceList.length : faces.length;
    var result = this.result;

    for (var j = 0; !result._shouldStop && j < Nfaces; j++) {
        var fi = faceList ? faceList[j] : j;

        var face = faces[fi];
        var faceNormal = normals[fi];
        var q = quat;
        var x = position;

        // determine if ray intersects the plane of the face
        // note: this works regardless of the direction of the face normal

        // Get plane point in world coordinates...
        vector.copy(vertices[face[0]]);
        q.vmult(vector,vector);
        vector.vadd(x,vector);

        // ...but make it relative to the ray from. We'll fix this later.
        vector.vsub(from,vector);

        // Get plane normal
        q.vmult(faceNormal,normal);

        // If this dot product is negative, we have something interesting
        var dot = direction.dot(normal);

        // Bail out if ray and plane are parallel
        if ( Math.abs( dot ) < this$1.precision ){
            continue;
        }

        // calc distance to plane
        var scalar = normal.dot(vector) / dot;

        // if negative distance, then plane is behind ray
        if (scalar < 0){
            continue;
        }

        // if (dot < 0) {

        // Intersection point is from + direction * scalar
        direction.mult(scalar,intersectPoint);
        intersectPoint.vadd(from,intersectPoint);

        // a is the point we compare points b and c with.
        a.copy(vertices[face[0]]);
        q.vmult(a,a);
        x.vadd(a,a);

        for(var i = 1; !result._shouldStop && i < face.length - 1; i++){
            // Transform 3 vertices to world coords
            b.copy(vertices[face[i]]);
            c.copy(vertices[face[i+1]]);
            q.vmult(b,b);
            q.vmult(c,c);
            x.vadd(b,b);
            x.vadd(c,c);

            var distance = intersectPoint.distanceTo(from);

            if(!(pointInTriangle(intersectPoint, a, b, c) || pointInTriangle(intersectPoint, b, a, c)) || distance > fromToDistance){
                continue;
            }

            this$1.reportIntersection(normal, intersectPoint, shape, body, fi);
        }
        // }
    }
};
Ray.prototype[Shape.types.CONVEXPOLYHEDRON] = Ray.prototype.intersectConvex;

var intersectTrimesh_normal = new Vec3();
var intersectTrimesh_localDirection = new Vec3();
var intersectTrimesh_localFrom = new Vec3();
var intersectTrimesh_localTo = new Vec3();
var intersectTrimesh_worldNormal = new Vec3();
var intersectTrimesh_worldIntersectPoint = new Vec3();
var intersectTrimesh_localAABB = new AABB();
var intersectTrimesh_triangles = [];
var intersectTrimesh_treeTransform = new Transform();

/**
 * @method intersectTrimesh
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 * @param {object} [options]
 * @todo Optimize by transforming the world to local space first.
 * @todo Use Octree lookup
 */
Ray.prototype.intersectTrimesh = function intersectTrimesh(
    mesh,
    quat,
    position,
    body,
    options
){
    var this$1 = this;

    var normal = intersectTrimesh_normal;
    var triangles = intersectTrimesh_triangles;
    var treeTransform = intersectTrimesh_treeTransform;
    var vector = intersectConvex_vector;
    var localDirection = intersectTrimesh_localDirection;
    var localFrom = intersectTrimesh_localFrom;
    var localTo = intersectTrimesh_localTo;
    var worldIntersectPoint = intersectTrimesh_worldIntersectPoint;
    var worldNormal = intersectTrimesh_worldNormal;
    var faceList = (options && options.faceList) || null;

    // Checking faces
    var indices = mesh.indices,
        vertices = mesh.vertices,
        normals = mesh.faceNormals;

    var from = this.from;
    var to = this.to;
    var direction = this._direction;

    treeTransform.position.copy(position);
    treeTransform.quaternion.copy(quat);

    // Transform ray to local space!
    Transform.vectorToLocalFrame(position, quat, direction, localDirection);
    //body.vectorToLocalFrame(direction, localDirection);
    Transform.pointToLocalFrame(position, quat, from, localFrom);
    //body.pointToLocalFrame(from, localFrom);
    Transform.pointToLocalFrame(position, quat, to, localTo);
    //body.pointToLocalFrame(to, localTo);
    var fromToDistanceSquared = localFrom.distanceSquared(localTo);

    mesh.tree.rayQuery(this, treeTransform, triangles);

    for (var i = 0, N = triangles.length; !this.result._shouldStop && i !== N; i++) {
        var trianglesIndex = triangles[i];

        mesh.getNormal(trianglesIndex, normal);

        // determine if ray intersects the plane of the face
        // note: this works regardless of the direction of the face normal

        // Get plane point in world coordinates...
        mesh.getVertex(indices[trianglesIndex * 3], a);

        // ...but make it relative to the ray from. We'll fix this later.
        a.vsub(localFrom,vector);

        // Get plane normal
        // quat.vmult(normal, normal);

        // If this dot product is negative, we have something interesting
        var dot = localDirection.dot(normal);

        // Bail out if ray and plane are parallel
        // if (Math.abs( dot ) < this.precision){
        //     continue;
        // }

        // calc distance to plane
        var scalar = normal.dot(vector) / dot;

        // if negative distance, then plane is behind ray
        if (scalar < 0){
            continue;
        }

        // Intersection point is from + direction * scalar
        localDirection.scale(scalar,intersectPoint);
        intersectPoint.vadd(localFrom,intersectPoint);

        // Get triangle vertices
        mesh.getVertex(indices[trianglesIndex * 3 + 1], b);
        mesh.getVertex(indices[trianglesIndex * 3 + 2], c);

        var squaredDistance = intersectPoint.distanceSquared(localFrom);

        if(!(pointInTriangle(intersectPoint, b, a, c) || pointInTriangle(intersectPoint, a, b, c)) || squaredDistance > fromToDistanceSquared){
            continue;
        }

        // transform intersectpoint and normal to world
        Transform.vectorToWorldFrame(quat, normal, worldNormal);
        //body.vectorToWorldFrame(normal, worldNormal);
        Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);
        //body.pointToWorldFrame(intersectPoint, worldIntersectPoint);
        this$1.reportIntersection(worldNormal, worldIntersectPoint, mesh, body, trianglesIndex);
    }
    triangles.length = 0;
};
Ray.prototype[Shape.types.TRIMESH] = Ray.prototype.intersectTrimesh;


/**
 * @method reportIntersection
 * @private
 * @param  {Vec3} normal
 * @param  {Vec3} hitPointWorld
 * @param  {Shape} shape
 * @param  {Body} body
 * @return {boolean} True if the intersections should continue
 */
Ray.prototype.reportIntersection = function(normal, hitPointWorld, shape, body, hitFaceIndex){
    var from = this.from;
    var to = this.to;
    var distance = from.distanceTo(hitPointWorld);
    var result = this.result;

    // Skip back faces?
    if(this.skipBackfaces && normal.dot(this._direction) > 0){
        return;
    }

    result.hitFaceIndex = typeof(hitFaceIndex) !== 'undefined' ? hitFaceIndex : -1;

    switch(this.mode){
    case Ray.ALL:
        this.hasHit = true;
        result.set(
            from,
            to,
            normal,
            hitPointWorld,
            shape,
            body,
            distance
        );
        result.hasHit = true;
        this.callback(result);
        break;

    case Ray.CLOSEST:

        // Store if closer than current closest
        if(distance < result.distance || !result.hasHit){
            this.hasHit = true;
            result.hasHit = true;
            result.set(
                from,
                to,
                normal,
                hitPointWorld,
                shape,
                body,
                distance
            );
        }
        break;

    case Ray.ANY:

        // Report and stop.
        this.hasHit = true;
        result.hasHit = true;
        result.set(
            from,
            to,
            normal,
            hitPointWorld,
            shape,
            body,
            distance
        );
        result._shouldStop = true;
        break;
    }
};

var v0 = new Vec3(),
    intersect = new Vec3();
function distanceFromIntersection(from, direction, position) {

    // v0 is vector from from to position
    position.vsub(from,v0);
    var dot = v0.dot(direction);

    // intersect = direction*dot + from
    direction.mult(dot,intersect);
    intersect.vadd(from,intersect);

    var distance = position.distanceTo(intersect);

    return distance;
}


},{"../collision/AABB":3,"../collision/RaycastResult":10,"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"../shapes/Box":37,"../shapes/ConvexPolyhedron":38,"../shapes/Shape":43}],10:[function(_dereq_,module,exports){
var Vec3 = _dereq_('../math/Vec3');

module.exports = RaycastResult;

/**
 * Storage for Ray casting data.
 * @class RaycastResult
 * @constructor
 */
function RaycastResult(){

	/**
	 * @property {Vec3} rayFromWorld
	 */
	this.rayFromWorld = new Vec3();

	/**
	 * @property {Vec3} rayToWorld
	 */
	this.rayToWorld = new Vec3();

	/**
	 * @property {Vec3} hitNormalWorld
	 */
	this.hitNormalWorld = new Vec3();

	/**
	 * @property {Vec3} hitPointWorld
	 */
	this.hitPointWorld = new Vec3();

	/**
	 * @property {boolean} hasHit
	 */
	this.hasHit = false;

	/**
	 * The hit shape, or null.
	 * @property {Shape} shape
	 */
	this.shape = null;

	/**
	 * The hit body, or null.
	 * @property {Body} body
	 */
	this.body = null;

	/**
	 * The index of the hit triangle, if the hit shape was a trimesh.
	 * @property {number} hitFaceIndex
	 * @default -1
	 */
	this.hitFaceIndex = -1;

	/**
	 * Distance to the hit. Will be set to -1 if there was no hit.
	 * @property {number} distance
	 * @default -1
	 */
	this.distance = -1;

	/**
	 * If the ray should stop traversing the bodies.
	 * @private
	 * @property {Boolean} _shouldStop
	 * @default false
	 */
	this._shouldStop = false;
}

/**
 * Reset all result data.
 * @method reset
 */
RaycastResult.prototype.reset = function () {
	this.rayFromWorld.setZero();
	this.rayToWorld.setZero();
	this.hitNormalWorld.setZero();
	this.hitPointWorld.setZero();
	this.hasHit = false;
	this.shape = null;
	this.body = null;
	this.hitFaceIndex = -1;
	this.distance = -1;
	this._shouldStop = false;
};

/**
 * @method abort
 */
RaycastResult.prototype.abort = function(){
	this._shouldStop = true;
};

/**
 * @method set
 * @param {Vec3} rayFromWorld
 * @param {Vec3} rayToWorld
 * @param {Vec3} hitNormalWorld
 * @param {Vec3} hitPointWorld
 * @param {Shape} shape
 * @param {Body} body
 * @param {number} distance
 */
RaycastResult.prototype.set = function(
	rayFromWorld,
	rayToWorld,
	hitNormalWorld,
	hitPointWorld,
	shape,
	body,
	distance
){
	this.rayFromWorld.copy(rayFromWorld);
	this.rayToWorld.copy(rayToWorld);
	this.hitNormalWorld.copy(hitNormalWorld);
	this.hitPointWorld.copy(hitPointWorld);
	this.shape = shape;
	this.body = body;
	this.distance = distance;
};
},{"../math/Vec3":30}],11:[function(_dereq_,module,exports){
var Shape = _dereq_('../shapes/Shape');
var Broadphase = _dereq_('../collision/Broadphase');

module.exports = SAPBroadphase;

/**
 * Sweep and prune broadphase along one axis.
 *
 * @class SAPBroadphase
 * @constructor
 * @param {World} [world]
 * @extends Broadphase
 */
function SAPBroadphase(world){
    Broadphase.apply(this);

    /**
     * List of bodies currently in the broadphase.
     * @property axisList
     * @type {Array}
     */
    this.axisList = [];

    /**
     * The world to search in.
     * @property world
     * @type {World}
     */
    this.world = null;

    /**
     * Axis to sort the bodies along. Set to 0 for x axis, and 1 for y axis. For best performance, choose an axis that the bodies are spread out more on.
     * @property axisIndex
     * @type {Number}
     */
    this.axisIndex = 0;

    var axisList = this.axisList;

    this._addBodyHandler = function(e){
        axisList.push(e.body);
    };

    this._removeBodyHandler = function(e){
        var idx = axisList.indexOf(e.body);
        if(idx !== -1){
            axisList.splice(idx,1);
        }
    };

    if(world){
        this.setWorld(world);
    }
}
SAPBroadphase.prototype = new Broadphase();

/**
 * Change the world
 * @method setWorld
 * @param  {World} world
 */
SAPBroadphase.prototype.setWorld = function(world){
    var this$1 = this;

    // Clear the old axis array
    this.axisList.length = 0;

    // Add all bodies from the new world
    for(var i=0; i<world.bodies.length; i++){
        this$1.axisList.push(world.bodies[i]);
    }

    // Remove old handlers, if any
    world.removeEventListener("addBody", this._addBodyHandler);
    world.removeEventListener("removeBody", this._removeBodyHandler);

    // Add handlers to update the list of bodies.
    world.addEventListener("addBody", this._addBodyHandler);
    world.addEventListener("removeBody", this._removeBodyHandler);

    this.world = world;
    this.dirty = true;
};

/**
 * @static
 * @method insertionSortX
 * @param  {Array} a
 * @return {Array}
 */
SAPBroadphase.insertionSortX = function(a) {
    for(var i=1,l=a.length;i<l;i++) {
        var v = a[i];
        for(var j=i - 1;j>=0;j--) {
            if(a[j].aabb.lowerBound.x <= v.aabb.lowerBound.x){
                break;
            }
            a[j+1] = a[j];
        }
        a[j+1] = v;
    }
    return a;
};

/**
 * @static
 * @method insertionSortY
 * @param  {Array} a
 * @return {Array}
 */
SAPBroadphase.insertionSortY = function(a) {
    for(var i=1,l=a.length;i<l;i++) {
        var v = a[i];
        for(var j=i - 1;j>=0;j--) {
            if(a[j].aabb.lowerBound.y <= v.aabb.lowerBound.y){
                break;
            }
            a[j+1] = a[j];
        }
        a[j+1] = v;
    }
    return a;
};

/**
 * @static
 * @method insertionSortZ
 * @param  {Array} a
 * @return {Array}
 */
SAPBroadphase.insertionSortZ = function(a) {
    for(var i=1,l=a.length;i<l;i++) {
        var v = a[i];
        for(var j=i - 1;j>=0;j--) {
            if(a[j].aabb.lowerBound.z <= v.aabb.lowerBound.z){
                break;
            }
            a[j+1] = a[j];
        }
        a[j+1] = v;
    }
    return a;
};

/**
 * Collect all collision pairs
 * @method collisionPairs
 * @param  {World} world
 * @param  {Array} p1
 * @param  {Array} p2
 */
SAPBroadphase.prototype.collisionPairs = function(world,p1,p2){
    var this$1 = this;

    var bodies = this.axisList,
        N = bodies.length,
        axisIndex = this.axisIndex,
        i, j;

    if(this.dirty){
        this.sortList();
        this.dirty = false;
    }

    // Look through the list
    for(i=0; i !== N; i++){
        var bi = bodies[i];

        for(j=i+1; j < N; j++){
            var bj = bodies[j];

            if(!this$1.needBroadphaseCollision(bi,bj)){
                continue;
            }

            if(!SAPBroadphase.checkBounds(bi,bj,axisIndex)){
                break;
            }

            this$1.intersectionTest(bi,bj,p1,p2);
        }
    }
};

SAPBroadphase.prototype.sortList = function(){
    var axisList = this.axisList;
    var axisIndex = this.axisIndex;
    var N = axisList.length;

    // Update AABBs
    for(var i = 0; i!==N; i++){
        var bi = axisList[i];
        if(bi.aabbNeedsUpdate){
            bi.computeAABB();
        }
    }

    // Sort the list
    if(axisIndex === 0){
        SAPBroadphase.insertionSortX(axisList);
    } else if(axisIndex === 1){
        SAPBroadphase.insertionSortY(axisList);
    } else if(axisIndex === 2){
        SAPBroadphase.insertionSortZ(axisList);
    }
};

/**
 * Check if the bounds of two bodies overlap, along the given SAP axis.
 * @static
 * @method checkBounds
 * @param  {Body} bi
 * @param  {Body} bj
 * @param  {Number} axisIndex
 * @return {Boolean}
 */
SAPBroadphase.checkBounds = function(bi, bj, axisIndex){
    var biPos;
    var bjPos;

    if(axisIndex === 0){
        biPos = bi.position.x;
        bjPos = bj.position.x;
    } else if(axisIndex === 1){
        biPos = bi.position.y;
        bjPos = bj.position.y;
    } else if(axisIndex === 2){
        biPos = bi.position.z;
        bjPos = bj.position.z;
    }

    var ri = bi.boundingRadius,
        rj = bj.boundingRadius,
        boundA1 = biPos - ri,
        boundA2 = biPos + ri,
        boundB1 = bjPos - rj;

    return boundB1 < boundA2;
};

/**
 * Computes the variance of the body positions and estimates the best
 * axis to use. Will automatically set property .axisIndex.
 * @method autoDetectAxis
 */
SAPBroadphase.prototype.autoDetectAxis = function(){
    var sumX=0,
        sumX2=0,
        sumY=0,
        sumY2=0,
        sumZ=0,
        sumZ2=0,
        bodies = this.axisList,
        N = bodies.length,
        invN=1/N;

    for(var i=0; i!==N; i++){
        var b = bodies[i];

        var centerX = b.position.x;
        sumX += centerX;
        sumX2 += centerX*centerX;

        var centerY = b.position.y;
        sumY += centerY;
        sumY2 += centerY*centerY;

        var centerZ = b.position.z;
        sumZ += centerZ;
        sumZ2 += centerZ*centerZ;
    }

    var varianceX = sumX2 - sumX*sumX*invN,
        varianceY = sumY2 - sumY*sumY*invN,
        varianceZ = sumZ2 - sumZ*sumZ*invN;

    if(varianceX > varianceY){
        if(varianceX > varianceZ){
            this.axisIndex = 0;
        } else{
            this.axisIndex = 2;
        }
    } else if(varianceY > varianceZ){
        this.axisIndex = 1;
    } else{
        this.axisIndex = 2;
    }
};

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
SAPBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    if(this.dirty){
        this.sortList();
        this.dirty = false;
    }

    var axisIndex = this.axisIndex, axis = 'x';
    if(axisIndex === 1){ axis = 'y'; }
    if(axisIndex === 2){ axis = 'z'; }

    var axisList = this.axisList;
    var lower = aabb.lowerBound[axis];
    var upper = aabb.upperBound[axis];
    for(var i = 0; i < axisList.length; i++){
        var b = axisList[i];

        if(b.aabbNeedsUpdate){
            b.computeAABB();
        }

        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"../collision/Broadphase":5,"../shapes/Shape":43}],12:[function(_dereq_,module,exports){
module.exports = ConeTwistConstraint;

var Constraint = _dereq_('./Constraint');
var PointToPointConstraint = _dereq_('./PointToPointConstraint');
var ConeEquation = _dereq_('../equations/ConeEquation');
var RotationalEquation = _dereq_('../equations/RotationalEquation');
var ContactEquation = _dereq_('../equations/ContactEquation');
var Vec3 = _dereq_('../math/Vec3');

/**
 * @class ConeTwistConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {Vec3} [options.pivotA]
 * @param {Vec3} [options.pivotB]
 * @param {Vec3} [options.axisA]
 * @param {Vec3} [options.axisB]
 * @param {Number} [options.maxForce=1e6]
 * @extends PointToPointConstraint
 */
function ConeTwistConstraint(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

    // Set pivot point in between
    var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
    var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
    this.axisA = options.axisA ? options.axisA.clone() : new Vec3();
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3();

    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);

    this.collideConnected = !!options.collideConnected;

    this.angle = typeof(options.angle) !== 'undefined' ? options.angle : 0;

    /**
     * @property {ConeEquation} coneEquation
     */
    var c = this.coneEquation = new ConeEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalEquation} twistEquation
     */
    var t = this.twistEquation = new RotationalEquation(bodyA,bodyB,options);
    this.twistAngle = typeof(options.twistAngle) !== 'undefined' ? options.twistAngle : 0;

    // Make the cone equation push the bodies toward the cone axis, not outward
    c.maxForce = 0;
    c.minForce = -maxForce;

    // Make the twist equation add torque toward the initial position
    t.maxForce = 0;
    t.minForce = -maxForce;

    this.equations.push(c, t);
}
ConeTwistConstraint.prototype = new PointToPointConstraint();
ConeTwistConstraint.constructor = ConeTwistConstraint;

var ConeTwistConstraint_update_tmpVec1 = new Vec3();
var ConeTwistConstraint_update_tmpVec2 = new Vec3();

ConeTwistConstraint.prototype.update = function(){
    var bodyA = this.bodyA,
        bodyB = this.bodyB,
        cone = this.coneEquation,
        twist = this.twistEquation;

    PointToPointConstraint.prototype.update.call(this);

    // Update the axes to the cone constraint
    bodyA.vectorToWorldFrame(this.axisA, cone.axisA);
    bodyB.vectorToWorldFrame(this.axisB, cone.axisB);

    // Update the world axes in the twist constraint
    this.axisA.tangents(twist.axisA, twist.axisA);
    bodyA.vectorToWorldFrame(twist.axisA, twist.axisA);

    this.axisB.tangents(twist.axisB, twist.axisB);
    bodyB.vectorToWorldFrame(twist.axisB, twist.axisB);

    cone.angle = this.angle;
    twist.maxAngle = this.twistAngle;
};


},{"../equations/ConeEquation":18,"../equations/ContactEquation":19,"../equations/RotationalEquation":22,"../math/Vec3":30,"./Constraint":13,"./PointToPointConstraint":17}],13:[function(_dereq_,module,exports){
module.exports = Constraint;

var Utils = _dereq_('../utils/Utils');

/**
 * Constraint base class
 * @class Constraint
 * @author schteppe
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {boolean} [options.collideConnected=true]
 * @param {boolean} [options.wakeUpBodies=true]
 */
function Constraint(bodyA, bodyB, options){
    options = Utils.defaults(options,{
        collideConnected : true,
        wakeUpBodies : true,
    });

    /**
     * Equations to be solved in this constraint
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * @property {Body} bodyA
     */
    this.bodyA = bodyA;

    /**
     * @property {Body} bodyB
     */
    this.bodyB = bodyB;

    /**
     * @property {Number} id
     */
    this.id = Constraint.idCounter++;

    /**
     * Set to true if you want the bodies to collide when they are connected.
     * @property collideConnected
     * @type {boolean}
     */
    this.collideConnected = options.collideConnected;

    if(options.wakeUpBodies){
        if(bodyA){
            bodyA.wakeUp();
        }
        if(bodyB){
            bodyB.wakeUp();
        }
    }
}

/**
 * Update all the equations with data.
 * @method update
 */
Constraint.prototype.update = function(){
    throw new Error("method update() not implmemented in this Constraint subclass!");
};

/**
 * Enables all equations in the constraint.
 * @method enable
 */
Constraint.prototype.enable = function(){
    var eqs = this.equations;
    for(var i=0; i<eqs.length; i++){
        eqs[i].enabled = true;
    }
};

/**
 * Disables all equations in the constraint.
 * @method disable
 */
Constraint.prototype.disable = function(){
    var eqs = this.equations;
    for(var i=0; i<eqs.length; i++){
        eqs[i].enabled = false;
    }
};

Constraint.idCounter = 0;

},{"../utils/Utils":53}],14:[function(_dereq_,module,exports){
module.exports = DistanceConstraint;

var Constraint = _dereq_('./Constraint');
var ContactEquation = _dereq_('../equations/ContactEquation');

/**
 * Constrains two bodies to be at a constant distance from each others center of mass.
 * @class DistanceConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} [distance] The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB
 * @param {Number} [maxForce=1e6]
 * @extends Constraint
 */
function DistanceConstraint(bodyA,bodyB,distance,maxForce){
    Constraint.call(this,bodyA,bodyB);

    if(typeof(distance)==="undefined") {
        distance = bodyA.position.distanceTo(bodyB.position);
    }

    if(typeof(maxForce)==="undefined") {
        maxForce = 1e6;
    }

    /**
     * @property {number} distance
     */
    this.distance = distance;

    /**
     * @property {ContactEquation} distanceEquation
     */
    var eq = this.distanceEquation = new ContactEquation(bodyA, bodyB);
    this.equations.push(eq);

    // Make it bidirectional
    eq.minForce = -maxForce;
    eq.maxForce =  maxForce;
}
DistanceConstraint.prototype = new Constraint();

DistanceConstraint.prototype.update = function(){
    var bodyA = this.bodyA;
    var bodyB = this.bodyB;
    var eq = this.distanceEquation;
    var halfDist = this.distance * 0.5;
    var normal = eq.ni;

    bodyB.position.vsub(bodyA.position, normal);
    normal.normalize();
    normal.mult(halfDist, eq.ri);
    normal.mult(-halfDist, eq.rj);
};
},{"../equations/ContactEquation":19,"./Constraint":13}],15:[function(_dereq_,module,exports){
module.exports = HingeConstraint;

var Constraint = _dereq_('./Constraint');
var PointToPointConstraint = _dereq_('./PointToPointConstraint');
var RotationalEquation = _dereq_('../equations/RotationalEquation');
var RotationalMotorEquation = _dereq_('../equations/RotationalMotorEquation');
var ContactEquation = _dereq_('../equations/ContactEquation');
var Vec3 = _dereq_('../math/Vec3');

/**
 * Hinge constraint. Think of it as a door hinge. It tries to keep the door in the correct place and with the correct orientation.
 * @class HingeConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {Vec3} [options.pivotA] A point defined locally in bodyA. This defines the offset of axisA.
 * @param {Vec3} [options.axisA] An axis that bodyA can rotate around, defined locally in bodyA.
 * @param {Vec3} [options.pivotB]
 * @param {Vec3} [options.axisB]
 * @param {Number} [options.maxForce=1e6]
 * @extends PointToPointConstraint
 */
function HingeConstraint(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;
    var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
    var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();

    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);

    /**
     * Rotation axis, defined locally in bodyA.
     * @property {Vec3} axisA
     */
    var axisA = this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1,0,0);
    axisA.normalize();

    /**
     * Rotation axis, defined locally in bodyB.
     * @property {Vec3} axisB
     */
    var axisB = this.axisB = options.axisB ? options.axisB.clone() : new Vec3(1,0,0);
    axisB.normalize();

    /**
     * @property {RotationalEquation} rotationalEquation1
     */
    var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalEquation} rotationalEquation2
     */
    var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalMotorEquation} motorEquation
     */
    var motor = this.motorEquation = new RotationalMotorEquation(bodyA,bodyB,maxForce);
    motor.enabled = false; // Not enabled by default

    // Equations to be fed to the solver
    this.equations.push(
        r1, // rotational1
        r2, // rotational2
        motor
    );
}
HingeConstraint.prototype = new PointToPointConstraint();
HingeConstraint.constructor = HingeConstraint;

/**
 * @method enableMotor
 */
HingeConstraint.prototype.enableMotor = function(){
    this.motorEquation.enabled = true;
};

/**
 * @method disableMotor
 */
HingeConstraint.prototype.disableMotor = function(){
    this.motorEquation.enabled = false;
};

/**
 * @method setMotorSpeed
 * @param {number} speed
 */
HingeConstraint.prototype.setMotorSpeed = function(speed){
    this.motorEquation.targetVelocity = speed;
};

/**
 * @method setMotorMaxForce
 * @param {number} maxForce
 */
HingeConstraint.prototype.setMotorMaxForce = function(maxForce){
    this.motorEquation.maxForce = maxForce;
    this.motorEquation.minForce = -maxForce;
};

var HingeConstraint_update_tmpVec1 = new Vec3();
var HingeConstraint_update_tmpVec2 = new Vec3();

HingeConstraint.prototype.update = function(){
    var bodyA = this.bodyA,
        bodyB = this.bodyB,
        motor = this.motorEquation,
        r1 = this.rotationalEquation1,
        r2 = this.rotationalEquation2,
        worldAxisA = HingeConstraint_update_tmpVec1,
        worldAxisB = HingeConstraint_update_tmpVec2;

    var axisA = this.axisA;
    var axisB = this.axisB;

    PointToPointConstraint.prototype.update.call(this);

    // Get world axes
    bodyA.quaternion.vmult(axisA, worldAxisA);
    bodyB.quaternion.vmult(axisB, worldAxisB);

    worldAxisA.tangents(r1.axisA, r2.axisA);
    r1.axisB.copy(worldAxisB);
    r2.axisB.copy(worldAxisB);

    if(this.motorEquation.enabled){
        bodyA.quaternion.vmult(this.axisA, motor.axisA);
        bodyB.quaternion.vmult(this.axisB, motor.axisB);
    }
};


},{"../equations/ContactEquation":19,"../equations/RotationalEquation":22,"../equations/RotationalMotorEquation":23,"../math/Vec3":30,"./Constraint":13,"./PointToPointConstraint":17}],16:[function(_dereq_,module,exports){
module.exports = LockConstraint;

var Constraint = _dereq_('./Constraint');
var PointToPointConstraint = _dereq_('./PointToPointConstraint');
var RotationalEquation = _dereq_('../equations/RotationalEquation');
var RotationalMotorEquation = _dereq_('../equations/RotationalMotorEquation');
var ContactEquation = _dereq_('../equations/ContactEquation');
var Vec3 = _dereq_('../math/Vec3');

/**
 * Lock constraint. Will remove all degrees of freedom between the bodies.
 * @class LockConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {Number} [options.maxForce=1e6]
 * @extends PointToPointConstraint
 */
function LockConstraint(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

    // Set pivot point in between
    var pivotA = new Vec3();
    var pivotB = new Vec3();
    var halfWay = new Vec3();
    bodyA.position.vadd(bodyB.position, halfWay);
    halfWay.scale(0.5, halfWay);
    bodyB.pointToLocalFrame(halfWay, pivotB);
    bodyA.pointToLocalFrame(halfWay, pivotA);
    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);

    /**
     * @property {RotationalEquation} rotationalEquation1
     */
    var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalEquation} rotationalEquation2
     */
    var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalEquation} rotationalEquation3
     */
    var r3 = this.rotationalEquation3 = new RotationalEquation(bodyA,bodyB,options);

    this.equations.push(r1, r2, r3);
}
LockConstraint.prototype = new PointToPointConstraint();
LockConstraint.constructor = LockConstraint;

var LockConstraint_update_tmpVec1 = new Vec3();
var LockConstraint_update_tmpVec2 = new Vec3();

LockConstraint.prototype.update = function(){
    var bodyA = this.bodyA,
        bodyB = this.bodyB,
        motor = this.motorEquation,
        r1 = this.rotationalEquation1,
        r2 = this.rotationalEquation2,
        r3 = this.rotationalEquation3;

    PointToPointConstraint.prototype.update.call(this);

    bodyA.vectorToWorldFrame(Vec3.UNIT_X, r1.axisA);
    bodyB.vectorToWorldFrame(Vec3.UNIT_Y, r1.axisB);

    bodyA.vectorToWorldFrame(Vec3.UNIT_Y, r2.axisA);
    bodyB.vectorToWorldFrame(Vec3.UNIT_Z, r2.axisB);

    bodyA.vectorToWorldFrame(Vec3.UNIT_Z, r3.axisA);
    bodyB.vectorToWorldFrame(Vec3.UNIT_X, r3.axisB);
};


},{"../equations/ContactEquation":19,"../equations/RotationalEquation":22,"../equations/RotationalMotorEquation":23,"../math/Vec3":30,"./Constraint":13,"./PointToPointConstraint":17}],17:[function(_dereq_,module,exports){
module.exports = PointToPointConstraint;

var Constraint = _dereq_('./Constraint');
var ContactEquation = _dereq_('../equations/ContactEquation');
var Vec3 = _dereq_('../math/Vec3');

/**
 * Connects two bodies at given offset points.
 * @class PointToPointConstraint
 * @extends Constraint
 * @constructor
 * @param {Body} bodyA
 * @param {Vec3} pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.
 * @param {Body} bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.
 * @param {Vec3} pivotB See pivotA.
 * @param {Number} maxForce The maximum force that should be applied to constrain the bodies.
 *
 * @example
 *     var bodyA = new Body({ mass: 1 });
 *     var bodyB = new Body({ mass: 1 });
 *     bodyA.position.set(-1, 0, 0);
 *     bodyB.position.set(1, 0, 0);
 *     bodyA.addShape(shapeA);
 *     bodyB.addShape(shapeB);
 *     world.addBody(bodyA);
 *     world.addBody(bodyB);
 *     var localPivotA = new Vec3(1, 0, 0);
 *     var localPivotB = new Vec3(-1, 0, 0);
 *     var constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB);
 *     world.addConstraint(constraint);
 */
function PointToPointConstraint(bodyA,pivotA,bodyB,pivotB,maxForce){
    Constraint.call(this,bodyA,bodyB);

    maxForce = typeof(maxForce) !== 'undefined' ? maxForce : 1e6;

    /**
     * Pivot, defined locally in bodyA.
     * @property {Vec3} pivotA
     */
    this.pivotA = pivotA ? pivotA.clone() : new Vec3();

    /**
     * Pivot, defined locally in bodyB.
     * @property {Vec3} pivotB
     */
    this.pivotB = pivotB ? pivotB.clone() : new Vec3();

    /**
     * @property {ContactEquation} equationX
     */
    var x = this.equationX = new ContactEquation(bodyA,bodyB);

    /**
     * @property {ContactEquation} equationY
     */
    var y = this.equationY = new ContactEquation(bodyA,bodyB);

    /**
     * @property {ContactEquation} equationZ
     */
    var z = this.equationZ = new ContactEquation(bodyA,bodyB);

    // Equations to be fed to the solver
    this.equations.push(x, y, z);

    // Make the equations bidirectional
    x.minForce = y.minForce = z.minForce = -maxForce;
    x.maxForce = y.maxForce = z.maxForce =  maxForce;

    x.ni.set(1, 0, 0);
    y.ni.set(0, 1, 0);
    z.ni.set(0, 0, 1);
}
PointToPointConstraint.prototype = new Constraint();

PointToPointConstraint.prototype.update = function(){
    var bodyA = this.bodyA;
    var bodyB = this.bodyB;
    var x = this.equationX;
    var y = this.equationY;
    var z = this.equationZ;

    // Rotate the pivots to world space
    bodyA.quaternion.vmult(this.pivotA,x.ri);
    bodyB.quaternion.vmult(this.pivotB,x.rj);

    y.ri.copy(x.ri);
    y.rj.copy(x.rj);
    z.ri.copy(x.ri);
    z.rj.copy(x.rj);
};
},{"../equations/ContactEquation":19,"../math/Vec3":30,"./Constraint":13}],18:[function(_dereq_,module,exports){
module.exports = ConeEquation;

var Vec3 = _dereq_('../math/Vec3');
var Mat3 = _dereq_('../math/Mat3');
var Equation = _dereq_('./Equation');

/**
 * Cone equation. Works to keep the given body world vectors aligned, or tilted within a given angle from each other.
 * @class ConeEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Vec3} [options.axisA] Local axis in A
 * @param {Vec3} [options.axisB] Local axis in B
 * @param {Vec3} [options.angle] The "cone angle" to keep
 * @param {number} [options.maxForce=1e6]
 * @extends Equation
 */
function ConeEquation(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

    Equation.call(this,bodyA,bodyB,-maxForce, maxForce);

    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);

    /**
     * The cone angle to keep
     * @property {number} angle
     */
    this.angle = typeof(options.angle) !== 'undefined' ? options.angle : 0;
}

ConeEquation.prototype = new Equation();
ConeEquation.prototype.constructor = ConeEquation;

var tmpVec1 = new Vec3();
var tmpVec2 = new Vec3();

ConeEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,

        ni = this.axisA,
        nj = this.axisB,

        nixnj = tmpVec1,
        njxni = tmpVec2,

        GA = this.jacobianElementA,
        GB = this.jacobianElementB;

    // Caluclate cross products
    ni.cross(nj, nixnj);
    nj.cross(ni, njxni);

    // The angle between two vector is:
    // cos(theta) = a * b / (length(a) * length(b) = { len(a) = len(b) = 1 } = a * b

    // g = a * b
    // gdot = (b x a) * wi + (a x b) * wj
    // G = [0 bxa 0 axb]
    // W = [vi wi vj wj]
    GA.rotational.copy(njxni);
    GB.rotational.copy(nixnj);

    var g = Math.cos(this.angle) - ni.dot(nj),
        GW = this.computeGW(),
        GiMf = this.computeGiMf();

    var B = - g * a - GW * b - h * GiMf;

    return B;
};


},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],19:[function(_dereq_,module,exports){
module.exports = ContactEquation;

var Equation = _dereq_('./Equation');
var Vec3 = _dereq_('../math/Vec3');
var Mat3 = _dereq_('../math/Mat3');

/**
 * Contact/non-penetration constraint equation
 * @class ContactEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @extends Equation
 */
function ContactEquation(bodyA, bodyB, maxForce){
    maxForce = typeof(maxForce) !== 'undefined' ? maxForce : 1e6;
    Equation.call(this, bodyA, bodyB, 0, maxForce);

    /**
     * @property restitution
     * @type {Number}
     */
    this.restitution = 0.0; // "bounciness": u1 = -e*u0

    /**
     * World-oriented vector that goes from the center of bi to the contact point.
     * @property {Vec3} ri
     */
    this.ri = new Vec3();

    /**
     * World-oriented vector that starts in body j position and goes to the contact point.
     * @property {Vec3} rj
     */
    this.rj = new Vec3();

    /**
     * Contact normal, pointing out of body i.
     * @property {Vec3} ni
     */
    this.ni = new Vec3();
}

ContactEquation.prototype = new Equation();
ContactEquation.prototype.constructor = ContactEquation;

var ContactEquation_computeB_temp1 = new Vec3(); // Temp vectors
var ContactEquation_computeB_temp2 = new Vec3();
var ContactEquation_computeB_temp3 = new Vec3();
ContactEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,
        bi = this.bi,
        bj = this.bj,
        ri = this.ri,
        rj = this.rj,
        rixn = ContactEquation_computeB_temp1,
        rjxn = ContactEquation_computeB_temp2,

        vi = bi.velocity,
        wi = bi.angularVelocity,
        fi = bi.force,
        taui = bi.torque,

        vj = bj.velocity,
        wj = bj.angularVelocity,
        fj = bj.force,
        tauj = bj.torque,

        penetrationVec = ContactEquation_computeB_temp3,

        GA = this.jacobianElementA,
        GB = this.jacobianElementB,

        n = this.ni;

    // Caluclate cross products
    ri.cross(n,rixn);
    rj.cross(n,rjxn);

    // g = xj+rj -(xi+ri)
    // G = [ -ni  -rixn  ni  rjxn ]
    n.negate(GA.spatial);
    rixn.negate(GA.rotational);
    GB.spatial.copy(n);
    GB.rotational.copy(rjxn);

    // Calculate the penetration vector
    penetrationVec.copy(bj.position);
    penetrationVec.vadd(rj,penetrationVec);
    penetrationVec.vsub(bi.position,penetrationVec);
    penetrationVec.vsub(ri,penetrationVec);

    var g = n.dot(penetrationVec);

    // Compute iteration
    var ePlusOne = this.restitution + 1;
    var GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);
    var GiMf = this.computeGiMf();

    var B = - g * a - GW * b - h*GiMf;

    return B;
};

var ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3();

/**
 * Get the current relative velocity in the contact point.
 * @method getImpactVelocityAlongNormal
 * @return {number}
 */
ContactEquation.prototype.getImpactVelocityAlongNormal = function(){
    var vi = ContactEquation_getImpactVelocityAlongNormal_vi;
    var vj = ContactEquation_getImpactVelocityAlongNormal_vj;
    var xi = ContactEquation_getImpactVelocityAlongNormal_xi;
    var xj = ContactEquation_getImpactVelocityAlongNormal_xj;
    var relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;

    this.bi.position.vadd(this.ri, xi);
    this.bj.position.vadd(this.rj, xj);

    this.bi.getVelocityAtWorldPoint(xi, vi);
    this.bj.getVelocityAtWorldPoint(xj, vj);

    vi.vsub(vj, relVel);

    return this.ni.dot(relVel);
};


},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],20:[function(_dereq_,module,exports){
module.exports = Equation;

var JacobianElement = _dereq_('../math/JacobianElement'),
    Vec3 = _dereq_('../math/Vec3');

/**
 * Equation base class
 * @class Equation
 * @constructor
 * @author schteppe
 * @param {Body} bi
 * @param {Body} bj
 * @param {Number} minForce Minimum (read: negative max) force to be applied by the constraint.
 * @param {Number} maxForce Maximum (read: positive max) force to be applied by the constraint.
 */
function Equation(bi,bj,minForce,maxForce){
    this.id = Equation.id++;

    /**
     * @property {number} minForce
     */
    this.minForce = typeof(minForce)==="undefined" ? -1e6 : minForce;

    /**
     * @property {number} maxForce
     */
    this.maxForce = typeof(maxForce)==="undefined" ? 1e6 : maxForce;

    /**
     * @property bi
     * @type {Body}
     */
    this.bi = bi;

    /**
     * @property bj
     * @type {Body}
     */
    this.bj = bj;

    /**
     * SPOOK parameter
     * @property {number} a
     */
    this.a = 0.0;

    /**
     * SPOOK parameter
     * @property {number} b
     */
    this.b = 0.0;

    /**
     * SPOOK parameter
     * @property {number} eps
     */
    this.eps = 0.0;

    /**
     * @property {JacobianElement} jacobianElementA
     */
    this.jacobianElementA = new JacobianElement();

    /**
     * @property {JacobianElement} jacobianElementB
     */
    this.jacobianElementB = new JacobianElement();

    /**
     * @property {boolean} enabled
     * @default true
     */
    this.enabled = true;

    // Set typical spook params
    this.setSpookParams(1e7,4,1/60);
}
Equation.prototype.constructor = Equation;

Equation.id = 0;

/**
 * Recalculates a,b,eps.
 * @method setSpookParams
 */
Equation.prototype.setSpookParams = function(stiffness,relaxation,timeStep){
    var d = relaxation,
        k = stiffness,
        h = timeStep;
    this.a = 4.0 / (h * (1 + 4 * d));
    this.b = (4.0 * d) / (1 + 4 * d);
    this.eps = 4.0 / (h * h * k * (1 + 4 * d));
};

/**
 * Computes the RHS of the SPOOK equation
 * @method computeB
 * @return {Number}
 */
Equation.prototype.computeB = function(a,b,h){
    var GW = this.computeGW(),
        Gq = this.computeGq(),
        GiMf = this.computeGiMf();
    return - Gq * a - GW * b - GiMf*h;
};

/**
 * Computes G*q, where q are the generalized body coordinates
 * @method computeGq
 * @return {Number}
 */
Equation.prototype.computeGq = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        xi = bi.position,
        xj = bj.position;
    return GA.spatial.dot(xi) + GB.spatial.dot(xj);
};

var zero = new Vec3();

/**
 * Computes G*W, where W are the body velocities
 * @method computeGW
 * @return {Number}
 */
Equation.prototype.computeGW = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        vi = bi.velocity,
        vj = bj.velocity,
        wi = bi.angularVelocity || zero,
        wj = bj.angularVelocity || zero;
    return GA.multiplyVectors(vi,wi) + GB.multiplyVectors(vj,wj);
};


/**
 * Computes G*Wlambda, where W are the body velocities
 * @method computeGWlambda
 * @return {Number}
 */
Equation.prototype.computeGWlambda = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        vi = bi.vlambda,
        vj = bj.vlambda,
        wi = bi.wlambda || zero,
        wj = bj.wlambda || zero;
    return GA.multiplyVectors(vi,wi) + GB.multiplyVectors(vj,wj);
};

/**
 * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
 * @method computeGiMf
 * @return {Number}
 */
var iMfi = new Vec3(),
    iMfj = new Vec3(),
    invIi_vmult_taui = new Vec3(),
    invIj_vmult_tauj = new Vec3();
Equation.prototype.computeGiMf = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        fi = bi.force,
        ti = bi.torque,
        fj = bj.force,
        tj = bj.torque,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve;

    if(bi.invInertiaWorldSolve){ bi.invInertiaWorldSolve.vmult(ti,invIi_vmult_taui); }
    else { invIi_vmult_taui.set(0,0,0); }
    if(bj.invInertiaWorldSolve){ bj.invInertiaWorldSolve.vmult(tj,invIj_vmult_tauj); }
    else { invIj_vmult_tauj.set(0,0,0); }

    fi.mult(invMassi,iMfi);
    fj.mult(invMassj,iMfj);

    return GA.multiplyVectors(iMfi,invIi_vmult_taui) + GB.multiplyVectors(iMfj,invIj_vmult_tauj);
};

/**
 * Computes G*inv(M)*G'
 * @method computeGiMGt
 * @return {Number}
 */
var tmp = new Vec3();
Equation.prototype.computeGiMGt = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaWorldSolve,
        invIj = bj.invInertiaWorldSolve,
        result = invMassi + invMassj;

    if(invIi){
        invIi.vmult(GA.rotational,tmp);
        result += tmp.dot(GA.rotational);
    }

    if(invIj){
        invIj.vmult(GB.rotational,tmp);
        result += tmp.dot(GB.rotational);
    }

    return  result;
};

var addToWlambda_temp = new Vec3(),
    addToWlambda_Gi = new Vec3(),
    addToWlambda_Gj = new Vec3(),
    addToWlambda_ri = new Vec3(),
    addToWlambda_rj = new Vec3(),
    addToWlambda_Mdiag = new Vec3();

/**
 * Add constraint velocity to the bodies.
 * @method addToWlambda
 * @param {Number} deltalambda
 */
Equation.prototype.addToWlambda = function(deltalambda){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        temp = addToWlambda_temp;

    // Add to linear velocity
    // v_lambda += inv(M) * delta_lamba * G
    GA.spatial.mult(bi.invMassSolve * deltalambda,temp);
    bi.vlambda.vadd(temp, bi.vlambda);

    GB.spatial.mult(bj.invMassSolve * deltalambda,temp);
    bj.vlambda.vadd(temp, bj.vlambda);

    // Add to angular velocity
    if(bi.invInertiaWorldSolve){
        bi.invInertiaWorldSolve.vmult(GA.rotational,temp);
        temp.mult(deltalambda,temp);
        bi.wlambda.vadd(temp,bi.wlambda);
    }

    if(bj.invInertiaWorldSolve){
        bj.invInertiaWorldSolve.vmult(GB.rotational,temp);
        temp.mult(deltalambda,temp);
        bj.wlambda.vadd(temp,bj.wlambda);
    }
};

/**
 * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
 * @method computeInvC
 * @param  {Number} eps
 * @return {Number}
 */
Equation.prototype.computeC = function(){
    return this.computeGiMGt() + this.eps;
};

},{"../math/JacobianElement":26,"../math/Vec3":30}],21:[function(_dereq_,module,exports){
module.exports = FrictionEquation;

var Equation = _dereq_('./Equation');
var Vec3 = _dereq_('../math/Vec3');
var Mat3 = _dereq_('../math/Mat3');

/**
 * Constrains the slipping in a contact along a tangent
 * @class FrictionEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
 * @extends Equation
 */
function FrictionEquation(bodyA, bodyB, slipForce){
    Equation.call(this,bodyA, bodyB, -slipForce, slipForce);
    this.ri = new Vec3();
    this.rj = new Vec3();
    this.t = new Vec3(); // tangent
}

FrictionEquation.prototype = new Equation();
FrictionEquation.prototype.constructor = FrictionEquation;

var FrictionEquation_computeB_temp1 = new Vec3();
var FrictionEquation_computeB_temp2 = new Vec3();
FrictionEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,
        bi = this.bi,
        bj = this.bj,
        ri = this.ri,
        rj = this.rj,
        rixt = FrictionEquation_computeB_temp1,
        rjxt = FrictionEquation_computeB_temp2,
        t = this.t;

    // Caluclate cross products
    ri.cross(t,rixt);
    rj.cross(t,rjxt);

    // G = [-t -rixt t rjxt]
    // And remember, this is a pure velocity constraint, g is always zero!
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB;
    t.negate(GA.spatial);
    rixt.negate(GA.rotational);
    GB.spatial.copy(t);
    GB.rotational.copy(rjxt);

    var GW = this.computeGW();
    var GiMf = this.computeGiMf();

    var B = - GW * b - h * GiMf;

    return B;
};

},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],22:[function(_dereq_,module,exports){
module.exports = RotationalEquation;

var Vec3 = _dereq_('../math/Vec3');
var Mat3 = _dereq_('../math/Mat3');
var Equation = _dereq_('./Equation');

/**
 * Rotational constraint. Works to keep the local vectors orthogonal to each other in world space.
 * @class RotationalEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Vec3} [options.axisA]
 * @param {Vec3} [options.axisB]
 * @param {number} [options.maxForce]
 * @extends Equation
 */
function RotationalEquation(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

    Equation.call(this,bodyA,bodyB,-maxForce, maxForce);

    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);

    this.maxAngle = Math.PI / 2;
}

RotationalEquation.prototype = new Equation();
RotationalEquation.prototype.constructor = RotationalEquation;

var tmpVec1 = new Vec3();
var tmpVec2 = new Vec3();

RotationalEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,

        ni = this.axisA,
        nj = this.axisB,

        nixnj = tmpVec1,
        njxni = tmpVec2,

        GA = this.jacobianElementA,
        GB = this.jacobianElementB;

    // Caluclate cross products
    ni.cross(nj, nixnj);
    nj.cross(ni, njxni);

    // g = ni * nj
    // gdot = (nj x ni) * wi + (ni x nj) * wj
    // G = [0 njxni 0 nixnj]
    // W = [vi wi vj wj]
    GA.rotational.copy(njxni);
    GB.rotational.copy(nixnj);

    var g = Math.cos(this.maxAngle) - ni.dot(nj),
        GW = this.computeGW(),
        GiMf = this.computeGiMf();

    var B = - g * a - GW * b - h * GiMf;

    return B;
};


},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],23:[function(_dereq_,module,exports){
module.exports = RotationalMotorEquation;

var Vec3 = _dereq_('../math/Vec3');
var Mat3 = _dereq_('../math/Mat3');
var Equation = _dereq_('./Equation');

/**
 * Rotational motor constraint. Tries to keep the relative angular velocity of the bodies to a given value.
 * @class RotationalMotorEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} maxForce
 * @extends Equation
 */
function RotationalMotorEquation(bodyA, bodyB, maxForce){
    maxForce = typeof(maxForce)!=='undefined' ? maxForce : 1e6;
    Equation.call(this,bodyA,bodyB,-maxForce,maxForce);

    /**
     * World oriented rotational axis
     * @property {Vec3} axisA
     */
    this.axisA = new Vec3();

    /**
     * World oriented rotational axis
     * @property {Vec3} axisB
     */
    this.axisB = new Vec3(); // World oriented rotational axis

    /**
     * Motor velocity
     * @property {Number} targetVelocity
     */
    this.targetVelocity = 0;
}

RotationalMotorEquation.prototype = new Equation();
RotationalMotorEquation.prototype.constructor = RotationalMotorEquation;

RotationalMotorEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,
        bi = this.bi,
        bj = this.bj,

        axisA = this.axisA,
        axisB = this.axisB,

        GA = this.jacobianElementA,
        GB = this.jacobianElementB;

    // g = 0
    // gdot = axisA * wi - axisB * wj
    // gdot = G * W = G * [vi wi vj wj]
    // =>
    // G = [0 axisA 0 -axisB]

    GA.rotational.copy(axisA);
    axisB.negate(GB.rotational);

    var GW = this.computeGW() - this.targetVelocity,
        GiMf = this.computeGiMf();

    var B = - GW * b - h * GiMf;

    return B;
};

},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],24:[function(_dereq_,module,exports){
var Utils = _dereq_('../utils/Utils');

module.exports = ContactMaterial;

/**
 * Defines what happens when two materials meet.
 * @class ContactMaterial
 * @constructor
 * @param {Material} m1
 * @param {Material} m2
 * @param {object} [options]
 * @param {Number} [options.friction=0.3]
 * @param {Number} [options.restitution=0.3]
 * @param {number} [options.contactEquationStiffness=1e7]
 * @param {number} [options.contactEquationRelaxation=3]
 * @param {number} [options.frictionEquationStiffness=1e7]
 * @param {Number} [options.frictionEquationRelaxation=3]
 */
function ContactMaterial(m1, m2, options){
    options = Utils.defaults(options, {
        friction: 0.3,
        restitution: 0.3,
        contactEquationStiffness: 1e7,
        contactEquationRelaxation: 3,
        frictionEquationStiffness: 1e7,
        frictionEquationRelaxation: 3
    });

    /**
     * Identifier of this material
     * @property {Number} id
     */
    this.id = ContactMaterial.idCounter++;

    /**
     * Participating materials
     * @property {Array} materials
     * @todo  Should be .materialA and .materialB instead
     */
    this.materials = [m1, m2];

    /**
     * Friction coefficient
     * @property {Number} friction
     */
    this.friction = options.friction;

    /**
     * Restitution coefficient
     * @property {Number} restitution
     */
    this.restitution = options.restitution;

    /**
     * Stiffness of the produced contact equations
     * @property {Number} contactEquationStiffness
     */
    this.contactEquationStiffness = options.contactEquationStiffness;

    /**
     * Relaxation time of the produced contact equations
     * @property {Number} contactEquationRelaxation
     */
    this.contactEquationRelaxation = options.contactEquationRelaxation;

    /**
     * Stiffness of the produced friction equations
     * @property {Number} frictionEquationStiffness
     */
    this.frictionEquationStiffness = options.frictionEquationStiffness;

    /**
     * Relaxation time of the produced friction equations
     * @property {Number} frictionEquationRelaxation
     */
    this.frictionEquationRelaxation = options.frictionEquationRelaxation;
}

ContactMaterial.idCounter = 0;

},{"../utils/Utils":53}],25:[function(_dereq_,module,exports){
module.exports = Material;

/**
 * Defines a physics material.
 * @class Material
 * @constructor
 * @param {object} [options]
 * @author schteppe
 */
function Material(options){
    var name = '';
    options = options || {};

    // Backwards compatibility fix
    if(typeof(options) === 'string'){
        name = options;
        options = {};
    } else if(typeof(options) === 'object') {
        name = '';
    }

    /**
     * @property name
     * @type {String}
     */
    this.name = name;

    /**
     * material id.
     * @property id
     * @type {number}
     */
    this.id = Material.idCounter++;

    /**
     * Friction for this material. If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.
     * @property {number} friction
     */
    this.friction = typeof(options.friction) !== 'undefined' ? options.friction : -1;

    /**
     * Restitution for this material. If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.
     * @property {number} restitution
     */
    this.restitution = typeof(options.restitution) !== 'undefined' ? options.restitution : -1;
}

Material.idCounter = 0;

},{}],26:[function(_dereq_,module,exports){
module.exports = JacobianElement;

var Vec3 = _dereq_('./Vec3');

/**
 * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.
 * @class JacobianElement
 * @constructor
 */
function JacobianElement(){

    /**
     * @property {Vec3} spatial
     */
    this.spatial = new Vec3();

    /**
     * @property {Vec3} rotational
     */
    this.rotational = new Vec3();
}

/**
 * Multiply with other JacobianElement
 * @method multiplyElement
 * @param  {JacobianElement} element
 * @return {Number}
 */
JacobianElement.prototype.multiplyElement = function(element){
    return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);
};

/**
 * Multiply with two vectors
 * @method multiplyVectors
 * @param  {Vec3} spatial
 * @param  {Vec3} rotational
 * @return {Number}
 */
JacobianElement.prototype.multiplyVectors = function(spatial,rotational){
    return spatial.dot(this.spatial) + rotational.dot(this.rotational);
};

},{"./Vec3":30}],27:[function(_dereq_,module,exports){
module.exports = Mat3;

var Vec3 = _dereq_('./Vec3');

/**
 * A 3x3 matrix.
 * @class Mat3
 * @constructor
 * @param array elements Array of nine elements. Optional.
 * @author schteppe / http://github.com/schteppe
 */
function Mat3(elements){
    /**
     * A vector of length 9, containing all matrix elements
     * @property {Array} elements
     */
    if(elements){
        this.elements = elements;
    } else {
        this.elements = [0,0,0,0,0,0,0,0,0];
    }
}

/**
 * Sets the matrix to identity
 * @method identity
 * @todo Should perhaps be renamed to setIdentity() to be more clear.
 * @todo Create another function that immediately creates an identity matrix eg. eye()
 */
Mat3.prototype.identity = function(){
    var e = this.elements;
    e[0] = 1;
    e[1] = 0;
    e[2] = 0;

    e[3] = 0;
    e[4] = 1;
    e[5] = 0;

    e[6] = 0;
    e[7] = 0;
    e[8] = 1;
};

/**
 * Set all elements to zero
 * @method setZero
 */
Mat3.prototype.setZero = function(){
    var e = this.elements;
    e[0] = 0;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 0;
    e[5] = 0;
    e[6] = 0;
    e[7] = 0;
    e[8] = 0;
};

/**
 * Sets the matrix diagonal elements from a Vec3
 * @method setTrace
 * @param {Vec3} vec3
 */
Mat3.prototype.setTrace = function(vec3){
    var e = this.elements;
    e[0] = vec3.x;
    e[4] = vec3.y;
    e[8] = vec3.z;
};

/**
 * Gets the matrix diagonal elements
 * @method getTrace
 * @return {Vec3}
 */
Mat3.prototype.getTrace = function(target){
    var target = target || new Vec3();
    var e = this.elements;
    target.x = e[0];
    target.y = e[4];
    target.z = e[8];
};

/**
 * Matrix-Vector multiplication
 * @method vmult
 * @param {Vec3} v The vector to multiply with
 * @param {Vec3} target Optional, target to save the result in.
 */
Mat3.prototype.vmult = function(v,target){
    target = target || new Vec3();

    var e = this.elements,
        x = v.x,
        y = v.y,
        z = v.z;
    target.x = e[0]*x + e[1]*y + e[2]*z;
    target.y = e[3]*x + e[4]*y + e[5]*z;
    target.z = e[6]*x + e[7]*y + e[8]*z;

    return target;
};

/**
 * Matrix-scalar multiplication
 * @method smult
 * @param {Number} s
 */
Mat3.prototype.smult = function(s){
    var this$1 = this;

    for(var i=0; i<this.elements.length; i++){
        this$1.elements[i] *= s;
    }
};

/**
 * Matrix multiplication
 * @method mmult
 * @param {Mat3} m Matrix to multiply with from left side.
 * @return {Mat3} The result.
 */
Mat3.prototype.mmult = function(m,target){
    var this$1 = this;

    var r = target || new Mat3();
    for(var i=0; i<3; i++){
        for(var j=0; j<3; j++){
            var sum = 0.0;
            for(var k=0; k<3; k++){
                sum += m.elements[i+k*3] * this$1.elements[k+j*3];
            }
            r.elements[i+j*3] = sum;
        }
    }
    return r;
};

/**
 * Scale each column of the matrix
 * @method scale
 * @param {Vec3} v
 * @return {Mat3} The result.
 */
Mat3.prototype.scale = function(v,target){
    target = target || new Mat3();
    var e = this.elements,
        t = target.elements;
    for(var i=0; i!==3; i++){
        t[3*i + 0] = v.x * e[3*i + 0];
        t[3*i + 1] = v.y * e[3*i + 1];
        t[3*i + 2] = v.z * e[3*i + 2];
    }
    return target;
};

/**
 * Solve Ax=b
 * @method solve
 * @param {Vec3} b The right hand side
 * @param {Vec3} target Optional. Target vector to save in.
 * @return {Vec3} The solution x
 * @todo should reuse arrays
 */
Mat3.prototype.solve = function(b,target){
    var this$1 = this;

    target = target || new Vec3();

    // Construct equations
    var nr = 3; // num rows
    var nc = 4; // num cols
    var eqns = [];
    for(var i=0; i<nr*nc; i++){
        eqns.push(0);
    }
    var i,j;
    for(i=0; i<3; i++){
        for(j=0; j<3; j++){
            eqns[i+nc*j] = this$1.elements[i+3*j];
        }
    }
    eqns[3+4*0] = b.x;
    eqns[3+4*1] = b.y;
    eqns[3+4*2] = b.z;

    // Compute right upper triangular version of the matrix - Gauss elimination
    var n = 3, k = n, np;
    var kp = 4; // num rows
    var p;
    do {
        i = k - n;
        if (eqns[i+nc*i] === 0) {
            // the pivot is null, swap lines
            for (j = i + 1; j < k; j++) {
                if (eqns[i+nc*j] !== 0) {
                    np = kp;
                    do {  // do ligne( i ) = ligne( i ) + ligne( k )
                        p = kp - np;
                        eqns[p+nc*i] += eqns[p+nc*j];
                    } while (--np);
                    break;
                }
            }
        }
        if (eqns[i+nc*i] !== 0) {
            for (j = i + 1; j < k; j++) {
                var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
                np = kp;
                do {  // do ligne( k ) = ligne( k ) - multiplier * ligne( i )
                    p = kp - np;
                    eqns[p+nc*j] = p <= i ? 0 : eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;
                } while (--np);
            }
        }
    } while (--n);

    // Get the solution
    target.z = eqns[2*nc+3] / eqns[2*nc+2];
    target.y = (eqns[1*nc+3] - eqns[1*nc+2]*target.z) / eqns[1*nc+1];
    target.x = (eqns[0*nc+3] - eqns[0*nc+2]*target.z - eqns[0*nc+1]*target.y) / eqns[0*nc+0];

    if(isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x===Infinity || target.y===Infinity || target.z===Infinity){
        throw "Could not solve equation! Got x=["+target.toString()+"], b=["+b.toString()+"], A=["+this.toString()+"]";
    }

    return target;
};

/**
 * Get an element in the matrix by index. Index starts at 0, not 1!!!
 * @method e
 * @param {Number} row
 * @param {Number} column
 * @param {Number} value Optional. If provided, the matrix element will be set to this value.
 * @return {Number}
 */
Mat3.prototype.e = function( row , column ,value){
    if(value===undefined){
        return this.elements[column+3*row];
    } else {
        // Set value
        this.elements[column+3*row] = value;
    }
};

/**
 * Copy another matrix into this matrix object.
 * @method copy
 * @param {Mat3} source
 * @return {Mat3} this
 */
Mat3.prototype.copy = function(source){
    var this$1 = this;

    for(var i=0; i < source.elements.length; i++){
        this$1.elements[i] = source.elements[i];
    }
    return this;
};

/**
 * Returns a string representation of the matrix.
 * @method toString
 * @return string
 */
Mat3.prototype.toString = function(){
    var this$1 = this;

    var r = "";
    var sep = ",";
    for(var i=0; i<9; i++){
        r += this$1.elements[i] + sep;
    }
    return r;
};

/**
 * reverse the matrix
 * @method reverse
 * @param {Mat3} target Optional. Target matrix to save in.
 * @return {Mat3} The solution x
 */
Mat3.prototype.reverse = function(target){
    var this$1 = this;


    target = target || new Mat3();

    // Construct equations
    var nr = 3; // num rows
    var nc = 6; // num cols
    var eqns = [];
    for(var i=0; i<nr*nc; i++){
        eqns.push(0);
    }
    var i,j;
    for(i=0; i<3; i++){
        for(j=0; j<3; j++){
            eqns[i+nc*j] = this$1.elements[i+3*j];
        }
    }
    eqns[3+6*0] = 1;
    eqns[3+6*1] = 0;
    eqns[3+6*2] = 0;
    eqns[4+6*0] = 0;
    eqns[4+6*1] = 1;
    eqns[4+6*2] = 0;
    eqns[5+6*0] = 0;
    eqns[5+6*1] = 0;
    eqns[5+6*2] = 1;

    // Compute right upper triangular version of the matrix - Gauss elimination
    var n = 3, k = n, np;
    var kp = nc; // num rows
    var p;
    do {
        i = k - n;
        if (eqns[i+nc*i] === 0) {
            // the pivot is null, swap lines
            for (j = i + 1; j < k; j++) {
                if (eqns[i+nc*j] !== 0) {
                    np = kp;
                    do { // do line( i ) = line( i ) + line( k )
                        p = kp - np;
                        eqns[p+nc*i] += eqns[p+nc*j];
                    } while (--np);
                    break;
                }
            }
        }
        if (eqns[i+nc*i] !== 0) {
            for (j = i + 1; j < k; j++) {
                var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
                np = kp;
                do { // do line( k ) = line( k ) - multiplier * line( i )
                    p = kp - np;
                    eqns[p+nc*j] = p <= i ? 0 : eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;
                } while (--np);
            }
        }
    } while (--n);

    // eliminate the upper left triangle of the matrix
    i = 2;
    do {
        j = i-1;
        do {
            var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
            np = nc;
            do {
                p = nc - np;
                eqns[p+nc*j] =  eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;
            } while (--np);
        } while (j--);
    } while (--i);

    // operations on the diagonal
    i = 2;
    do {
        var multiplier = 1 / eqns[i+nc*i];
        np = nc;
        do {
            p = nc - np;
            eqns[p+nc*i] = eqns[p+nc*i] * multiplier ;
        } while (--np);
    } while (i--);

    i = 2;
    do {
        j = 2;
        do {
            p = eqns[nr+j+nc*i];
            if( isNaN( p ) || p ===Infinity ){
                throw "Could not reverse! A=["+this$1.toString()+"]";
            }
            target.e( i , j , p );
        } while (j--);
    } while (i--);

    return target;
};

/**
 * Set the matrix from a quaterion
 * @method setRotationFromQuaternion
 * @param {Quaternion} q
 */
Mat3.prototype.setRotationFromQuaternion = function( q ) {
    var x = q.x, y = q.y, z = q.z, w = q.w,
        x2 = x + x, y2 = y + y, z2 = z + z,
        xx = x * x2, xy = x * y2, xz = x * z2,
        yy = y * y2, yz = y * z2, zz = z * z2,
        wx = w * x2, wy = w * y2, wz = w * z2,
        e = this.elements;

    e[3*0 + 0] = 1 - ( yy + zz );
    e[3*0 + 1] = xy - wz;
    e[3*0 + 2] = xz + wy;

    e[3*1 + 0] = xy + wz;
    e[3*1 + 1] = 1 - ( xx + zz );
    e[3*1 + 2] = yz - wx;

    e[3*2 + 0] = xz - wy;
    e[3*2 + 1] = yz + wx;
    e[3*2 + 2] = 1 - ( xx + yy );

    return this;
};

/**
 * Transpose the matrix
 * @method transpose
 * @param  {Mat3} target Where to store the result.
 * @return {Mat3} The target Mat3, or a new Mat3 if target was omitted.
 */
Mat3.prototype.transpose = function( target ) {
    target = target || new Mat3();

    var Mt = target.elements,
        M = this.elements;

    for(var i=0; i!==3; i++){
        for(var j=0; j!==3; j++){
            Mt[3*i + j] = M[3*j + i];
        }
    }

    return target;
};

},{"./Vec3":30}],28:[function(_dereq_,module,exports){
module.exports = Quaternion;

var Vec3 = _dereq_('./Vec3');

/**
 * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
 * @class Quaternion
 * @constructor
 * @param {Number} x Multiplier of the imaginary basis vector i.
 * @param {Number} y Multiplier of the imaginary basis vector j.
 * @param {Number} z Multiplier of the imaginary basis vector k.
 * @param {Number} w Multiplier of the real part.
 * @see http://en.wikipedia.org/wiki/Quaternion
 */
function Quaternion(x,y,z,w){
    /**
     * @property {Number} x
     */
    this.x = x!==undefined ? x : 0;

    /**
     * @property {Number} y
     */
    this.y = y!==undefined ? y : 0;

    /**
     * @property {Number} z
     */
    this.z = z!==undefined ? z : 0;

    /**
     * The multiplier of the real quaternion basis vector.
     * @property {Number} w
     */
    this.w = w!==undefined ? w : 1;
}

/**
 * Set the value of the quaternion.
 * @method set
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @param {Number} w
 */
Quaternion.prototype.set = function(x,y,z,w){
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
};

/**
 * Convert to a readable format
 * @method toString
 * @return string
 */
Quaternion.prototype.toString = function(){
    return this.x+","+this.y+","+this.z+","+this.w;
};

/**
 * Convert to an Array
 * @method toArray
 * @return Array
 */
Quaternion.prototype.toArray = function(){
    return [this.x, this.y, this.z, this.w];
};

/**
 * Set the quaternion components given an axis and an angle.
 * @method setFromAxisAngle
 * @param {Vec3} axis
 * @param {Number} angle in radians
 */
Quaternion.prototype.setFromAxisAngle = function(axis,angle){
    var s = Math.sin(angle*0.5);
    this.x = axis.x * s;
    this.y = axis.y * s;
    this.z = axis.z * s;
    this.w = Math.cos(angle*0.5);
};

/**
 * Converts the quaternion to axis/angle representation.
 * @method toAxisAngle
 * @param {Vec3} targetAxis Optional. A vector object to reuse for storing the axis.
 * @return Array An array, first elemnt is the axis and the second is the angle in radians.
 */
Quaternion.prototype.toAxisAngle = function(targetAxis){
    targetAxis = targetAxis || new Vec3();
    this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised
    var angle = 2 * Math.acos(this.w);
    var s = Math.sqrt(1-this.w*this.w); // assuming quaternion normalised then w is less than 1, so term always positive.
    if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
        // if s close to zero then direction of axis not important
        targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;
        targetAxis.y = this.y;
        targetAxis.z = this.z;
    } else {
        targetAxis.x = this.x / s; // normalise axis
        targetAxis.y = this.y / s;
        targetAxis.z = this.z / s;
    }
    return [targetAxis,angle];
};

var sfv_t1 = new Vec3(),
    sfv_t2 = new Vec3();

/**
 * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
 * @method setFromVectors
 * @param {Vec3} u
 * @param {Vec3} v
 */
Quaternion.prototype.setFromVectors = function(u,v){
    if(u.isAntiparallelTo(v)){
        var t1 = sfv_t1;
        var t2 = sfv_t2;

        u.tangents(t1,t2);
        this.setFromAxisAngle(t1,Math.PI);
    } else {
        var a = u.cross(v);
        this.x = a.x;
        this.y = a.y;
        this.z = a.z;
        this.w = Math.sqrt(Math.pow(u.norm(),2) * Math.pow(v.norm(),2)) + u.dot(v);
        this.normalize();
    }
};

/**
 * Quaternion multiplication
 * @method mult
 * @param {Quaternion} q
 * @param {Quaternion} target Optional.
 * @return {Quaternion}
 */
var Quaternion_mult_va = new Vec3();
var Quaternion_mult_vb = new Vec3();
var Quaternion_mult_vaxvb = new Vec3();
Quaternion.prototype.mult = function(q,target){
    target = target || new Quaternion();
    var w = this.w,
        va = Quaternion_mult_va,
        vb = Quaternion_mult_vb,
        vaxvb = Quaternion_mult_vaxvb;

    va.set(this.x,this.y,this.z);
    vb.set(q.x,q.y,q.z);
    target.w = w*q.w - va.dot(vb);
    va.cross(vb,vaxvb);

    target.x = w * vb.x + q.w*va.x + vaxvb.x;
    target.y = w * vb.y + q.w*va.y + vaxvb.y;
    target.z = w * vb.z + q.w*va.z + vaxvb.z;

    return target;
};

/**
 * Get the inverse quaternion rotation.
 * @method inverse
 * @param {Quaternion} target
 * @return {Quaternion}
 */
Quaternion.prototype.inverse = function(target){
    var x = this.x, y = this.y, z = this.z, w = this.w;
    target = target || new Quaternion();

    this.conjugate(target);
    var inorm2 = 1/(x*x + y*y + z*z + w*w);
    target.x *= inorm2;
    target.y *= inorm2;
    target.z *= inorm2;
    target.w *= inorm2;

    return target;
};

/**
 * Get the quaternion conjugate
 * @method conjugate
 * @param {Quaternion} target
 * @return {Quaternion}
 */
Quaternion.prototype.conjugate = function(target){
    target = target || new Quaternion();

    target.x = -this.x;
    target.y = -this.y;
    target.z = -this.z;
    target.w = this.w;

    return target;
};

/**
 * Normalize the quaternion. Note that this changes the values of the quaternion.
 * @method normalize
 */
Quaternion.prototype.normalize = function(){
    var l = Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);
    if ( l === 0 ) {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
    } else {
        l = 1 / l;
        this.x *= l;
        this.y *= l;
        this.z *= l;
        this.w *= l;
    }
};

/**
 * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
 * @method normalizeFast
 * @see http://jsperf.com/fast-quaternion-normalization
 * @author unphased, https://github.com/unphased
 */
Quaternion.prototype.normalizeFast = function () {
    var f = (3.0-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2.0;
    if ( f === 0 ) {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
    } else {
        this.x *= f;
        this.y *= f;
        this.z *= f;
        this.w *= f;
    }
};

/**
 * Multiply the quaternion by a vector
 * @method vmult
 * @param {Vec3} v
 * @param {Vec3} target Optional
 * @return {Vec3}
 */
Quaternion.prototype.vmult = function(v,target){
    target = target || new Vec3();

    var x = v.x,
        y = v.y,
        z = v.z;

    var qx = this.x,
        qy = this.y,
        qz = this.z,
        qw = this.w;

    // q*v
    var ix =  qw * x + qy * z - qz * y,
    iy =  qw * y + qz * x - qx * z,
    iz =  qw * z + qx * y - qy * x,
    iw = -qx * x - qy * y - qz * z;

    target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

    return target;
};

/**
 * Copies value of source to this quaternion.
 * @method copy
 * @param {Quaternion} source
 * @return {Quaternion} this
 */
Quaternion.prototype.copy = function(source){
    this.x = source.x;
    this.y = source.y;
    this.z = source.z;
    this.w = source.w;
    return this;
};

/**
 * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: http://www.euclideanspace.com/maths/standards/index.htm
 * @method toEuler
 * @param {Vec3} target
 * @param string order Three-character string e.g. "YZX", which also is default.
 */
Quaternion.prototype.toEuler = function(target,order){
    order = order || "YZX";

    var heading, attitude, bank;
    var x = this.x, y = this.y, z = this.z, w = this.w;

    switch(order){
    case "YZX":
        var test = x*y + z*w;
        if (test > 0.499) { // singularity at north pole
            heading = 2 * Math.atan2(x,w);
            attitude = Math.PI/2;
            bank = 0;
        }
        if (test < -0.499) { // singularity at south pole
            heading = -2 * Math.atan2(x,w);
            attitude = - Math.PI/2;
            bank = 0;
        }
        if(isNaN(heading)){
            var sqx = x*x;
            var sqy = y*y;
            var sqz = z*z;
            heading = Math.atan2(2*y*w - 2*x*z , 1 - 2*sqy - 2*sqz); // Heading
            attitude = Math.asin(2*test); // attitude
            bank = Math.atan2(2*x*w - 2*y*z , 1 - 2*sqx - 2*sqz); // bank
        }
        break;
    default:
        throw new Error("Euler order "+order+" not supported yet.");
    }

    target.y = heading;
    target.z = attitude;
    target.x = bank;
};

/**
 * See http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
 * @method setFromEuler
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @param {String} order The order to apply angles: 'XYZ' or 'YXZ' or any other combination
 */
Quaternion.prototype.setFromEuler = function ( x, y, z, order ) {
    order = order || "XYZ";

    var c1 = Math.cos( x / 2 );
    var c2 = Math.cos( y / 2 );
    var c3 = Math.cos( z / 2 );
    var s1 = Math.sin( x / 2 );
    var s2 = Math.sin( y / 2 );
    var s3 = Math.sin( z / 2 );

    if ( order === 'XYZ' ) {

        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( order === 'YXZ' ) {

        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( order === 'ZXY' ) {

        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( order === 'ZYX' ) {

        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( order === 'YZX' ) {

        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( order === 'XZY' ) {

        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;

    }

    return this;

};

Quaternion.prototype.clone = function(){
    return new Quaternion(this.x, this.y, this.z, this.w);
};
},{"./Vec3":30}],29:[function(_dereq_,module,exports){
var Vec3 = _dereq_('./Vec3');
var Quaternion = _dereq_('./Quaternion');

module.exports = Transform;

/**
 * @class Transform
 * @constructor
 */
function Transform(options) {
    options = options || {};

	/**
	 * @property {Vec3} position
	 */
	this.position = new Vec3();
    if(options.position){
        this.position.copy(options.position);
    }

	/**
	 * @property {Quaternion} quaternion
	 */
	this.quaternion = new Quaternion();
    if(options.quaternion){
        this.quaternion.copy(options.quaternion);
    }
}

var tmpQuat = new Quaternion();

/**
 * @static
 * @method pointToLocaFrame
 * @param {Vec3} position
 * @param {Quaternion} quaternion
 * @param {Vec3} worldPoint
 * @param {Vec3} result
 */
Transform.pointToLocalFrame = function(position, quaternion, worldPoint, result){
    var result = result || new Vec3();
    worldPoint.vsub(position, result);
    quaternion.conjugate(tmpQuat);
    tmpQuat.vmult(result, result);
    return result;
};

/**
 * Get a global point in local transform coordinates.
 * @method pointToLocal
 * @param  {Vec3} point
 * @param  {Vec3} result
 * @return {Vec3} The "result" vector object
 */
Transform.prototype.pointToLocal = function(worldPoint, result){
    return Transform.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);
};

/**
 * @static
 * @method pointToWorldFrame
 * @param {Vec3} position
 * @param {Vec3} quaternion
 * @param {Vec3} localPoint
 * @param {Vec3} result
 */
Transform.pointToWorldFrame = function(position, quaternion, localPoint, result){
    var result = result || new Vec3();
    quaternion.vmult(localPoint, result);
    result.vadd(position, result);
    return result;
};

/**
 * Get a local point in global transform coordinates.
 * @method pointToWorld
 * @param  {Vec3} point
 * @param  {Vec3} result
 * @return {Vec3} The "result" vector object
 */
Transform.prototype.pointToWorld = function(localPoint, result){
    return Transform.pointToWorldFrame(this.position, this.quaternion, localPoint, result);
};


Transform.prototype.vectorToWorldFrame = function(localVector, result){
    var result = result || new Vec3();
    this.quaternion.vmult(localVector, result);
    return result;
};

Transform.vectorToWorldFrame = function(quaternion, localVector, result){
    quaternion.vmult(localVector, result);
    return result;
};

Transform.vectorToLocalFrame = function(position, quaternion, worldVector, result){
    var result = result || new Vec3();
    quaternion.w *= -1;
    quaternion.vmult(worldVector, result);
    quaternion.w *= -1;
    return result;
};

},{"./Quaternion":28,"./Vec3":30}],30:[function(_dereq_,module,exports){
module.exports = Vec3;

var Mat3 = _dereq_('./Mat3');

/**
 * 3-dimensional vector
 * @class Vec3
 * @constructor
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @author schteppe
 * @example
 *     var v = new Vec3(1, 2, 3);
 *     console.log('x=' + v.x); // x=1
 */
function Vec3(x,y,z){
    /**
     * @property x
     * @type {Number}
     */
    this.x = x||0.0;

    /**
     * @property y
     * @type {Number}
     */
    this.y = y||0.0;

    /**
     * @property z
     * @type {Number}
     */
    this.z = z||0.0;
}

/**
 * @static
 * @property {Vec3} ZERO
 */
Vec3.ZERO = new Vec3(0, 0, 0);

/**
 * @static
 * @property {Vec3} UNIT_X
 */
Vec3.UNIT_X = new Vec3(1, 0, 0);

/**
 * @static
 * @property {Vec3} UNIT_Y
 */
Vec3.UNIT_Y = new Vec3(0, 1, 0);

/**
 * @static
 * @property {Vec3} UNIT_Z
 */
Vec3.UNIT_Z = new Vec3(0, 0, 1);

/**
 * Vector cross product
 * @method cross
 * @param {Vec3} v
 * @param {Vec3} target Optional. Target to save in.
 * @return {Vec3}
 */
Vec3.prototype.cross = function(v,target){
    var vx=v.x, vy=v.y, vz=v.z, x=this.x, y=this.y, z=this.z;
    target = target || new Vec3();

    target.x = (y * vz) - (z * vy);
    target.y = (z * vx) - (x * vz);
    target.z = (x * vy) - (y * vx);

    return target;
};

/**
 * Set the vectors' 3 elements
 * @method set
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @return Vec3
 */
Vec3.prototype.set = function(x,y,z){
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
};

/**
 * Set all components of the vector to zero.
 * @method setZero
 */
Vec3.prototype.setZero = function(){
    this.x = this.y = this.z = 0;
};

/**
 * Vector addition
 * @method vadd
 * @param {Vec3} v
 * @param {Vec3} target Optional.
 * @return {Vec3}
 */
Vec3.prototype.vadd = function(v,target){
    if(target){
        target.x = v.x + this.x;
        target.y = v.y + this.y;
        target.z = v.z + this.z;
    } else {
        return new Vec3(this.x + v.x,
                               this.y + v.y,
                               this.z + v.z);
    }
};

/**
 * Vector subtraction
 * @method vsub
 * @param {Vec3} v
 * @param {Vec3} target Optional. Target to save in.
 * @return {Vec3}
 */
Vec3.prototype.vsub = function(v,target){
    if(target){
        target.x = this.x - v.x;
        target.y = this.y - v.y;
        target.z = this.z - v.z;
    } else {
        return new Vec3(this.x-v.x,
                               this.y-v.y,
                               this.z-v.z);
    }
};

/**
 * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
 * @method crossmat
 * @see http://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf
 * @return {Mat3}
 */
Vec3.prototype.crossmat = function(){
    return new Mat3([     0,  -this.z,   this.y,
                            this.z,        0,  -this.x,
                           -this.y,   this.x,        0]);
};

/**
 * Normalize the vector. Note that this changes the values in the vector.
 * @method normalize
 * @return {Number} Returns the norm of the vector
 */
Vec3.prototype.normalize = function(){
    var x=this.x, y=this.y, z=this.z;
    var n = Math.sqrt(x*x + y*y + z*z);
    if(n>0.0){
        var invN = 1/n;
        this.x *= invN;
        this.y *= invN;
        this.z *= invN;
    } else {
        // Make something up
        this.x = 0;
        this.y = 0;
        this.z = 0;
    }
    return n;
};

/**
 * Get the version of this vector that is of length 1.
 * @method unit
 * @param {Vec3} target Optional target to save in
 * @return {Vec3} Returns the unit vector
 */
Vec3.prototype.unit = function(target){
    target = target || new Vec3();
    var x=this.x, y=this.y, z=this.z;
    var ninv = Math.sqrt(x*x + y*y + z*z);
    if(ninv>0.0){
        ninv = 1.0/ninv;
        target.x = x * ninv;
        target.y = y * ninv;
        target.z = z * ninv;
    } else {
        target.x = 1;
        target.y = 0;
        target.z = 0;
    }
    return target;
};

/**
 * Get the length of the vector
 * @method norm
 * @return {Number}
 * @deprecated Use .length() instead
 */
Vec3.prototype.norm = function(){
    var x=this.x, y=this.y, z=this.z;
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Get the length of the vector
 * @method length
 * @return {Number}
 */
Vec3.prototype.length = Vec3.prototype.norm;

/**
 * Get the squared length of the vector
 * @method norm2
 * @return {Number}
 * @deprecated Use .lengthSquared() instead.
 */
Vec3.prototype.norm2 = function(){
    return this.dot(this);
};

/**
 * Get the squared length of the vector.
 * @method lengthSquared
 * @return {Number}
 */
Vec3.prototype.lengthSquared = Vec3.prototype.norm2;

/**
 * Get distance from this point to another point
 * @method distanceTo
 * @param  {Vec3} p
 * @return {Number}
 */
Vec3.prototype.distanceTo = function(p){
    var x=this.x, y=this.y, z=this.z;
    var px=p.x, py=p.y, pz=p.z;
    return Math.sqrt((px-x)*(px-x)+
                     (py-y)*(py-y)+
                     (pz-z)*(pz-z));
};

/**
 * Get squared distance from this point to another point
 * @method distanceSquared
 * @param  {Vec3} p
 * @return {Number}
 */
Vec3.prototype.distanceSquared = function(p){
    var x=this.x, y=this.y, z=this.z;
    var px=p.x, py=p.y, pz=p.z;
    return (px-x)*(px-x) + (py-y)*(py-y) + (pz-z)*(pz-z);
};

/**
 * Multiply all the components of the vector with a scalar.
 * @deprecated Use .scale instead
 * @method mult
 * @param {Number} scalar
 * @param {Vec3} target The vector to save the result in.
 * @return {Vec3}
 * @deprecated Use .scale() instead
 */
Vec3.prototype.mult = function(scalar,target){
    target = target || new Vec3();
    var x = this.x,
        y = this.y,
        z = this.z;
    target.x = scalar * x;
    target.y = scalar * y;
    target.z = scalar * z;
    return target;
};

/**
 * Multiply the vector with a scalar.
 * @method scale
 * @param {Number} scalar
 * @param {Vec3} target
 * @return {Vec3}
 */
Vec3.prototype.scale = Vec3.prototype.mult;

/**
 * Calculate dot product
 * @method dot
 * @param {Vec3} v
 * @return {Number}
 */
Vec3.prototype.dot = function(v){
    return this.x * v.x + this.y * v.y + this.z * v.z;
};

/**
 * @method isZero
 * @return bool
 */
Vec3.prototype.isZero = function(){
    return this.x===0 && this.y===0 && this.z===0;
};

/**
 * Make the vector point in the opposite direction.
 * @method negate
 * @param {Vec3} target Optional target to save in
 * @return {Vec3}
 */
Vec3.prototype.negate = function(target){
    target = target || new Vec3();
    target.x = -this.x;
    target.y = -this.y;
    target.z = -this.z;
    return target;
};

/**
 * Compute two artificial tangents to the vector
 * @method tangents
 * @param {Vec3} t1 Vector object to save the first tangent in
 * @param {Vec3} t2 Vector object to save the second tangent in
 */
var Vec3_tangents_n = new Vec3();
var Vec3_tangents_randVec = new Vec3();
Vec3.prototype.tangents = function(t1,t2){
    var norm = this.norm();
    if(norm>0.0){
        var n = Vec3_tangents_n;
        var inorm = 1/norm;
        n.set(this.x*inorm,this.y*inorm,this.z*inorm);
        var randVec = Vec3_tangents_randVec;
        if(Math.abs(n.x) < 0.9){
            randVec.set(1,0,0);
            n.cross(randVec,t1);
        } else {
            randVec.set(0,1,0);
            n.cross(randVec,t1);
        }
        n.cross(t1,t2);
    } else {
        // The normal length is zero, make something up
        t1.set(1, 0, 0);
        t2.set(0, 1, 0);
    }
};

/**
 * Converts to a more readable format
 * @method toString
 * @return string
 */
Vec3.prototype.toString = function(){
    return this.x+","+this.y+","+this.z;
};

/**
 * Converts to an array
 * @method toArray
 * @return Array
 */
Vec3.prototype.toArray = function(){
    return [this.x, this.y, this.z];
};

/**
 * Copies value of source to this vector.
 * @method copy
 * @param {Vec3} source
 * @return {Vec3} this
 */
Vec3.prototype.copy = function(source){
    this.x = source.x;
    this.y = source.y;
    this.z = source.z;
    return this;
};


/**
 * Do a linear interpolation between two vectors
 * @method lerp
 * @param {Vec3} v
 * @param {Number} t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
 * @param {Vec3} target
 */
Vec3.prototype.lerp = function(v,t,target){
    var x=this.x, y=this.y, z=this.z;
    target.x = x + (v.x-x)*t;
    target.y = y + (v.y-y)*t;
    target.z = z + (v.z-z)*t;
};

/**
 * Check if a vector equals is almost equal to another one.
 * @method almostEquals
 * @param {Vec3} v
 * @param {Number} precision
 * @return bool
 */
Vec3.prototype.almostEquals = function(v,precision){
    if(precision===undefined){
        precision = 1e-6;
    }
    if( Math.abs(this.x-v.x)>precision ||
        Math.abs(this.y-v.y)>precision ||
        Math.abs(this.z-v.z)>precision){
        return false;
    }
    return true;
};

/**
 * Check if a vector is almost zero
 * @method almostZero
 * @param {Number} precision
 */
Vec3.prototype.almostZero = function(precision){
    if(precision===undefined){
        precision = 1e-6;
    }
    if( Math.abs(this.x)>precision ||
        Math.abs(this.y)>precision ||
        Math.abs(this.z)>precision){
        return false;
    }
    return true;
};

var antip_neg = new Vec3();

/**
 * Check if the vector is anti-parallel to another vector.
 * @method isAntiparallelTo
 * @param  {Vec3}  v
 * @param  {Number}  precision Set to zero for exact comparisons
 * @return {Boolean}
 */
Vec3.prototype.isAntiparallelTo = function(v,precision){
    this.negate(antip_neg);
    return antip_neg.almostEquals(v,precision);
};

/**
 * Clone the vector
 * @method clone
 * @return {Vec3}
 */
Vec3.prototype.clone = function(){
    return new Vec3(this.x, this.y, this.z);
};
},{"./Mat3":27}],31:[function(_dereq_,module,exports){
module.exports = Body;

var EventTarget = _dereq_('../utils/EventTarget');
var Shape = _dereq_('../shapes/Shape');
var Vec3 = _dereq_('../math/Vec3');
var Mat3 = _dereq_('../math/Mat3');
var Quaternion = _dereq_('../math/Quaternion');
var Material = _dereq_('../material/Material');
var AABB = _dereq_('../collision/AABB');
var Box = _dereq_('../shapes/Box');

/**
 * Base class for all body types.
 * @class Body
 * @constructor
 * @extends EventTarget
 * @param {object} [options]
 * @param {Vec3} [options.position]
 * @param {Vec3} [options.velocity]
 * @param {Vec3} [options.angularVelocity]
 * @param {Quaternion} [options.quaternion]
 * @param {number} [options.mass]
 * @param {Material} [options.material]
 * @param {number} [options.type]
 * @param {number} [options.linearDamping=0.01]
 * @param {number} [options.angularDamping=0.01]
 * @param {boolean} [options.allowSleep=true]
 * @param {number} [options.sleepSpeedLimit=0.1]
 * @param {number} [options.sleepTimeLimit=1]
 * @param {number} [options.collisionFilterGroup=1]
 * @param {number} [options.collisionFilterMask=1]
 * @param {boolean} [options.fixedRotation=false]
 * @param {Body} [options.shape]
 * @example
 *     var body = new Body({
 *         mass: 1
 *     });
 *     var shape = new Sphere(1);
 *     body.addShape(shape);
 *     world.add(body);
 */
function Body(options){
    options = options || {};

    EventTarget.apply(this);

    this.id = Body.idCounter++;

    /**
     * Reference to the world the body is living in
     * @property world
     * @type {World}
     */
    this.world = null;

    /**
     * Callback function that is used BEFORE stepping the system. Use it to apply forces, for example. Inside the function, "this" will refer to this Body object.
     * @property preStep
     * @type {Function}
     * @deprecated Use World events instead
     */
    this.preStep = null;

    /**
     * Callback function that is used AFTER stepping the system. Inside the function, "this" will refer to this Body object.
     * @property postStep
     * @type {Function}
     * @deprecated Use World events instead
     */
    this.postStep = null;

    this.vlambda = new Vec3();

    /**
     * @property {Number} collisionFilterGroup
     */
    this.collisionFilterGroup = typeof(options.collisionFilterGroup) === 'number' ? options.collisionFilterGroup : 1;

    /**
     * @property {Number} collisionFilterMask
     */
    this.collisionFilterMask = typeof(options.collisionFilterMask) === 'number' ? options.collisionFilterMask : 1;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
     * @property {Number} collisionResponse
     */
	this.collisionResponse = true;

    /**
     * @property position
     * @type {Vec3}
     */
    this.position = new Vec3();

    if(options.position){
        this.position.copy(options.position);
    }

    /**
     * @property {Vec3} previousPosition
     */
    this.previousPosition = new Vec3();

    /**
     * Initial position of the body
     * @property initPosition
     * @type {Vec3}
     */
    this.initPosition = new Vec3();

    /**
     * @property velocity
     * @type {Vec3}
     */
    this.velocity = new Vec3();

    if(options.velocity){
        this.velocity.copy(options.velocity);
    }

    /**
     * @property initVelocity
     * @type {Vec3}
     */
    this.initVelocity = new Vec3();

    /**
     * Linear force on the body
     * @property force
     * @type {Vec3}
     */
    this.force = new Vec3();

    var mass = typeof(options.mass) === 'number' ? options.mass : 0;

    /**
     * @property mass
     * @type {Number}
     * @default 0
     */
    this.mass = mass;

    /**
     * @property invMass
     * @type {Number}
     */
    this.invMass = mass > 0 ? 1.0 / mass : 0;

    /**
     * @property material
     * @type {Material}
     */
    this.material = options.material || null;

    /**
     * @property linearDamping
     * @type {Number}
     */
    this.linearDamping = typeof(options.linearDamping) === 'number' ? options.linearDamping : 0.01;

    /**
     * One of: Body.DYNAMIC, Body.STATIC and Body.KINEMATIC.
     * @property type
     * @type {Number}
     */
    this.type = (mass <= 0.0 ? Body.STATIC : Body.DYNAMIC);
    if(typeof(options.type) === typeof(Body.STATIC)){
        this.type = options.type;
    }

    /**
     * If true, the body will automatically fall to sleep.
     * @property allowSleep
     * @type {Boolean}
     * @default true
     */
    this.allowSleep = typeof(options.allowSleep) !== 'undefined' ? options.allowSleep : true;

    /**
     * Current sleep state.
     * @property sleepState
     * @type {Number}
     */
    this.sleepState = 0;

    /**
     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
     * @property sleepSpeedLimit
     * @type {Number}
     * @default 0.1
     */
    this.sleepSpeedLimit = typeof(options.sleepSpeedLimit) !== 'undefined' ? options.sleepSpeedLimit : 0.1;

    /**
     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
     * @property sleepTimeLimit
     * @type {Number}
     * @default 1
     */
    this.sleepTimeLimit = typeof(options.sleepTimeLimit) !== 'undefined' ? options.sleepTimeLimit : 1;

    this.timeLastSleepy = 0;

    this._wakeUpAfterNarrowphase = false;


    /**
     * Rotational force on the body, around center of mass
     * @property {Vec3} torque
     */
    this.torque = new Vec3();

    /**
     * Orientation of the body
     * @property quaternion
     * @type {Quaternion}
     */
    this.quaternion = new Quaternion();

    if(options.quaternion){
        this.quaternion.copy(options.quaternion);
    }

    /**
     * @property initQuaternion
     * @type {Quaternion}
     */
    this.initQuaternion = new Quaternion();

    /**
     * @property angularVelocity
     * @type {Vec3}
     */
    this.angularVelocity = new Vec3();

    if(options.angularVelocity){
        this.angularVelocity.copy(options.angularVelocity);
    }

    /**
     * @property initAngularVelocity
     * @type {Vec3}
     */
    this.initAngularVelocity = new Vec3();

    this.interpolatedPosition = new Vec3();
    this.interpolatedQuaternion = new Quaternion();

    /**
     * @property shapes
     * @type {array}
     */
    this.shapes = [];

    /**
     * @property shapeOffsets
     * @type {array}
     */
    this.shapeOffsets = [];

    /**
     * @property shapeOrientations
     * @type {array}
     */
    this.shapeOrientations = [];

    /**
     * @property inertia
     * @type {Vec3}
     */
    this.inertia = new Vec3();

    /**
     * @property {Vec3} invInertia
     */
    this.invInertia = new Vec3();

    /**
     * @property {Mat3} invInertiaWorld
     */
    this.invInertiaWorld = new Mat3();

    this.invMassSolve = 0;

    /**
     * @property {Vec3} invInertiaSolve
     */
    this.invInertiaSolve = new Vec3();

    /**
     * @property {Mat3} invInertiaWorldSolve
     */
    this.invInertiaWorldSolve = new Mat3();

    /**
     * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() after changing this.
     * @property {Boolean} fixedRotation
     * @default false
     */
    this.fixedRotation = typeof(options.fixedRotation) !== "undefined" ? options.fixedRotation : false;

    /**
     * @property {Number} angularDamping
     */
    this.angularDamping = typeof(options.angularDamping) !== 'undefined' ? options.angularDamping : 0.01;

    /**
     * @property aabb
     * @type {AABB}
     */
    this.aabb = new AABB();

    /**
     * Indicates if the AABB needs to be updated before use.
     * @property aabbNeedsUpdate
     * @type {Boolean}
     */
    this.aabbNeedsUpdate = true;

    this.wlambda = new Vec3();

    if(options.shape){
        this.addShape(options.shape);
    }

    this.updateMassProperties();
}
Body.prototype = new EventTarget();
Body.prototype.constructor = Body;

/**
 * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
 * @static
 * @property DYNAMIC
 * @type {Number}
 */
Body.DYNAMIC = 1;

/**
 * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
 * @static
 * @property STATIC
 * @type {Number}
 */
Body.STATIC = 2;

/**
 * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
 * @static
 * @property KINEMATIC
 * @type {Number}
 */
Body.KINEMATIC = 4;



/**
 * @static
 * @property AWAKE
 * @type {number}
 */
Body.AWAKE = 0;

/**
 * @static
 * @property SLEEPY
 * @type {number}
 */
Body.SLEEPY = 1;

/**
 * @static
 * @property SLEEPING
 * @type {number}
 */
Body.SLEEPING = 2;

Body.idCounter = 0;

/**
 * Wake the body up.
 * @method wakeUp
 */
Body.prototype.wakeUp = function(){
    var s = this.sleepState;
    this.sleepState = 0;
    if(s === Body.SLEEPING){
        this.dispatchEvent({type:"wakeup"});
    }
};

/**
 * Force body sleep
 * @method sleep
 */
Body.prototype.sleep = function(){
    this.sleepState = Body.SLEEPING;
    this.velocity.set(0,0,0);
    this.angularVelocity.set(0,0,0);
};

Body.sleepyEvent = {
    type: "sleepy"
};

Body.sleepEvent = {
    type: "sleep"
};

/**
 * Called every timestep to update internal sleep timer and change sleep state if needed.
 * @method sleepTick
 * @param {Number} time The world time in seconds
 */
Body.prototype.sleepTick = function(time){
    if(this.allowSleep){
        var sleepState = this.sleepState;
        var speedSquared = this.velocity.norm2() + this.angularVelocity.norm2();
        var speedLimitSquared = Math.pow(this.sleepSpeedLimit,2);
        if(sleepState===Body.AWAKE && speedSquared < speedLimitSquared){
            this.sleepState = Body.SLEEPY; // Sleepy
            this.timeLastSleepy = time;
            this.dispatchEvent(Body.sleepyEvent);
        } else if(sleepState===Body.SLEEPY && speedSquared > speedLimitSquared){
            this.wakeUp(); // Wake up
        } else if(sleepState===Body.SLEEPY && (time - this.timeLastSleepy ) > this.sleepTimeLimit){
            this.sleep(); // Sleeping
            this.dispatchEvent(Body.sleepEvent);
        }
    }
};

/**
 * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
 * @method updateSolveMassProperties
 */
Body.prototype.updateSolveMassProperties = function(){
    if(this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC){
        this.invMassSolve = 0;
        this.invInertiaSolve.setZero();
        this.invInertiaWorldSolve.setZero();
    } else {
        this.invMassSolve = this.invMass;
        this.invInertiaSolve.copy(this.invInertia);
        this.invInertiaWorldSolve.copy(this.invInertiaWorld);
    }
};

/**
 * Convert a world point to local body frame.
 * @method pointToLocalFrame
 * @param  {Vec3} worldPoint
 * @param  {Vec3} result
 * @return {Vec3}
 */
Body.prototype.pointToLocalFrame = function(worldPoint,result){
    var result = result || new Vec3();
    worldPoint.vsub(this.position,result);
    this.quaternion.conjugate().vmult(result,result);
    return result;
};

/**
 * Convert a world vector to local body frame.
 * @method vectorToLocalFrame
 * @param  {Vec3} worldPoint
 * @param  {Vec3} result
 * @return {Vec3}
 */
Body.prototype.vectorToLocalFrame = function(worldVector, result){
    var result = result || new Vec3();
    this.quaternion.conjugate().vmult(worldVector,result);
    return result;
};

/**
 * Convert a local body point to world frame.
 * @method pointToWorldFrame
 * @param  {Vec3} localPoint
 * @param  {Vec3} result
 * @return {Vec3}
 */
Body.prototype.pointToWorldFrame = function(localPoint,result){
    var result = result || new Vec3();
    this.quaternion.vmult(localPoint,result);
    result.vadd(this.position,result);
    return result;
};

/**
 * Convert a local body point to world frame.
 * @method vectorToWorldFrame
 * @param  {Vec3} localVector
 * @param  {Vec3} result
 * @return {Vec3}
 */
Body.prototype.vectorToWorldFrame = function(localVector, result){
    var result = result || new Vec3();
    this.quaternion.vmult(localVector, result);
    return result;
};

var tmpVec = new Vec3();
var tmpQuat = new Quaternion();

/**
 * Add a shape to the body with a local offset and orientation.
 * @method addShape
 * @param {Shape} shape
 * @param {Vec3} offset
 * @param {Quaternion} quaternion
 * @return {Body} The body object, for chainability.
 */
Body.prototype.addShape = function(shape, _offset, _orientation){
    var offset = new Vec3();
    var orientation = new Quaternion();

    if(_offset){
        offset.copy(_offset);
    }
    if(_orientation){
        orientation.copy(_orientation);
    }

    this.shapes.push(shape);
    this.shapeOffsets.push(offset);
    this.shapeOrientations.push(orientation);
    this.updateMassProperties();
    this.updateBoundingRadius();

    this.aabbNeedsUpdate = true;

    return this;
};

/**
 * Update the bounding radius of the body. Should be done if any of the shapes are changed.
 * @method updateBoundingRadius
 */
Body.prototype.updateBoundingRadius = function(){
    var shapes = this.shapes,
        shapeOffsets = this.shapeOffsets,
        N = shapes.length,
        radius = 0;

    for(var i=0; i!==N; i++){
        var shape = shapes[i];
        shape.updateBoundingSphereRadius();
        var offset = shapeOffsets[i].norm(),
            r = shape.boundingSphereRadius;
        if(offset + r > radius){
            radius = offset + r;
        }
    }

    this.boundingRadius = radius;
};

var computeAABB_shapeAABB = new AABB();

/**
 * Updates the .aabb
 * @method computeAABB
 * @todo rename to updateAABB()
 */
Body.prototype.computeAABB = function(){
    var this$1 = this;

    var shapes = this.shapes,
        shapeOffsets = this.shapeOffsets,
        shapeOrientations = this.shapeOrientations,
        N = shapes.length,
        offset = tmpVec,
        orientation = tmpQuat,
        bodyQuat = this.quaternion,
        aabb = this.aabb,
        shapeAABB = computeAABB_shapeAABB;

    for(var i=0; i!==N; i++){
        var shape = shapes[i];

        // Get shape world quaternion
        shapeOrientations[i].mult(bodyQuat, orientation);

        // Get shape world position
        orientation.vmult(shapeOffsets[i], offset);
        offset.vadd(this$1.position, offset);

        // vec2.rotate(offset, shapeOffsets[i], bodyAngle);
        // vec2.add(offset, offset, this.position);

        // Get shape AABB
        shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);

        if(i === 0){
            aabb.copy(shapeAABB);
        } else {
            aabb.extend(shapeAABB);
        }
    }

    this.aabbNeedsUpdate = false;
};

var uiw_m1 = new Mat3(),
    uiw_m2 = new Mat3(),
    uiw_m3 = new Mat3();

/**
 * Update .inertiaWorld and .invInertiaWorld
 * @method updateInertiaWorld
 */
Body.prototype.updateInertiaWorld = function(force){
    var I = this.invInertia;
    if (I.x === I.y && I.y === I.z && !force) {
        // If inertia M = s*I, where I is identity and s a scalar, then
        //    R*M*R' = R*(s*I)*R' = s*R*I*R' = s*R*R' = s*I = M
        // where R is the rotation matrix.
        // In other words, we don't have to transform the inertia if all
        // inertia diagonal entries are equal.
    } else {
        var m1 = uiw_m1,
            m2 = uiw_m2;
        m1.setRotationFromQuaternion(this.quaternion);
        m1.transpose(m2);
        m1.scale(I,m1);
        m1.mmult(m2,this.invInertiaWorld);
        //m3.getTrace(this.invInertiaWorld);
    }

    /*
    this.quaternion.vmult(this.inertia,this.inertiaWorld);
    this.quaternion.vmult(this.invInertia,this.invInertiaWorld);
    */
};

/**
 * Apply force to a world point. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.torque.
 * @method applyForce
 * @param  {Vec3} force The amount of force to add.
 * @param  {Vec3} worldPoint A world point to apply the force on.
 */
var Body_applyForce_r = new Vec3();
var Body_applyForce_rotForce = new Vec3();
Body.prototype.applyForce = function(force,worldPoint){
    if(this.type !== Body.DYNAMIC){
        return;
    }

    // Compute point position relative to the body center
    var r = Body_applyForce_r;
    worldPoint.vsub(this.position,r);

    // Compute produced rotational force
    var rotForce = Body_applyForce_rotForce;
    r.cross(force,rotForce);

    // Add linear force
    this.force.vadd(force,this.force);

    // Add rotational force
    this.torque.vadd(rotForce,this.torque);
};

/**
 * Apply force to a local point in the body.
 * @method applyLocalForce
 * @param  {Vec3} force The force vector to apply, defined locally in the body frame.
 * @param  {Vec3} localPoint A local point in the body to apply the force on.
 */
var Body_applyLocalForce_worldForce = new Vec3();
var Body_applyLocalForce_worldPoint = new Vec3();
Body.prototype.applyLocalForce = function(localForce, localPoint){
    if(this.type !== Body.DYNAMIC){
        return;
    }

    var worldForce = Body_applyLocalForce_worldForce;
    var worldPoint = Body_applyLocalForce_worldPoint;

    // Transform the force vector to world space
    this.vectorToWorldFrame(localForce, worldForce);
    this.pointToWorldFrame(localPoint, worldPoint);

    this.applyForce(worldForce, worldPoint);
};

/**
 * Apply impulse to a world point. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
 * @method applyImpulse
 * @param  {Vec3} impulse The amount of impulse to add.
 * @param  {Vec3} worldPoint A world point to apply the force on.
 */
var Body_applyImpulse_r = new Vec3();
var Body_applyImpulse_velo = new Vec3();
var Body_applyImpulse_rotVelo = new Vec3();
Body.prototype.applyImpulse = function(impulse, worldPoint){
    if(this.type !== Body.DYNAMIC){
        return;
    }

    // Compute point position relative to the body center
    var r = Body_applyImpulse_r;
    worldPoint.vsub(this.position,r);

    // Compute produced central impulse velocity
    var velo = Body_applyImpulse_velo;
    velo.copy(impulse);
    velo.mult(this.invMass,velo);

    // Add linear impulse
    this.velocity.vadd(velo, this.velocity);

    // Compute produced rotational impulse velocity
    var rotVelo = Body_applyImpulse_rotVelo;
    r.cross(impulse,rotVelo);

    /*
    rotVelo.x *= this.invInertia.x;
    rotVelo.y *= this.invInertia.y;
    rotVelo.z *= this.invInertia.z;
    */
    this.invInertiaWorld.vmult(rotVelo,rotVelo);

    // Add rotational Impulse
    this.angularVelocity.vadd(rotVelo, this.angularVelocity);
};

/**
 * Apply locally-defined impulse to a local point in the body.
 * @method applyLocalImpulse
 * @param  {Vec3} force The force vector to apply, defined locally in the body frame.
 * @param  {Vec3} localPoint A local point in the body to apply the force on.
 */
var Body_applyLocalImpulse_worldImpulse = new Vec3();
var Body_applyLocalImpulse_worldPoint = new Vec3();
Body.prototype.applyLocalImpulse = function(localImpulse, localPoint){
    if(this.type !== Body.DYNAMIC){
        return;
    }

    var worldImpulse = Body_applyLocalImpulse_worldImpulse;
    var worldPoint = Body_applyLocalImpulse_worldPoint;

    // Transform the force vector to world space
    this.vectorToWorldFrame(localImpulse, worldImpulse);
    this.pointToWorldFrame(localPoint, worldPoint);

    this.applyImpulse(worldImpulse, worldPoint);
};

var Body_updateMassProperties_halfExtents = new Vec3();

/**
 * Should be called whenever you change the body shape or mass.
 * @method updateMassProperties
 */
Body.prototype.updateMassProperties = function(){
    var halfExtents = Body_updateMassProperties_halfExtents;

    this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;
    var I = this.inertia;
    var fixed = this.fixedRotation;

    // Approximate with AABB box
    this.computeAABB();
    halfExtents.set(
        (this.aabb.upperBound.x-this.aabb.lowerBound.x) / 2,
        (this.aabb.upperBound.y-this.aabb.lowerBound.y) / 2,
        (this.aabb.upperBound.z-this.aabb.lowerBound.z) / 2
    );
    Box.calculateInertia(halfExtents, this.mass, I);

    this.invInertia.set(
        I.x > 0 && !fixed ? 1.0 / I.x : 0,
        I.y > 0 && !fixed ? 1.0 / I.y : 0,
        I.z > 0 && !fixed ? 1.0 / I.z : 0
    );
    this.updateInertiaWorld(true);
};

/**
 * Get world velocity of a point in the body.
 * @method getVelocityAtWorldPoint
 * @param  {Vec3} worldPoint
 * @param  {Vec3} result
 * @return {Vec3} The result vector.
 */
Body.prototype.getVelocityAtWorldPoint = function(worldPoint, result){
    var r = new Vec3();
    worldPoint.vsub(this.position, r);
    this.angularVelocity.cross(r, result);
    this.velocity.vadd(result, result);
    return result;
};

},{"../collision/AABB":3,"../material/Material":25,"../math/Mat3":27,"../math/Quaternion":28,"../math/Vec3":30,"../shapes/Box":37,"../shapes/Shape":43,"../utils/EventTarget":49}],32:[function(_dereq_,module,exports){
var Body = _dereq_('./Body');
var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var RaycastResult = _dereq_('../collision/RaycastResult');
var Ray = _dereq_('../collision/Ray');
var WheelInfo = _dereq_('../objects/WheelInfo');

module.exports = RaycastVehicle;

/**
 * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.
 * @class RaycastVehicle
 * @constructor
 * @param {object} [options]
 * @param {Body} [options.chassisBody] The car chassis body.
 * @param {integer} [options.indexRightAxis] Axis to use for right. x=0, y=1, z=2
 * @param {integer} [options.indexLeftAxis]
 * @param {integer} [options.indexUpAxis]
 */
function RaycastVehicle(options){

    /**
     * @property {Body} chassisBody
     */
    this.chassisBody = options.chassisBody;

    /**
     * An array of WheelInfo objects.
     * @property {array} wheelInfos
     */
    this.wheelInfos = [];

    /**
     * Will be set to true if the car is sliding.
     * @property {boolean} sliding
     */
    this.sliding = false;

    /**
     * @property {World} world
     */
    this.world = null;

    /**
     * Index of the right axis, 0=x, 1=y, 2=z
     * @property {integer} indexRightAxis
     * @default 1
     */
    this.indexRightAxis = typeof(options.indexRightAxis) !== 'undefined' ? options.indexRightAxis : 1;

    /**
     * Index of the forward axis, 0=x, 1=y, 2=z
     * @property {integer} indexForwardAxis
     * @default 0
     */
    this.indexForwardAxis = typeof(options.indexForwardAxis) !== 'undefined' ? options.indexForwardAxis : 0;

    /**
     * Index of the up axis, 0=x, 1=y, 2=z
     * @property {integer} indexUpAxis
     * @default 2
     */
    this.indexUpAxis = typeof(options.indexUpAxis) !== 'undefined' ? options.indexUpAxis : 2;
}

var tmpVec1 = new Vec3();
var tmpVec2 = new Vec3();
var tmpVec3 = new Vec3();
var tmpVec4 = new Vec3();
var tmpVec5 = new Vec3();
var tmpVec6 = new Vec3();
var tmpRay = new Ray();

/**
 * Add a wheel. For information about the options, see WheelInfo.
 * @method addWheel
 * @param {object} [options]
 */
RaycastVehicle.prototype.addWheel = function(options){
    options = options || {};

    var info = new WheelInfo(options);
    var index = this.wheelInfos.length;
    this.wheelInfos.push(info);

    return index;
};

/**
 * Set the steering value of a wheel.
 * @method setSteeringValue
 * @param {number} value
 * @param {integer} wheelIndex
 */
RaycastVehicle.prototype.setSteeringValue = function(value, wheelIndex){
    var wheel = this.wheelInfos[wheelIndex];
    wheel.steering = value;
};

var torque = new Vec3();

/**
 * Set the wheel force to apply on one of the wheels each time step
 * @method applyEngineForce
 * @param  {number} value
 * @param  {integer} wheelIndex
 */
RaycastVehicle.prototype.applyEngineForce = function(value, wheelIndex){
    this.wheelInfos[wheelIndex].engineForce = value;
};

/**
 * Set the braking force of a wheel
 * @method setBrake
 * @param {number} brake
 * @param {integer} wheelIndex
 */
RaycastVehicle.prototype.setBrake = function(brake, wheelIndex){
    this.wheelInfos[wheelIndex].brake = brake;
};

/**
 * Add the vehicle including its constraints to the world.
 * @method addToWorld
 * @param {World} world
 */
RaycastVehicle.prototype.addToWorld = function(world){
    var constraints = this.constraints;
    world.add(this.chassisBody);
    var that = this;
    this.preStepCallback = function(){
        that.updateVehicle(world.dt);
    };
    world.addEventListener('preStep', this.preStepCallback);
    this.world = world;
};

/**
 * Get one of the wheel axles, world-oriented.
 * @private
 * @method getVehicleAxisWorld
 * @param  {integer} axisIndex
 * @param  {Vec3} result
 */
RaycastVehicle.prototype.getVehicleAxisWorld = function(axisIndex, result){
    result.set(
        axisIndex === 0 ? 1 : 0,
        axisIndex === 1 ? 1 : 0,
        axisIndex === 2 ? 1 : 0
    );
    this.chassisBody.vectorToWorldFrame(result, result);
};

RaycastVehicle.prototype.updateVehicle = function(timeStep){
    var this$1 = this;

    var wheelInfos = this.wheelInfos;
    var numWheels = wheelInfos.length;
    var chassisBody = this.chassisBody;

    for (var i = 0; i < numWheels; i++) {
        this$1.updateWheelTransform(i);
    }

    this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.norm();

    var forwardWorld = new Vec3();
    this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);

    if (forwardWorld.dot(chassisBody.velocity) < 0){
        this.currentVehicleSpeedKmHour *= -1;
    }

    // simulate suspension
    for (var i = 0; i < numWheels; i++) {
        this$1.castRay(wheelInfos[i]);
    }

    this.updateSuspension(timeStep);

    var impulse = new Vec3();
    var relpos = new Vec3();
    for (var i = 0; i < numWheels; i++) {
        //apply suspension force
        var wheel = wheelInfos[i];
        var suspensionForce = wheel.suspensionForce;
        if (suspensionForce > wheel.maxSuspensionForce) {
            suspensionForce = wheel.maxSuspensionForce;
        }
        wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse);

        wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos);
        chassisBody.applyImpulse(impulse, wheel.raycastResult.hitPointWorld/*relpos*/);
    }

    this.updateFriction(timeStep);

    var hitNormalWorldScaledWithProj = new Vec3();
    var fwd  = new Vec3();
    var vel = new Vec3();
    for (i = 0; i < numWheels; i++) {
        var wheel = wheelInfos[i];
        //var relpos = new Vec3();
        //wheel.chassisConnectionPointWorld.vsub(chassisBody.position, relpos);
        chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel);

        // Hack to get the rotation in the correct direction
        var m = 1;
        switch(this$1.indexUpAxis){
        case 1:
            m = -1;
            break;
        }

        if (wheel.isInContact) {

            this$1.getVehicleAxisWorld(this$1.indexForwardAxis, fwd);
            var proj = fwd.dot(wheel.raycastResult.hitNormalWorld);
            wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj);

            fwd.vsub(hitNormalWorldScaledWithProj, fwd);

            var proj2 = fwd.dot(vel);
            wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;
        }

        if((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed){
            // Apply custom rotation when accelerating and sliding
            wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;
        }

        // Lock wheels
        if(Math.abs(wheel.brake) > Math.abs(wheel.engineForce)){
            wheel.deltaRotation = 0;
        }

        wheel.rotation += wheel.deltaRotation; // Use the old value
        wheel.deltaRotation *= 0.99; // damping of rotation when not in contact
    }
};

RaycastVehicle.prototype.updateSuspension = function(deltaTime) {
    var chassisBody = this.chassisBody;
    var chassisMass = chassisBody.mass;
    var wheelInfos = this.wheelInfos;
    var numWheels = wheelInfos.length;

    for (var w_it = 0; w_it < numWheels; w_it++){
        var wheel = wheelInfos[w_it];

        if (wheel.isInContact){
            var force;

            // Spring
            var susp_length = wheel.suspensionRestLength;
            var current_length = wheel.suspensionLength;
            var length_diff = (susp_length - current_length);

            force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension;

            // Damper
            var projected_rel_vel = wheel.suspensionRelativeVelocity;
            var susp_damping;
            if (projected_rel_vel < 0) {
                susp_damping = wheel.dampingCompression;
            } else {
                susp_damping = wheel.dampingRelaxation;
            }
            force -= susp_damping * projected_rel_vel;

            wheel.suspensionForce = force * chassisMass;
            if (wheel.suspensionForce < 0) {
                wheel.suspensionForce = 0;
            }
        } else {
            wheel.suspensionForce = 0;
        }
    }
};

/**
 * Remove the vehicle including its constraints from the world.
 * @method removeFromWorld
 * @param {World} world
 */
RaycastVehicle.prototype.removeFromWorld = function(world){
    var constraints = this.constraints;
    world.remove(this.chassisBody);
    world.removeEventListener('preStep', this.preStepCallback);
    this.world = null;
};

var castRay_rayvector = new Vec3();
var castRay_target = new Vec3();
RaycastVehicle.prototype.castRay = function(wheel) {
    var rayvector = castRay_rayvector;
    var target = castRay_target;

    this.updateWheelTransformWorld(wheel);
    var chassisBody = this.chassisBody;

    var depth = -1;

    var raylen = wheel.suspensionRestLength + wheel.radius;

    wheel.directionWorld.scale(raylen, rayvector);
    var source = wheel.chassisConnectionPointWorld;
    source.vadd(rayvector, target);
    var raycastResult = wheel.raycastResult;

    raycastResult.reset();
    // Turn off ray collision with the chassis temporarily
    var oldState = chassisBody.collisionResponse;
    chassisBody.collisionResponse = false;

    // Cast ray against world
    this.world.rayTest(source, target, raycastResult);
    chassisBody.collisionResponse = oldState;

    var object = raycastResult.body;

    wheel.raycastResult.groundObject = 0;

    if (object) {
        depth = raycastResult.distance;
        wheel.raycastResult.hitNormalWorld  = raycastResult.hitNormalWorld;
        wheel.isInContact = true;

        var hitDistance = raycastResult.distance;
        wheel.suspensionLength = hitDistance - wheel.radius;

        // clamp on max suspension travel
        var minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel;
        var maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;
        if (wheel.suspensionLength < minSuspensionLength) {
            wheel.suspensionLength = minSuspensionLength;
        }
        if (wheel.suspensionLength > maxSuspensionLength) {
            wheel.suspensionLength = maxSuspensionLength;
            wheel.raycastResult.reset();
        }

        var denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld);

        var chassis_velocity_at_contactPoint = new Vec3();
        chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);

        var projVel = wheel.raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint );

        if (denominator >= -0.1) {
            wheel.suspensionRelativeVelocity = 0;
            wheel.clippedInvContactDotSuspension = 1 / 0.1;
        } else {
            var inv = -1 / denominator;
            wheel.suspensionRelativeVelocity = projVel * inv;
            wheel.clippedInvContactDotSuspension = inv;
        }

    } else {

        //put wheel info as in rest position
        wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;
        wheel.suspensionRelativeVelocity = 0.0;
        wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld);
        wheel.clippedInvContactDotSuspension = 1.0;
    }

    return depth;
};

RaycastVehicle.prototype.updateWheelTransformWorld = function(wheel){
    wheel.isInContact = false;
    var chassisBody = this.chassisBody;
    chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld);
    chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld);
    chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);
};


/**
 * Update one of the wheel transform.
 * Note when rendering wheels: during each step, wheel transforms are updated BEFORE the chassis; ie. their position becomes invalid after the step. Thus when you render wheels, you must update wheel transforms before rendering them. See raycastVehicle demo for an example.
 * @method updateWheelTransform
 * @param {integer} wheelIndex The wheel index to update.
 */
RaycastVehicle.prototype.updateWheelTransform = function(wheelIndex){
    var up = tmpVec4;
    var right = tmpVec5;
    var fwd = tmpVec6;

    var wheel = this.wheelInfos[wheelIndex];
    this.updateWheelTransformWorld(wheel);

    wheel.directionLocal.scale(-1, up);
    right.copy(wheel.axleLocal);
    up.cross(right, fwd);
    fwd.normalize();
    right.normalize();

    // Rotate around steering over the wheelAxle
    var steering = wheel.steering;
    var steeringOrn = new Quaternion();
    steeringOrn.setFromAxisAngle(up, steering);

    var rotatingOrn = new Quaternion();
    rotatingOrn.setFromAxisAngle(right, wheel.rotation);

    // World rotation of the wheel
    var q = wheel.worldTransform.quaternion;
    this.chassisBody.quaternion.mult(steeringOrn, q);
    q.mult(rotatingOrn, q);

    q.normalize();

    // world position of the wheel
    var p = wheel.worldTransform.position;
    p.copy(wheel.directionWorld);
    p.scale(wheel.suspensionLength, p);
    p.vadd(wheel.chassisConnectionPointWorld, p);
};

var directions = [
    new Vec3(1, 0, 0),
    new Vec3(0, 1, 0),
    new Vec3(0, 0, 1)
];

/**
 * Get the world transform of one of the wheels
 * @method getWheelTransformWorld
 * @param  {integer} wheelIndex
 * @return {Transform}
 */
RaycastVehicle.prototype.getWheelTransformWorld = function(wheelIndex) {
    return this.wheelInfos[wheelIndex].worldTransform;
};


var updateFriction_surfNormalWS_scaled_proj = new Vec3();
var updateFriction_axle = [];
var updateFriction_forwardWS = [];
var sideFrictionStiffness2 = 1;
RaycastVehicle.prototype.updateFriction = function(timeStep) {
    var this$1 = this;

    var surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj;

    //calculate the impulse, so that the wheels don't move sidewards
    var wheelInfos = this.wheelInfos;
    var numWheels = wheelInfos.length;
    var chassisBody = this.chassisBody;
    var forwardWS = updateFriction_forwardWS;
    var axle = updateFriction_axle;

    for (var i = 0; i < numWheels; i++) {
        var wheel = wheelInfos[i];

        var groundObject = wheel.raycastResult.body;
        wheel.sideImpulse = 0;
        wheel.forwardImpulse = 0;
        if(!forwardWS[i]){
            forwardWS[i] = new Vec3();
        }
        if(!axle[i]){
            axle[i] = new Vec3();
        }
    }

    for (var i = 0; i < numWheels; i++){
        var wheel = wheelInfos[i];

        var groundObject = wheel.raycastResult.body;

        if (groundObject) {
            var axlei = axle[i];
            var wheelTrans = this$1.getWheelTransformWorld(i);

            // Get world axle
            wheelTrans.vectorToWorldFrame(directions[this$1.indexRightAxis], axlei);

            var surfNormalWS = wheel.raycastResult.hitNormalWorld;
            var proj = axlei.dot(surfNormalWS);
            surfNormalWS.scale(proj, surfNormalWS_scaled_proj);
            axlei.vsub(surfNormalWS_scaled_proj, axlei);
            axlei.normalize();

            surfNormalWS.cross(axlei, forwardWS[i]);
            forwardWS[i].normalize();

            wheel.sideImpulse = resolveSingleBilateral(
                chassisBody,
                wheel.raycastResult.hitPointWorld,
                groundObject,
                wheel.raycastResult.hitPointWorld,
                axlei
            );

            wheel.sideImpulse *= sideFrictionStiffness2;
        }
    }

    var sideFactor = 1;
    var fwdFactor = 0.5;

    this.sliding = false;
    for (var i = 0; i < numWheels; i++) {
        var wheel = wheelInfos[i];
        var groundObject = wheel.raycastResult.body;

        var rollingFriction = 0;

        wheel.slipInfo = 1;
        if (groundObject) {
            var defaultRollingFrictionImpulse = 0;
            var maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse;

            // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);
            // rollingFriction = calcRollingFriction(contactPt);
            rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);

            rollingFriction += wheel.engineForce * timeStep;

            // rollingFriction = 0;
            var factor = maxImpulse / rollingFriction;
            wheel.slipInfo *= factor;
        }

        //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)

        wheel.forwardImpulse = 0;
        wheel.skidInfo = 1;

        if (groundObject) {
            wheel.skidInfo = 1;

            var maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;
            var maximpSide = maximp;

            var maximpSquared = maximp * maximpSide;

            wheel.forwardImpulse = rollingFriction;//wheelInfo.engineForce* timeStep;

            var x = wheel.forwardImpulse * fwdFactor;
            var y = wheel.sideImpulse * sideFactor;

            var impulseSquared = x * x + y * y;

            wheel.sliding = false;
            if (impulseSquared > maximpSquared) {
                this$1.sliding = true;
                wheel.sliding = true;

                var factor = maximp / Math.sqrt(impulseSquared);

                wheel.skidInfo *= factor;
            }
        }
    }

    if (this.sliding) {
        for (var i = 0; i < numWheels; i++) {
            var wheel = wheelInfos[i];
            if (wheel.sideImpulse !== 0) {
                if (wheel.skidInfo < 1){
                    wheel.forwardImpulse *= wheel.skidInfo;
                    wheel.sideImpulse *= wheel.skidInfo;
                }
            }
        }
    }

    // apply the impulses
    for (var i = 0; i < numWheels; i++) {
        var wheel = wheelInfos[i];

        var rel_pos = new Vec3();
        //wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, rel_pos);
        // cannons applyimpulse is using world coord for the position
        rel_pos.copy(wheel.raycastResult.hitPointWorld);

        if (wheel.forwardImpulse !== 0) {
            var impulse = new Vec3();
            forwardWS[i].scale(wheel.forwardImpulse, impulse);
            chassisBody.applyImpulse(impulse, rel_pos);
        }

        if (wheel.sideImpulse !== 0){
            var groundObject = wheel.raycastResult.body;

            var rel_pos2 = new Vec3();
            //wheel.raycastResult.hitPointWorld.vsub(groundObject.position, rel_pos2);
            rel_pos2.copy(wheel.raycastResult.hitPointWorld);
            var sideImp = new Vec3();
            axle[i].scale(wheel.sideImpulse, sideImp);

            // Scale the relative position in the up direction with rollInfluence.
            // If rollInfluence is 1, the impulse will be applied on the hitPoint (easy to roll over), if it is zero it will be applied in the same plane as the center of mass (not easy to roll over).
            chassisBody.pointToLocalFrame(rel_pos, rel_pos);
            rel_pos['xyz'[this$1.indexUpAxis]] *= wheel.rollInfluence;
            chassisBody.pointToWorldFrame(rel_pos, rel_pos);
            chassisBody.applyImpulse(sideImp, rel_pos);

            //apply friction impulse on the ground
            sideImp.scale(-1, sideImp);
            groundObject.applyImpulse(sideImp, rel_pos2);
        }
    }
};

var calcRollingFriction_vel1 = new Vec3();
var calcRollingFriction_vel2 = new Vec3();
var calcRollingFriction_vel = new Vec3();

function calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {
    var j1 = 0;
    var contactPosWorld = frictionPosWorld;

    // var rel_pos1 = new Vec3();
    // var rel_pos2 = new Vec3();
    var vel1 = calcRollingFriction_vel1;
    var vel2 = calcRollingFriction_vel2;
    var vel = calcRollingFriction_vel;
    // contactPosWorld.vsub(body0.position, rel_pos1);
    // contactPosWorld.vsub(body1.position, rel_pos2);

    body0.getVelocityAtWorldPoint(contactPosWorld, vel1);
    body1.getVelocityAtWorldPoint(contactPosWorld, vel2);
    vel1.vsub(vel2, vel);

    var vrel = frictionDirectionWorld.dot(vel);

    var denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);
    var denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);
    var relaxation = 1;
    var jacDiagABInv = relaxation / (denom0 + denom1);

    // calculate j that moves us to zero relative velocity
    j1 = -vrel * jacDiagABInv;

    if (maxImpulse < j1) {
        j1 = maxImpulse;
    }
    if (j1 < -maxImpulse) {
        j1 = -maxImpulse;
    }

    return j1;
}

var computeImpulseDenominator_r0 = new Vec3();
var computeImpulseDenominator_c0 = new Vec3();
var computeImpulseDenominator_vec = new Vec3();
var computeImpulseDenominator_m = new Vec3();
function computeImpulseDenominator(body, pos, normal) {
    var r0 = computeImpulseDenominator_r0;
    var c0 = computeImpulseDenominator_c0;
    var vec = computeImpulseDenominator_vec;
    var m = computeImpulseDenominator_m;

    pos.vsub(body.position, r0);
    r0.cross(normal, c0);
    body.invInertiaWorld.vmult(c0, m);
    m.cross(r0, vec);

    return body.invMass + normal.dot(vec);
}


var resolveSingleBilateral_vel1 = new Vec3();
var resolveSingleBilateral_vel2 = new Vec3();
var resolveSingleBilateral_vel = new Vec3();

//bilateral constraint between two dynamic objects
function resolveSingleBilateral(body1, pos1, body2, pos2, normal, impulse){
    var normalLenSqr = normal.norm2();
    if (normalLenSqr > 1.1){
        return 0; // no impulse
    }
    // var rel_pos1 = new Vec3();
    // var rel_pos2 = new Vec3();
    // pos1.vsub(body1.position, rel_pos1);
    // pos2.vsub(body2.position, rel_pos2);

    var vel1 = resolveSingleBilateral_vel1;
    var vel2 = resolveSingleBilateral_vel2;
    var vel = resolveSingleBilateral_vel;
    body1.getVelocityAtWorldPoint(pos1, vel1);
    body2.getVelocityAtWorldPoint(pos2, vel2);

    vel1.vsub(vel2, vel);

    var rel_vel = normal.dot(vel);

    var contactDamping = 0.2;
    var massTerm = 1 / (body1.invMass + body2.invMass);
    var impulse = - contactDamping * rel_vel * massTerm;

    return impulse;
}
},{"../collision/Ray":9,"../collision/RaycastResult":10,"../math/Quaternion":28,"../math/Vec3":30,"../objects/WheelInfo":36,"./Body":31}],33:[function(_dereq_,module,exports){
var Body = _dereq_('./Body');
var Sphere = _dereq_('../shapes/Sphere');
var Box = _dereq_('../shapes/Box');
var Vec3 = _dereq_('../math/Vec3');
var HingeConstraint = _dereq_('../constraints/HingeConstraint');

module.exports = RigidVehicle;

/**
 * Simple vehicle helper class with spherical rigid body wheels.
 * @class RigidVehicle
 * @constructor
 * @param {Body} [options.chassisBody]
 */
function RigidVehicle(options){
    this.wheelBodies = [];

    /**
     * @property coordinateSystem
     * @type {Vec3}
     */
    this.coordinateSystem = typeof(options.coordinateSystem)==='undefined' ? new Vec3(1, 2, 3) : options.coordinateSystem.clone();

    /**
     * @property {Body} chassisBody
     */
    this.chassisBody = options.chassisBody;

    if(!this.chassisBody){
        // No chassis body given. Create it!
        var chassisShape = new Box(new Vec3(5, 2, 0.5));
        this.chassisBody = new Body(1, chassisShape);
    }

    /**
     * @property constraints
     * @type {Array}
     */
    this.constraints = [];

    this.wheelAxes = [];
    this.wheelForces = [];
}

/**
 * Add a wheel
 * @method addWheel
 * @param {object} options
 * @param {boolean} [options.isFrontWheel]
 * @param {Vec3} [options.position] Position of the wheel, locally in the chassis body.
 * @param {Vec3} [options.direction] Slide direction of the wheel along the suspension.
 * @param {Vec3} [options.axis] Axis of rotation of the wheel, locally defined in the chassis.
 * @param {Body} [options.body] The wheel body.
 */
RigidVehicle.prototype.addWheel = function(options){
    options = options || {};
    var wheelBody = options.body;
    if(!wheelBody){
        wheelBody =  new Body(1, new Sphere(1.2));
    }
    this.wheelBodies.push(wheelBody);
    this.wheelForces.push(0);

    // Position constrain wheels
    var zero = new Vec3();
    var position = typeof(options.position) !== 'undefined' ? options.position.clone() : new Vec3();

    // Set position locally to the chassis
    var worldPosition = new Vec3();
    this.chassisBody.pointToWorldFrame(position, worldPosition);
    wheelBody.position.set(worldPosition.x, worldPosition.y, worldPosition.z);

    // Constrain wheel
    var axis = typeof(options.axis) !== 'undefined' ? options.axis.clone() : new Vec3(0, 1, 0);
    this.wheelAxes.push(axis);

    var hingeConstraint = new HingeConstraint(this.chassisBody, wheelBody, {
        pivotA: position,
        axisA: axis,
        pivotB: Vec3.ZERO,
        axisB: axis,
        collideConnected: false
    });
    this.constraints.push(hingeConstraint);

    return this.wheelBodies.length - 1;
};

/**
 * Set the steering value of a wheel.
 * @method setSteeringValue
 * @param {number} value
 * @param {integer} wheelIndex
 * @todo check coordinateSystem
 */
RigidVehicle.prototype.setSteeringValue = function(value, wheelIndex){
    // Set angle of the hinge axis
    var axis = this.wheelAxes[wheelIndex];

    var c = Math.cos(value),
        s = Math.sin(value),
        x = axis.x,
        y = axis.y;
    this.constraints[wheelIndex].axisA.set(
        c*x -s*y,
        s*x +c*y,
        0
    );
};

/**
 * Set the target rotational speed of the hinge constraint.
 * @method setMotorSpeed
 * @param {number} value
 * @param {integer} wheelIndex
 */
RigidVehicle.prototype.setMotorSpeed = function(value, wheelIndex){
    var hingeConstraint = this.constraints[wheelIndex];
    hingeConstraint.enableMotor();
    hingeConstraint.motorTargetVelocity = value;
};

/**
 * Set the target rotational speed of the hinge constraint.
 * @method disableMotor
 * @param {number} value
 * @param {integer} wheelIndex
 */
RigidVehicle.prototype.disableMotor = function(wheelIndex){
    var hingeConstraint = this.constraints[wheelIndex];
    hingeConstraint.disableMotor();
};

var torque = new Vec3();

/**
 * Set the wheel force to apply on one of the wheels each time step
 * @method setWheelForce
 * @param  {number} value
 * @param  {integer} wheelIndex
 */
RigidVehicle.prototype.setWheelForce = function(value, wheelIndex){
    this.wheelForces[wheelIndex] = value;
};

/**
 * Apply a torque on one of the wheels.
 * @method applyWheelForce
 * @param  {number} value
 * @param  {integer} wheelIndex
 */
RigidVehicle.prototype.applyWheelForce = function(value, wheelIndex){
    var axis = this.wheelAxes[wheelIndex];
    var wheelBody = this.wheelBodies[wheelIndex];
    var bodyTorque = wheelBody.torque;

    axis.scale(value, torque);
    wheelBody.vectorToWorldFrame(torque, torque);
    bodyTorque.vadd(torque, bodyTorque);
};

/**
 * Add the vehicle including its constraints to the world.
 * @method addToWorld
 * @param {World} world
 */
RigidVehicle.prototype.addToWorld = function(world){
    var constraints = this.constraints;
    var bodies = this.wheelBodies.concat([this.chassisBody]);

    for (var i = 0; i < bodies.length; i++) {
        world.add(bodies[i]);
    }

    for (var i = 0; i < constraints.length; i++) {
        world.addConstraint(constraints[i]);
    }

    world.addEventListener('preStep', this._update.bind(this));
};

RigidVehicle.prototype._update = function(){
    var this$1 = this;

    var wheelForces = this.wheelForces;
    for (var i = 0; i < wheelForces.length; i++) {
        this$1.applyWheelForce(wheelForces[i], i);
    }
};

/**
 * Remove the vehicle including its constraints from the world.
 * @method removeFromWorld
 * @param {World} world
 */
RigidVehicle.prototype.removeFromWorld = function(world){
    var constraints = this.constraints;
    var bodies = this.wheelBodies.concat([this.chassisBody]);

    for (var i = 0; i < bodies.length; i++) {
        world.remove(bodies[i]);
    }

    for (var i = 0; i < constraints.length; i++) {
        world.removeConstraint(constraints[i]);
    }
};

var worldAxis = new Vec3();

/**
 * Get current rotational velocity of a wheel
 * @method getWheelSpeed
 * @param {integer} wheelIndex
 */
RigidVehicle.prototype.getWheelSpeed = function(wheelIndex){
    var axis = this.wheelAxes[wheelIndex];
    var wheelBody = this.wheelBodies[wheelIndex];
    var w = wheelBody.angularVelocity;
    this.chassisBody.vectorToWorldFrame(axis, worldAxis);
    return w.dot(worldAxis);
};

},{"../constraints/HingeConstraint":15,"../math/Vec3":30,"../shapes/Box":37,"../shapes/Sphere":44,"./Body":31}],34:[function(_dereq_,module,exports){
module.exports = SPHSystem;

var Shape = _dereq_('../shapes/Shape');
var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var Particle = _dereq_('../shapes/Particle');
var Body = _dereq_('../objects/Body');
var Material = _dereq_('../material/Material');

/**
 * Smoothed-particle hydrodynamics system
 * @class SPHSystem
 * @constructor
 */
function SPHSystem(){
    this.particles = [];
	
    /**
     * Density of the system (kg/m3).
     * @property {number} density
     */
    this.density = 1;
	
    /**
     * Distance below which two particles are considered to be neighbors.
     * It should be adjusted so there are about 15-20 neighbor particles within this radius.
     * @property {number} smoothingRadius
     */
    this.smoothingRadius = 1;
    this.speedOfSound = 1;
	
    /**
     * Viscosity of the system.
     * @property {number} viscosity
     */
    this.viscosity = 0.01;
    this.eps = 0.000001;

    // Stuff Computed per particle
    this.pressures = [];
    this.densities = [];
    this.neighbors = [];
}

/**
 * Add a particle to the system.
 * @method add
 * @param {Body} particle
 */
SPHSystem.prototype.add = function(particle){
    this.particles.push(particle);
    if(this.neighbors.length < this.particles.length){
        this.neighbors.push([]);
    }
};

/**
 * Remove a particle from the system.
 * @method remove
 * @param {Body} particle
 */
SPHSystem.prototype.remove = function(particle){
    var idx = this.particles.indexOf(particle);
    if(idx !== -1){
        this.particles.splice(idx,1);
        if(this.neighbors.length > this.particles.length){
            this.neighbors.pop();
        }
    }
};

/**
 * Get neighbors within smoothing volume, save in the array neighbors
 * @method getNeighbors
 * @param {Body} particle
 * @param {Array} neighbors
 */
var SPHSystem_getNeighbors_dist = new Vec3();
SPHSystem.prototype.getNeighbors = function(particle,neighbors){
    var this$1 = this;

    var N = this.particles.length,
        id = particle.id,
        R2 = this.smoothingRadius * this.smoothingRadius,
        dist = SPHSystem_getNeighbors_dist;
    for(var i=0; i!==N; i++){
        var p = this$1.particles[i];
        p.position.vsub(particle.position,dist);
        if(id!==p.id && dist.norm2() < R2){
            neighbors.push(p);
        }
    }
};

// Temp vectors for calculation
var SPHSystem_update_dist = new Vec3(),
    SPHSystem_update_a_pressure = new Vec3(),
    SPHSystem_update_a_visc = new Vec3(),
    SPHSystem_update_gradW = new Vec3(),
    SPHSystem_update_r_vec = new Vec3(),
    SPHSystem_update_u = new Vec3(); // Relative velocity
SPHSystem.prototype.update = function(){
    var this$1 = this;

    var N = this.particles.length,
        dist = SPHSystem_update_dist,
        cs = this.speedOfSound,
        eps = this.eps;

    for(var i=0; i!==N; i++){
        var p = this$1.particles[i]; // Current particle
        var neighbors = this$1.neighbors[i];

        // Get neighbors
        neighbors.length = 0;
        this$1.getNeighbors(p,neighbors);
        neighbors.push(this$1.particles[i]); // Add current too
        var numNeighbors = neighbors.length;

        // Accumulate density for the particle
        var sum = 0.0;
        for(var j=0; j!==numNeighbors; j++){

            //printf("Current particle has position %f %f %f\n",objects[id].pos.x(),objects[id].pos.y(),objects[id].pos.z());
            p.position.vsub(neighbors[j].position, dist);
            var len = dist.norm();

            var weight = this$1.w(len);
            sum += neighbors[j].mass * weight;
        }

        // Save
        this$1.densities[i] = sum;
        this$1.pressures[i] = cs * cs * (this$1.densities[i] - this$1.density);
    }

    // Add forces

    // Sum to these accelerations
    var a_pressure= SPHSystem_update_a_pressure;
    var a_visc =    SPHSystem_update_a_visc;
    var gradW =     SPHSystem_update_gradW;
    var r_vec =     SPHSystem_update_r_vec;
    var u =         SPHSystem_update_u;

    for(var i=0; i!==N; i++){

        var particle = this$1.particles[i];

        a_pressure.set(0,0,0);
        a_visc.set(0,0,0);

        // Init vars
        var Pij;
        var nabla;
        var neighbors = this$1.neighbors[i];
        var numNeighbors = neighbors.length;

        //printf("Neighbors: ");
        for(var j=0; j!==numNeighbors; j++){

            var neighbor = neighbors[j];
            //printf("%d ",nj);

            // Get r once for all..
            particle.position.vsub(neighbor.position,r_vec);
            var r = r_vec.norm();

            // Pressure contribution
            Pij = -neighbor.mass * (this$1.pressures[i] / (this$1.densities[i]*this$1.densities[i] + eps) + this$1.pressures[j] / (this$1.densities[j]*this$1.densities[j] + eps));
            this$1.gradw(r_vec, gradW);
            // Add to pressure acceleration
            gradW.mult(Pij , gradW);
            a_pressure.vadd(gradW, a_pressure);

            // Viscosity contribution
            neighbor.velocity.vsub(particle.velocity, u);
            u.mult( 1.0 / (0.0001+this$1.densities[i] * this$1.densities[j]) * this$1.viscosity * neighbor.mass , u );
            nabla = this$1.nablaw(r);
            u.mult(nabla,u);
            // Add to viscosity acceleration
            a_visc.vadd( u, a_visc );
        }

        // Calculate force
        a_visc.mult(particle.mass, a_visc);
        a_pressure.mult(particle.mass, a_pressure);

        // Add force to particles
        particle.force.vadd(a_visc, particle.force);
        particle.force.vadd(a_pressure, particle.force);
    }
};

// Calculate the weight using the W(r) weightfunction
SPHSystem.prototype.w = function(r){
    // 315
    var h = this.smoothingRadius;
    return 315.0/(64.0*Math.PI*Math.pow(h,9)) * Math.pow(h*h-r*r,3);
};

// calculate gradient of the weight function
SPHSystem.prototype.gradw = function(rVec,resultVec){
    var r = rVec.norm(),
        h = this.smoothingRadius;
    rVec.mult(945.0/(32.0*Math.PI*Math.pow(h,9)) * Math.pow((h*h-r*r),2) , resultVec);
};

// Calculate nabla(W)
SPHSystem.prototype.nablaw = function(r){
    var h = this.smoothingRadius;
    var nabla = 945.0/(32.0*Math.PI*Math.pow(h,9)) * (h*h-r*r)*(7*r*r - 3*h*h);
    return nabla;
};

},{"../material/Material":25,"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"../shapes/Particle":41,"../shapes/Shape":43}],35:[function(_dereq_,module,exports){
var Vec3 = _dereq_('../math/Vec3');

module.exports = Spring;

/**
 * A spring, connecting two bodies.
 *
 * @class Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restLength]   A number > 0. Default: 1
 * @param {number} [options.stiffness]    A number >= 0. Default: 100
 * @param {number} [options.damping]      A number >= 0. Default: 1
 * @param {Vec3}  [options.worldAnchorA] Where to hook the spring to body A, in world coordinates.
 * @param {Vec3}  [options.worldAnchorB]
 * @param {Vec3}  [options.localAnchorA] Where to hook the spring to body A, in local body coordinates.
 * @param {Vec3}  [options.localAnchorB]
 */
function Spring(bodyA,bodyB,options){
    options = options || {};

    /**
     * Rest length of the spring.
     * @property restLength
     * @type {number}
     */
    this.restLength = typeof(options.restLength) === "number" ? options.restLength : 1;

    /**
     * Stiffness of the spring.
     * @property stiffness
     * @type {number}
     */
    this.stiffness = options.stiffness || 100;

    /**
     * Damping of the spring.
     * @property damping
     * @type {number}
     */
    this.damping = options.damping || 1;

    /**
     * First connected body.
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second connected body.
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;

    /**
     * Anchor for bodyA in local bodyA coordinates.
     * @property localAnchorA
     * @type {Vec3}
     */
    this.localAnchorA = new Vec3();

    /**
     * Anchor for bodyB in local bodyB coordinates.
     * @property localAnchorB
     * @type {Vec3}
     */
    this.localAnchorB = new Vec3();

    if(options.localAnchorA){
        this.localAnchorA.copy(options.localAnchorA);
    }
    if(options.localAnchorB){
        this.localAnchorB.copy(options.localAnchorB);
    }
    if(options.worldAnchorA){
        this.setWorldAnchorA(options.worldAnchorA);
    }
    if(options.worldAnchorB){
        this.setWorldAnchorB(options.worldAnchorB);
    }
}

/**
 * Set the anchor point on body A, using world coordinates.
 * @method setWorldAnchorA
 * @param {Vec3} worldAnchorA
 */
Spring.prototype.setWorldAnchorA = function(worldAnchorA){
    this.bodyA.pointToLocalFrame(worldAnchorA,this.localAnchorA);
};

/**
 * Set the anchor point on body B, using world coordinates.
 * @method setWorldAnchorB
 * @param {Vec3} worldAnchorB
 */
Spring.prototype.setWorldAnchorB = function(worldAnchorB){
    this.bodyB.pointToLocalFrame(worldAnchorB,this.localAnchorB);
};

/**
 * Get the anchor point on body A, in world coordinates.
 * @method getWorldAnchorA
 * @param {Vec3} result The vector to store the result in.
 */
Spring.prototype.getWorldAnchorA = function(result){
    this.bodyA.pointToWorldFrame(this.localAnchorA,result);
};

/**
 * Get the anchor point on body B, in world coordinates.
 * @method getWorldAnchorB
 * @param {Vec3} result The vector to store the result in.
 */
Spring.prototype.getWorldAnchorB = function(result){
    this.bodyB.pointToWorldFrame(this.localAnchorB,result);
};

var applyForce_r =              new Vec3(),
    applyForce_r_unit =         new Vec3(),
    applyForce_u =              new Vec3(),
    applyForce_f =              new Vec3(),
    applyForce_worldAnchorA =   new Vec3(),
    applyForce_worldAnchorB =   new Vec3(),
    applyForce_ri =             new Vec3(),
    applyForce_rj =             new Vec3(),
    applyForce_ri_x_f =         new Vec3(),
    applyForce_rj_x_f =         new Vec3(),
    applyForce_tmp =            new Vec3();

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
Spring.prototype.applyForce = function(){
    var k = this.stiffness,
        d = this.damping,
        l = this.restLength,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        r = applyForce_r,
        r_unit = applyForce_r_unit,
        u = applyForce_u,
        f = applyForce_f,
        tmp = applyForce_tmp;

    var worldAnchorA = applyForce_worldAnchorA,
        worldAnchorB = applyForce_worldAnchorB,
        ri = applyForce_ri,
        rj = applyForce_rj,
        ri_x_f = applyForce_ri_x_f,
        rj_x_f = applyForce_rj_x_f;

    // Get world anchors
    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB);

    // Get offset points
    worldAnchorA.vsub(bodyA.position,ri);
    worldAnchorB.vsub(bodyB.position,rj);

    // Compute distance vector between world anchor points
    worldAnchorB.vsub(worldAnchorA,r);
    var rlen = r.norm();
    r_unit.copy(r);
    r_unit.normalize();

    // Compute relative velocity of the anchor points, u
    bodyB.velocity.vsub(bodyA.velocity,u);
    // Add rotational velocity

    bodyB.angularVelocity.cross(rj,tmp);
    u.vadd(tmp,u);
    bodyA.angularVelocity.cross(ri,tmp);
    u.vsub(tmp,u);

    // F = - k * ( x - L ) - D * ( u )
    r_unit.mult(-k*(rlen-l) - d*u.dot(r_unit), f);

    // Add forces to bodies
    bodyA.force.vsub(f,bodyA.force);
    bodyB.force.vadd(f,bodyB.force);

    // Angular force
    ri.cross(f,ri_x_f);
    rj.cross(f,rj_x_f);
    bodyA.torque.vsub(ri_x_f,bodyA.torque);
    bodyB.torque.vadd(rj_x_f,bodyB.torque);
};

},{"../math/Vec3":30}],36:[function(_dereq_,module,exports){
var Vec3 = _dereq_('../math/Vec3');
var Transform = _dereq_('../math/Transform');
var RaycastResult = _dereq_('../collision/RaycastResult');
var Utils = _dereq_('../utils/Utils');

module.exports = WheelInfo;

/**
 * @class WheelInfo
 * @constructor
 * @param {Object} [options]
 *
 * @param {Vec3} [options.chassisConnectionPointLocal]
 * @param {Vec3} [options.chassisConnectionPointWorld]
 * @param {Vec3} [options.directionLocal]
 * @param {Vec3} [options.directionWorld]
 * @param {Vec3} [options.axleLocal]
 * @param {Vec3} [options.axleWorld]
 * @param {number} [options.suspensionRestLength=1]
 * @param {number} [options.suspensionMaxLength=2]
 * @param {number} [options.radius=1]
 * @param {number} [options.suspensionStiffness=100]
 * @param {number} [options.dampingCompression=10]
 * @param {number} [options.dampingRelaxation=10]
 * @param {number} [options.frictionSlip=10000]
 * @param {number} [options.steering=0]
 * @param {number} [options.rotation=0]
 * @param {number} [options.deltaRotation=0]
 * @param {number} [options.rollInfluence=0.01]
 * @param {number} [options.maxSuspensionForce]
 * @param {boolean} [options.isFrontWheel=true]
 * @param {number} [options.clippedInvContactDotSuspension=1]
 * @param {number} [options.suspensionRelativeVelocity=0]
 * @param {number} [options.suspensionForce=0]
 * @param {number} [options.skidInfo=0]
 * @param {number} [options.suspensionLength=0]
 * @param {number} [options.maxSuspensionTravel=1]
 * @param {boolean} [options.useCustomSlidingRotationalSpeed=false]
 * @param {number} [options.customSlidingRotationalSpeed=-0.1]
 */
function WheelInfo(options){
    options = Utils.defaults(options, {
        chassisConnectionPointLocal: new Vec3(),
        chassisConnectionPointWorld: new Vec3(),
        directionLocal: new Vec3(),
        directionWorld: new Vec3(),
        axleLocal: new Vec3(),
        axleWorld: new Vec3(),
        suspensionRestLength: 1,
        suspensionMaxLength: 2,
        radius: 1,
        suspensionStiffness: 100,
        dampingCompression: 10,
        dampingRelaxation: 10,
        frictionSlip: 10000,
        steering: 0,
        rotation: 0,
        deltaRotation: 0,
        rollInfluence: 0.01,
        maxSuspensionForce: Number.MAX_VALUE,
        isFrontWheel: true,
        clippedInvContactDotSuspension: 1,
        suspensionRelativeVelocity: 0,
        suspensionForce: 0,
        skidInfo: 0,
        suspensionLength: 0,
        maxSuspensionTravel: 1,
        useCustomSlidingRotationalSpeed: false,
        customSlidingRotationalSpeed: -0.1
    });

    /**
     * Max travel distance of the suspension, in meters.
     * @property {number} maxSuspensionTravel
     */
    this.maxSuspensionTravel = options.maxSuspensionTravel;

    /**
     * Speed to apply to the wheel rotation when the wheel is sliding.
     * @property {number} customSlidingRotationalSpeed
     */
    this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed;

    /**
     * If the customSlidingRotationalSpeed should be used.
     * @property {Boolean} useCustomSlidingRotationalSpeed
     */
    this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed;

    /**
     * @property {Boolean} sliding
     */
    this.sliding = false;

    /**
     * Connection point, defined locally in the chassis body frame.
     * @property {Vec3} chassisConnectionPointLocal
     */
    this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone();

    /**
     * @property {Vec3} chassisConnectionPointWorld
     */
    this.chassisConnectionPointWorld = options.chassisConnectionPointWorld.clone();

    /**
     * @property {Vec3} directionLocal
     */
    this.directionLocal = options.directionLocal.clone();

    /**
     * @property {Vec3} directionWorld
     */
    this.directionWorld = options.directionWorld.clone();

    /**
     * @property {Vec3} axleLocal
     */
    this.axleLocal = options.axleLocal.clone();

    /**
     * @property {Vec3} axleWorld
     */
    this.axleWorld = options.axleWorld.clone();

    /**
     * @property {number} suspensionRestLength
     */
    this.suspensionRestLength = options.suspensionRestLength;

    /**
     * @property {number} suspensionMaxLength
     */
    this.suspensionMaxLength = options.suspensionMaxLength;

    /**
     * @property {number} radius
     */
    this.radius = options.radius;

    /**
     * @property {number} suspensionStiffness
     */
    this.suspensionStiffness = options.suspensionStiffness;

    /**
     * @property {number} dampingCompression
     */
    this.dampingCompression = options.dampingCompression;

    /**
     * @property {number} dampingRelaxation
     */
    this.dampingRelaxation = options.dampingRelaxation;

    /**
     * @property {number} frictionSlip
     */
    this.frictionSlip = options.frictionSlip;

    /**
     * @property {number} steering
     */
    this.steering = 0;

    /**
     * Rotation value, in radians.
     * @property {number} rotation
     */
    this.rotation = 0;

    /**
     * @property {number} deltaRotation
     */
    this.deltaRotation = 0;

    /**
     * @property {number} rollInfluence
     */
    this.rollInfluence = options.rollInfluence;

    /**
     * @property {number} maxSuspensionForce
     */
    this.maxSuspensionForce = options.maxSuspensionForce;

    /**
     * @property {number} engineForce
     */
    this.engineForce = 0;

    /**
     * @property {number} brake
     */
    this.brake = 0;

    /**
     * @property {number} isFrontWheel
     */
    this.isFrontWheel = options.isFrontWheel;

    /**
     * @property {number} clippedInvContactDotSuspension
     */
    this.clippedInvContactDotSuspension = 1;

    /**
     * @property {number} suspensionRelativeVelocity
     */
    this.suspensionRelativeVelocity = 0;

    /**
     * @property {number} suspensionForce
     */
    this.suspensionForce = 0;

    /**
     * @property {number} skidInfo
     */
    this.skidInfo = 0;

    /**
     * @property {number} suspensionLength
     */
    this.suspensionLength = 0;

    /**
     * @property {number} sideImpulse
     */
    this.sideImpulse = 0;

    /**
     * @property {number} forwardImpulse
     */
    this.forwardImpulse = 0;

    /**
     * The result from raycasting
     * @property {RaycastResult} raycastResult
     */
    this.raycastResult = new RaycastResult();

    /**
     * Wheel world transform
     * @property {Transform} worldTransform
     */
    this.worldTransform = new Transform();

    /**
     * @property {boolean} isInContact
     */
    this.isInContact = false;
}

var chassis_velocity_at_contactPoint = new Vec3();
var relpos = new Vec3();
var chassis_velocity_at_contactPoint = new Vec3();
WheelInfo.prototype.updateWheel = function(chassis){
    var raycastResult = this.raycastResult;

    if (this.isInContact){
        var project= raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);
        raycastResult.hitPointWorld.vsub(chassis.position, relpos);
        chassis.getVelocityAtWorldPoint(relpos, chassis_velocity_at_contactPoint);
        var projVel = raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint );
        if (project >= -0.1) {
            this.suspensionRelativeVelocity = 0.0;
            this.clippedInvContactDotSuspension = 1.0 / 0.1;
        } else {
            var inv = -1 / project;
            this.suspensionRelativeVelocity = projVel * inv;
            this.clippedInvContactDotSuspension = inv;
        }

    } else {
        // Not in contact : position wheel in a nice (rest length) position
        raycastResult.suspensionLength = this.suspensionRestLength;
        this.suspensionRelativeVelocity = 0.0;
        raycastResult.directionWorld.scale(-1, raycastResult.hitNormalWorld);
        this.clippedInvContactDotSuspension = 1.0;
    }
};
},{"../collision/RaycastResult":10,"../math/Transform":29,"../math/Vec3":30,"../utils/Utils":53}],37:[function(_dereq_,module,exports){
module.exports = Box;

var Shape = _dereq_('./Shape');
var Vec3 = _dereq_('../math/Vec3');
var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');

/**
 * A 3d box shape.
 * @class Box
 * @constructor
 * @param {Vec3} halfExtents
 * @author schteppe
 * @extends Shape
 */
function Box(halfExtents){
    Shape.call(this);

    this.type = Shape.types.BOX;

    /**
     * @property halfExtents
     * @type {Vec3}
     */
    this.halfExtents = halfExtents;

    /**
     * Used by the contact generator to make contacts with other convex polyhedra for example
     * @property convexPolyhedronRepresentation
     * @type {ConvexPolyhedron}
     */
    this.convexPolyhedronRepresentation = null;

    this.updateConvexPolyhedronRepresentation();
    this.updateBoundingSphereRadius();
}
Box.prototype = new Shape();
Box.prototype.constructor = Box;

/**
 * Updates the local convex polyhedron representation used for some collisions.
 * @method updateConvexPolyhedronRepresentation
 */
Box.prototype.updateConvexPolyhedronRepresentation = function(){
    var sx = this.halfExtents.x;
    var sy = this.halfExtents.y;
    var sz = this.halfExtents.z;
    var V = Vec3;

    var vertices = [
        new V(-sx,-sy,-sz),
        new V( sx,-sy,-sz),
        new V( sx, sy,-sz),
        new V(-sx, sy,-sz),
        new V(-sx,-sy, sz),
        new V( sx,-sy, sz),
        new V( sx, sy, sz),
        new V(-sx, sy, sz)
    ];

    var indices = [
        [3,2,1,0], // -z
        [4,5,6,7], // +z
        [5,4,0,1], // -y
        [2,3,7,6], // +y
        [0,4,7,3], // -x
        [1,2,6,5] ];

    var axes = [
        new V(0, 0, 1),
        new V(0, 1, 0),
        new V(1, 0, 0)
    ];

    var h = new ConvexPolyhedron(vertices, indices);
    this.convexPolyhedronRepresentation = h;
    h.material = this.material;
};

/**
 * @method calculateLocalInertia
 * @param  {Number} mass
 * @param  {Vec3} target
 * @return {Vec3}
 */
Box.prototype.calculateLocalInertia = function(mass,target){
    target = target || new Vec3();
    Box.calculateInertia(this.halfExtents, mass, target);
    return target;
};

Box.calculateInertia = function(halfExtents,mass,target){
    var e = halfExtents;
    target.x = 1.0 / 12.0 * mass * (   2*e.y*2*e.y + 2*e.z*2*e.z );
    target.y = 1.0 / 12.0 * mass * (   2*e.x*2*e.x + 2*e.z*2*e.z );
    target.z = 1.0 / 12.0 * mass * (   2*e.y*2*e.y + 2*e.x*2*e.x );
};

/**
 * Get the box 6 side normals
 * @method getSideNormals
 * @param {array}      sixTargetVectors An array of 6 vectors, to store the resulting side normals in.
 * @param {Quaternion} quat             Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
 * @return {array}
 */
Box.prototype.getSideNormals = function(sixTargetVectors,quat){
    var sides = sixTargetVectors;
    var ex = this.halfExtents;
    sides[0].set(  ex.x,     0,     0);
    sides[1].set(     0,  ex.y,     0);
    sides[2].set(     0,     0,  ex.z);
    sides[3].set( -ex.x,     0,     0);
    sides[4].set(     0, -ex.y,     0);
    sides[5].set(     0,     0, -ex.z);

    if(quat!==undefined){
        for(var i=0; i!==sides.length; i++){
            quat.vmult(sides[i],sides[i]);
        }
    }

    return sides;
};

Box.prototype.volume = function(){
    return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
};

Box.prototype.updateBoundingSphereRadius = function(){
    this.boundingSphereRadius = this.halfExtents.norm();
};

var worldCornerTempPos = new Vec3();
var worldCornerTempNeg = new Vec3();
Box.prototype.forEachWorldCorner = function(pos,quat,callback){

    var e = this.halfExtents;
    var corners = [[  e.x,  e.y,  e.z],
                   [ -e.x,  e.y,  e.z],
                   [ -e.x, -e.y,  e.z],
                   [ -e.x, -e.y, -e.z],
                   [  e.x, -e.y, -e.z],
                   [  e.x,  e.y, -e.z],
                   [ -e.x,  e.y, -e.z],
                   [  e.x, -e.y,  e.z]];
    for(var i=0; i<corners.length; i++){
        worldCornerTempPos.set(corners[i][0],corners[i][1],corners[i][2]);
        quat.vmult(worldCornerTempPos,worldCornerTempPos);
        pos.vadd(worldCornerTempPos,worldCornerTempPos);
        callback(worldCornerTempPos.x,
                 worldCornerTempPos.y,
                 worldCornerTempPos.z);
    }
};

var worldCornersTemp = [
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3()
];
Box.prototype.calculateWorldAABB = function(pos,quat,min,max){

    var e = this.halfExtents;
    worldCornersTemp[0].set(e.x, e.y, e.z);
    worldCornersTemp[1].set(-e.x,  e.y, e.z);
    worldCornersTemp[2].set(-e.x, -e.y, e.z);
    worldCornersTemp[3].set(-e.x, -e.y, -e.z);
    worldCornersTemp[4].set(e.x, -e.y, -e.z);
    worldCornersTemp[5].set(e.x,  e.y, -e.z);
    worldCornersTemp[6].set(-e.x,  e.y, -e.z);
    worldCornersTemp[7].set(e.x, -e.y,  e.z);

    var wc = worldCornersTemp[0];
    quat.vmult(wc, wc);
    pos.vadd(wc, wc);
    max.copy(wc);
    min.copy(wc);
    for(var i=1; i<8; i++){
        var wc = worldCornersTemp[i];
        quat.vmult(wc, wc);
        pos.vadd(wc, wc);
        var x = wc.x;
        var y = wc.y;
        var z = wc.z;
        if(x > max.x){
            max.x = x;
        }
        if(y > max.y){
            max.y = y;
        }
        if(z > max.z){
            max.z = z;
        }

        if(x < min.x){
            min.x = x;
        }
        if(y < min.y){
            min.y = y;
        }
        if(z < min.z){
            min.z = z;
        }
    }

    // Get each axis max
    // min.set(Infinity,Infinity,Infinity);
    // max.set(-Infinity,-Infinity,-Infinity);
    // this.forEachWorldCorner(pos,quat,function(x,y,z){
    //     if(x > max.x){
    //         max.x = x;
    //     }
    //     if(y > max.y){
    //         max.y = y;
    //     }
    //     if(z > max.z){
    //         max.z = z;
    //     }

    //     if(x < min.x){
    //         min.x = x;
    //     }
    //     if(y < min.y){
    //         min.y = y;
    //     }
    //     if(z < min.z){
    //         min.z = z;
    //     }
    // });
};

},{"../math/Vec3":30,"./ConvexPolyhedron":38,"./Shape":43}],38:[function(_dereq_,module,exports){
module.exports = ConvexPolyhedron;

var Shape = _dereq_('./Shape');
var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var Transform = _dereq_('../math/Transform');

/**
 * A set of polygons describing a convex shape.
 * @class ConvexPolyhedron
 * @constructor
 * @extends Shape
 * @description The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained
 * in the same 3D plane), instead these should be merged into one polygon.
 *
 * @param {array} points An array of Vec3's
 * @param {array} faces Array of integer arrays, describing which vertices that is included in each face.
 *
 * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
 * @author schteppe / https://github.com/schteppe
 * @see http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
 * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
 *
 * @todo Move the clipping functions to ContactGenerator?
 * @todo Automatically merge coplanar polygons in constructor.
 */
function ConvexPolyhedron(points, faces, uniqueAxes) {
    Shape.call(this);
    this.type = Shape.types.CONVEXPOLYHEDRON;

    /**
     * Array of Vec3
     * @property vertices
     * @type {Array}
     */
    this.vertices = points||[];

    this.worldVertices = []; // World transformed version of .vertices
    this.worldVerticesNeedsUpdate = true;

    /**
     * Array of integer arrays, indicating which vertices each face consists of
     * @property faces
     * @type {Array}
     */
    this.faces = faces||[];

    /**
     * Array of Vec3
     * @property faceNormals
     * @type {Array}
     */
    this.faceNormals = [];
    this.computeNormals();

    this.worldFaceNormalsNeedsUpdate = true;
    this.worldFaceNormals = []; // World transformed version of .faceNormals

    /**
     * Array of Vec3
     * @property uniqueEdges
     * @type {Array}
     */
    this.uniqueEdges = [];

    /**
     * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.
     * @property {Array} uniqueAxes
     */
    this.uniqueAxes = uniqueAxes ? uniqueAxes.slice() : null;

    this.computeEdges();
    this.updateBoundingSphereRadius();
}
ConvexPolyhedron.prototype = new Shape();
ConvexPolyhedron.prototype.constructor = ConvexPolyhedron;

var computeEdges_tmpEdge = new Vec3();
/**
 * Computes uniqueEdges
 * @method computeEdges
 */
ConvexPolyhedron.prototype.computeEdges = function(){
    var faces = this.faces;
    var vertices = this.vertices;
    var nv = vertices.length;
    var edges = this.uniqueEdges;

    edges.length = 0;

    var edge = computeEdges_tmpEdge;

    for(var i=0; i !== faces.length; i++){
        var face = faces[i];
        var numVertices = face.length;
        for(var j = 0; j !== numVertices; j++){
            var k = ( j+1 ) % numVertices;
            vertices[face[j]].vsub(vertices[face[k]], edge);
            edge.normalize();
            var found = false;
            for(var p=0; p !== edges.length; p++){
                if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)){
                    found = true;
                    break;
                }
            }

            if (!found){
                edges.push(edge.clone());
            }
        }
    }
};

/**
 * Compute the normals of the faces. Will reuse existing Vec3 objects in the .faceNormals array if they exist.
 * @method computeNormals
 */
ConvexPolyhedron.prototype.computeNormals = function(){
    var this$1 = this;

    this.faceNormals.length = this.faces.length;

    // Generate normals
    for(var i=0; i<this.faces.length; i++){

        // Check so all vertices exists for this face
        for(var j=0; j<this.faces[i].length; j++){
            if(!this$1.vertices[this$1.faces[i][j]]){
                throw new Error("Vertex "+this$1.faces[i][j]+" not found!");
            }
        }

        var n = this$1.faceNormals[i] || new Vec3();
        this$1.getFaceNormal(i,n);
        n.negate(n);
        this$1.faceNormals[i] = n;
        var vertex = this$1.vertices[this$1.faces[i][0]];
        if(n.dot(vertex) < 0){
            console.error(".faceNormals[" + i + "] = Vec3("+n.toString()+") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");
            for(var j=0; j<this.faces[i].length; j++){
                console.warn(".vertices["+this$1.faces[i][j]+"] = Vec3("+this$1.vertices[this$1.faces[i][j]].toString()+")");
            }
        }
    }
};

/**
 * Get face normal given 3 vertices
 * @static
 * @method getFaceNormal
 * @param {Vec3} va
 * @param {Vec3} vb
 * @param {Vec3} vc
 * @param {Vec3} target
 */
var cb = new Vec3();
var ab = new Vec3();
ConvexPolyhedron.computeNormal = function ( va, vb, vc, target ) {
    vb.vsub(va,ab);
    vc.vsub(vb,cb);
    cb.cross(ab,target);
    if ( !target.isZero() ) {
        target.normalize();
    }
};

/**
 * Compute the normal of a face from its vertices
 * @method getFaceNormal
 * @param  {Number} i
 * @param  {Vec3} target
 */
ConvexPolyhedron.prototype.getFaceNormal = function(i,target){
    var f = this.faces[i];
    var va = this.vertices[f[0]];
    var vb = this.vertices[f[1]];
    var vc = this.vertices[f[2]];
    return ConvexPolyhedron.computeNormal(va,vb,vc,target);
};

/**
 * @method clipAgainstHull
 * @param {Vec3} posA
 * @param {Quaternion} quatA
 * @param {ConvexPolyhedron} hullB
 * @param {Vec3} posB
 * @param {Quaternion} quatB
 * @param {Vec3} separatingNormal
 * @param {Number} minDist Clamp distance
 * @param {Number} maxDist
 * @param {array} result The an array of contact point objects, see clipFaceAgainstHull
 * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
 */
var cah_WorldNormal = new Vec3();
ConvexPolyhedron.prototype.clipAgainstHull = function(posA,quatA,hullB,posB,quatB,separatingNormal,minDist,maxDist,result){
    var WorldNormal = cah_WorldNormal;
    var closestFaceB = -1;
    var dmax = -Number.MAX_VALUE;
    for(var face=0; face < hullB.faces.length; face++){
        WorldNormal.copy(hullB.faceNormals[face]);
        quatB.vmult(WorldNormal,WorldNormal);
        //posB.vadd(WorldNormal,WorldNormal);
        var d = WorldNormal.dot(separatingNormal);
        if (d > dmax){
            dmax = d;
            closestFaceB = face;
        }
    }
    var worldVertsB1 = [];
    var polyB = hullB.faces[closestFaceB];
    var numVertices = polyB.length;
    for(var e0=0; e0<numVertices; e0++){
        var b = hullB.vertices[polyB[e0]];
        var worldb = new Vec3();
        worldb.copy(b);
        quatB.vmult(worldb,worldb);
        posB.vadd(worldb,worldb);
        worldVertsB1.push(worldb);
    }

    if (closestFaceB>=0){
        this.clipFaceAgainstHull(separatingNormal,
                                 posA,
                                 quatA,
                                 worldVertsB1,
                                 minDist,
                                 maxDist,
                                 result);
    }
};

/**
 * Find the separating axis between this hull and another
 * @method findSeparatingAxis
 * @param {ConvexPolyhedron} hullB
 * @param {Vec3} posA
 * @param {Quaternion} quatA
 * @param {Vec3} posB
 * @param {Quaternion} quatB
 * @param {Vec3} target The target vector to save the axis in
 * @return {bool} Returns false if a separation is found, else true
 */
var fsa_faceANormalWS3 = new Vec3(),
    fsa_Worldnormal1 = new Vec3(),
    fsa_deltaC = new Vec3(),
    fsa_worldEdge0 = new Vec3(),
    fsa_worldEdge1 = new Vec3(),
    fsa_Cross = new Vec3();
ConvexPolyhedron.prototype.findSeparatingAxis = function(hullB,posA,quatA,posB,quatB,target, faceListA, faceListB){
    var faceANormalWS3 = fsa_faceANormalWS3,
        Worldnormal1 = fsa_Worldnormal1,
        deltaC = fsa_deltaC,
        worldEdge0 = fsa_worldEdge0,
        worldEdge1 = fsa_worldEdge1,
        Cross = fsa_Cross;

    var dmin = Number.MAX_VALUE;
    var hullA = this;
    if(!hullA.uniqueAxes){

        var numFacesA = faceListA ? faceListA.length : hullA.faces.length;

        // Test face normals from hullA
        for(var i=0; i<numFacesA; i++){
            var fi = faceListA ? faceListA[i] : i;

            // Get world face normal
            faceANormalWS3.copy(hullA.faceNormals[fi]);
            quatA.vmult(faceANormalWS3,faceANormalWS3);

            var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
            if(d===false){
                return false;
            }

            if(d<dmin){
                dmin = d;
                target.copy(faceANormalWS3);
            }
        }

    } else {

        // Test unique axes
        for(var i = 0; i !== hullA.uniqueAxes.length; i++){

            // Get world axis
            quatA.vmult(hullA.uniqueAxes[i],faceANormalWS3);

            var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
            if(d===false){
                return false;
            }

            if(d<dmin){
                dmin = d;
                target.copy(faceANormalWS3);
            }
        }
    }

    if(!hullB.uniqueAxes){

        // Test face normals from hullB
        var numFacesB = faceListB ? faceListB.length : hullB.faces.length;
        for(var i=0;i<numFacesB;i++){

            var fi = faceListB ? faceListB[i] : i;

            Worldnormal1.copy(hullB.faceNormals[fi]);
            quatB.vmult(Worldnormal1,Worldnormal1);
            var d = hullA.testSepAxis(Worldnormal1, hullB,posA,quatA,posB,quatB);
            if(d===false){
                return false;
            }

            if(d<dmin){
                dmin = d;
                target.copy(Worldnormal1);
            }
        }
    } else {

        // Test unique axes in B
        for(var i = 0; i !== hullB.uniqueAxes.length; i++){
            quatB.vmult(hullB.uniqueAxes[i],Worldnormal1);

            var d = hullA.testSepAxis(Worldnormal1, hullB,posA,quatA,posB,quatB);
            if(d===false){
                return false;
            }

            if(d<dmin){
                dmin = d;
                target.copy(Worldnormal1);
            }
        }
    }

    // Test edges
    for(var e0=0; e0 !== hullA.uniqueEdges.length; e0++){

        // Get world edge
        quatA.vmult(hullA.uniqueEdges[e0],worldEdge0);

        for(var e1=0; e1 !== hullB.uniqueEdges.length; e1++){

            // Get world edge 2
            quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);
            worldEdge0.cross(worldEdge1,Cross);

            if(!Cross.almostZero()){
                Cross.normalize();
                var dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);
                if(dist === false){
                    return false;
                }
                if(dist < dmin){
                    dmin = dist;
                    target.copy(Cross);
                }
            }
        }
    }

    posB.vsub(posA,deltaC);
    if((deltaC.dot(target))>0.0){
        target.negate(target);
    }

    return true;
};

var maxminA=[], maxminB=[];

/**
 * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
 * @method testSepAxis
 * @param {Vec3} axis
 * @param {ConvexPolyhedron} hullB
 * @param {Vec3} posA
 * @param {Quaternion} quatA
 * @param {Vec3} posB
 * @param {Quaternion} quatB
 * @return {number} The overlap depth, or FALSE if no penetration.
 */
ConvexPolyhedron.prototype.testSepAxis = function(axis, hullB, posA, quatA, posB, quatB){
    var hullA=this;
    ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);
    ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);
    var maxA = maxminA[0];
    var minA = maxminA[1];
    var maxB = maxminB[0];
    var minB = maxminB[1];
    if(maxA<minB || maxB<minA){
        return false; // Separated
    }
    var d0 = maxA - minB;
    var d1 = maxB - minA;
    var depth = d0<d1 ? d0:d1;
    return depth;
};

var cli_aabbmin = new Vec3(),
    cli_aabbmax = new Vec3();

/**
 * @method calculateLocalInertia
 * @param  {Number} mass
 * @param  {Vec3} target
 */
ConvexPolyhedron.prototype.calculateLocalInertia = function(mass,target){
    // Approximate with box inertia
    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
    this.computeLocalAABB(cli_aabbmin,cli_aabbmax);
    var x = cli_aabbmax.x - cli_aabbmin.x,
        y = cli_aabbmax.y - cli_aabbmin.y,
        z = cli_aabbmax.z - cli_aabbmin.z;
    target.x = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*z*2*z );
    target.y = 1.0 / 12.0 * mass * ( 2*x*2*x + 2*z*2*z );
    target.z = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*x*2*x );
};

/**
 * @method getPlaneConstantOfFace
 * @param  {Number} face_i Index of the face
 * @return {Number}
 */
ConvexPolyhedron.prototype.getPlaneConstantOfFace = function(face_i){
    var f = this.faces[face_i];
    var n = this.faceNormals[face_i];
    var v = this.vertices[f[0]];
    var c = -n.dot(v);
    return c;
};

/**
 * Clip a face against a hull.
 * @method clipFaceAgainstHull
 * @param {Vec3} separatingNormal
 * @param {Vec3} posA
 * @param {Quaternion} quatA
 * @param {Array} worldVertsB1 An array of Vec3 with vertices in the world frame.
 * @param {Number} minDist Distance clamping
 * @param {Number} maxDist
 * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
 */
var cfah_faceANormalWS = new Vec3(),
    cfah_edge0 = new Vec3(),
    cfah_WorldEdge0 = new Vec3(),
    cfah_worldPlaneAnormal1 = new Vec3(),
    cfah_planeNormalWS1 = new Vec3(),
    cfah_worldA1 = new Vec3(),
    cfah_localPlaneNormal = new Vec3(),
    cfah_planeNormalWS = new Vec3();
ConvexPolyhedron.prototype.clipFaceAgainstHull = function(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist,result){
    var this$1 = this;

    var faceANormalWS = cfah_faceANormalWS,
        edge0 = cfah_edge0,
        WorldEdge0 = cfah_WorldEdge0,
        worldPlaneAnormal1 = cfah_worldPlaneAnormal1,
        planeNormalWS1 = cfah_planeNormalWS1,
        worldA1 = cfah_worldA1,
        localPlaneNormal = cfah_localPlaneNormal,
        planeNormalWS = cfah_planeNormalWS;

    var hullA = this;
    var worldVertsB2 = [];
    var pVtxIn = worldVertsB1;
    var pVtxOut = worldVertsB2;
    // Find the face with normal closest to the separating axis
    var closestFaceA = -1;
    var dmin = Number.MAX_VALUE;
    for(var face=0; face<hullA.faces.length; face++){
        faceANormalWS.copy(hullA.faceNormals[face]);
        quatA.vmult(faceANormalWS,faceANormalWS);
        //posA.vadd(faceANormalWS,faceANormalWS);
        var d = faceANormalWS.dot(separatingNormal);
        if (d < dmin){
            dmin = d;
            closestFaceA = face;
        }
    }
    if (closestFaceA < 0){
        // console.log("--- did not find any closest face... ---");
        return;
    }
    //console.log("closest A: ",closestFaceA);
    // Get the face and construct connected faces
    var polyA = hullA.faces[closestFaceA];
    polyA.connectedFaces = [];
    for(var i=0; i<hullA.faces.length; i++){
        for(var j=0; j<hullA.faces[i].length; j++){
            if(polyA.indexOf(hullA.faces[i][j])!==-1 /* Sharing a vertex*/ && i!==closestFaceA /* Not the one we are looking for connections from */ && polyA.connectedFaces.indexOf(i)===-1 /* Not already added */ ){
                polyA.connectedFaces.push(i);
            }
        }
    }
    // Clip the polygon to the back of the planes of all faces of hull A, that are adjacent to the witness face
    var numContacts = pVtxIn.length;
    var numVerticesA = polyA.length;
    for(var e0=0; e0<numVerticesA; e0++){
        var a = hullA.vertices[polyA[e0]];
        var b = hullA.vertices[polyA[(e0+1)%numVerticesA]];
        a.vsub(b,edge0);
        WorldEdge0.copy(edge0);
        quatA.vmult(WorldEdge0,WorldEdge0);
        posA.vadd(WorldEdge0,WorldEdge0);
        worldPlaneAnormal1.copy(this$1.faceNormals[closestFaceA]);//transA.getBasis()* btVector3(polyA.m_plane[0],polyA.m_plane[1],polyA.m_plane[2]);
        quatA.vmult(worldPlaneAnormal1,worldPlaneAnormal1);
        posA.vadd(worldPlaneAnormal1,worldPlaneAnormal1);
        WorldEdge0.cross(worldPlaneAnormal1,planeNormalWS1);
        planeNormalWS1.negate(planeNormalWS1);
        worldA1.copy(a);
        quatA.vmult(worldA1,worldA1);
        posA.vadd(worldA1,worldA1);
        var planeEqWS1 = -worldA1.dot(planeNormalWS1);
        var planeEqWS;
        {
            var otherFace = polyA.connectedFaces[e0];
            localPlaneNormal.copy(this$1.faceNormals[otherFace]);
            var localPlaneEq = this$1.getPlaneConstantOfFace(otherFace);

            planeNormalWS.copy(localPlaneNormal);
            quatA.vmult(planeNormalWS,planeNormalWS);
            //posA.vadd(planeNormalWS,planeNormalWS);
            var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
        }

        // Clip face against our constructed plane
        this$1.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS);

        // Throw away all clipped points, but save the reamining until next clip
        while(pVtxIn.length){
            pVtxIn.shift();
        }
        while(pVtxOut.length){
            pVtxIn.push(pVtxOut.shift());
        }
    }

    //console.log("Resulting points after clip:",pVtxIn);

    // only keep contact points that are behind the witness face
    localPlaneNormal.copy(this.faceNormals[closestFaceA]);

    var localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);
    planeNormalWS.copy(localPlaneNormal);
    quatA.vmult(planeNormalWS,planeNormalWS);

    var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
    for (var i=0; i<pVtxIn.length; i++){
        var depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; //???
        /*console.log("depth calc from normal=",planeNormalWS.toString()," and constant "+planeEqWS+" and vertex ",pVtxIn[i].toString()," gives "+depth);*/
        if (depth <=minDist){
            console.log("clamped: depth="+depth+" to minDist="+(minDist+""));
            depth = minDist;
        }

        if (depth <=maxDist){
            var point = pVtxIn[i];
            if(depth<=0){
                /*console.log("Got contact point ",point.toString(),
                  ", depth=",depth,
                  "contact normal=",separatingNormal.toString(),
                  "plane",planeNormalWS.toString(),
                  "planeConstant",planeEqWS);*/
                var p = {
                    point:point,
                    normal:planeNormalWS,
                    depth: depth,
                };
                result.push(p);
            }
        }
    }
};

/**
 * Clip a face in a hull against the back of a plane.
 * @method clipFaceAgainstPlane
 * @param {Array} inVertices
 * @param {Array} outVertices
 * @param {Vec3} planeNormal
 * @param {Number} planeConstant The constant in the mathematical plane equation
 */
ConvexPolyhedron.prototype.clipFaceAgainstPlane = function(inVertices,outVertices, planeNormal, planeConstant){
    var n_dot_first, n_dot_last;
    var numVerts = inVertices.length;

    if(numVerts < 2){
        return outVertices;
    }

    var firstVertex = inVertices[inVertices.length-1],
        lastVertex =   inVertices[0];

    n_dot_first = planeNormal.dot(firstVertex) + planeConstant;

    for(var vi = 0; vi < numVerts; vi++){
        lastVertex = inVertices[vi];
        n_dot_last = planeNormal.dot(lastVertex) + planeConstant;
        if(n_dot_first < 0){
            if(n_dot_last < 0){
                // Start < 0, end < 0, so output lastVertex
                var newv = new Vec3();
                newv.copy(lastVertex);
                outVertices.push(newv);
            } else {
                // Start < 0, end >= 0, so output intersection
                var newv = new Vec3();
                firstVertex.lerp(lastVertex,
                                 n_dot_first / (n_dot_first - n_dot_last),
                                 newv);
                outVertices.push(newv);
            }
        } else {
            if(n_dot_last<0){
                // Start >= 0, end < 0 so output intersection and end
                var newv = new Vec3();
                firstVertex.lerp(lastVertex,
                                 n_dot_first / (n_dot_first - n_dot_last),
                                 newv);
                outVertices.push(newv);
                outVertices.push(lastVertex);
            }
        }
        firstVertex = lastVertex;
        n_dot_first = n_dot_last;
    }
    return outVertices;
};

// Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
ConvexPolyhedron.prototype.computeWorldVertices = function(position,quat){
    var this$1 = this;

    var N = this.vertices.length;
    while(this.worldVertices.length < N){
        this$1.worldVertices.push( new Vec3() );
    }

    var verts = this.vertices,
        worldVerts = this.worldVertices;
    for(var i=0; i!==N; i++){
        quat.vmult( verts[i] , worldVerts[i] );
        position.vadd( worldVerts[i] , worldVerts[i] );
    }

    this.worldVerticesNeedsUpdate = false;
};

var computeLocalAABB_worldVert = new Vec3();
ConvexPolyhedron.prototype.computeLocalAABB = function(aabbmin,aabbmax){
    var n = this.vertices.length,
        vertices = this.vertices;

    aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);

    for(var i=0; i<n; i++){
        var v = vertices[i];
        if     (v.x < aabbmin.x){
            aabbmin.x = v.x;
        } else if(v.x > aabbmax.x){
            aabbmax.x = v.x;
        }
        if     (v.y < aabbmin.y){
            aabbmin.y = v.y;
        } else if(v.y > aabbmax.y){
            aabbmax.y = v.y;
        }
        if     (v.z < aabbmin.z){
            aabbmin.z = v.z;
        } else if(v.z > aabbmax.z){
            aabbmax.z = v.z;
        }
    }
};

/**
 * Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
 * @method computeWorldFaceNormals
 * @param  {Quaternion} quat
 */
ConvexPolyhedron.prototype.computeWorldFaceNormals = function(quat){
    var this$1 = this;

    var N = this.faceNormals.length;
    while(this.worldFaceNormals.length < N){
        this$1.worldFaceNormals.push( new Vec3() );
    }

    var normals = this.faceNormals,
        worldNormals = this.worldFaceNormals;
    for(var i=0; i!==N; i++){
        quat.vmult( normals[i] , worldNormals[i] );
    }

    this.worldFaceNormalsNeedsUpdate = false;
};

/**
 * @method updateBoundingSphereRadius
 */
ConvexPolyhedron.prototype.updateBoundingSphereRadius = function(){
    // Assume points are distributed with local (0,0,0) as center
    var max2 = 0;
    var verts = this.vertices;
    for(var i=0, N=verts.length; i!==N; i++) {
        var norm2 = verts[i].norm2();
        if(norm2 > max2){
            max2 = norm2;
        }
    }
    this.boundingSphereRadius = Math.sqrt(max2);
};

var tempWorldVertex = new Vec3();

/**
 * @method calculateWorldAABB
 * @param {Vec3}        pos
 * @param {Quaternion}  quat
 * @param {Vec3}        min
 * @param {Vec3}        max
 */
ConvexPolyhedron.prototype.calculateWorldAABB = function(pos,quat,min,max){
    var n = this.vertices.length, verts = this.vertices;
    var minx,miny,minz,maxx,maxy,maxz;
    for(var i=0; i<n; i++){
        tempWorldVertex.copy(verts[i]);
        quat.vmult(tempWorldVertex,tempWorldVertex);
        pos.vadd(tempWorldVertex,tempWorldVertex);
        var v = tempWorldVertex;
        if     (v.x < minx || minx===undefined){
            minx = v.x;
        } else if(v.x > maxx || maxx===undefined){
            maxx = v.x;
        }

        if     (v.y < miny || miny===undefined){
            miny = v.y;
        } else if(v.y > maxy || maxy===undefined){
            maxy = v.y;
        }

        if     (v.z < minz || minz===undefined){
            minz = v.z;
        } else if(v.z > maxz || maxz===undefined){
            maxz = v.z;
        }
    }
    min.set(minx,miny,minz);
    max.set(maxx,maxy,maxz);
};

/**
 * Get approximate convex volume
 * @method volume
 * @return {Number}
 */
ConvexPolyhedron.prototype.volume = function(){
    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
};

/**
 * Get an average of all the vertices positions
 * @method getAveragePointLocal
 * @param  {Vec3} target
 * @return {Vec3}
 */
ConvexPolyhedron.prototype.getAveragePointLocal = function(target){
    target = target || new Vec3();
    var n = this.vertices.length,
        verts = this.vertices;
    for(var i=0; i<n; i++){
        target.vadd(verts[i],target);
    }
    target.mult(1/n,target);
    return target;
};

/**
 * Transform all local points. Will change the .vertices
 * @method transformAllPoints
 * @param  {Vec3} offset
 * @param  {Quaternion} quat
 */
ConvexPolyhedron.prototype.transformAllPoints = function(offset,quat){
    var this$1 = this;

    var n = this.vertices.length,
        verts = this.vertices;

    // Apply rotation
    if(quat){
        // Rotate vertices
        for(var i=0; i<n; i++){
            var v = verts[i];
            quat.vmult(v,v);
        }
        // Rotate face normals
        for(var i=0; i<this.faceNormals.length; i++){
            var v = this$1.faceNormals[i];
            quat.vmult(v,v);
        }
        /*
        // Rotate edges
        for(var i=0; i<this.uniqueEdges.length; i++){
            var v = this.uniqueEdges[i];
            quat.vmult(v,v);
        }*/
    }

    // Apply offset
    if(offset){
        for(var i=0; i<n; i++){
            var v = verts[i];
            v.vadd(offset,v);
        }
    }
};

/**
 * Checks whether p is inside the polyhedra. Must be in local coords. The point lies outside of the convex hull of the other points if and only if the direction of all the vectors from it to those other points are on less than one half of a sphere around it.
 * @method pointIsInside
 * @param  {Vec3} p      A point given in local coordinates
 * @return {Boolean}
 */
var ConvexPolyhedron_pointIsInside = new Vec3();
var ConvexPolyhedron_vToP = new Vec3();
var ConvexPolyhedron_vToPointInside = new Vec3();
ConvexPolyhedron.prototype.pointIsInside = function(p){
    var this$1 = this;

    var n = this.vertices.length,
        verts = this.vertices,
        faces = this.faces,
        normals = this.faceNormals;
    var positiveResult = null;
    var N = this.faces.length;
    var pointInside = ConvexPolyhedron_pointIsInside;
    this.getAveragePointLocal(pointInside);
    for(var i=0; i<N; i++){
        var numVertices = this$1.faces[i].length;
        var n = normals[i];
        var v = verts[faces[i][0]]; // We only need one point in the face

        // This dot product determines which side of the edge the point is
        var vToP = ConvexPolyhedron_vToP;
        p.vsub(v,vToP);
        var r1 = n.dot(vToP);

        var vToPointInside = ConvexPolyhedron_vToPointInside;
        pointInside.vsub(v,vToPointInside);
        var r2 = n.dot(vToPointInside);

        if((r1<0 && r2>0) || (r1>0 && r2<0)){
            return false; // Encountered some other sign. Exit.
        } else {
        }
    }

    // If we got here, all dot products were of the same sign.
    return positiveResult ? 1 : -1;
};

/**
 * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis. Results are saved in the array maxmin.
 * @static
 * @method project
 * @param {ConvexPolyhedron} hull
 * @param {Vec3} axis
 * @param {Vec3} pos
 * @param {Quaternion} quat
 * @param {array} result result[0] and result[1] will be set to maximum and minimum, respectively.
 */
var project_worldVertex = new Vec3();
var project_localAxis = new Vec3();
var project_localOrigin = new Vec3();
ConvexPolyhedron.project = function(hull, axis, pos, quat, result){
    var n = hull.vertices.length,
        worldVertex = project_worldVertex,
        localAxis = project_localAxis,
        max = 0,
        min = 0,
        localOrigin = project_localOrigin,
        vs = hull.vertices;

    localOrigin.setZero();

    // Transform the axis to local
    Transform.vectorToLocalFrame(pos, quat, axis, localAxis);
    Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);
    var add = localOrigin.dot(localAxis);

    min = max = vs[0].dot(localAxis);

    for(var i = 1; i < n; i++){
        var val = vs[i].dot(localAxis);

        if(val > max){
            max = val;
        }

        if(val < min){
            min = val;
        }
    }

    min -= add;
    max -= add;

    if(min > max){
        // Inconsistent - swap
        var temp = min;
        min = max;
        max = temp;
    }
    // Output
    result[0] = max;
    result[1] = min;
};

},{"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"./Shape":43}],39:[function(_dereq_,module,exports){
module.exports = Cylinder;

var Shape = _dereq_('./Shape');
var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');

/**
 * @class Cylinder
 * @constructor
 * @extends ConvexPolyhedron
 * @author schteppe / https://github.com/schteppe
 * @param {Number} radiusTop
 * @param {Number} radiusBottom
 * @param {Number} height
 * @param {Number} numSegments The number of segments to build the cylinder out of
 */
function Cylinder( radiusTop, radiusBottom, height , numSegments ) {
    var N = numSegments,
        verts = [],
        axes = [],
        faces = [],
        bottomface = [],
        topface = [],
        cos = Math.cos,
        sin = Math.sin;

    // First bottom point
    verts.push(new Vec3(radiusBottom*cos(0),
                               radiusBottom*sin(0),
                               -height*0.5));
    bottomface.push(0);

    // First top point
    verts.push(new Vec3(radiusTop*cos(0),
                               radiusTop*sin(0),
                               height*0.5));
    topface.push(1);

    for(var i=0; i<N; i++){
        var theta = 2*Math.PI/N * (i+1);
        var thetaN = 2*Math.PI/N * (i+0.5);
        if(i<N-1){
            // Bottom
            verts.push(new Vec3(radiusBottom*cos(theta),
                                       radiusBottom*sin(theta),
                                       -height*0.5));
            bottomface.push(2*i+2);
            // Top
            verts.push(new Vec3(radiusTop*cos(theta),
                                       radiusTop*sin(theta),
                                       height*0.5));
            topface.push(2*i+3);

            // Face
            faces.push([2*i+2, 2*i+3, 2*i+1,2*i]);
        } else {
            faces.push([0,1, 2*i+1, 2*i]); // Connect
        }

        // Axis: we can cut off half of them if we have even number of segments
        if(N % 2 === 1 || i < N / 2){
            axes.push(new Vec3(cos(thetaN), sin(thetaN), 0));
        }
    }
    faces.push(topface);
    axes.push(new Vec3(0,0,1));

    // Reorder bottom face
    var temp = [];
    for(var i=0; i<bottomface.length; i++){
        temp.push(bottomface[bottomface.length - i - 1]);
    }
    faces.push(temp);

    this.type = Shape.types.CONVEXPOLYHEDRON;
    ConvexPolyhedron.call( this, verts, faces, axes );
}

Cylinder.prototype = new ConvexPolyhedron();

},{"../math/Quaternion":28,"../math/Vec3":30,"./ConvexPolyhedron":38,"./Shape":43}],40:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape');
var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');
var Vec3 = _dereq_('../math/Vec3');
var Utils = _dereq_('../utils/Utils');

module.exports = Heightfield;

/**
 * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.
 * @class Heightfield
 * @extends Shape
 * @constructor
 * @param {Array} data An array of Y values that will be used to construct the terrain.
 * @param {object} options
 * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
 * @param {Number} [options.maxValue] Maximum value.
 * @param {Number} [options.elementSize=0.1] World spacing between the data points in X direction.
 * @todo Should be possible to use along all axes, not just y
 *
 * @example
 *     // Generate some height data (y-values).
 *     var data = [];
 *     for(var i = 0; i < 1000; i++){
 *         var y = 0.5 * Math.cos(0.2 * i);
 *         data.push(y);
 *     }
 *
 *     // Create the heightfield shape
 *     var heightfieldShape = new Heightfield(data, {
 *         elementSize: 1 // Distance between the data points in X and Y directions
 *     });
 *     var heightfieldBody = new Body();
 *     heightfieldBody.addShape(heightfieldShape);
 *     world.addBody(heightfieldBody);
 */
function Heightfield(data, options){
    options = Utils.defaults(options, {
        maxValue : null,
        minValue : null,
        elementSize : 1
    });

    /**
     * An array of numbers, or height values, that are spread out along the x axis.
     * @property {array} data
     */
    this.data = data;

    /**
     * Max value of the data
     * @property {number} maxValue
     */
    this.maxValue = options.maxValue;

    /**
     * Max value of the data
     * @property {number} minValue
     */
    this.minValue = options.minValue;

    /**
     * The width of each element
     * @property {number} elementSize
     * @todo elementSizeX and Y
     */
    this.elementSize = options.elementSize;

    if(options.minValue === null){
        this.updateMinValue();
    }
    if(options.maxValue === null){
        this.updateMaxValue();
    }

    this.cacheEnabled = true;

    Shape.call(this);

    this.pillarConvex = new ConvexPolyhedron();
    this.pillarOffset = new Vec3();

    this.type = Shape.types.HEIGHTFIELD;
    this.updateBoundingSphereRadius();

    // "i_j_isUpper" => { convex: ..., offset: ... }
    // for example:
    // _cachedPillars["0_2_1"]
    this._cachedPillars = {};
}
Heightfield.prototype = new Shape();

/**
 * Call whenever you change the data array.
 * @method update
 */
Heightfield.prototype.update = function(){
    this._cachedPillars = {};
};

/**
 * Update the .minValue property
 * @method updateMinValue
 */
Heightfield.prototype.updateMinValue = function(){
    var data = this.data;
    var minValue = data[0][0];
    for(var i=0; i !== data.length; i++){
        for(var j=0; j !== data[i].length; j++){
            var v = data[i][j];
            if(v < minValue){
                minValue = v;
            }
        }
    }
    this.minValue = minValue;
};

/**
 * Update the .maxValue property
 * @method updateMaxValue
 */
Heightfield.prototype.updateMaxValue = function(){
    var data = this.data;
    var maxValue = data[0][0];
    for(var i=0; i !== data.length; i++){
        for(var j=0; j !== data[i].length; j++){
            var v = data[i][j];
            if(v > maxValue){
                maxValue = v;
            }
        }
    }
    this.maxValue = maxValue;
};

/**
 * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.
 * @method setHeightValueAtIndex
 * @param {integer} xi
 * @param {integer} yi
 * @param {number} value
 */
Heightfield.prototype.setHeightValueAtIndex = function(xi, yi, value){
    var data = this.data;
    data[xi][yi] = value;

    // Invalidate cache
    this.clearCachedConvexTrianglePillar(xi, yi, false);
    if(xi > 0){
        this.clearCachedConvexTrianglePillar(xi - 1, yi, true);
        this.clearCachedConvexTrianglePillar(xi - 1, yi, false);
    }
    if(yi > 0){
        this.clearCachedConvexTrianglePillar(xi, yi - 1, true);
        this.clearCachedConvexTrianglePillar(xi, yi - 1, false);
    }
    if(yi > 0 && xi > 0){
        this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, true);
    }
};

/**
 * Get max/min in a rectangle in the matrix data
 * @method getRectMinMax
 * @param  {integer} iMinX
 * @param  {integer} iMinY
 * @param  {integer} iMaxX
 * @param  {integer} iMaxY
 * @param  {array} [result] An array to store the results in.
 * @return {array} The result array, if it was passed in. Minimum will be at position 0 and max at 1.
 */
Heightfield.prototype.getRectMinMax = function (iMinX, iMinY, iMaxX, iMaxY, result) {
    result = result || [];

    // Get max and min of the data
    var data = this.data,
        max = this.minValue; // Set first value
    for(var i = iMinX; i <= iMaxX; i++){
        for(var j = iMinY; j <= iMaxY; j++){
            var height = data[i][j];
            if(height > max){
                max = height;
            }
        }
    }

    result[0] = this.minValue;
    result[1] = max;
};

/**
 * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.
 * @method getIndexOfPosition
 * @param  {number} x
 * @param  {number} y
 * @param  {array} result Two-element array
 * @param  {boolean} clamp If the position should be clamped to the heightfield edge.
 * @return {boolean}
 */
Heightfield.prototype.getIndexOfPosition = function (x, y, result, clamp) {

    // Get the index of the data points to test against
    var w = this.elementSize;
    var data = this.data;
    var xi = Math.floor(x / w);
    var yi = Math.floor(y / w);

    result[0] = xi;
    result[1] = yi;

    if(clamp){
        // Clamp index to edges
        if(xi < 0){ xi = 0; }
        if(yi < 0){ yi = 0; }
        if(xi >= data.length - 1){ xi = data.length - 1; }
        if(yi >= data[0].length - 1){ yi = data[0].length - 1; }
    }

    // Bail out if we are out of the terrain
    if(xi < 0 || yi < 0 || xi >= data.length-1 || yi >= data[0].length-1){
        return false;
    }

    return true;
};

Heightfield.prototype.getHeightAt = function(x, y, edgeClamp){
    var idx = [];
    this.getIndexOfPosition(x, y, idx, edgeClamp);

    // TODO: get upper or lower triangle, then use barycentric interpolation to get the height in the triangle.
    var minmax = [];
    this.getRectMinMax(idx[0], idx[1] + 1, idx[0], idx[1] + 1, minmax);

    return (minmax[0] + minmax[1]) / 2; // average
};

Heightfield.prototype.getCacheConvexTrianglePillarKey = function(xi, yi, getUpperTriangle){
    return xi + '_' + yi + '_' + (getUpperTriangle ? 1 : 0);
};

Heightfield.prototype.getCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle){
    return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
};

Heightfield.prototype.setCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle, convex, offset){
    this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)] = {
        convex: convex,
        offset: offset
    };
};

Heightfield.prototype.clearCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle){
    delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
};

/**
 * Get a triangle in the terrain in the form of a triangular convex shape.
 * @method getConvexTrianglePillar
 * @param  {integer} i
 * @param  {integer} j
 * @param  {boolean} getUpperTriangle
 */
Heightfield.prototype.getConvexTrianglePillar = function(xi, yi, getUpperTriangle){
    var result = this.pillarConvex;
    var offsetResult = this.pillarOffset;

    if(this.cacheEnabled){
        var data = this.getCachedConvexTrianglePillar(xi, yi, getUpperTriangle);
        if(data){
            this.pillarConvex = data.convex;
            this.pillarOffset = data.offset;
            return;
        }

        result = new ConvexPolyhedron();
        offsetResult = new Vec3();

        this.pillarConvex = result;
        this.pillarOffset = offsetResult;
    }

    var data = this.data;
    var elementSize = this.elementSize;
    var faces = result.faces;

    // Reuse verts if possible
    result.vertices.length = 6;
    for (var i = 0; i < 6; i++) {
        if(!result.vertices[i]){
            result.vertices[i] = new Vec3();
        }
    }

    // Reuse faces if possible
    faces.length = 5;
    for (var i = 0; i < 5; i++) {
        if(!faces[i]){
            faces[i] = [];
        }
    }

    var verts = result.vertices;

    var h = (Math.min(
        data[xi][yi],
        data[xi+1][yi],
        data[xi][yi+1],
        data[xi+1][yi+1]
    ) - this.minValue ) / 2 + this.minValue;

    if (!getUpperTriangle) {

        // Center of the triangle pillar - all polygons are given relative to this one
        offsetResult.set(
            (xi + 0.25) * elementSize, // sort of center of a triangle
            (yi + 0.25) * elementSize,
            h // vertical center
        );

        // Top triangle verts
        verts[0].set(
            -0.25 * elementSize,
            -0.25 * elementSize,
            data[xi][yi] - h
        );
        verts[1].set(
            0.75 * elementSize,
            -0.25 * elementSize,
            data[xi + 1][yi] - h
        );
        verts[2].set(
            -0.25 * elementSize,
            0.75 * elementSize,
            data[xi][yi + 1] - h
        );

        // bottom triangle verts
        verts[3].set(
            -0.25 * elementSize,
            -0.25 * elementSize,
            -h-1
        );
        verts[4].set(
            0.75 * elementSize,
            -0.25 * elementSize,
            -h-1
        );
        verts[5].set(
            -0.25 * elementSize,
            0.75  * elementSize,
            -h-1
        );

        // top triangle
        faces[0][0] = 0;
        faces[0][1] = 1;
        faces[0][2] = 2;

        // bottom triangle
        faces[1][0] = 5;
        faces[1][1] = 4;
        faces[1][2] = 3;

        // -x facing quad
        faces[2][0] = 0;
        faces[2][1] = 2;
        faces[2][2] = 5;
        faces[2][3] = 3;

        // -y facing quad
        faces[3][0] = 1;
        faces[3][1] = 0;
        faces[3][2] = 3;
        faces[3][3] = 4;

        // +xy facing quad
        faces[4][0] = 4;
        faces[4][1] = 5;
        faces[4][2] = 2;
        faces[4][3] = 1;


    } else {

        // Center of the triangle pillar - all polygons are given relative to this one
        offsetResult.set(
            (xi + 0.75) * elementSize, // sort of center of a triangle
            (yi + 0.75) * elementSize,
            h // vertical center
        );

        // Top triangle verts
        verts[0].set(
            0.25 * elementSize,
            0.25 * elementSize,
            data[xi + 1][yi + 1] - h
        );
        verts[1].set(
            -0.75 * elementSize,
            0.25 * elementSize,
            data[xi][yi + 1] - h
        );
        verts[2].set(
            0.25 * elementSize,
            -0.75 * elementSize,
            data[xi + 1][yi] - h
        );

        // bottom triangle verts
        verts[3].set(
            0.25 * elementSize,
            0.25 * elementSize,
            - h-1
        );
        verts[4].set(
            -0.75 * elementSize,
            0.25 * elementSize,
            - h-1
        );
        verts[5].set(
            0.25 * elementSize,
            -0.75 * elementSize,
            - h-1
        );

        // Top triangle
        faces[0][0] = 0;
        faces[0][1] = 1;
        faces[0][2] = 2;

        // bottom triangle
        faces[1][0] = 5;
        faces[1][1] = 4;
        faces[1][2] = 3;

        // +x facing quad
        faces[2][0] = 2;
        faces[2][1] = 5;
        faces[2][2] = 3;
        faces[2][3] = 0;

        // +y facing quad
        faces[3][0] = 3;
        faces[3][1] = 4;
        faces[3][2] = 1;
        faces[3][3] = 0;

        // -xy facing quad
        faces[4][0] = 1;
        faces[4][1] = 4;
        faces[4][2] = 5;
        faces[4][3] = 2;
    }

    result.computeNormals();
    result.computeEdges();
    result.updateBoundingSphereRadius();

    this.setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, result, offsetResult);
};

Heightfield.prototype.calculateLocalInertia = function(mass, target){
    target = target || new Vec3();
    target.set(0, 0, 0);
    return target;
};

Heightfield.prototype.volume = function(){
    return Number.MAX_VALUE; // The terrain is infinite
};

Heightfield.prototype.calculateWorldAABB = function(pos, quat, min, max){
    // TODO: do it properly
    min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
};

Heightfield.prototype.updateBoundingSphereRadius = function(){
    // Use the bounding box of the min/max values
    var data = this.data,
        s = this.elementSize;
    this.boundingSphereRadius = new Vec3(data.length * s, data[0].length * s, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm();
};

},{"../math/Vec3":30,"../utils/Utils":53,"./ConvexPolyhedron":38,"./Shape":43}],41:[function(_dereq_,module,exports){
module.exports = Particle;

var Shape = _dereq_('./Shape');
var Vec3 = _dereq_('../math/Vec3');

/**
 * Particle shape.
 * @class Particle
 * @constructor
 * @author schteppe
 * @extends Shape
 */
function Particle(){
    Shape.call(this);

    this.type = Shape.types.PARTICLE;
}
Particle.prototype = new Shape();
Particle.prototype.constructor = Particle;

/**
 * @method calculateLocalInertia
 * @param  {Number} mass
 * @param  {Vec3} target
 * @return {Vec3}
 */
Particle.prototype.calculateLocalInertia = function(mass,target){
    target = target || new Vec3();
    target.set(0, 0, 0);
    return target;
};

Particle.prototype.volume = function(){
    return 0;
};

Particle.prototype.updateBoundingSphereRadius = function(){
    this.boundingSphereRadius = 0;
};

Particle.prototype.calculateWorldAABB = function(pos,quat,min,max){
    // Get each axis max
    min.copy(pos);
    max.copy(pos);
};

},{"../math/Vec3":30,"./Shape":43}],42:[function(_dereq_,module,exports){
module.exports = Plane;

var Shape = _dereq_('./Shape');
var Vec3 = _dereq_('../math/Vec3');

/**
 * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a RigidBody and rotate that body. See the demos.
 * @class Plane
 * @constructor
 * @extends Shape
 * @author schteppe
 */
function Plane(){
    Shape.call(this);
    this.type = Shape.types.PLANE;

    // World oriented normal
    this.worldNormal = new Vec3();
    this.worldNormalNeedsUpdate = true;

    this.boundingSphereRadius = Number.MAX_VALUE;
}
Plane.prototype = new Shape();
Plane.prototype.constructor = Plane;

Plane.prototype.computeWorldNormal = function(quat){
    var n = this.worldNormal;
    n.set(0,0,1);
    quat.vmult(n,n);
    this.worldNormalNeedsUpdate = false;
};

Plane.prototype.calculateLocalInertia = function(mass,target){
    target = target || new Vec3();
    return target;
};

Plane.prototype.volume = function(){
    return Number.MAX_VALUE; // The plane is infinite...
};

var tempNormal = new Vec3();
Plane.prototype.calculateWorldAABB = function(pos, quat, min, max){
    // The plane AABB is infinite, except if the normal is pointing along any axis
    tempNormal.set(0,0,1); // Default plane normal is z
    quat.vmult(tempNormal,tempNormal);
    var maxVal = Number.MAX_VALUE;
    min.set(-maxVal, -maxVal, -maxVal);
    max.set(maxVal, maxVal, maxVal);

    if(tempNormal.x === 1){ max.x = pos.x; }
    if(tempNormal.y === 1){ max.y = pos.y; }
    if(tempNormal.z === 1){ max.z = pos.z; }

    if(tempNormal.x === -1){ min.x = pos.x; }
    if(tempNormal.y === -1){ min.y = pos.y; }
    if(tempNormal.z === -1){ min.z = pos.z; }
};

Plane.prototype.updateBoundingSphereRadius = function(){
    this.boundingSphereRadius = Number.MAX_VALUE;
};
},{"../math/Vec3":30,"./Shape":43}],43:[function(_dereq_,module,exports){
module.exports = Shape;

var Shape = _dereq_('./Shape');
var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var Material = _dereq_('../material/Material');

/**
 * Base class for shapes
 * @class Shape
 * @constructor
 * @author schteppe
 * @todo Should have a mechanism for caching bounding sphere radius instead of calculating it each time
 */
function Shape(){

    /**
     * Identifyer of the Shape.
     * @property {number} id
     */
    this.id = Shape.idCounter++;

    /**
     * The type of this shape. Must be set to an int > 0 by subclasses.
     * @property type
     * @type {Number}
     * @see Shape.types
     */
    this.type = 0;

    /**
     * The local bounding sphere radius of this shape.
     * @property {Number} boundingSphereRadius
     */
    this.boundingSphereRadius = 0;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
     * @property {boolean} collisionResponse
     */
    this.collisionResponse = true;

    /**
     * @property {Material} material
     */
    this.material = null;
}
Shape.prototype.constructor = Shape;

/**
 * Computes the bounding sphere radius. The result is stored in the property .boundingSphereRadius
 * @method updateBoundingSphereRadius
 * @return {Number}
 */
Shape.prototype.updateBoundingSphereRadius = function(){
    throw "computeBoundingSphereRadius() not implemented for shape type "+this.type;
};

/**
 * Get the volume of this shape
 * @method volume
 * @return {Number}
 */
Shape.prototype.volume = function(){
    throw "volume() not implemented for shape type "+this.type;
};

/**
 * Calculates the inertia in the local frame for this shape.
 * @method calculateLocalInertia
 * @return {Vec3}
 * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
 */
Shape.prototype.calculateLocalInertia = function(mass,target){
    throw "calculateLocalInertia() not implemented for shape type "+this.type;
};

Shape.idCounter = 0;

/**
 * The available shape types.
 * @static
 * @property types
 * @type {Object}
 */
Shape.types = {
    SPHERE:1,
    PLANE:2,
    BOX:4,
    COMPOUND:8,
    CONVEXPOLYHEDRON:16,
    HEIGHTFIELD:32,
    PARTICLE:64,
    CYLINDER:128,
    TRIMESH:256
};


},{"../material/Material":25,"../math/Quaternion":28,"../math/Vec3":30,"./Shape":43}],44:[function(_dereq_,module,exports){
module.exports = Sphere;

var Shape = _dereq_('./Shape');
var Vec3 = _dereq_('../math/Vec3');

/**
 * Spherical shape
 * @class Sphere
 * @constructor
 * @extends Shape
 * @param {Number} radius The radius of the sphere, a non-negative number.
 * @author schteppe / http://github.com/schteppe
 */
function Sphere(radius){
    Shape.call(this);

    /**
     * @property {Number} radius
     */
    this.radius = radius!==undefined ? Number(radius) : 1.0;
    this.type = Shape.types.SPHERE;

    if(this.radius < 0){
        throw new Error('The sphere radius cannot be negative.');
    }

    this.updateBoundingSphereRadius();
}
Sphere.prototype = new Shape();
Sphere.prototype.constructor = Sphere;

Sphere.prototype.calculateLocalInertia = function(mass,target){
    target = target || new Vec3();
    var I = 2.0*mass*this.radius*this.radius/5.0;
    target.x = I;
    target.y = I;
    target.z = I;
    return target;
};

Sphere.prototype.volume = function(){
    return 4.0 * Math.PI * this.radius / 3.0;
};

Sphere.prototype.updateBoundingSphereRadius = function(){
    this.boundingSphereRadius = this.radius;
};

Sphere.prototype.calculateWorldAABB = function(pos,quat,min,max){
    var r = this.radius;
    var axes = ['x','y','z'];
    for(var i=0; i<axes.length; i++){
        var ax = axes[i];
        min[ax] = pos[ax] - r;
        max[ax] = pos[ax] + r;
    }
};

},{"../math/Vec3":30,"./Shape":43}],45:[function(_dereq_,module,exports){
module.exports = Trimesh;

var Shape = _dereq_('./Shape');
var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var Transform = _dereq_('../math/Transform');
var AABB = _dereq_('../collision/AABB');
var Octree = _dereq_('../utils/Octree');

/**
 * @class Trimesh
 * @constructor
 * @param {array} vertices
 * @param {array} indices
 * @extends Shape
 * @example
 *     // How to make a mesh with a single triangle
 *     var vertices = [
 *         0, 0, 0, // vertex 0
 *         1, 0, 0, // vertex 1
 *         0, 1, 0  // vertex 2
 *     ];
 *     var indices = [
 *         0, 1, 2  // triangle 0
 *     ];
 *     var trimeshShape = new Trimesh(vertices, indices);
 */
function Trimesh(vertices, indices) {
    Shape.call(this);
    this.type = Shape.types.TRIMESH;

    /**
     * @property vertices
     * @type {Array}
     */
    this.vertices = new Float32Array(vertices);

    /**
     * Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.
     * @property indices
     * @type {Array}
     */
    this.indices = new Int16Array(indices);

    /**
     * The normals data.
     * @property normals
     * @type {Array}
     */
    this.normals = new Float32Array(indices.length);

    /**
     * The local AABB of the mesh.
     * @property aabb
     * @type {Array}
     */
    this.aabb = new AABB();

    /**
     * References to vertex pairs, making up all unique edges in the trimesh.
     * @property {array} edges
     */
    this.edges = null;

    /**
     * Local scaling of the mesh. Use .setScale() to set it.
     * @property {Vec3} scale
     */
    this.scale = new Vec3(1, 1, 1);

    /**
     * The indexed triangles. Use .updateTree() to update it.
     * @property {Octree} tree
     */
    this.tree = new Octree();

    this.updateEdges();
    this.updateNormals();
    this.updateAABB();
    this.updateBoundingSphereRadius();
    this.updateTree();
}
Trimesh.prototype = new Shape();
Trimesh.prototype.constructor = Trimesh;

var computeNormals_n = new Vec3();

/**
 * @method updateTree
 */
Trimesh.prototype.updateTree = function(){
    var this$1 = this;

    var tree = this.tree;

    tree.reset();
    tree.aabb.copy(this.aabb);
    var scale = this.scale; // The local mesh AABB is scaled, but the octree AABB should be unscaled
    tree.aabb.lowerBound.x *= 1 / scale.x;
    tree.aabb.lowerBound.y *= 1 / scale.y;
    tree.aabb.lowerBound.z *= 1 / scale.z;
    tree.aabb.upperBound.x *= 1 / scale.x;
    tree.aabb.upperBound.y *= 1 / scale.y;
    tree.aabb.upperBound.z *= 1 / scale.z;

    // Insert all triangles
    var triangleAABB = new AABB();
    var a = new Vec3();
    var b = new Vec3();
    var c = new Vec3();
    var points = [a, b, c];
    for (var i = 0; i < this.indices.length / 3; i++) {
        //this.getTriangleVertices(i, a, b, c);

        // Get unscaled triangle verts
        var i3 = i * 3;
        this$1._getUnscaledVertex(this$1.indices[i3], a);
        this$1._getUnscaledVertex(this$1.indices[i3 + 1], b);
        this$1._getUnscaledVertex(this$1.indices[i3 + 2], c);

        triangleAABB.setFromPoints(points);
        tree.insert(triangleAABB, i);
    }
    tree.removeEmptyNodes();
};

var unscaledAABB = new AABB();

/**
 * Get triangles in a local AABB from the trimesh.
 * @method getTrianglesInAABB
 * @param  {AABB} aabb
 * @param  {array} result An array of integers, referencing the queried triangles.
 */
Trimesh.prototype.getTrianglesInAABB = function(aabb, result){
    unscaledAABB.copy(aabb);

    // Scale it to local
    var scale = this.scale;
    var isx = scale.x;
    var isy = scale.y;
    var isz = scale.z;
    var l = unscaledAABB.lowerBound;
    var u = unscaledAABB.upperBound;
    l.x /= isx;
    l.y /= isy;
    l.z /= isz;
    u.x /= isx;
    u.y /= isy;
    u.z /= isz;

    return this.tree.aabbQuery(unscaledAABB, result);
};

/**
 * @method setScale
 * @param {Vec3} scale
 */
Trimesh.prototype.setScale = function(scale){
    var wasUniform = this.scale.x === this.scale.y === this.scale.z;
    var isUniform = scale.x === scale.y === scale.z;

    if(!(wasUniform && isUniform)){
        // Non-uniform scaling. Need to update normals.
        this.updateNormals();
    }
    this.scale.copy(scale);
    this.updateAABB();
    this.updateBoundingSphereRadius();
};

/**
 * Compute the normals of the faces. Will save in the .normals array.
 * @method updateNormals
 */
Trimesh.prototype.updateNormals = function(){
    var this$1 = this;

    var n = computeNormals_n;

    // Generate normals
    var normals = this.normals;
    for(var i=0; i < this.indices.length / 3; i++){
        var i3 = i * 3;

        var a = this$1.indices[i3],
            b = this$1.indices[i3 + 1],
            c = this$1.indices[i3 + 2];

        this$1.getVertex(a, va);
        this$1.getVertex(b, vb);
        this$1.getVertex(c, vc);

        Trimesh.computeNormal(vb, va, vc, n);

        normals[i3] = n.x;
        normals[i3 + 1] = n.y;
        normals[i3 + 2] = n.z;
    }
};

/**
 * Update the .edges property
 * @method updateEdges
 */
Trimesh.prototype.updateEdges = function(){
    var this$1 = this;

    var edges = {};
    var add = function(indexA, indexB){
        var key = a < b ? a + '_' + b : b + '_' + a;
        edges[key] = true;
    };
    for(var i=0; i < this.indices.length / 3; i++){
        var i3 = i * 3;
        var a = this$1.indices[i3],
            b = this$1.indices[i3 + 1],
            c = this$1.indices[i3 + 2];
        add(a,b);
        add(b,c);
        add(c,a);
    }
    var keys = Object.keys(edges);
    this.edges = new Int16Array(keys.length * 2);
    for (var i = 0; i < keys.length; i++) {
        var indices = keys[i].split('_');
        this$1.edges[2 * i] = parseInt(indices[0], 10);
        this$1.edges[2 * i + 1] = parseInt(indices[1], 10);
    }
};

/**
 * Get an edge vertex
 * @method getEdgeVertex
 * @param  {number} edgeIndex
 * @param  {number} firstOrSecond 0 or 1, depending on which one of the vertices you need.
 * @param  {Vec3} vertexStore Where to store the result
 */
Trimesh.prototype.getEdgeVertex = function(edgeIndex, firstOrSecond, vertexStore){
    var vertexIndex = this.edges[edgeIndex * 2 + (firstOrSecond ? 1 : 0)];
    this.getVertex(vertexIndex, vertexStore);
};

var getEdgeVector_va = new Vec3();
var getEdgeVector_vb = new Vec3();

/**
 * Get a vector along an edge.
 * @method getEdgeVector
 * @param  {number} edgeIndex
 * @param  {Vec3} vectorStore
 */
Trimesh.prototype.getEdgeVector = function(edgeIndex, vectorStore){
    var va = getEdgeVector_va;
    var vb = getEdgeVector_vb;
    this.getEdgeVertex(edgeIndex, 0, va);
    this.getEdgeVertex(edgeIndex, 1, vb);
    vb.vsub(va, vectorStore);
};

/**
 * Get face normal given 3 vertices
 * @static
 * @method computeNormal
 * @param {Vec3} va
 * @param {Vec3} vb
 * @param {Vec3} vc
 * @param {Vec3} target
 */
var cb = new Vec3();
var ab = new Vec3();
Trimesh.computeNormal = function ( va, vb, vc, target ) {
    vb.vsub(va,ab);
    vc.vsub(vb,cb);
    cb.cross(ab,target);
    if ( !target.isZero() ) {
        target.normalize();
    }
};

var va = new Vec3();
var vb = new Vec3();
var vc = new Vec3();

/**
 * Get vertex i.
 * @method getVertex
 * @param  {number} i
 * @param  {Vec3} out
 * @return {Vec3} The "out" vector object
 */
Trimesh.prototype.getVertex = function(i, out){
    var scale = this.scale;
    this._getUnscaledVertex(i, out);
    out.x *= scale.x;
    out.y *= scale.y;
    out.z *= scale.z;
    return out;
};

/**
 * Get raw vertex i
 * @private
 * @method _getUnscaledVertex
 * @param  {number} i
 * @param  {Vec3} out
 * @return {Vec3} The "out" vector object
 */
Trimesh.prototype._getUnscaledVertex = function(i, out){
    var i3 = i * 3;
    var vertices = this.vertices;
    return out.set(
        vertices[i3],
        vertices[i3 + 1],
        vertices[i3 + 2]
    );
};

/**
 * Get a vertex from the trimesh,transformed by the given position and quaternion.
 * @method getWorldVertex
 * @param  {number} i
 * @param  {Vec3} pos
 * @param  {Quaternion} quat
 * @param  {Vec3} out
 * @return {Vec3} The "out" vector object
 */
Trimesh.prototype.getWorldVertex = function(i, pos, quat, out){
    this.getVertex(i, out);
    Transform.pointToWorldFrame(pos, quat, out, out);
    return out;
};

/**
 * Get the three vertices for triangle i.
 * @method getTriangleVertices
 * @param  {number} i
 * @param  {Vec3} a
 * @param  {Vec3} b
 * @param  {Vec3} c
 */
Trimesh.prototype.getTriangleVertices = function(i, a, b, c){
    var i3 = i * 3;
    this.getVertex(this.indices[i3], a);
    this.getVertex(this.indices[i3 + 1], b);
    this.getVertex(this.indices[i3 + 2], c);
};

/**
 * Compute the normal of triangle i.
 * @method getNormal
 * @param  {Number} i
 * @param  {Vec3} target
 * @return {Vec3} The "target" vector object
 */
Trimesh.prototype.getNormal = function(i, target){
    var i3 = i * 3;
    return target.set(
        this.normals[i3],
        this.normals[i3 + 1],
        this.normals[i3 + 2]
    );
};

var cli_aabb = new AABB();

/**
 * @method calculateLocalInertia
 * @param  {Number} mass
 * @param  {Vec3} target
 * @return {Vec3} The "target" vector object
 */
Trimesh.prototype.calculateLocalInertia = function(mass,target){
    // Approximate with box inertia
    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
    this.computeLocalAABB(cli_aabb);
    var x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x,
        y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y,
        z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;
    return target.set(
        1.0 / 12.0 * mass * ( 2*y*2*y + 2*z*2*z ),
        1.0 / 12.0 * mass * ( 2*x*2*x + 2*z*2*z ),
        1.0 / 12.0 * mass * ( 2*y*2*y + 2*x*2*x )
    );
};

var computeLocalAABB_worldVert = new Vec3();

/**
 * Compute the local AABB for the trimesh
 * @method computeLocalAABB
 * @param  {AABB} aabb
 */
Trimesh.prototype.computeLocalAABB = function(aabb){
    var this$1 = this;

    var l = aabb.lowerBound,
        u = aabb.upperBound,
        n = this.vertices.length,
        vertices = this.vertices,
        v = computeLocalAABB_worldVert;

    this.getVertex(0, v);
    l.copy(v);
    u.copy(v);

    for(var i=0; i !== n; i++){
        this$1.getVertex(i, v);

        if(v.x < l.x){
            l.x = v.x;
        } else if(v.x > u.x){
            u.x = v.x;
        }

        if(v.y < l.y){
            l.y = v.y;
        } else if(v.y > u.y){
            u.y = v.y;
        }

        if(v.z < l.z){
            l.z = v.z;
        } else if(v.z > u.z){
            u.z = v.z;
        }
    }
};


/**
 * Update the .aabb property
 * @method updateAABB
 */
Trimesh.prototype.updateAABB = function(){
    this.computeLocalAABB(this.aabb);
};

/**
 * Will update the .boundingSphereRadius property
 * @method updateBoundingSphereRadius
 */
Trimesh.prototype.updateBoundingSphereRadius = function(){
    var this$1 = this;

    // Assume points are distributed with local (0,0,0) as center
    var max2 = 0;
    var vertices = this.vertices;
    var v = new Vec3();
    for(var i=0, N=vertices.length / 3; i !== N; i++) {
        this$1.getVertex(i, v);
        var norm2 = v.norm2();
        if(norm2 > max2){
            max2 = norm2;
        }
    }
    this.boundingSphereRadius = Math.sqrt(max2);
};

var tempWorldVertex = new Vec3();
var calculateWorldAABB_frame = new Transform();
var calculateWorldAABB_aabb = new AABB();

/**
 * @method calculateWorldAABB
 * @param {Vec3}        pos
 * @param {Quaternion}  quat
 * @param {Vec3}        min
 * @param {Vec3}        max
 */
Trimesh.prototype.calculateWorldAABB = function(pos,quat,min,max){
    /*
    var n = this.vertices.length / 3,
        verts = this.vertices;
    var minx,miny,minz,maxx,maxy,maxz;

    var v = tempWorldVertex;
    for(var i=0; i<n; i++){
        this.getVertex(i, v);
        quat.vmult(v, v);
        pos.vadd(v, v);
        if (v.x < minx || minx===undefined){
            minx = v.x;
        } else if(v.x > maxx || maxx===undefined){
            maxx = v.x;
        }

        if (v.y < miny || miny===undefined){
            miny = v.y;
        } else if(v.y > maxy || maxy===undefined){
            maxy = v.y;
        }

        if (v.z < minz || minz===undefined){
            minz = v.z;
        } else if(v.z > maxz || maxz===undefined){
            maxz = v.z;
        }
    }
    min.set(minx,miny,minz);
    max.set(maxx,maxy,maxz);
    */

    // Faster approximation using local AABB
    var frame = calculateWorldAABB_frame;
    var result = calculateWorldAABB_aabb;
    frame.position = pos;
    frame.quaternion = quat;
    this.aabb.toWorldFrame(frame, result);
    min.copy(result.lowerBound);
    max.copy(result.upperBound);
};

/**
 * Get approximate volume
 * @method volume
 * @return {Number}
 */
Trimesh.prototype.volume = function(){
    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
};

/**
 * Create a Trimesh instance, shaped as a torus.
 * @static
 * @method createTorus
 * @param  {number} [radius=1]
 * @param  {number} [tube=0.5]
 * @param  {number} [radialSegments=8]
 * @param  {number} [tubularSegments=6]
 * @param  {number} [arc=6.283185307179586]
 * @return {Trimesh} A torus
 */
Trimesh.createTorus = function (radius, tube, radialSegments, tubularSegments, arc) {
    radius = radius || 1;
    tube = tube || 0.5;
    radialSegments = radialSegments || 8;
    tubularSegments = tubularSegments || 6;
    arc = arc || Math.PI * 2;

    var vertices = [];
    var indices = [];

    for ( var j = 0; j <= radialSegments; j ++ ) {
        for ( var i = 0; i <= tubularSegments; i ++ ) {
            var u = i / tubularSegments * arc;
            var v = j / radialSegments * Math.PI * 2;

            var x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
            var y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
            var z = tube * Math.sin( v );

            vertices.push( x, y, z );
        }
    }

    for ( var j = 1; j <= radialSegments; j ++ ) {
        for ( var i = 1; i <= tubularSegments; i ++ ) {
            var a = ( tubularSegments + 1 ) * j + i - 1;
            var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
            var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
            var d = ( tubularSegments + 1 ) * j + i;

            indices.push(a, b, d);
            indices.push(b, c, d);
        }
    }

    return new Trimesh(vertices, indices);
};

},{"../collision/AABB":3,"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"../utils/Octree":50,"./Shape":43}],46:[function(_dereq_,module,exports){
module.exports = GSSolver;

var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var Solver = _dereq_('./Solver');

/**
 * Constraint equation Gauss-Seidel solver.
 * @class GSSolver
 * @constructor
 * @todo The spook parameters should be specified for each constraint, not globally.
 * @author schteppe / https://github.com/schteppe
 * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
 * @extends Solver
 */
function GSSolver(){
    Solver.call(this);

    /**
     * The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
     * @property iterations
     * @type {Number}
     * @todo write more about solver and iterations in the wiki
     */
    this.iterations = 10;

    /**
     * When tolerance is reached, the system is assumed to be converged.
     * @property tolerance
     * @type {Number}
     */
    this.tolerance = 1e-7;
}
GSSolver.prototype = new Solver();

var GSSolver_solve_lambda = []; // Just temporary number holders that we want to reuse each solve.
var GSSolver_solve_invCs = [];
var GSSolver_solve_Bs = [];
GSSolver.prototype.solve = function(dt,world){
    var iter = 0,
        maxIter = this.iterations,
        tolSquared = this.tolerance*this.tolerance,
        equations = this.equations,
        Neq = equations.length,
        bodies = world.bodies,
        Nbodies = bodies.length,
        h = dt,
        q, B, invC, deltalambda, deltalambdaTot, GWlambda, lambdaj;

    // Update solve mass
    if(Neq !== 0){
        for(var i=0; i!==Nbodies; i++){
            bodies[i].updateSolveMassProperties();
        }
    }

    // Things that does not change during iteration can be computed once
    var invCs = GSSolver_solve_invCs,
        Bs = GSSolver_solve_Bs,
        lambda = GSSolver_solve_lambda;
    invCs.length = Neq;
    Bs.length = Neq;
    lambda.length = Neq;
    for(var i=0; i!==Neq; i++){
        var c = equations[i];
        lambda[i] = 0.0;
        Bs[i] = c.computeB(h);
        invCs[i] = 1.0 / c.computeC();
    }

    if(Neq !== 0){

        // Reset vlambda
        for(var i=0; i!==Nbodies; i++){
            var b=bodies[i],
                vlambda=b.vlambda,
                wlambda=b.wlambda;
            vlambda.set(0,0,0);
            if(wlambda){
                wlambda.set(0,0,0);
            }
        }

        // Iterate over equations
        for(iter=0; iter!==maxIter; iter++){

            // Accumulate the total error for each iteration.
            deltalambdaTot = 0.0;

            for(var j=0; j!==Neq; j++){

                var c = equations[j];

                // Compute iteration
                B = Bs[j];
                invC = invCs[j];
                lambdaj = lambda[j];
                GWlambda = c.computeGWlambda();
                deltalambda = invC * ( B - GWlambda - c.eps * lambdaj );

                // Clamp if we are not within the min/max interval
                if(lambdaj + deltalambda < c.minForce){
                    deltalambda = c.minForce - lambdaj;
                } else if(lambdaj + deltalambda > c.maxForce){
                    deltalambda = c.maxForce - lambdaj;
                }
                lambda[j] += deltalambda;

                deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)

                c.addToWlambda(deltalambda);
            }

            // If the total error is small enough - stop iterate
            if(deltalambdaTot*deltalambdaTot < tolSquared){
                break;
            }
        }

        // Add result to velocity
        for(var i=0; i!==Nbodies; i++){
            var b=bodies[i],
                v=b.velocity,
                w=b.angularVelocity;
            v.vadd(b.vlambda, v);
            if(w){
                w.vadd(b.wlambda, w);
            }
        }
    }

    return iter;
};

},{"../math/Quaternion":28,"../math/Vec3":30,"./Solver":47}],47:[function(_dereq_,module,exports){
module.exports = Solver;

/**
 * Constraint equation solver base class.
 * @class Solver
 * @constructor
 * @author schteppe / https://github.com/schteppe
 */
function Solver(){
    /**
     * All equations to be solved
     * @property {Array} equations
     */
    this.equations = [];
}

/**
 * Should be implemented in subclasses!
 * @method solve
 * @param  {Number} dt
 * @param  {World} world
 */
Solver.prototype.solve = function(dt,world){
    // Should return the number of iterations done!
    return 0;
};

/**
 * Add an equation
 * @method addEquation
 * @param {Equation} eq
 */
Solver.prototype.addEquation = function(eq){
    if (eq.enabled) {
        this.equations.push(eq);
    }
};

/**
 * Remove an equation
 * @method removeEquation
 * @param {Equation} eq
 */
Solver.prototype.removeEquation = function(eq){
    var eqs = this.equations;
    var i = eqs.indexOf(eq);
    if(i !== -1){
        eqs.splice(i,1);
    }
};

/**
 * Add all equations
 * @method removeAllEquations
 */
Solver.prototype.removeAllEquations = function(){
    this.equations.length = 0;
};


},{}],48:[function(_dereq_,module,exports){
module.exports = SplitSolver;

var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var Solver = _dereq_('./Solver');
var Body = _dereq_('../objects/Body');

/**
 * Splits the equations into islands and solves them independently. Can improve performance.
 * @class SplitSolver
 * @constructor
 * @extends Solver
 * @param {Solver} subsolver
 */
function SplitSolver(subsolver){
    var this$1 = this;

    Solver.call(this);
    this.iterations = 10;
    this.tolerance = 1e-7;
    this.subsolver = subsolver;
    this.nodes = [];
    this.nodePool = [];

    // Create needed nodes, reuse if possible
    while(this.nodePool.length < 128){
        this$1.nodePool.push(this$1.createNode());
    }
}
SplitSolver.prototype = new Solver();

// Returns the number of subsystems
var SplitSolver_solve_nodes = []; // All allocated node objects
var SplitSolver_solve_eqs = [];   // Temp array
var SplitSolver_solve_dummyWorld = {bodies:[]}; // Temp object

var STATIC = Body.STATIC;
function getUnvisitedNode(nodes){
    var Nnodes = nodes.length;
    for(var i=0; i!==Nnodes; i++){
        var node = nodes[i];
        if(!node.visited && !(node.body.type & STATIC)){
            return node;
        }
    }
    return false;
}

var queue = [];
function bfs(root,visitFunc,bds,eqs){
    queue.push(root);
    root.visited = true;
    visitFunc(root,bds,eqs);
    while(queue.length) {
        var node = queue.pop();
        // Loop over unvisited child nodes
        var child;
        while((child = getUnvisitedNode(node.children))) {
            child.visited = true;
            visitFunc(child,bds,eqs);
            queue.push(child);
        }
    }
}

function visitFunc(node,bds,eqs){
    bds.push(node.body);
    var Neqs = node.eqs.length;
    for(var i=0; i!==Neqs; i++){
        var eq = node.eqs[i];
        if(eqs.indexOf(eq) === -1){
            eqs.push(eq);
        }
    }
}

SplitSolver.prototype.createNode = function(){
    return { body:null, children:[], eqs:[], visited:false };
};

/**
 * Solve the subsystems
 * @method solve
 * @param  {Number} dt
 * @param  {World} world
 */
SplitSolver.prototype.solve = function(dt,world){
    var this$1 = this;

    var nodes=SplitSolver_solve_nodes,
        nodePool=this.nodePool,
        bodies=world.bodies,
        equations=this.equations,
        Neq=equations.length,
        Nbodies=bodies.length,
        subsolver=this.subsolver;

    // Create needed nodes, reuse if possible
    while(nodePool.length < Nbodies){
        nodePool.push(this$1.createNode());
    }
    nodes.length = Nbodies;
    for (var i = 0; i < Nbodies; i++) {
        nodes[i] = nodePool[i];
    }

    // Reset node values
    for(var i=0; i!==Nbodies; i++){
        var node = nodes[i];
        node.body = bodies[i];
        node.children.length = 0;
        node.eqs.length = 0;
        node.visited = false;
    }
    for(var k=0; k!==Neq; k++){
        var eq=equations[k],
            i=bodies.indexOf(eq.bi),
            j=bodies.indexOf(eq.bj),
            ni=nodes[i],
            nj=nodes[j];
        ni.children.push(nj);
        ni.eqs.push(eq);
        nj.children.push(ni);
        nj.eqs.push(eq);
    }

    var child, n=0, eqs=SplitSolver_solve_eqs;

    subsolver.tolerance = this.tolerance;
    subsolver.iterations = this.iterations;

    var dummyWorld = SplitSolver_solve_dummyWorld;
    while((child = getUnvisitedNode(nodes))){
        eqs.length = 0;
        dummyWorld.bodies.length = 0;
        bfs(child, visitFunc, dummyWorld.bodies, eqs);

        var Neqs = eqs.length;

        eqs = eqs.sort(sortById);

        for(var i=0; i!==Neqs; i++){
            subsolver.addEquation(eqs[i]);
        }

        var iter = subsolver.solve(dt,dummyWorld);
        subsolver.removeAllEquations();
        n++;
    }

    return n;
};

function sortById(a, b){
    return b.id - a.id;
}
},{"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"./Solver":47}],49:[function(_dereq_,module,exports){
/**
 * Base class for objects that dispatches events.
 * @class EventTarget
 * @constructor
 */
var EventTarget = function () {

};

module.exports = EventTarget;

EventTarget.prototype = {
    constructor: EventTarget,

    /**
     * Add an event listener
     * @method addEventListener
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventTarget} The self object, for chainability.
     */
    addEventListener: function ( type, listener ) {
        if ( this._listeners === undefined ){ this._listeners = {}; }
        var listeners = this._listeners;
        if ( listeners[ type ] === undefined ) {
            listeners[ type ] = [];
        }
        if ( listeners[ type ].indexOf( listener ) === - 1 ) {
            listeners[ type ].push( listener );
        }
        return this;
    },

    /**
     * Check if an event listener is added
     * @method hasEventListener
     * @param  {String} type
     * @param  {Function} listener
     * @return {Boolean}
     */
    hasEventListener: function ( type, listener ) {
        if ( this._listeners === undefined ){ return false; }
        var listeners = this._listeners;
        if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
            return true;
        }
        return false;
    },

    /**
     * Remove an event listener
     * @method removeEventListener
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventTarget} The self object, for chainability.
     */
    removeEventListener: function ( type, listener ) {
        if ( this._listeners === undefined ){ return this; }
        var listeners = this._listeners;
        if ( listeners[type] === undefined ){ return this; }
        var index = listeners[ type ].indexOf( listener );
        if ( index !== - 1 ) {
            listeners[ type ].splice( index, 1 );
        }
        return this;
    },

    /**
     * Emit an event.
     * @method dispatchEvent
     * @param  {Object} event
     * @param  {String} event.type
     * @return {EventTarget} The self object, for chainability.
     */
    dispatchEvent: function ( event ) {
        var this$1 = this;

        if ( this._listeners === undefined ){ return this; }
        var listeners = this._listeners;
        var listenerArray = listeners[ event.type ];
        if ( listenerArray !== undefined ) {
            event.target = this;
            for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {
                listenerArray[ i ].call( this$1, event );
            }
        }
        return this;
    }
};

},{}],50:[function(_dereq_,module,exports){
var AABB = _dereq_('../collision/AABB');
var Vec3 = _dereq_('../math/Vec3');

module.exports = Octree;

/**
 * @class OctreeNode
 * @param {object} [options]
 * @param {Octree} [options.root]
 * @param {AABB} [options.aabb]
 */
function OctreeNode(options){
    options = options || {};

    /**
     * The root node
     * @property {OctreeNode} root
     */
    this.root = options.root || null;

    /**
     * Boundary of this node
     * @property {AABB} aabb
     */
    this.aabb = options.aabb ? options.aabb.clone() : new AABB();

    /**
     * Contained data at the current node level.
     * @property {Array} data
     */
    this.data = [];

    /**
     * Children to this node
     * @property {Array} children
     */
    this.children = [];
}

/**
 * @class Octree
 * @param {AABB} aabb The total AABB of the tree
 * @param {object} [options]
 * @param {number} [options.maxDepth=8]
 * @extends OctreeNode
 */
function Octree(aabb, options){
    options = options || {};
    options.root = null;
    options.aabb = aabb;
    OctreeNode.call(this, options);

    /**
     * Maximum subdivision depth
     * @property {number} maxDepth
     */
    this.maxDepth = typeof(options.maxDepth) !== 'undefined' ? options.maxDepth : 8;
}
Octree.prototype = new OctreeNode();

OctreeNode.prototype.reset = function(aabb, options){
    this.children.length = this.data.length = 0;
};

/**
 * Insert data into this node
 * @method insert
 * @param  {AABB} aabb
 * @param  {object} elementData
 * @return {boolean} True if successful, otherwise false
 */
OctreeNode.prototype.insert = function(aabb, elementData, level){
    var nodeData = this.data;
    level = level || 0;

    // Ignore objects that do not belong in this node
    if (!this.aabb.contains(aabb)){
        return false; // object cannot be added
    }

    var children = this.children;

    if(level < (this.maxDepth || this.root.maxDepth)){
        // Subdivide if there are no children yet
        var subdivided = false;
        if (!children.length){
            this.subdivide();
            subdivided = true;
        }

        // add to whichever node will accept it
        for (var i = 0; i !== 8; i++) {
            if (children[i].insert(aabb, elementData, level + 1)){
                return true;
            }
        }

        if(subdivided){
            // No children accepted! Might as well just remove em since they contain none
            children.length = 0;
        }
    }

    // Too deep, or children didnt want it. add it in current node
    nodeData.push(elementData);

    return true;
};

var halfDiagonal = new Vec3();

/**
 * Create 8 equally sized children nodes and put them in the .children array.
 * @method subdivide
 */
OctreeNode.prototype.subdivide = function() {
    var aabb = this.aabb;
    var l = aabb.lowerBound;
    var u = aabb.upperBound;

    var children = this.children;

    children.push(
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,0,0) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,0,0) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,1,0) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,1,1) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,1,1) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,0,1) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,0,1) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,1,0) }) })
    );

    u.vsub(l, halfDiagonal);
    halfDiagonal.scale(0.5, halfDiagonal);

    var root = this.root || this;

    for (var i = 0; i !== 8; i++) {
        var child = children[i];

        // Set current node as root
        child.root = root;

        // Compute bounds
        var lowerBound = child.aabb.lowerBound;
        lowerBound.x *= halfDiagonal.x;
        lowerBound.y *= halfDiagonal.y;
        lowerBound.z *= halfDiagonal.z;

        lowerBound.vadd(l, lowerBound);

        // Upper bound is always lower bound + halfDiagonal
        lowerBound.vadd(halfDiagonal, child.aabb.upperBound);
    }
};

/**
 * Get all data, potentially within an AABB
 * @method aabbQuery
 * @param  {AABB} aabb
 * @param  {array} result
 * @return {array} The "result" object
 */
OctreeNode.prototype.aabbQuery = function(aabb, result) {

    var nodeData = this.data;

    // abort if the range does not intersect this node
    // if (!this.aabb.overlaps(aabb)){
    //     return result;
    // }

    // Add objects at this level
    // Array.prototype.push.apply(result, nodeData);

    // Add child data
    // @todo unwrap recursion into a queue / loop, that's faster in JS
    var children = this.children;


    // for (var i = 0, N = this.children.length; i !== N; i++) {
    //     children[i].aabbQuery(aabb, result);
    // }

    var queue = [this];
    while (queue.length) {
        var node = queue.pop();
        if (node.aabb.overlaps(aabb)){
            Array.prototype.push.apply(result, node.data);
        }
        Array.prototype.push.apply(queue, node.children);
    }

    return result;
};

var tmpAABB = new AABB();

/**
 * Get all data, potentially intersected by a ray.
 * @method rayQuery
 * @param  {Ray} ray
 * @param  {Transform} treeTransform
 * @param  {array} result
 * @return {array} The "result" object
 */
OctreeNode.prototype.rayQuery = function(ray, treeTransform, result) {

    // Use aabb query for now.
    // @todo implement real ray query which needs less lookups
    ray.getAABB(tmpAABB);
    tmpAABB.toLocalFrame(treeTransform, tmpAABB);
    this.aabbQuery(tmpAABB, result);

    return result;
};

/**
 * @method removeEmptyNodes
 */
OctreeNode.prototype.removeEmptyNodes = function() {
    var queue = [this];
    while (queue.length) {
        var node = queue.pop();
        for (var i = node.children.length - 1; i >= 0; i--) {
            if(!node.children[i].data.length){
                node.children.splice(i, 1);
            }
        }
        Array.prototype.push.apply(queue, node.children);
    }
};

},{"../collision/AABB":3,"../math/Vec3":30}],51:[function(_dereq_,module,exports){
module.exports = Pool;

/**
 * For pooling objects that can be reused.
 * @class Pool
 * @constructor
 */
function Pool(){
    /**
     * The pooled objects
     * @property {Array} objects
     */
    this.objects = [];

    /**
     * Constructor of the objects
     * @property {mixed} type
     */
    this.type = Object;
}

/**
 * Release an object after use
 * @method release
 * @param {Object} obj
 */
Pool.prototype.release = function(){
    var arguments$1 = arguments;
    var this$1 = this;

    var Nargs = arguments.length;
    for(var i=0; i!==Nargs; i++){
        this$1.objects.push(arguments$1[i]);
    }
};

/**
 * Get an object
 * @method get
 * @return {mixed}
 */
Pool.prototype.get = function(){
    if(this.objects.length===0){
        return this.constructObject();
    } else {
        return this.objects.pop();
    }
};

/**
 * Construct an object. Should be implmented in each subclass.
 * @method constructObject
 * @return {mixed}
 */
Pool.prototype.constructObject = function(){
    throw new Error("constructObject() not implemented in this Pool subclass yet!");
};

},{}],52:[function(_dereq_,module,exports){
module.exports = TupleDictionary;

/**
 * @class TupleDictionary
 * @constructor
 */
function TupleDictionary() {

    /**
     * The data storage
     * @property data
     * @type {Object}
     */
    this.data = { keys:[] };
}

/**
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */
TupleDictionary.prototype.get = function(i, j) {
    if (i > j) {
        // swap
        var temp = j;
        j = i;
        i = temp;
    }
    return this.data[i+'-'+j];
};

/**
 * @method set
 * @param  {Number} i
 * @param  {Number} j
 * @param {Number} value
 */
TupleDictionary.prototype.set = function(i, j, value) {
    if (i > j) {
        var temp = j;
        j = i;
        i = temp;
    }
    var key = i+'-'+j;

    // Check if key already exists
    if(!this.get(i,j)){
        this.data.keys.push(key);
    }

    this.data[key] = value;
};

/**
 * @method reset
 */
TupleDictionary.prototype.reset = function() {
    var data = this.data,
        keys = data.keys;
    while(keys.length > 0){
        var key = keys.pop();
        delete data[key];
    }
};

},{}],53:[function(_dereq_,module,exports){
function Utils(){}

module.exports = Utils;

/**
 * Extend an options object with default values.
 * @static
 * @method defaults
 * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.
 * @param  {object} defaults An object containing default values.
 * @return {object} The modified options object.
 */
Utils.defaults = function(options, defaults){
    options = options || {};

    for(var key in defaults){
        if(!(key in options)){
            options[key] = defaults[key];
        }
    }

    return options;
};

},{}],54:[function(_dereq_,module,exports){
module.exports = Vec3Pool;

var Vec3 = _dereq_('../math/Vec3');
var Pool = _dereq_('./Pool');

/**
 * @class Vec3Pool
 * @constructor
 * @extends Pool
 */
function Vec3Pool(){
    Pool.call(this);
    this.type = Vec3;
}
Vec3Pool.prototype = new Pool();

/**
 * Construct a vector
 * @method constructObject
 * @return {Vec3}
 */
Vec3Pool.prototype.constructObject = function(){
    return new Vec3();
};

},{"../math/Vec3":30,"./Pool":51}],55:[function(_dereq_,module,exports){
module.exports = Narrowphase;

var AABB = _dereq_('../collision/AABB');
var Shape = _dereq_('../shapes/Shape');
var Ray = _dereq_('../collision/Ray');
var Vec3 = _dereq_('../math/Vec3');
var Transform = _dereq_('../math/Transform');
var ConvexPolyhedron = _dereq_('../shapes/ConvexPolyhedron');
var Quaternion = _dereq_('../math/Quaternion');
var Solver = _dereq_('../solver/Solver');
var Vec3Pool = _dereq_('../utils/Vec3Pool');
var ContactEquation = _dereq_('../equations/ContactEquation');
var FrictionEquation = _dereq_('../equations/FrictionEquation');

/**
 * Helper class for the World. Generates ContactEquations.
 * @class Narrowphase
 * @constructor
 * @todo Sphere-ConvexPolyhedron contacts
 * @todo Contact reduction
 * @todo  should move methods to prototype
 */
function Narrowphase(world){

    /**
     * Internal storage of pooled contact points.
     * @property {Array} contactPointPool
     */
    this.contactPointPool = [];

    this.frictionEquationPool = [];

    this.result = [];
    this.frictionResult = [];

    /**
     * Pooled vectors.
     * @property {Vec3Pool} v3pool
     */
    this.v3pool = new Vec3Pool();

    this.world = world;
    this.currentContactMaterial = null;

    /**
     * @property {Boolean} enableFrictionReduction
     */
    this.enableFrictionReduction = false;
}

/**
 * Make a contact object, by using the internal pool or creating a new one.
 * @method createContactEquation
 * @return {ContactEquation}
 */
Narrowphase.prototype.createContactEquation = function(bi, bj, si, sj, rsi, rsj){
    var c;
    if(this.contactPointPool.length){
        c = this.contactPointPool.pop();
        c.bi = bi;
        c.bj = bj;
    } else {
        c = new ContactEquation(bi, bj);
    }

    c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

    var cm = this.currentContactMaterial;

    c.restitution = cm.restitution;

    c.setSpookParams(
        cm.contactEquationStiffness,
        cm.contactEquationRelaxation,
        this.world.dt
    );

    var matA = si.material || bi.material;
    var matB = sj.material || bj.material;
    if(matA && matB && matA.restitution >= 0 && matB.restitution >= 0){
        c.restitution = matA.restitution * matB.restitution;
    }

    c.si = rsi || si;
    c.sj = rsj || sj;

    return c;
};

Narrowphase.prototype.createFrictionEquationsFromContact = function(contactEquation, outArray){
    var bodyA = contactEquation.bi;
    var bodyB = contactEquation.bj;
    var shapeA = contactEquation.si;
    var shapeB = contactEquation.sj;

    var world = this.world;
    var cm = this.currentContactMaterial;

    // If friction or restitution were specified in the material, use them
    var friction = cm.friction;
    var matA = shapeA.material || bodyA.material;
    var matB = shapeB.material || bodyB.material;
    if(matA && matB && matA.friction >= 0 && matB.friction >= 0){
        friction = matA.friction * matB.friction;
    }

    if(friction > 0){

        // Create 2 tangent equations
        var mug = friction * world.gravity.length();
        var reducedMass = (bodyA.invMass + bodyB.invMass);
        if(reducedMass > 0){
            reducedMass = 1/reducedMass;
        }
        var pool = this.frictionEquationPool;
        var c1 = pool.length ? pool.pop() : new FrictionEquation(bodyA,bodyB,mug*reducedMass);
        var c2 = pool.length ? pool.pop() : new FrictionEquation(bodyA,bodyB,mug*reducedMass);

        c1.bi = c2.bi = bodyA;
        c1.bj = c2.bj = bodyB;
        c1.minForce = c2.minForce = -mug*reducedMass;
        c1.maxForce = c2.maxForce = mug*reducedMass;

        // Copy over the relative vectors
        c1.ri.copy(contactEquation.ri);
        c1.rj.copy(contactEquation.rj);
        c2.ri.copy(contactEquation.ri);
        c2.rj.copy(contactEquation.rj);

        // Construct tangents
        contactEquation.ni.tangents(c1.t, c2.t);

        // Set spook params
        c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
        c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);

        c1.enabled = c2.enabled = contactEquation.enabled;

        outArray.push(c1, c2);

        return true;
    }

    return false;
};

var averageNormal = new Vec3();
var averageContactPointA = new Vec3();
var averageContactPointB = new Vec3();

// Take the average N latest contact point on the plane.
Narrowphase.prototype.createFrictionFromAverage = function(numContacts){
    var this$1 = this;

    // The last contactEquation
    var c = this.result[this.result.length - 1];

    // Create the result: two "average" friction equations
    if (!this.createFrictionEquationsFromContact(c, this.frictionResult) || numContacts === 1) {
        return;
    }

    var f1 = this.frictionResult[this.frictionResult.length - 2];
    var f2 = this.frictionResult[this.frictionResult.length - 1];

    averageNormal.setZero();
    averageContactPointA.setZero();
    averageContactPointB.setZero();

    var bodyA = c.bi;
    var bodyB = c.bj;
    for(var i=0; i!==numContacts; i++){
        c = this$1.result[this$1.result.length - 1 - i];
        if(c.bodyA !== bodyA){
            averageNormal.vadd(c.ni, averageNormal); // vec2.add(eq.t, eq.t, c.normalA);
            averageContactPointA.vadd(c.ri, averageContactPointA); // vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
            averageContactPointB.vadd(c.rj, averageContactPointB);
        } else {
            averageNormal.vsub(c.ni, averageNormal); // vec2.sub(eq.t, eq.t, c.normalA);
            averageContactPointA.vadd(c.rj, averageContactPointA); // vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
            averageContactPointB.vadd(c.ri, averageContactPointB);
        }
    }

    var invNumContacts = 1 / numContacts;
    averageContactPointA.scale(invNumContacts, f1.ri); // vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);
    averageContactPointB.scale(invNumContacts, f1.rj); // vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);
    f2.ri.copy(f1.ri); // Should be the same
    f2.rj.copy(f1.rj);
    averageNormal.normalize();
    averageNormal.tangents(f1.t, f2.t);
    // return eq;
};


var tmpVec1 = new Vec3();
var tmpVec2 = new Vec3();
var tmpQuat1 = new Quaternion();
var tmpQuat2 = new Quaternion();

/**
 * Generate all contacts between a list of body pairs
 * @method getContacts
 * @param {array} p1 Array of body indices
 * @param {array} p2 Array of body indices
 * @param {World} world
 * @param {array} result Array to store generated contacts
 * @param {array} oldcontacts Optional. Array of reusable contact objects
 */
Narrowphase.prototype.getContacts = function(p1, p2, world, result, oldcontacts, frictionResult, frictionPool){
    var this$1 = this;

    // Save old contact objects
    this.contactPointPool = oldcontacts;
    this.frictionEquationPool = frictionPool;
    this.result = result;
    this.frictionResult = frictionResult;

    var qi = tmpQuat1;
    var qj = tmpQuat2;
    var xi = tmpVec1;
    var xj = tmpVec2;

    for(var k=0, N=p1.length; k!==N; k++){

        // Get current collision bodies
        var bi = p1[k],
            bj = p2[k];

        // Get contact material
        var bodyContactMaterial = null;
        if(bi.material && bj.material){
            bodyContactMaterial = world.getContactMaterial(bi.material,bj.material) || null;
        }

        for (var i = 0; i < bi.shapes.length; i++) {
            bi.quaternion.mult(bi.shapeOrientations[i], qi);
            bi.quaternion.vmult(bi.shapeOffsets[i], xi);
            xi.vadd(bi.position, xi);
            var si = bi.shapes[i];

            for (var j = 0; j < bj.shapes.length; j++) {

                // Compute world transform of shapes
                bj.quaternion.mult(bj.shapeOrientations[j], qj);
                bj.quaternion.vmult(bj.shapeOffsets[j], xj);
                xj.vadd(bj.position, xj);
                var sj = bj.shapes[j];

                if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
                    continue;
                }

                // Get collision material
                var shapeContactMaterial = null;
                if(si.material && sj.material){
                    shapeContactMaterial = world.getContactMaterial(si.material,sj.material) || null;
                }

                this$1.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial;

                // Get contacts
                var resolver = this$1[si.type | sj.type];
                if(resolver){
                    if (si.type < sj.type) {
                        resolver.call(this$1, si, sj, xi, xj, qi, qj, bi, bj, si, sj);
                    } else {
                        resolver.call(this$1, sj, si, xj, xi, qj, qi, bj, bi, si, sj);
                    }
                }
            }
        }
    }
};

Narrowphase.prototype[Shape.types.BOX | Shape.types.BOX] =
Narrowphase.prototype.boxBox = function(si,sj,xi,xj,qi,qj,bi,bj){
    si.convexPolyhedronRepresentation.material = si.material;
    sj.convexPolyhedronRepresentation.material = sj.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
    this.convexConvex(si.convexPolyhedronRepresentation,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj,si,sj);
};

Narrowphase.prototype[Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.boxConvex = function(si,sj,xi,xj,qi,qj,bi,bj){
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    this.convexConvex(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);
};

Narrowphase.prototype[Shape.types.BOX | Shape.types.PARTICLE] =
Narrowphase.prototype.boxParticle = function(si,sj,xi,xj,qi,qj,bi,bj){
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    this.convexParticle(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);
};

/**
 * @method sphereSphere
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.SPHERE] =
Narrowphase.prototype.sphereSphere = function(si,sj,xi,xj,qi,qj,bi,bj){
    // We will have only one contact in this case
    var r = this.createContactEquation(bi,bj,si,sj);

    // Contact normal
    xj.vsub(xi, r.ni);
    r.ni.normalize();

    // Contact point locations
    r.ri.copy(r.ni);
    r.rj.copy(r.ni);
    r.ri.mult(si.radius, r.ri);
    r.rj.mult(-sj.radius, r.rj);

    r.ri.vadd(xi, r.ri);
    r.ri.vsub(bi.position, r.ri);

    r.rj.vadd(xj, r.rj);
    r.rj.vsub(bj.position, r.rj);

    this.result.push(r);

    this.createFrictionEquationsFromContact(r, this.frictionResult);
};

/**
 * @method planeTrimesh
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
var planeTrimesh_normal = new Vec3();
var planeTrimesh_relpos = new Vec3();
var planeTrimesh_projected = new Vec3();
Narrowphase.prototype[Shape.types.PLANE | Shape.types.TRIMESH] =
Narrowphase.prototype.planeTrimesh = function(
    planeShape,
    trimeshShape,
    planePos,
    trimeshPos,
    planeQuat,
    trimeshQuat,
    planeBody,
    trimeshBody
){
    var this$1 = this;

    // Make contacts!
    var v = new Vec3();

    var normal = planeTrimesh_normal;
    normal.set(0,0,1);
    planeQuat.vmult(normal,normal); // Turn normal according to plane

    for(var i=0; i<trimeshShape.vertices.length / 3; i++){

        // Get world vertex from trimesh
        trimeshShape.getVertex(i, v);

        // Safe up
        var v2 = new Vec3();
        v2.copy(v);
        Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);

        // Check plane side
        var relpos = planeTrimesh_relpos;
        v.vsub(planePos, relpos);
        var dot = normal.dot(relpos);

        if(dot <= 0.0){
            var r = this$1.createContactEquation(planeBody,trimeshBody,planeShape,trimeshShape);

            r.ni.copy(normal); // Contact normal is the plane normal

            // Get vertex position projected on plane
            var projected = planeTrimesh_projected;
            normal.scale(relpos.dot(normal), projected);
            v.vsub(projected,projected);

            // ri is the projected world position minus plane position
            r.ri.copy(projected);
            r.ri.vsub(planeBody.position, r.ri);

            r.rj.copy(v);
            r.rj.vsub(trimeshBody.position, r.rj);

            // Store result
            this$1.result.push(r);
            this$1.createFrictionEquationsFromContact(r, this$1.frictionResult);
        }
    }
};

/**
 * @method sphereTrimesh
 * @param  {Shape}      sphereShape
 * @param  {Shape}      trimeshShape
 * @param  {Vec3}       spherePos
 * @param  {Vec3}       trimeshPos
 * @param  {Quaternion} sphereQuat
 * @param  {Quaternion} trimeshQuat
 * @param  {Body}       sphereBody
 * @param  {Body}       trimeshBody
 */
var sphereTrimesh_normal = new Vec3();
var sphereTrimesh_relpos = new Vec3();
var sphereTrimesh_projected = new Vec3();
var sphereTrimesh_v = new Vec3();
var sphereTrimesh_v2 = new Vec3();
var sphereTrimesh_edgeVertexA = new Vec3();
var sphereTrimesh_edgeVertexB = new Vec3();
var sphereTrimesh_edgeVector = new Vec3();
var sphereTrimesh_edgeVectorUnit = new Vec3();
var sphereTrimesh_localSpherePos = new Vec3();
var sphereTrimesh_tmp = new Vec3();
var sphereTrimesh_va = new Vec3();
var sphereTrimesh_vb = new Vec3();
var sphereTrimesh_vc = new Vec3();
var sphereTrimesh_localSphereAABB = new AABB();
var sphereTrimesh_triangles = [];
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.TRIMESH] =
Narrowphase.prototype.sphereTrimesh = function (
    sphereShape,
    trimeshShape,
    spherePos,
    trimeshPos,
    sphereQuat,
    trimeshQuat,
    sphereBody,
    trimeshBody
) {
    var this$1 = this;


    var edgeVertexA = sphereTrimesh_edgeVertexA;
    var edgeVertexB = sphereTrimesh_edgeVertexB;
    var edgeVector = sphereTrimesh_edgeVector;
    var edgeVectorUnit = sphereTrimesh_edgeVectorUnit;
    var localSpherePos = sphereTrimesh_localSpherePos;
    var tmp = sphereTrimesh_tmp;
    var localSphereAABB = sphereTrimesh_localSphereAABB;
    var v2 = sphereTrimesh_v2;
    var relpos = sphereTrimesh_relpos;
    var triangles = sphereTrimesh_triangles;

    // Convert sphere position to local in the trimesh
    Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos);

    // Get the aabb of the sphere locally in the trimesh
    var sphereRadius = sphereShape.radius;
    localSphereAABB.lowerBound.set(
        localSpherePos.x - sphereRadius,
        localSpherePos.y - sphereRadius,
        localSpherePos.z - sphereRadius
    );
    localSphereAABB.upperBound.set(
        localSpherePos.x + sphereRadius,
        localSpherePos.y + sphereRadius,
        localSpherePos.z + sphereRadius
    );

    trimeshShape.getTrianglesInAABB(localSphereAABB, triangles);
    //for (var i = 0; i < trimeshShape.indices.length / 3; i++) triangles.push(i); // All

    // Vertices
    var v = sphereTrimesh_v;
    var radiusSquared = sphereShape.radius * sphereShape.radius;
    for(var i=0; i<triangles.length; i++){
        for (var j = 0; j < 3; j++) {

            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], v);

            // Check vertex overlap in sphere
            v.vsub(localSpherePos, relpos);

            if(relpos.norm2() <= radiusSquared){

                // Safe up
                v2.copy(v);
                Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);

                v.vsub(spherePos, relpos);

                var r = this$1.createContactEquation(sphereBody,trimeshBody,sphereShape,trimeshShape);
                r.ni.copy(relpos);
                r.ni.normalize();

                // ri is the vector from sphere center to the sphere surface
                r.ri.copy(r.ni);
                r.ri.scale(sphereShape.radius, r.ri);
                r.ri.vadd(spherePos, r.ri);
                r.ri.vsub(sphereBody.position, r.ri);

                r.rj.copy(v);
                r.rj.vsub(trimeshBody.position, r.rj);

                // Store result
                this$1.result.push(r);
                this$1.createFrictionEquationsFromContact(r, this$1.frictionResult);
            }
        }
    }

    // Check all edges
    for(var i=0; i<triangles.length; i++){
        for (var j = 0; j < 3; j++) {

            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], edgeVertexA);
            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + ((j+1)%3)], edgeVertexB);
            edgeVertexB.vsub(edgeVertexA, edgeVector);

            // Project sphere position to the edge
            localSpherePos.vsub(edgeVertexB, tmp);
            var positionAlongEdgeB = tmp.dot(edgeVector);

            localSpherePos.vsub(edgeVertexA, tmp);
            var positionAlongEdgeA = tmp.dot(edgeVector);

            if(positionAlongEdgeA > 0 && positionAlongEdgeB < 0){

                // Now check the orthogonal distance from edge to sphere center
                localSpherePos.vsub(edgeVertexA, tmp);

                edgeVectorUnit.copy(edgeVector);
                edgeVectorUnit.normalize();
                positionAlongEdgeA = tmp.dot(edgeVectorUnit);

                edgeVectorUnit.scale(positionAlongEdgeA, tmp);
                tmp.vadd(edgeVertexA, tmp);

                // tmp is now the sphere center position projected to the edge, defined locally in the trimesh frame
                var dist = tmp.distanceTo(localSpherePos);
                if(dist < sphereShape.radius){
                    var r = this$1.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape);

                    tmp.vsub(localSpherePos, r.ni);
                    r.ni.normalize();
                    r.ni.scale(sphereShape.radius, r.ri);

                    Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
                    tmp.vsub(trimeshBody.position, r.rj);

                    Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
                    Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);

                    this$1.result.push(r);
                    this$1.createFrictionEquationsFromContact(r, this$1.frictionResult);
                }
            }
        }
    }

    // Triangle faces
    var va = sphereTrimesh_va;
    var vb = sphereTrimesh_vb;
    var vc = sphereTrimesh_vc;
    var normal = sphereTrimesh_normal;
    for(var i=0, N = triangles.length; i !== N; i++){
        trimeshShape.getTriangleVertices(triangles[i], va, vb, vc);
        trimeshShape.getNormal(triangles[i], normal);
        localSpherePos.vsub(va, tmp);
        var dist = tmp.dot(normal);
        normal.scale(dist, tmp);
        localSpherePos.vsub(tmp, tmp);

        // tmp is now the sphere position projected to the triangle plane
        dist = tmp.distanceTo(localSpherePos);
        if(Ray.pointInTriangle(tmp, va, vb, vc) && dist < sphereShape.radius){
            var r = this$1.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape);

            tmp.vsub(localSpherePos, r.ni);
            r.ni.normalize();
            r.ni.scale(sphereShape.radius, r.ri);

            Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
            tmp.vsub(trimeshBody.position, r.rj);

            Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
            Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);

            this$1.result.push(r);
            this$1.createFrictionEquationsFromContact(r, this$1.frictionResult);
        }
    }

    triangles.length = 0;
};

var point_on_plane_to_sphere = new Vec3();
var plane_to_sphere_ortho = new Vec3();

/**
 * @method spherePlane
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.PLANE] =
Narrowphase.prototype.spherePlane = function(si,sj,xi,xj,qi,qj,bi,bj){
    // We will have one contact in this case
    var r = this.createContactEquation(bi,bj,si,sj);

    // Contact normal
    r.ni.set(0,0,1);
    qj.vmult(r.ni, r.ni);
    r.ni.negate(r.ni); // body i is the sphere, flip normal
    r.ni.normalize(); // Needed?

    // Vector from sphere center to contact point
    r.ni.mult(si.radius, r.ri);

    // Project down sphere on plane
    xi.vsub(xj, point_on_plane_to_sphere);
    r.ni.mult(r.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);
    point_on_plane_to_sphere.vsub(plane_to_sphere_ortho,r.rj); // The sphere position projected to plane

    if(-point_on_plane_to_sphere.dot(r.ni) <= si.radius){

        // Make it relative to the body
        var ri = r.ri;
        var rj = r.rj;
        ri.vadd(xi, ri);
        ri.vsub(bi.position, ri);
        rj.vadd(xj, rj);
        rj.vsub(bj.position, rj);

        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
};

// See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html
var pointInPolygon_edge = new Vec3();
var pointInPolygon_edge_x_normal = new Vec3();
var pointInPolygon_vtp = new Vec3();
function pointInPolygon(verts, normal, p){
    var positiveResult = null;
    var N = verts.length;
    for(var i=0; i!==N; i++){
        var v = verts[i];

        // Get edge to the next vertex
        var edge = pointInPolygon_edge;
        verts[(i+1) % (N)].vsub(v,edge);

        // Get cross product between polygon normal and the edge
        var edge_x_normal = pointInPolygon_edge_x_normal;
        //var edge_x_normal = new Vec3();
        edge.cross(normal,edge_x_normal);

        // Get vector between point and current vertex
        var vertex_to_p = pointInPolygon_vtp;
        p.vsub(v,vertex_to_p);

        // This dot product determines which side of the edge the point is
        var r = edge_x_normal.dot(vertex_to_p);

        // If all such dot products have same sign, we are inside the polygon.
        if(positiveResult===null || (r>0 && positiveResult===true) || (r<=0 && positiveResult===false)){
            if(positiveResult===null){
                positiveResult = r>0;
            }
            continue;
        } else {
            return false; // Encountered some other sign. Exit.
        }
    }

    // If we got here, all dot products were of the same sign.
    return true;
}

var box_to_sphere = new Vec3();
var sphereBox_ns = new Vec3();
var sphereBox_ns1 = new Vec3();
var sphereBox_ns2 = new Vec3();
var sphereBox_sides = [new Vec3(),new Vec3(),new Vec3(),new Vec3(),new Vec3(),new Vec3()];
var sphereBox_sphere_to_corner = new Vec3();
var sphereBox_side_ns = new Vec3();
var sphereBox_side_ns1 = new Vec3();
var sphereBox_side_ns2 = new Vec3();

/**
 * @method sphereBox
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.BOX] =
Narrowphase.prototype.sphereBox = function(si,sj,xi,xj,qi,qj,bi,bj){
    var this$1 = this;

    var v3pool = this.v3pool;

    // we refer to the box as body j
    var sides = sphereBox_sides;
    xi.vsub(xj,box_to_sphere);
    sj.getSideNormals(sides,qj);
    var R =     si.radius;
    var found = false;

    // Store the resulting side penetration info
    var side_ns = sphereBox_side_ns;
    var side_ns1 = sphereBox_side_ns1;
    var side_ns2 = sphereBox_side_ns2;
    var side_h = null;
    var side_penetrations = 0;
    var side_dot1 = 0;
    var side_dot2 = 0;
    var side_distance = null;
    for(var idx=0,nsides=sides.length; idx!==nsides && found===false; idx++){
        // Get the plane side normal (ns)
        var ns = sphereBox_ns;
        ns.copy(sides[idx]);

        var h = ns.norm();
        ns.normalize();

        // The normal/distance dot product tells which side of the plane we are
        var dot = box_to_sphere.dot(ns);

        if(dot<h+R && dot>0){
            // Intersects plane. Now check the other two dimensions
            var ns1 = sphereBox_ns1;
            var ns2 = sphereBox_ns2;
            ns1.copy(sides[(idx+1)%3]);
            ns2.copy(sides[(idx+2)%3]);
            var h1 = ns1.norm();
            var h2 = ns2.norm();
            ns1.normalize();
            ns2.normalize();
            var dot1 = box_to_sphere.dot(ns1);
            var dot2 = box_to_sphere.dot(ns2);
            if(dot1<h1 && dot1>-h1 && dot2<h2 && dot2>-h2){
                var dist = Math.abs(dot-h-R);
                if(side_distance===null || dist < side_distance){
                    side_distance = dist;
                    side_dot1 = dot1;
                    side_dot2 = dot2;
                    side_h = h;
                    side_ns.copy(ns);
                    side_ns1.copy(ns1);
                    side_ns2.copy(ns2);
                    side_penetrations++;
                }
            }
        }
    }
    if(side_penetrations){
        found = true;
        var r = this.createContactEquation(bi,bj,si,sj);
        side_ns.mult(-R,r.ri); // Sphere r
        r.ni.copy(side_ns);
        r.ni.negate(r.ni); // Normal should be out of sphere
        side_ns.mult(side_h,side_ns);
        side_ns1.mult(side_dot1,side_ns1);
        side_ns.vadd(side_ns1,side_ns);
        side_ns2.mult(side_dot2,side_ns2);
        side_ns.vadd(side_ns2,r.rj);

        // Make relative to bodies
        r.ri.vadd(xi, r.ri);
        r.ri.vsub(bi.position, r.ri);
        r.rj.vadd(xj, r.rj);
        r.rj.vsub(bj.position, r.rj);

        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
    }

    // Check corners
    var rj = v3pool.get();
    var sphere_to_corner = sphereBox_sphere_to_corner;
    for(var j=0; j!==2 && !found; j++){
        for(var k=0; k!==2 && !found; k++){
            for(var l=0; l!==2 && !found; l++){
                rj.set(0,0,0);
                if(j){
                    rj.vadd(sides[0],rj);
                } else {
                    rj.vsub(sides[0],rj);
                }
                if(k){
                    rj.vadd(sides[1],rj);
                } else {
                    rj.vsub(sides[1],rj);
                }
                if(l){
                    rj.vadd(sides[2],rj);
                } else {
                    rj.vsub(sides[2],rj);
                }

                // World position of corner
                xj.vadd(rj,sphere_to_corner);
                sphere_to_corner.vsub(xi,sphere_to_corner);

                if(sphere_to_corner.norm2() < R*R){
                    found = true;
                    var r = this$1.createContactEquation(bi,bj,si,sj);
                    r.ri.copy(sphere_to_corner);
                    r.ri.normalize();
                    r.ni.copy(r.ri);
                    r.ri.mult(R,r.ri);
                    r.rj.copy(rj);

                    // Make relative to bodies
                    r.ri.vadd(xi, r.ri);
                    r.ri.vsub(bi.position, r.ri);
                    r.rj.vadd(xj, r.rj);
                    r.rj.vsub(bj.position, r.rj);

                    this$1.result.push(r);
                    this$1.createFrictionEquationsFromContact(r, this$1.frictionResult);
                }
            }
        }
    }
    v3pool.release(rj);
    rj = null;

    // Check edges
    var edgeTangent = v3pool.get();
    var edgeCenter = v3pool.get();
    var r = v3pool.get(); // r = edge center to sphere center
    var orthogonal = v3pool.get();
    var dist = v3pool.get();
    var Nsides = sides.length;
    for(var j=0; j!==Nsides && !found; j++){
        for(var k=0; k!==Nsides && !found; k++){
            if(j%3 !== k%3){
                // Get edge tangent
                sides[k].cross(sides[j],edgeTangent);
                edgeTangent.normalize();
                sides[j].vadd(sides[k], edgeCenter);
                r.copy(xi);
                r.vsub(edgeCenter,r);
                r.vsub(xj,r);
                var orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction
                edgeTangent.mult(orthonorm,orthogonal); // Vector from edge center to sphere center in the tangent direction

                // Find the third side orthogonal to this one
                var l = 0;
                while(l===j%3 || l===k%3){
                    l++;
                }

                // vec from edge center to sphere projected to the plane orthogonal to the edge tangent
                dist.copy(xi);
                dist.vsub(orthogonal,dist);
                dist.vsub(edgeCenter,dist);
                dist.vsub(xj,dist);

                // Distances in tangent direction and distance in the plane orthogonal to it
                var tdist = Math.abs(orthonorm);
                var ndist = dist.norm();

                if(tdist < sides[l].norm() && ndist<R){
                    found = true;
                    var res = this$1.createContactEquation(bi,bj,si,sj);
                    edgeCenter.vadd(orthogonal,res.rj); // box rj
                    res.rj.copy(res.rj);
                    dist.negate(res.ni);
                    res.ni.normalize();

                    res.ri.copy(res.rj);
                    res.ri.vadd(xj,res.ri);
                    res.ri.vsub(xi,res.ri);
                    res.ri.normalize();
                    res.ri.mult(R,res.ri);

                    // Make relative to bodies
                    res.ri.vadd(xi, res.ri);
                    res.ri.vsub(bi.position, res.ri);
                    res.rj.vadd(xj, res.rj);
                    res.rj.vsub(bj.position, res.rj);

                    this$1.result.push(res);
                    this$1.createFrictionEquationsFromContact(res, this$1.frictionResult);
                }
            }
        }
    }
    v3pool.release(edgeTangent,edgeCenter,r,orthogonal,dist);
};

var convex_to_sphere = new Vec3();
var sphereConvex_edge = new Vec3();
var sphereConvex_edgeUnit = new Vec3();
var sphereConvex_sphereToCorner = new Vec3();
var sphereConvex_worldCorner = new Vec3();
var sphereConvex_worldNormal = new Vec3();
var sphereConvex_worldPoint = new Vec3();
var sphereConvex_worldSpherePointClosestToPlane = new Vec3();
var sphereConvex_penetrationVec = new Vec3();
var sphereConvex_sphereToWorldPoint = new Vec3();

/**
 * @method sphereConvex
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.sphereConvex = function(si,sj,xi,xj,qi,qj,bi,bj){
    var this$1 = this;

    var v3pool = this.v3pool;
    xi.vsub(xj,convex_to_sphere);
    var normals = sj.faceNormals;
    var faces = sj.faces;
    var verts = sj.vertices;
    var R =     si.radius;
    for(var i=0; i!==verts.length; i++){
        var v = verts[i];

        // World position of corner
        var worldCorner = sphereConvex_worldCorner;
        qj.vmult(v,worldCorner);
        xj.vadd(worldCorner,worldCorner);
        var sphere_to_corner = sphereConvex_sphereToCorner;
        worldCorner.vsub(xi, sphere_to_corner);
        if(sphere_to_corner.norm2() < R * R){
            found = true;
            var r = this$1.createContactEquation(bi,bj,si,sj);
            r.ri.copy(sphere_to_corner);
            r.ri.normalize();
            r.ni.copy(r.ri);
            r.ri.mult(R,r.ri);
            worldCorner.vsub(xj,r.rj);

            // Should be relative to the body.
            r.ri.vadd(xi, r.ri);
            r.ri.vsub(bi.position, r.ri);

            // Should be relative to the body.
            r.rj.vadd(xj, r.rj);
            r.rj.vsub(bj.position, r.rj);

            this$1.result.push(r);
            this$1.createFrictionEquationsFromContact(r, this$1.frictionResult);
            return;
        }
    }

    // Check side (plane) intersections
    var found = false;
    for(var i=0, nfaces=faces.length; i!==nfaces && found===false; i++){
        var normal = normals[i];
        var face = faces[i];

        // Get world-transformed normal of the face
        var worldNormal = sphereConvex_worldNormal;
        qj.vmult(normal,worldNormal);

        // Get a world vertex from the face
        var worldPoint = sphereConvex_worldPoint;
        qj.vmult(verts[face[0]],worldPoint);
        worldPoint.vadd(xj,worldPoint);

        // Get a point on the sphere, closest to the face normal
        var worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;
        worldNormal.mult(-R, worldSpherePointClosestToPlane);
        xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane);

        // Vector from a face point to the closest point on the sphere
        var penetrationVec = sphereConvex_penetrationVec;
        worldSpherePointClosestToPlane.vsub(worldPoint,penetrationVec);

        // The penetration. Negative value means overlap.
        var penetration = penetrationVec.dot(worldNormal);

        var worldPointToSphere = sphereConvex_sphereToWorldPoint;
        xi.vsub(worldPoint, worldPointToSphere);

        if(penetration < 0 && worldPointToSphere.dot(worldNormal)>0){
            // Intersects plane. Now check if the sphere is inside the face polygon
            var faceVerts = []; // Face vertices, in world coords
            for(var j=0, Nverts=face.length; j!==Nverts; j++){
                var worldVertex = v3pool.get();
                qj.vmult(verts[face[j]], worldVertex);
                xj.vadd(worldVertex,worldVertex);
                faceVerts.push(worldVertex);
            }

            if(pointInPolygon(faceVerts,worldNormal,xi)){ // Is the sphere center in the face polygon?
                found = true;
                var r = this$1.createContactEquation(bi,bj,si,sj);

                worldNormal.mult(-R, r.ri); // Contact offset, from sphere center to contact
                worldNormal.negate(r.ni); // Normal pointing out of sphere

                var penetrationVec2 = v3pool.get();
                worldNormal.mult(-penetration, penetrationVec2);
                var penetrationSpherePoint = v3pool.get();
                worldNormal.mult(-R, penetrationSpherePoint);

                //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);
                xi.vsub(xj,r.rj);
                r.rj.vadd(penetrationSpherePoint,r.rj);
                r.rj.vadd(penetrationVec2 , r.rj);

                // Should be relative to the body.
                r.rj.vadd(xj, r.rj);
                r.rj.vsub(bj.position, r.rj);

                // Should be relative to the body.
                r.ri.vadd(xi, r.ri);
                r.ri.vsub(bi.position, r.ri);

                v3pool.release(penetrationVec2);
                v3pool.release(penetrationSpherePoint);

                this$1.result.push(r);
                this$1.createFrictionEquationsFromContact(r, this$1.frictionResult);

                // Release world vertices
                for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){
                    v3pool.release(faceVerts[j]);
                }

                return; // We only expect *one* face contact
            } else {
                // Edge?
                for(var j=0; j!==face.length; j++){

                    // Get two world transformed vertices
                    var v1 = v3pool.get();
                    var v2 = v3pool.get();
                    qj.vmult(verts[face[(j+1)%face.length]], v1);
                    qj.vmult(verts[face[(j+2)%face.length]], v2);
                    xj.vadd(v1, v1);
                    xj.vadd(v2, v2);

                    // Construct edge vector
                    var edge = sphereConvex_edge;
                    v2.vsub(v1,edge);

                    // Construct the same vector, but normalized
                    var edgeUnit = sphereConvex_edgeUnit;
                    edge.unit(edgeUnit);

                    // p is xi projected onto the edge
                    var p = v3pool.get();
                    var v1_to_xi = v3pool.get();
                    xi.vsub(v1, v1_to_xi);
                    var dot = v1_to_xi.dot(edgeUnit);
                    edgeUnit.mult(dot, p);
                    p.vadd(v1, p);

                    // Compute a vector from p to the center of the sphere
                    var xi_to_p = v3pool.get();
                    p.vsub(xi, xi_to_p);

                    // Collision if the edge-sphere distance is less than the radius
                    // AND if p is in between v1 and v2
                    if(dot > 0 && dot*dot<edge.norm2() && xi_to_p.norm2() < R*R){ // Collision if the edge-sphere distance is less than the radius
                        // Edge contact!
                        var r = this$1.createContactEquation(bi,bj,si,sj);
                        p.vsub(xj,r.rj);

                        p.vsub(xi,r.ni);
                        r.ni.normalize();

                        r.ni.mult(R,r.ri);

                        // Should be relative to the body.
                        r.rj.vadd(xj, r.rj);
                        r.rj.vsub(bj.position, r.rj);

                        // Should be relative to the body.
                        r.ri.vadd(xi, r.ri);
                        r.ri.vsub(bi.position, r.ri);

                        this$1.result.push(r);
                        this$1.createFrictionEquationsFromContact(r, this$1.frictionResult);

                        // Release world vertices
                        for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){
                            v3pool.release(faceVerts[j]);
                        }

                        v3pool.release(v1);
                        v3pool.release(v2);
                        v3pool.release(p);
                        v3pool.release(xi_to_p);
                        v3pool.release(v1_to_xi);

                        return;
                    }

                    v3pool.release(v1);
                    v3pool.release(v2);
                    v3pool.release(p);
                    v3pool.release(xi_to_p);
                    v3pool.release(v1_to_xi);
                }
            }

            // Release world vertices
            for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){
                v3pool.release(faceVerts[j]);
            }
        }
    }
};

var planeBox_normal = new Vec3();
var plane_to_corner = new Vec3();

/**
 * @method planeBox
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PLANE | Shape.types.BOX] =
Narrowphase.prototype.planeBox = function(si,sj,xi,xj,qi,qj,bi,bj){
    sj.convexPolyhedronRepresentation.material = sj.material;
    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
    this.planeConvex(si,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj);
};

var planeConvex_v = new Vec3();
var planeConvex_normal = new Vec3();
var planeConvex_relpos = new Vec3();
var planeConvex_projected = new Vec3();

/**
 * @method planeConvex
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.planeConvex = function(
    planeShape,
    convexShape,
    planePosition,
    convexPosition,
    planeQuat,
    convexQuat,
    planeBody,
    convexBody
){
    var this$1 = this;

    // Simply return the points behind the plane.
    var worldVertex = planeConvex_v,
        worldNormal = planeConvex_normal;
    worldNormal.set(0,0,1);
    planeQuat.vmult(worldNormal,worldNormal); // Turn normal according to plane orientation

    var numContacts = 0;
    var relpos = planeConvex_relpos;
    for(var i = 0; i !== convexShape.vertices.length; i++){

        // Get world convex vertex
        worldVertex.copy(convexShape.vertices[i]);
        convexQuat.vmult(worldVertex, worldVertex);
        convexPosition.vadd(worldVertex, worldVertex);
        worldVertex.vsub(planePosition, relpos);

        var dot = worldNormal.dot(relpos);
        if(dot <= 0.0){

            var r = this$1.createContactEquation(planeBody, convexBody, planeShape, convexShape);

            // Get vertex position projected on plane
            var projected = planeConvex_projected;
            worldNormal.mult(worldNormal.dot(relpos),projected);
            worldVertex.vsub(projected, projected);
            projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane

            r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane

            // rj is now just the vector from the convex center to the vertex
            worldVertex.vsub(convexPosition, r.rj);

            // Make it relative to the body
            r.ri.vadd(planePosition, r.ri);
            r.ri.vsub(planeBody.position, r.ri);
            r.rj.vadd(convexPosition, r.rj);
            r.rj.vsub(convexBody.position, r.rj);

            this$1.result.push(r);
            numContacts++;
            if(!this$1.enableFrictionReduction){
                this$1.createFrictionEquationsFromContact(r, this$1.frictionResult);
            }
        }
    }

    if(this.enableFrictionReduction && numContacts){
        this.createFrictionFromAverage(numContacts);
    }
};

var convexConvex_sepAxis = new Vec3();
var convexConvex_q = new Vec3();

/**
 * @method convexConvex
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.convexConvex = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,faceListA,faceListB){
    var this$1 = this;

    var sepAxis = convexConvex_sepAxis;

    if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
        return;
    }

    if(si.findSeparatingAxis(sj,xi,qi,xj,qj,sepAxis,faceListA,faceListB)){
        var res = [];
        var q = convexConvex_q;
        si.clipAgainstHull(xi,qi,sj,xj,qj,sepAxis,-100,100,res);
        var numContacts = 0;
        for(var j = 0; j !== res.length; j++){
            var r = this$1.createContactEquation(bi,bj,si,sj,rsi,rsj),
                ri = r.ri,
                rj = r.rj;
            sepAxis.negate(r.ni);
            res[j].normal.negate(q);
            q.mult(res[j].depth, q);
            res[j].point.vadd(q, ri);
            rj.copy(res[j].point);

            // Contact points are in world coordinates. Transform back to relative
            ri.vsub(xi,ri);
            rj.vsub(xj,rj);

            // Make relative to bodies
            ri.vadd(xi, ri);
            ri.vsub(bi.position, ri);
            rj.vadd(xj, rj);
            rj.vsub(bj.position, rj);

            this$1.result.push(r);
            numContacts++;
            if(!this$1.enableFrictionReduction){
                this$1.createFrictionEquationsFromContact(r, this$1.frictionResult);
            }
        }
        if(this.enableFrictionReduction && numContacts){
            this.createFrictionFromAverage(numContacts);
        }
    }
};


/**
 * @method convexTrimesh
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
// Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.TRIMESH] =
// Narrowphase.prototype.convexTrimesh = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,faceListA,faceListB){
//     var sepAxis = convexConvex_sepAxis;

//     if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
//         return;
//     }

//     // Construct a temp hull for each triangle
//     var hullB = new ConvexPolyhedron();

//     hullB.faces = [[0,1,2]];
//     var va = new Vec3();
//     var vb = new Vec3();
//     var vc = new Vec3();
//     hullB.vertices = [
//         va,
//         vb,
//         vc
//     ];

//     for (var i = 0; i < sj.indices.length / 3; i++) {

//         var triangleNormal = new Vec3();
//         sj.getNormal(i, triangleNormal);
//         hullB.faceNormals = [triangleNormal];

//         sj.getTriangleVertices(i, va, vb, vc);

//         var d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
//         if(!d){
//             triangleNormal.scale(-1, triangleNormal);
//             d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);

//             if(!d){
//                 continue;
//             }
//         }

//         var res = [];
//         var q = convexConvex_q;
//         si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);
//         for(var j = 0; j !== res.length; j++){
//             var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
//                 ri = r.ri,
//                 rj = r.rj;
//             r.ni.copy(triangleNormal);
//             r.ni.negate(r.ni);
//             res[j].normal.negate(q);
//             q.mult(res[j].depth, q);
//             res[j].point.vadd(q, ri);
//             rj.copy(res[j].point);

//             // Contact points are in world coordinates. Transform back to relative
//             ri.vsub(xi,ri);
//             rj.vsub(xj,rj);

//             // Make relative to bodies
//             ri.vadd(xi, ri);
//             ri.vsub(bi.position, ri);
//             rj.vadd(xj, rj);
//             rj.vsub(bj.position, rj);

//             result.push(r);
//         }
//     }
// };

var particlePlane_normal = new Vec3();
var particlePlane_relpos = new Vec3();
var particlePlane_projected = new Vec3();

/**
 * @method particlePlane
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PLANE | Shape.types.PARTICLE] =
Narrowphase.prototype.planeParticle = function(sj,si,xj,xi,qj,qi,bj,bi){
    var normal = particlePlane_normal;
    normal.set(0,0,1);
    bj.quaternion.vmult(normal,normal); // Turn normal according to plane orientation
    var relpos = particlePlane_relpos;
    xi.vsub(bj.position,relpos);
    var dot = normal.dot(relpos);
    if(dot <= 0.0){
        var r = this.createContactEquation(bi,bj,si,sj);
        r.ni.copy(normal); // Contact normal is the plane normal
        r.ni.negate(r.ni);
        r.ri.set(0,0,0); // Center of particle

        // Get particle position projected on plane
        var projected = particlePlane_projected;
        normal.mult(normal.dot(xi),projected);
        xi.vsub(projected,projected);
        //projected.vadd(bj.position,projected);

        // rj is now the projected world position minus plane position
        r.rj.copy(projected);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
};

var particleSphere_normal = new Vec3();

/**
 * @method particleSphere
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.SPHERE] =
Narrowphase.prototype.sphereParticle = function(sj,si,xj,xi,qj,qi,bj,bi){
    // The normal is the unit vector from sphere center to particle center
    var normal = particleSphere_normal;
    normal.set(0,0,1);
    xi.vsub(xj,normal);
    var lengthSquared = normal.norm2();

    if(lengthSquared <= sj.radius * sj.radius){
        var r = this.createContactEquation(bi,bj,si,sj);
        normal.normalize();
        r.rj.copy(normal);
        r.rj.mult(sj.radius,r.rj);
        r.ni.copy(normal); // Contact normal
        r.ni.negate(r.ni);
        r.ri.set(0,0,0); // Center of particle
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
};

// WIP
var cqj = new Quaternion();
var convexParticle_local = new Vec3();
var convexParticle_normal = new Vec3();
var convexParticle_penetratedFaceNormal = new Vec3();
var convexParticle_vertexToParticle = new Vec3();
var convexParticle_worldPenetrationVec = new Vec3();

/**
 * @method convexParticle
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.convexParticle = function(sj,si,xj,xi,qj,qi,bj,bi){
    var penetratedFaceIndex = -1;
    var penetratedFaceNormal = convexParticle_penetratedFaceNormal;
    var worldPenetrationVec = convexParticle_worldPenetrationVec;
    var minPenetration = null;
    var local = convexParticle_local;
    local.copy(xi);
    local.vsub(xj,local); // Convert position to relative the convex origin
    qj.conjugate(cqj);
    cqj.vmult(local,local);

    if(sj.pointIsInside(local)){

        if(sj.worldVerticesNeedsUpdate){
            sj.computeWorldVertices(xj,qj);
        }
        if(sj.worldFaceNormalsNeedsUpdate){
            sj.computeWorldFaceNormals(qj);
        }

        // For each world polygon in the polyhedra
        for(var i=0,nfaces=sj.faces.length; i!==nfaces; i++){

            // Construct world face vertices
            var verts = [ sj.worldVertices[ sj.faces[i][0] ] ];
            var normal = sj.worldFaceNormals[i];

            // Check how much the particle penetrates the polygon plane.
            xi.vsub(verts[0],convexParticle_vertexToParticle);
            var penetration = -normal.dot(convexParticle_vertexToParticle);
            if(minPenetration===null || Math.abs(penetration)<Math.abs(minPenetration)){
                minPenetration = penetration;
                penetratedFaceIndex = i;
                penetratedFaceNormal.copy(normal);
                
            }
        }

        if(penetratedFaceIndex!==-1){
            // Setup contact
            var r = this.createContactEquation(bi,bj,si,sj);
            penetratedFaceNormal.mult(minPenetration, worldPenetrationVec);

            // rj is the particle position projected to the face
            worldPenetrationVec.vadd(xi,worldPenetrationVec);
            worldPenetrationVec.vsub(xj,worldPenetrationVec);
            r.rj.copy(worldPenetrationVec);
            //var projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);
            //projectedToFace.copy(r.rj);

            //qj.vmult(r.rj,r.rj);
            penetratedFaceNormal.negate( r.ni ); // Contact normal
            r.ri.set(0,0,0); // Center of particle

            var ri = r.ri,
                rj = r.rj;

            // Make relative to bodies
            ri.vadd(xi, ri);
            ri.vsub(bi.position, ri);
            rj.vadd(xj, rj);
            rj.vsub(bj.position, rj);

            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
        } else {
            console.warn("Point found inside convex, but did not find penetrating face!");
        }
    }
};

Narrowphase.prototype[Shape.types.BOX | Shape.types.HEIGHTFIELD] =
Narrowphase.prototype.boxHeightfield = function (si,sj,xi,xj,qi,qj,bi,bj){
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    this.convexHeightfield(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj);
};

var convexHeightfield_tmp1 = new Vec3();
var convexHeightfield_tmp2 = new Vec3();
var convexHeightfield_faceList = [0];

/**
 * @method convexHeightfield
 */
Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD] =
Narrowphase.prototype.convexHeightfield = function (
    convexShape,
    hfShape,
    convexPos,
    hfPos,
    convexQuat,
    hfQuat,
    convexBody,
    hfBody
){
    var this$1 = this;

    var data = hfShape.data,
        w = hfShape.elementSize,
        radius = convexShape.boundingSphereRadius,
        worldPillarOffset = convexHeightfield_tmp2,
        faceList = convexHeightfield_faceList;

    // Get sphere position to heightfield local!
    var localConvexPos = convexHeightfield_tmp1;
    Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos);

    // Get the index of the data points to test against
    var iMinX = Math.floor((localConvexPos.x - radius) / w) - 1,
        iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1,
        iMinY = Math.floor((localConvexPos.y - radius) / w) - 1,
        iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1;

    // Bail out if we are out of the terrain
    if(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length){
        return;
    }

    // Clamp index to edges
    if(iMinX < 0){ iMinX = 0; }
    if(iMaxX < 0){ iMaxX = 0; }
    if(iMinY < 0){ iMinY = 0; }
    if(iMaxY < 0){ iMaxY = 0; }
    if(iMinX >= data.length){ iMinX = data.length - 1; }
    if(iMaxX >= data.length){ iMaxX = data.length - 1; }
    if(iMaxY >= data[0].length){ iMaxY = data[0].length - 1; }
    if(iMinY >= data[0].length){ iMinY = data[0].length - 1; }

    var minMax = [];
    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
    var min = minMax[0];
    var max = minMax[1];

    // Bail out if we're cant touch the bounding height box
    if(localConvexPos.z - radius > max || localConvexPos.z + radius < min){
        return;
    }

    for(var i = iMinX; i < iMaxX; i++){
        for(var j = iMinY; j < iMaxY; j++){

            // Lower triangle
            hfShape.getConvexTrianglePillar(i, j, false);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
                this$1.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, faceList, null);
            }

            // Upper triangle
            hfShape.getConvexTrianglePillar(i, j, true);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
                this$1.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, faceList, null);
            }
        }
    }
};

var sphereHeightfield_tmp1 = new Vec3();
var sphereHeightfield_tmp2 = new Vec3();

/**
 * @method sphereHeightfield
 */
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.HEIGHTFIELD] =
Narrowphase.prototype.sphereHeightfield = function (
    sphereShape,
    hfShape,
    spherePos,
    hfPos,
    sphereQuat,
    hfQuat,
    sphereBody,
    hfBody
){
    var this$1 = this;

    var data = hfShape.data,
        radius = sphereShape.radius,
        w = hfShape.elementSize,
        worldPillarOffset = sphereHeightfield_tmp2;

    // Get sphere position to heightfield local!
    var localSpherePos = sphereHeightfield_tmp1;
    Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos);

    // Get the index of the data points to test against
    var iMinX = Math.floor((localSpherePos.x - radius) / w) - 1,
        iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1,
        iMinY = Math.floor((localSpherePos.y - radius) / w) - 1,
        iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1;

    // Bail out if we are out of the terrain
    if(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMaxY > data[0].length){
        return;
    }

    // Clamp index to edges
    if(iMinX < 0){ iMinX = 0; }
    if(iMaxX < 0){ iMaxX = 0; }
    if(iMinY < 0){ iMinY = 0; }
    if(iMaxY < 0){ iMaxY = 0; }
    if(iMinX >= data.length){ iMinX = data.length - 1; }
    if(iMaxX >= data.length){ iMaxX = data.length - 1; }
    if(iMaxY >= data[0].length){ iMaxY = data[0].length - 1; }
    if(iMinY >= data[0].length){ iMinY = data[0].length - 1; }

    var minMax = [];
    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
    var min = minMax[0];
    var max = minMax[1];

    // Bail out if we're cant touch the bounding height box
    if(localSpherePos.z - radius > max || localSpherePos.z + radius < min){
        return;
    }

    var result = this.result;
    for(var i = iMinX; i < iMaxX; i++){
        for(var j = iMinY; j < iMaxY; j++){

            var numContactsBefore = result.length;

            // Lower triangle
            hfShape.getConvexTrianglePillar(i, j, false);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
                this$1.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody);
            }

            // Upper triangle
            hfShape.getConvexTrianglePillar(i, j, true);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
                this$1.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody);
            }

            var numContacts = result.length - numContactsBefore;

            if(numContacts > 2){
                return;
            }
            /*
            // Skip all but 1
            for (var k = 0; k < numContacts - 1; k++) {
                result.pop();
            }
            */
        }
    }
};

},{"../collision/AABB":3,"../collision/Ray":9,"../equations/ContactEquation":19,"../equations/FrictionEquation":21,"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"../shapes/ConvexPolyhedron":38,"../shapes/Shape":43,"../solver/Solver":47,"../utils/Vec3Pool":54}],56:[function(_dereq_,module,exports){
/* global performance */

module.exports = World;

var Shape = _dereq_('../shapes/Shape');
var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var GSSolver = _dereq_('../solver/GSSolver');
var Vec3Pool = _dereq_('../utils/Vec3Pool');
var ContactEquation = _dereq_('../equations/ContactEquation');
var FrictionEquation = _dereq_('../equations/FrictionEquation');
var Narrowphase = _dereq_('./Narrowphase');
var EventTarget = _dereq_('../utils/EventTarget');
var ArrayCollisionMatrix = _dereq_('../collision/ArrayCollisionMatrix');
var Material = _dereq_('../material/Material');
var ContactMaterial = _dereq_('../material/ContactMaterial');
var Body = _dereq_('../objects/Body');
var TupleDictionary = _dereq_('../utils/TupleDictionary');
var RaycastResult = _dereq_('../collision/RaycastResult');
var AABB = _dereq_('../collision/AABB');
var Ray = _dereq_('../collision/Ray');
var NaiveBroadphase = _dereq_('../collision/NaiveBroadphase');

/**
 * The physics world
 * @class World
 * @constructor
 * @extends EventTarget
 */
function World(){
    EventTarget.apply(this);

    /**
     * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is "fresh" inside event callbacks.
     * @property {Number} dt
     */
    this.dt = -1;

    /**
     * Makes bodies go to sleep when they've been inactive
     * @property allowSleep
     * @type {Boolean}
     */
    this.allowSleep = false;

    /**
     * All the current contacts (instances of ContactEquation) in the world.
     * @property contacts
     * @type {Array}
     */
    this.contacts = [];
    this.frictionEquations = [];

    /**
     * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
     * @property quatNormalizeSkip
     * @type {Number}
     */
    this.quatNormalizeSkip = 0;

    /**
     * Set to true to use fast quaternion normalization. It is often enough accurate to use. If bodies tend to explode, set to false.
     * @property quatNormalizeFast
     * @type {Boolean}
     * @see Quaternion.normalizeFast
     * @see Quaternion.normalize
     */
    this.quatNormalizeFast = false;

    /**
     * The wall-clock time since simulation start
     * @property time
     * @type {Number}
     */
    this.time = 0.0;

    /**
     * Number of timesteps taken since start
     * @property stepnumber
     * @type {Number}
     */
    this.stepnumber = 0;

    /// Default and last timestep sizes
    this.default_dt = 1/60;

    this.nextId = 0;
    /**
     * @property gravity
     * @type {Vec3}
     */
    this.gravity = new Vec3();

    /**
     * @property broadphase
     * @type {Broadphase}
     */
    this.broadphase = new NaiveBroadphase();

    /**
     * @property bodies
     * @type {Array}
     */
    this.bodies = [];

    /**
     * @property solver
     * @type {Solver}
     */
    this.solver = new GSSolver();

    /**
     * @property constraints
     * @type {Array}
     */
    this.constraints = [];

    /**
     * @property narrowphase
     * @type {Narrowphase}
     */
    this.narrowphase = new Narrowphase(this);

    /**
     * @property {ArrayCollisionMatrix} collisionMatrix
	 * @type {ArrayCollisionMatrix}
	 */
	this.collisionMatrix = new ArrayCollisionMatrix();

    /**
     * CollisionMatrix from the previous step.
     * @property {ArrayCollisionMatrix} collisionMatrixPrevious
	 * @type {ArrayCollisionMatrix}
	 */
	this.collisionMatrixPrevious = new ArrayCollisionMatrix();

    /**
     * All added materials
     * @property materials
     * @type {Array}
     */
    this.materials = [];

    /**
     * @property contactmaterials
     * @type {Array}
     */
    this.contactmaterials = [];

    /**
     * Used to look up a ContactMaterial given two instances of Material.
     * @property {TupleDictionary} contactMaterialTable
     */
    this.contactMaterialTable = new TupleDictionary();

    this.defaultMaterial = new Material("default");

    /**
     * This contact material is used if no suitable contactmaterial is found for a contact.
     * @property defaultContactMaterial
     * @type {ContactMaterial}
     */
    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, { friction: 0.3, restitution: 0.0 });

    /**
     * @property doProfiling
     * @type {Boolean}
     */
    this.doProfiling = false;

    /**
     * @property profile
     * @type {Object}
     */
    this.profile = {
        solve:0,
        makeContactConstraints:0,
        broadphase:0,
        integrate:0,
        narrowphase:0,
    };

    /**
     * @property subsystems
     * @type {Array}
     */
    this.subsystems = [];

    this.addBodyEvent = {
        type:"addBody",
        body : null,
    };

    this.removeBodyEvent = {
        type:"removeBody",
        body : null,
    };
}
World.prototype = new EventTarget();

// Temp stuff
var tmpAABB1 = new AABB();
var tmpRay = new Ray();

/**
 * Get the contact material between materials m1 and m2
 * @method getContactMaterial
 * @param {Material} m1
 * @param {Material} m2
 * @return {ContactMaterial} The contact material if it was found.
 */
World.prototype.getContactMaterial = function(m1,m2){
    return this.contactMaterialTable.get(m1.id,m2.id); //this.contactmaterials[this.mats2cmat[i+j*this.materials.length]];
};

/**
 * Get number of objects in the world.
 * @method numObjects
 * @return {Number}
 * @deprecated
 */
World.prototype.numObjects = function(){
    return this.bodies.length;
};

/**
 * Store old collision state info
 * @method collisionMatrixTick
 */
World.prototype.collisionMatrixTick = function(){
	var temp = this.collisionMatrixPrevious;
	this.collisionMatrixPrevious = this.collisionMatrix;
	this.collisionMatrix = temp;
	this.collisionMatrix.reset();
};

/**
 * Add a rigid body to the simulation.
 * @method add
 * @param {Body} body
 * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
 * @todo Adding an array of bodies should be possible. This would save some loops too
 * @deprecated Use .addBody instead
 */
World.prototype.add = World.prototype.addBody = function(body){
    if(this.bodies.indexOf(body) !== -1){
        return;
    }
    body.index = this.bodies.length;
    this.bodies.push(body);
    body.world = this;
    body.initPosition.copy(body.position);
    body.initVelocity.copy(body.velocity);
    body.timeLastSleepy = this.time;
    if(body instanceof Body){
        body.initAngularVelocity.copy(body.angularVelocity);
        body.initQuaternion.copy(body.quaternion);
    }
	this.collisionMatrix.setNumObjects(this.bodies.length);
    this.addBodyEvent.body = body;
    this.dispatchEvent(this.addBodyEvent);
};

/**
 * Add a constraint to the simulation.
 * @method addConstraint
 * @param {Constraint} c
 */
World.prototype.addConstraint = function(c){
    this.constraints.push(c);
};

/**
 * Removes a constraint
 * @method removeConstraint
 * @param {Constraint} c
 */
World.prototype.removeConstraint = function(c){
    var idx = this.constraints.indexOf(c);
    if(idx!==-1){
        this.constraints.splice(idx,1);
    }
};

/**
 * Raycast test
 * @method rayTest
 * @param {Vec3} from
 * @param {Vec3} to
 * @param {Function|RaycastResult} result
 * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.
 */
World.prototype.rayTest = function(from, to, result){
    if(result instanceof RaycastResult){
        // Do raycastclosest
        this.raycastClosest(from, to, {
            skipBackfaces: true
        }, result);
    } else {
        // Do raycastAll
        this.raycastAll(from, to, {
            skipBackfaces: true
        }, result);
    }
};

/**
 * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
 * @method raycastAll
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionFilterMask=-1]
 * @param  {number} [options.collisionFilterGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {Function} callback
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastAll = function(from, to, options, callback){
    options.mode = Ray.ALL;
    options.from = from;
    options.to = to;
    options.callback = callback;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
 * @method raycastAny
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionFilterMask=-1]
 * @param  {number} [options.collisionFilterGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {RaycastResult} result
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastAny = function(from, to, options, result){
    options.mode = Ray.ANY;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Ray cast, and return information of the closest hit.
 * @method raycastClosest
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionFilterMask=-1]
 * @param  {number} [options.collisionFilterGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {RaycastResult} result
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastClosest = function(from, to, options, result){
    options.mode = Ray.CLOSEST;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Remove a rigid body from the simulation.
 * @method remove
 * @param {Body} body
 * @deprecated Use .removeBody instead
 */
World.prototype.remove = function(body){
    body.world = null;
    var n = this.bodies.length-1,
        bodies = this.bodies,
        idx = bodies.indexOf(body);
    if(idx !== -1){
        bodies.splice(idx, 1); // Todo: should use a garbage free method

        // Recompute index
        for(var i=0; i!==bodies.length; i++){
            bodies[i].index = i;
        }

        this.collisionMatrix.setNumObjects(n);
        this.removeBodyEvent.body = body;
        this.dispatchEvent(this.removeBodyEvent);
    }
};

/**
 * Remove a rigid body from the simulation.
 * @method removeBody
 * @param {Body} body
 */
World.prototype.removeBody = World.prototype.remove;

/**
 * Adds a material to the World.
 * @method addMaterial
 * @param {Material} m
 * @todo Necessary?
 */
World.prototype.addMaterial = function(m){
    this.materials.push(m);
};

/**
 * Adds a contact material to the World
 * @method addContactMaterial
 * @param {ContactMaterial} cmat
 */
World.prototype.addContactMaterial = function(cmat) {

    // Add contact material
    this.contactmaterials.push(cmat);

    // Add current contact material to the material table
    this.contactMaterialTable.set(cmat.materials[0].id,cmat.materials[1].id,cmat);
};

// performance.now()
if(typeof performance === 'undefined'){
    performance = {};
}
if(!performance.now){
    var nowOffset = Date.now();
    if (performance.timing && performance.timing.navigationStart){
        nowOffset = performance.timing.navigationStart;
    }
    performance.now = function(){
        return Date.now() - nowOffset;
    };
}

var step_tmp1 = new Vec3();

/**
 * Step the physics world forward in time.
 *
 * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
 *
 * @method step
 * @param {Number} dt                       The fixed time step size to use.
 * @param {Number} [timeSinceLastCalled]    The time elapsed since the function was last called.
 * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
 *
 * @example
 *     // fixed timestepping without interpolation
 *     world.step(1/60);
 *
 * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
 */
World.prototype.step = function(dt, timeSinceLastCalled, maxSubSteps){
    var this$1 = this;

    maxSubSteps = maxSubSteps || 10;
    timeSinceLastCalled = timeSinceLastCalled || 0;

    if(timeSinceLastCalled === 0){ // Fixed, simple stepping

        this.internalStep(dt);

        // Increment time
        this.time += dt;

    } else {

        // Compute the number of fixed steps we should have taken since the last step
        var internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
        internalSteps = Math.min(internalSteps,maxSubSteps);

        // Do some fixed steps to catch up
        var t0 = performance.now();
        for(var i=0; i!==internalSteps; i++){
            this$1.internalStep(dt);
            if(performance.now() - t0 > dt * 1000){
                // We are slower than real-time. Better bail out.
                break;
            }
        }

        // Increment internal clock
        this.time += timeSinceLastCalled;

        // Compute "Left over" time step
        var h = this.time % dt;
        var h_div_dt = h / dt;
        var interpvelo = step_tmp1;
        var bodies = this.bodies;

        for(var j=0; j !== bodies.length; j++){
            var b = bodies[j];
            if(b.type !== Body.STATIC && b.sleepState !== Body.SLEEPING){

                // Interpolate
                b.position.vsub(b.previousPosition, interpvelo);
                interpvelo.scale(h_div_dt, interpvelo);
                b.position.vadd(interpvelo, b.interpolatedPosition);

                // TODO: interpolate quaternion
                // b.interpolatedAngle = b.angle + (b.angle - b.previousAngle) * h_div_dt;

            } else {

                // For static bodies, just copy. Who else will do it?
                b.interpolatedPosition.copy(b.position);
                b.interpolatedQuaternion.copy(b.quaternion);
            }
        }
    }
};

/**
 * Step the simulation
 * @method step
 * @param {Number} dt
 */
var World_step_postStepEvent = {type:"postStep"}, // Reusable event objects to save memory
    World_step_preStepEvent = {type:"preStep"},
    World_step_collideEvent = {type:"collide", body:null, contact:null },
    World_step_oldContacts = [], // Pools for unused objects
    World_step_frictionEquationPool = [],
    World_step_p1 = [], // Reusable arrays for collision pairs
    World_step_p2 = [],
    World_step_gvec = new Vec3(), // Temporary vectors and quats
    World_step_vi = new Vec3(),
    World_step_vj = new Vec3(),
    World_step_wi = new Vec3(),
    World_step_wj = new Vec3(),
    World_step_t1 = new Vec3(),
    World_step_t2 = new Vec3(),
    World_step_rixn = new Vec3(),
    World_step_rjxn = new Vec3(),
    World_step_step_q = new Quaternion(),
    World_step_step_w = new Quaternion(),
    World_step_step_wq = new Quaternion(),
    invI_tau_dt = new Vec3();
World.prototype.internalStep = function(dt){
    var this$1 = this;

    this.dt = dt;

    var world = this,
        that = this,
        contacts = this.contacts,
        p1 = World_step_p1,
        p2 = World_step_p2,
        N = this.numObjects(),
        bodies = this.bodies,
        solver = this.solver,
        gravity = this.gravity,
        doProfiling = this.doProfiling,
        profile = this.profile,
        DYNAMIC = Body.DYNAMIC,
        profilingStart,
        constraints = this.constraints,
        frictionEquationPool = World_step_frictionEquationPool,
        gnorm = gravity.norm(),
        gx = gravity.x,
        gy = gravity.y,
        gz = gravity.z,
        i=0;

    if(doProfiling){
        profilingStart = performance.now();
    }

    // Add gravity to all objects
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        if(bi.type & DYNAMIC){ // Only for dynamic bodies
            var f = bi.force, m = bi.mass;
            f.x += m*gx;
            f.y += m*gy;
            f.z += m*gz;
        }
    }

    // Update subsystems
    for(var i=0, Nsubsystems=this.subsystems.length; i!==Nsubsystems; i++){
        this$1.subsystems[i].update();
    }

    // Collision detection
    if(doProfiling){ profilingStart = performance.now(); }
    p1.length = 0; // Clean up pair arrays from last step
    p2.length = 0;
    this.broadphase.collisionPairs(this,p1,p2);
    if(doProfiling){ profile.broadphase = performance.now() - profilingStart; }

    // Remove constrained pairs with collideConnected == false
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        var c = constraints[i];
        if(!c.collideConnected){
            for(var j = p1.length-1; j>=0; j-=1){
                if( (c.bodyA === p1[j] && c.bodyB === p2[j]) ||
                    (c.bodyB === p1[j] && c.bodyA === p2[j])){
                    p1.splice(j, 1);
                    p2.splice(j, 1);
                }
            }
        }
    }

    this.collisionMatrixTick();

    // Generate contacts
    if(doProfiling){ profilingStart = performance.now(); }
    var oldcontacts = World_step_oldContacts;
    var NoldContacts = contacts.length;

    for(i=0; i!==NoldContacts; i++){
        oldcontacts.push(contacts[i]);
    }
    contacts.length = 0;

    // Transfer FrictionEquation from current list to the pool for reuse
    var NoldFrictionEquations = this.frictionEquations.length;
    for(i=0; i!==NoldFrictionEquations; i++){
        frictionEquationPool.push(this$1.frictionEquations[i]);
    }
    this.frictionEquations.length = 0;

    this.narrowphase.getContacts(
        p1,
        p2,
        this,
        contacts,
        oldcontacts, // To be reused
        this.frictionEquations,
        frictionEquationPool
    );

    if(doProfiling){
        profile.narrowphase = performance.now() - profilingStart;
    }

    // Loop over all collisions
    if(doProfiling){
        profilingStart = performance.now();
    }

    // Add all friction eqs
    for (var i = 0; i < this.frictionEquations.length; i++) {
        solver.addEquation(this$1.frictionEquations[i]);
    }

    var ncontacts = contacts.length;
    for(var k=0; k!==ncontacts; k++){

        // Current contact
        var c = contacts[k];

        // Get current collision indeces
        var bi = c.bi,
            bj = c.bj,
            si = c.si,
            sj = c.sj;

        // Get collision properties
        var cm;
        if(bi.material && bj.material){
            cm = this$1.getContactMaterial(bi.material,bj.material) || this$1.defaultContactMaterial;
        } else {
            cm = this$1.defaultContactMaterial;
        }

        // c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

        var mu = cm.friction;
        // c.restitution = cm.restitution;

        // If friction or restitution were specified in the material, use them
        if(bi.material && bj.material){
            if(bi.material.friction >= 0 && bj.material.friction >= 0){
                mu = bi.material.friction * bj.material.friction;
            }

            if(bi.material.restitution >= 0 && bj.material.restitution >= 0){
                c.restitution = bi.material.restitution * bj.material.restitution;
            }
        }

		// c.setSpookParams(
  //           cm.contactEquationStiffness,
  //           cm.contactEquationRelaxation,
  //           dt
  //       );

		solver.addEquation(c);

		// // Add friction constraint equation
		// if(mu > 0){

		// 	// Create 2 tangent equations
		// 	var mug = mu * gnorm;
		// 	var reducedMass = (bi.invMass + bj.invMass);
		// 	if(reducedMass > 0){
		// 		reducedMass = 1/reducedMass;
		// 	}
		// 	var pool = frictionEquationPool;
		// 	var c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
		// 	var c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
		// 	this.frictionEquations.push(c1, c2);

		// 	c1.bi = c2.bi = bi;
		// 	c1.bj = c2.bj = bj;
		// 	c1.minForce = c2.minForce = -mug*reducedMass;
		// 	c1.maxForce = c2.maxForce = mug*reducedMass;

		// 	// Copy over the relative vectors
		// 	c1.ri.copy(c.ri);
		// 	c1.rj.copy(c.rj);
		// 	c2.ri.copy(c.ri);
		// 	c2.rj.copy(c.rj);

		// 	// Construct tangents
		// 	c.ni.tangents(c1.t, c2.t);

  //           // Set spook params
  //           c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
  //           c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);

  //           c1.enabled = c2.enabled = c.enabled;

		// 	// Add equations to solver
		// 	solver.addEquation(c1);
		// 	solver.addEquation(c2);
		// }

        if( bi.allowSleep &&
            bi.type === Body.DYNAMIC &&
            bi.sleepState  === Body.SLEEPING &&
            bj.sleepState  === Body.AWAKE &&
            bj.type !== Body.STATIC
        ){
            var speedSquaredB = bj.velocity.norm2() + bj.angularVelocity.norm2();
            var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);
            if(speedSquaredB >= speedLimitSquaredB*2){
                bi._wakeUpAfterNarrowphase = true;
            }
        }

        if( bj.allowSleep &&
            bj.type === Body.DYNAMIC &&
            bj.sleepState  === Body.SLEEPING &&
            bi.sleepState  === Body.AWAKE &&
            bi.type !== Body.STATIC
        ){
            var speedSquaredA = bi.velocity.norm2() + bi.angularVelocity.norm2();
            var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);
            if(speedSquaredA >= speedLimitSquaredA*2){
                bj._wakeUpAfterNarrowphase = true;
            }
        }

        // Now we know that i and j are in contact. Set collision matrix state
		this$1.collisionMatrix.set(bi, bj, true);

        if (!this$1.collisionMatrixPrevious.get(bi, bj)) {
            // First contact!
            // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.
            World_step_collideEvent.body = bj;
            World_step_collideEvent.contact = c;
            bi.dispatchEvent(World_step_collideEvent);

            World_step_collideEvent.body = bi;
            bj.dispatchEvent(World_step_collideEvent);
        }
    }
    if(doProfiling){
        profile.makeContactConstraints = performance.now() - profilingStart;
        profilingStart = performance.now();
    }

    // Wake up bodies
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        if(bi._wakeUpAfterNarrowphase){
            bi.wakeUp();
            bi._wakeUpAfterNarrowphase = false;
        }
    }

    // Add user-added constraints
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        var c = constraints[i];
        c.update();
        for(var j=0, Neq=c.equations.length; j!==Neq; j++){
            var eq = c.equations[j];
            solver.addEquation(eq);
        }
    }

    // Solve the constrained system
    solver.solve(dt,this);

    if(doProfiling){
        profile.solve = performance.now() - profilingStart;
    }

    // Remove all contacts from solver
    solver.removeAllEquations();

    // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details
    var pow = Math.pow;
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        if(bi.type & DYNAMIC){ // Only for dynamic bodies
            var ld = pow(1.0 - bi.linearDamping,dt);
            var v = bi.velocity;
            v.mult(ld,v);
            var av = bi.angularVelocity;
            if(av){
                var ad = pow(1.0 - bi.angularDamping,dt);
                av.mult(ad,av);
            }
        }
    }

    this.dispatchEvent(World_step_preStepEvent);

    // Invoke pre-step callbacks
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        if(bi.preStep){
            bi.preStep.call(bi);
        }
    }

    // Leap frog
    // vnew = v + h*f/m
    // xnew = x + h*vnew
    if(doProfiling){
        profilingStart = performance.now();
    }
    var w = World_step_step_w;
    var wq = World_step_step_wq;
    var stepnumber = this.stepnumber;
    var DYNAMIC_OR_KINEMATIC = Body.DYNAMIC | Body.KINEMATIC;
    var quatNormalize = stepnumber % (this.quatNormalizeSkip+1) === 0;
    var quatNormalizeFast = this.quatNormalizeFast;
    var half_dt = dt * 0.5;
    var PLANE = Shape.types.PLANE,
        CONVEX = Shape.types.CONVEXPOLYHEDRON;

    for(i=0; i!==N; i++){
        var b = bodies[i],
            force = b.force,
            tau = b.torque;
        if((b.type & DYNAMIC_OR_KINEMATIC) && b.sleepState !== Body.SLEEPING){ // Only for dynamic
            var velo = b.velocity,
                angularVelo = b.angularVelocity,
                pos = b.position,
                quat = b.quaternion,
                invMass = b.invMass,
                invInertia = b.invInertiaWorld;

            velo.x += force.x * invMass * dt;
            velo.y += force.y * invMass * dt;
            velo.z += force.z * invMass * dt;

            if(b.angularVelocity){
                invInertia.vmult(tau,invI_tau_dt);
                invI_tau_dt.mult(dt,invI_tau_dt);
                invI_tau_dt.vadd(angularVelo,angularVelo);
            }

            // Use new velocity  - leap frog
            pos.x += velo.x * dt;
            pos.y += velo.y * dt;
            pos.z += velo.z * dt;

            if(b.angularVelocity){
                w.set(angularVelo.x, angularVelo.y, angularVelo.z, 0);
                w.mult(quat,wq);
                quat.x += half_dt * wq.x;
                quat.y += half_dt * wq.y;
                quat.z += half_dt * wq.z;
                quat.w += half_dt * wq.w;
                if(quatNormalize){
                    if(quatNormalizeFast){
                        quat.normalizeFast();
                    } else {
                        quat.normalize();
                    }
                }
            }

            if(b.aabb){
                b.aabbNeedsUpdate = true;
            }

            // Update world inertia
            if(b.updateInertiaWorld){
                b.updateInertiaWorld();
            }
        }
    }
    this.clearForces();

    this.broadphase.dirty = true;

    if(doProfiling){
        profile.integrate = performance.now() - profilingStart;
    }

    // Update world time
    this.time += dt;
    this.stepnumber += 1;

    this.dispatchEvent(World_step_postStepEvent);

    // Invoke post-step callbacks
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        var postStep = bi.postStep;
        if(postStep){
            postStep.call(bi);
        }
    }

    // Sleeping update
    if(this.allowSleep){
        for(i=0; i!==N; i++){
            bodies[i].sleepTick(this$1.time);
        }
    }
};

/**
 * Sets all body forces in the world to zero.
 * @method clearForces
 */
World.prototype.clearForces = function(){
    var bodies = this.bodies;
    var N = bodies.length;
    for(var i=0; i !== N; i++){
        var b = bodies[i],
            force = b.force,
            tau = b.torque;

        b.force.set(0,0,0);
        b.torque.set(0,0,0);
    }
};

},{"../collision/AABB":3,"../collision/ArrayCollisionMatrix":4,"../collision/NaiveBroadphase":7,"../collision/Ray":9,"../collision/RaycastResult":10,"../equations/ContactEquation":19,"../equations/FrictionEquation":21,"../material/ContactMaterial":24,"../material/Material":25,"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"../shapes/Shape":43,"../solver/GSSolver":46,"../utils/EventTarget":49,"../utils/TupleDictionary":52,"../utils/Vec3Pool":54,"./Narrowphase":55}]},{},[2])
(2)
});
});

var fixedTimeStep = 1 / 60;
var maxSubSteps = 3;

var CannonWorld$1 = (function (superclass) {
  function CannonWorld() {
    superclass.call(this);
    this.gravity.set(0, -9.82, 0);
  }

  if ( superclass ) CannonWorld.__proto__ = superclass;
  CannonWorld.prototype = Object.create( superclass && superclass.prototype );
  CannonWorld.prototype.constructor = CannonWorld;

  CannonWorld.prototype.setGravity = function setGravity (x, y, z) {
    this.gravity.set(x, y, z);
  };
  
  CannonWorld.prototype.add = function add (comp) {
    this.addBody(comp.collider);
  };

  CannonWorld.prototype.remove = function remove (comp) {
    this.removeBody(comp.collider);
  };

  CannonWorld.prototype.step = function step (dt) {
    superclass.prototype.step.call(this, fixedTimeStep, dt, maxSubSteps);
  };

  return CannonWorld;
}(cannon.World));

var enums$4 = {
  ENGINE_BUILTIN: 0,
  ENGINE_CANNON: 1,
};

var fixedTimeStep$1 = 1 / 60;
var maxSubSteps$1 = 3;

var PhysicsSystem = (function (System) {
  function PhysicsSystem() {
    System.call(this);
    this._engine = enums$4.ENGINE_CANNON;
    this._fullSimulation = false;
  }

  if ( System ) PhysicsSystem.__proto__ = System;
  PhysicsSystem.prototype = Object.create( System && System.prototype );
  PhysicsSystem.prototype.constructor = PhysicsSystem;

  PhysicsSystem.prototype.init = function init () {
    switch (this._engine) {
      case enums$4.ENGINE_BUILTIN:
        this.world = new CannonWorld();
        break;
      case enums$4.ENGINE_CANNON:
        this.world = new CannonWorld$1();
        break;
    }
  };
  
  PhysicsSystem.prototype.add = function add (comp) {
    this.world.add(comp);
  };

  PhysicsSystem.prototype.remove = function remove (comp) {
    this.world.remove(comp);
  };

  PhysicsSystem.prototype.postTick = function postTick () {
    if (!this._fullSimulation) { return; }
    this.world.step(fixedTimeStep$1, this._app.deltaTime, maxSubSteps$1);
  };

  return PhysicsSystem;
}(System));

Object.assign(PhysicsSystem, enums$4);

var BuiltInCollider = function BuiltInCollider() {
};
  
BuiltInCollider.prototype.onDestroy = function onDestroy () {
};

var v3_tmp = vec3.zero();
var qt_tmp = quat.create();

function maxComponent(v) { return Math.max(Math.max(v.x, v.y), v.z); }

var CannonCollider = (function (superclass) {
  function CannonCollider(options) {
    var this$1 = this;

    superclass.call(this, options);
    // save the entity reference
    this._entity = options._entity;
    this._world = options._system.world;
    this._size = vec3.new(1, 1, 1);
    // create shape
    this.shapeType = options.type;
    this.shape = this.createShape(options);
    this.addShape(this.shape, new cannon.Vec3().copy(options.center));
    // dispatch collision events to entity
    this.addEventListener('collide', function (event) {
      // TODO: uniform event interface across engines
      this$1._entity.emit('collide', event);
    });
    this.updateIn = this.updateIn.bind(this);
    this.updateOut = this.updateOut.bind(this);
    this.updateIn(); // TODO: emit event after transform change perhaps?
  }

  if ( superclass ) CannonCollider.__proto__ = superclass;
  CannonCollider.prototype = Object.create( superclass && superclass.prototype );
  CannonCollider.prototype.constructor = CannonCollider;

  CannonCollider.prototype.setUpdateMode = function setUpdateMode (options) {
    if (options.in) { this._world.addEventListener('preStep', this.updateIn); }
    else { this._world.removeEventListener('preStep', this.updateIn); }
    if (options.out) { this._world.addEventListener('postStep', this.updateOut); }
    else { this._world.removeEventListener('postStep', this.updateOut); }
  };
  
  CannonCollider.prototype.createShape = function createShape (options) {
    this._entity.getWorldScale(v3_tmp);
    switch (options.type) {
      case 'box':
        vec3.scale(v3_tmp, vec3.mul(v3_tmp, v3_tmp, options.size), 0.5);
        return new cannon.Box(new cannon.Vec3(v3_tmp.x, v3_tmp.y, v3_tmp.z));
      case 'sphere':
        return new cannon.Sphere(options.radius * maxComponent(v3_tmp));
      default:
        return new cannon.Shape();
    }
  };

  CannonCollider.prototype.setFixedRotation = function setFixedRotation (val) {
    this.fixedRotation = val;
    this.updateMassProperties();
  };

  CannonCollider.prototype.setIsKinematic = function setIsKinematic (val) {
    this._isKinematic = val;
    if (val) { this.type = cannon.Body.KINEMATIC; }
    else { this.type = (this.mass <= 0 ?
      cannon.Body.STATIC : cannon.Body.DYNAMIC); }
    if (this.type !== cannon.Body.STATIC)
      { this.setUpdateMode({out: true}); }
  };

  /**
   * Set the mass of the body, note that air resistance is not 
   * simulated so the value here doesn't affect the final velocity
   * @param {number} val the new mass
   */
  CannonCollider.prototype.setMass = function setMass (val) {
    this.mass = val;
    this.setIsKinematic(this._isKinematic);
    this.updateMassProperties();
  };

  CannonCollider.prototype.setCenter = function setCenter (val) {
    this.shapeOffsets[0].set(val.x, val.y, val.z);
    this.updateBoundingRadius();
  };

  CannonCollider.prototype.setSize = function setSize (val) {
    if (this.shapeType != 'box') { return; }
    if (!val) { val = this._size; }
    this._entity.getWorldScale(v3_tmp);
    vec3.scale(v3_tmp, vec3.mul(v3_tmp, v3_tmp, val), 0.5);
    this.shape.halfExtents.set(v3_tmp.x, v3_tmp.y, v3_tmp.z);
    this.shape.updateConvexPolyhedronRepresentation();
    this.shape.updateBoundingSphereRadius();
    this.updateBoundingRadius();
    this._size = val;
  };

  CannonCollider.prototype.setRadius = function setRadius (val) {
    if (this.shapeType != 'sphere') { return; }
    this._entity.getWorldScale(v3_tmp);
    this.shape.radius = val * maxComponent(v3_tmp);
    this.shape.updateBoundingSphereRadius();
    this.updateBoundingRadius();
  };

  CannonCollider.prototype.manualUpdate = function manualUpdate () {
    this.updateIn();
    this.setSize();
  };

  CannonCollider.prototype.updateIn = function updateIn () {
    this._entity._getWorldPosAndRot(v3_tmp, qt_tmp);
    this.position.set(v3_tmp.x, v3_tmp.y, v3_tmp.z);
    if (!this.fixedRotation)
      { this.quaternion.set(qt_tmp.x, qt_tmp.y, qt_tmp.z, qt_tmp.w); }
  };

  CannonCollider.prototype.updateOut = function updateOut () {
    this._entity.setWorldPos(this.position);
    if (!this.fixedRotation)
      { this._entity.setWorldRot(this.quaternion); }
  };

  return CannonCollider;
}(cannon.Body));

var ColliderComponent = (function (Component) {
  function ColliderComponent() {
    Component.call(this);
  }

  if ( Component ) ColliderComponent.__proto__ = Component;
  ColliderComponent.prototype = Object.create( Component && Component.prototype );
  ColliderComponent.prototype.constructor = ColliderComponent;
  
  ColliderComponent.prototype.onInit = function onInit () {
    switch (this._system._engine) {
      case PhysicsSystem.ENGINE_BUILTIN:
        this.collider = new BuiltInCollider(this);
        break;
      case PhysicsSystem.ENGINE_CANNON:
        this.collider = new CannonCollider(this);
        break;
    }
    /**
     * **@schema** The collider type
     * @type {AudioClip}
     */
    this.type = this._type;
    this.mass = this._mass;
    this.isKinematic = this._isKinematic;
    this.center = this._center;
    this.size = this._size;
    this.radius = this._radius;

    this._system.add(this);
  };

  ColliderComponent.prototype.onDestroy = function onDestroy () {
    this._system.remove(this);
  };

  return ColliderComponent;
}(Component));

ColliderComponent.schema = {
  type: {
    type: 'string',
    default: 'box'
  },
  isKinematic: {
    type: 'boolean',
    default: false,
    set: function set(val) {
      this._isKinematic = val;
      this.collider.setIsKinematic(val);
      if (val) { this._system._fullSimulation = true; }
    }
  },
  mass: {
    type: 'number',
    default: 0,
    set: function set(val) {
      this._mass = val;
      this.collider.setMass(val);
      if (val > 0) { this._system._fullSimulation = true; }
    }
  },
  center: {
    type: 'vec3',
    default: [0, 0, 0],
    set: function set(val) {
      this._center = val;
      this.collider.setCenter(val);
    }
  },
  size: {
    type: 'vec3',
    default: [2, 2, 2],
    set: function set(val) {
      this._size = val;
      this.collider.setSize(val);
    }
  },
  radius: {
    type: 'number',
    default: 1,
    set: function set(val) {
      this._radius = val;
      this.collider.setRadius(val);
    }
  }
};

var SkyboxComponent = (function (Component) {
  function SkyboxComponent() {
    Component.call(this);

    this._model = new renderer.Model();
    this._attachedCamera = null;

    /**
     * **@schema** The material of the model
     * @type {Material}
     */
    this.material = this._material;
    /**
     * **@schema** The material of the model
     * @type {TextureCube}
     */
    this.cubeMap = this._cubeMap;
  }

  if ( Component ) SkyboxComponent.__proto__ = Component;
  SkyboxComponent.prototype = Object.create( Component && Component.prototype );
  SkyboxComponent.prototype.constructor = SkyboxComponent;
  
  SkyboxComponent.prototype.onInit = function onInit () {
    this._model.setNode(this._entity);

    var ia = renderer.createIA(this._app.device, box$2(2, 2, 2, {
      widthSegments: 1,
      heightSegments: 1,
      lengthSegments: 1,
    }));
    this._model.setInputAssembler(ia);

    if (this._material === null) {
      this._material = new Material();
      this._material.effect = this._app.assets.get('builtin-effect-skybox');
    }

    this._updateMaterialParams();
    this._model.setEffect(this._material.effectInst);
  };

  SkyboxComponent.prototype.onEnable = function onEnable () {
    if (this._entity != null) {
      var cameraComponent = this._entity.getComp('Camera');
      if (cameraComponent != null && (cameraComponent._clearFlags & renderer.CLEAR_SKYBOX)) {
        this._attachedCamera = cameraComponent._camera;
        this._attachedCamera._clearModel = this._model;
      }
    }
  };

  SkyboxComponent.prototype.onDisable = function onDisable () {
    if (this._attachedCamera != null) {
      this._attachedCamera._clearModel = null;
      this._attachedCamera = null;
    }
  };

  SkyboxComponent.prototype._updateMaterialParams = function _updateMaterialParams () {
    if (this._material === null || this._material === undefined) {
      return;
    }
    if (this._cubeMap !== null && this._cubeMap !== undefined) {
      this._material.setProperty('cubeMap', this._cubeMap);
    }
  };

  return SkyboxComponent;
}(Component));

SkyboxComponent.schema = {
  material: {
    type: 'asset',
    default: null,
    set: function set(val) {
      this._material = val;
      if (!this._material) { return; }
      this._updateMaterialParams();
      this._model.setEffect(val.effectInst);
    }
  },

  cubeMap: {
    type: 'asset',
    default: null,
    set: function set(val) {
      this._cubeMap = val;
      this._updateMaterialParams();
    }
  }
};

var Particle = function Particle(particleSystem) {
  this.particleSystem = particleSystem;
  this.position = vec3.new(0, 0, 0);
  this.velocity = vec3.new(0, 0, 0);
  this.animatedVelocity = vec3.new(0, 0, 0);
  this.ultimateVelocity = vec3.new(0, 0, 0);
  this.angularVelocity = vec3.new(0, 0, 0);
  this.axisOfRotation = vec3.new(0, 0, 0);
  this.rotation = vec3.new(0, 0, 0);
  this.startSize = vec3.new(0, 0, 0);
  this.size = vec3.zero();
  this.startColor = color4.new(1, 1, 1, 1);
  this.color = color4.create();
  this.randomSeed = 0; // uint
  this.remainingLifetime = 0.0;
  this.startLifetime = 0.0;
  this.emitAccumulator0 = 0.0;
  this.emitAccumulator1 = 0.0;
  this.frameIndex = 0.0;
};

var ColorKey = function ColorKey () {};

ColorKey.schema = {
  color: {
    type: 'color3',
    default: [1, 1, 1],
  },

  time: {
    type: 'number',
    default: 0.0,
  }
};

var AlphaKey = function AlphaKey () {};

AlphaKey.schema = {
  alpha: {
    type: 'number',
    default: 1.0,
  },

  time: {
    type: 'number',
    default: 0.0,
  }
};

var Gradient = function Gradient() {
  this._rgb = color3.new(1, 1, 1);
  this._rgba = color4.new(1, 1, 1, 1);
};

Gradient.prototype.setKeys = function setKeys (colorKeys, alphaKeys) {
  this._colorKeys = colorKeys;
  this._alphaKeys = alphaKeys;
};

Gradient.prototype.sortKeys = function sortKeys () {
  if (this._colorKeys.length > 1) {
    this._colorKeys.sort(function (a, b) { return a.time - b.time; });
  }
  if (this._alphaKeys.length > 1) {
    this._alphaKeys.sort(function (a, b) { return a.time - b.time; });
  }
};

Gradient.prototype.getRGB = function getRGB (time) {
    var this$1 = this;

  if (this._colorKeys.length > 1) {
    time = repeat(time, 1);
    for (var i = 1; i < this._colorKeys.length; ++i) {
      var preTime = this$1._colorKeys[i - 1].time;
      var curTime = this$1._colorKeys[i].time;
      if (time >= preTime && time < curTime) {
        if(this$1._mode === 'fixed') {
          return this$1._colorKeys[i].color;
        }
        var factor = (time - preTime) / (curTime - preTime);
        color3.lerp(this$1._rgb, this$1._colorKeys[i - 1].color, this$1._colorKeys[i].color, factor);
        return this$1._rgb;
      }
    }
    console.warn('something went wrong. can not get gradient color.');
  } else if (this._colorKeys.length === 1) {
    return this._colorKeys[0].color;
  } else {
    return color3.set(this._rgb, 1, 1, 1);
  }
};

Gradient.prototype.getAlpha = function getAlpha (time) {
    var this$1 = this;

  if (this._alphaKeys.length > 1) {
    time = repeat(time, 1);
    for (var i = 1; i < this._alphaKeys.length; ++i) {
      var preTime = this$1._alphaKeys[i - 1].time;
      var curTime = this$1._alphaKeys[i].time;
      if (time >= preTime && time < curTime) {
        if(this$1._mode === 'fixed') {
          return this$1._alphaKeys[i].alpha;
        }
        var factor = (time - preTime) / (curTime - preTime);
        return (this$1._alphaKeys[i - 1].alpha * (1 - factor) + this$1._alphaKeys[i].alpha * factor);
      }
    }
    console.warn('something went wrong. can not get gradient alpha.');
  } else if (this._alphaKeys.length === 1) {
    return this._alphaKeys[0].alpha;
  } else {
    return 1.0;
  }
};

Gradient.prototype.evaluate = function evaluate (time) {
  var rgb = this.getRGB(time);
  color4.set(this._rgba, rgb.r, rgb.g, rgb.b, this.getAlpha(time));
  return this._rgba;
};

Gradient.prototype.randomColor = function randomColor () {
  var c = this._colorKeys[Math.trunc(Math.random() * this._colorKeys.length)];
  var a = this._alphaKeys[Math.trunc(Math.random() * this._alphaKeys.length)];
  color4.set(this._rgba, c.r, c.g, c.b, a);
  return this._rgba;
};

Gradient.schema = {
  colorKeys: {
    type: 'ColorKey',
    default: [],
    array: true,
  },

  alphaKeys: {
    type: 'AlphaKey',
    default: [],
    array: true,
  },

  mode: {
    type: 'enums',
    default: 'blend',
    options: [
      'blend',
      'fixed'
    ]
  }
};

var CurveRange = function CurveRange() {

};

CurveRange.prototype.evaluate = function evaluate (time, rndRatio) {
  switch (this._mode) {
    case 'constant':
      return this._constant;
    case 'curve':
      return this._curve.evaluate(time) * this._multiplier;
    case 'twoCurves':
      return lerp(this._curveMin.evaluate(time), this._curveMax.evaluate(time), rndRatio) * this._multiplier;
    case 'twoConstants':
      return lerp(this._constantMin, this._constantMax, rndRatio);
  }
};

CurveRange.schema = {
  mode: {
    type: 'enums',
    default: 'constant',
    options: [
      'constant',
      'curve',
      'twoCurves',
      'twoConstants'
    ],
  },
  curve: {
    type: 'AnimationCurve',
    default: null
  },
  curveMin: {
    type: 'AnimationCurve',
    default: null
  },
  curveMax: {
    type: 'AnimationCurve',
    default: null
  },
  constant: {
    type: 'number',
    default: 0
  },
  constantMin: {
    type: 'number',
    default: 0
  },
  constantMax: {
    type: 'number',
    default: 0
  },
  multiplier: {
    type: 'number',
    default: 1
  }
};

var GradientRange = function GradientRange () {};

GradientRange.prototype.evaluate = function evaluate (time, rndRatio) {
  switch (this._mode) {
    case 'color':
      return this._color;
    case 'twoColors':
      return color4.set(this._color, lerp(this._colorMin.r, this._colorMax.r, rndRatio), lerp(this._colorMin.g, this._colorMax.g, rndRatio), lerp(this._colorMin.b, this._colorMax.b, rndRatio), lerp(this._colorMin.a, this._colorMax.a, rndRatio));
    case 'randomColor':
      return this._gradient.randomColor();
    case 'gradient':
      return this._gradient.evaluate(time);
    case 'twoGradients':
      this._colorMin = this._gradientMin.evaluate(time);
      this._colorMax = this._gradientMax.evaluate(time);
      return color4.set(this._color, lerp(this._colorMin.r, this._colorMax.r, rndRatio), lerp(this._colorMin.g, this._colorMax.g, rndRatio), lerp(this._colorMin.b, this._colorMax.b, rndRatio), lerp(this._colorMin.a, this._colorMax.a, rndRatio));
  }
};

GradientRange.schema = {
  mode: {
    type: 'enums',
    default: 'color',
    options: [
      'color',
      'gradient',
      'twoColors',
      'twoGradients',
      'randomColor'
    ]
  },

  color: {
    type: 'color4',
    default: [1, 1, 1, 1]
  },

  colorMin: {
    type: 'color4',
    default: [1, 1, 1, 1]
  },

  colorMax: {
    type: 'color4',
    default: [1, 1, 1, 1]
  },

  gradient: {
    type: 'Gradient',
    default: null
  },

  gradientMin: {
    type: 'Gradient',
    default: null
  },

  gradientMax: {
    type: 'Gradient',
    default: null
  }
};

var _vertAttrsCache = {
  position: vec3.zero(),
  uv: vec4.zero(),
  uv0: vec2.zero(),
  color: vec4.zero(),
  color0: vec4.zero(),
  normal: vec3.zero(),
  tangent: vec3.zero(),
};

var _name2VertAttrs = {
  'position': { name: gfx.ATTR_POSITION, type: gfx.ATTR_TYPE_FLOAT32, num: 3 },
  'uv': { name: gfx.ATTR_UV, type: gfx.ATTR_TYPE_FLOAT32, num: 3 },
  'uv0': { name: gfx.ATTR_UV0, type: gfx.ATTR_TYPE_FLOAT32, num: 2 }, // size, rotateAngle
  'color': { name: gfx.ATTR_COLOR, type: gfx.ATTR_TYPE_FLOAT32, num: 4 },
  'normal': { name: gfx.ATTR_NORMAL, type: gfx.ATTR_TYPE_FLOAT32, num: 3 }, // 3D only
  'tangent': { name: gfx.ATTR_TANGENT, type: gfx.ATTR_TYPE_FLOAT32, num: 3 }, // 3D only
  'custom1': { name: gfx.ATTR_UV1, type: gfx.ATTR_TYPE_FLOAT32, num: 2 },
  'custom2': { name: gfx.ATTR_UV2, type: gfx.ATTR_TYPE_FLOAT32, num: 2 },
};

var _uvs = [
  0, 0, // bottom-left
  1, 0, // bottom-right
  0, 1, // top-left
  1, 1  // top-right
];

var ParticleSystemRenderer = function ParticleSystemRenderer() {
  this._model = null;

  this._vertAttrs = [];
  this._vertAttrFlags = {
    position: true,
    uv: true,
    uv0: true,
    color: true,
    normal: false,
    tangent: false,
    custom1: false,
    custom2: false,
    color0: false,
  };
  this.frameTile = vec2.new(1, 1);
};

ParticleSystemRenderer.prototype.setVertexAtrributes = function setVertexAtrributes (attrs) {
    var this$1 = this;

  // clear vertex attribute flags
  for (var key in this$1._vertAttrFlags) {
    this$1._vertAttrFlags[key] = false;
  }

  for (var i = 0; i < attrs.length; ++i) {
    var attr = _name2VertAttrs[attrs[i]];
    if (attr !== undefined) {
      this$1._vertAttrs.push(attr);
      this$1._vertAttrFlags[attrs[i]] = true;
    } else {
      console.error('vertex attribute name wrong.');
    }
  }
  this._model.setVertexAttributes(this._vertAttrs);
};

ParticleSystemRenderer.prototype.onInit = function onInit (ps) {
  this.particleSystem = ps;
  if (this._material === null || this._material === undefined) {
    this._material = new Material();
    this._material.effect = ps._app.assets.get('builtin-effect-particle-premultiply-blend');
  }
  this._updateMaterialParams();
  this._updateModel();
};

ParticleSystemRenderer.prototype._updateMaterialParams = function _updateMaterialParams () {
  if (!this.particleSystem) {
    return;
  }
  if (this.particleSystem._simulationSpace === 'world') {
    this._material.define('USE_WORLD_SPACE', true);
  } else {
    this._material.define('USE_WORLD_SPACE', false);
  }

  if (this._renderMode === 'billboard') {
    this._material.define('USE_BILLBOARD', true);
    this._material.define('USE_STRETCHED_BILLBOARD', false);
    this._material.define('USE_HORIZONTAL_BILLBOARD', false);
    this._material.define('USE_VERTICAL_BILLBOARD', false);
  } else if (this._renderMode === 'stretchedBillboard') {
    this._material.define('USE_BILLBOARD', false);
    this._material.define('USE_STRETCHED_BILLBOARD', true);
    this._material.define('USE_HORIZONTAL_BILLBOARD', false);
    this._material.define('USE_VERTICAL_BILLBOARD', false);
    this._material.setProperty('velocityScale', this._velocityScale);
    this._material.setProperty('lengthScale', this._lengthScale);
  } else if (this._renderMode === 'horizontalBillboard') {
    this._material.define('USE_BILLBOARD', false);
    this._material.define('USE_STRETCHED_BILLBOARD', false);
    this._material.define('USE_HORIZONTAL_BILLBOARD', true);
    this._material.define('USE_VERTICAL_BILLBOARD', false);
  } else if (this._renderMode === 'verticalBillboard') {
    this._material.define('USE_BILLBOARD', false);
    this._material.define('USE_STRETCHED_BILLBOARD', false);
    this._material.define('USE_HORIZONTAL_BILLBOARD', false);
    this._material.define('USE_VERTICAL_BILLBOARD', true);
  } else {
    console.warn(("particle system renderMode " + (this._renderMode) + " not support."));
  }

  if (this.particleSystem.textureAnimationModule.enable) {
    this._material.setProperty('frameTile', vec2.set(this.frameTile, this.particleSystem.textureAnimationModule.numTilesX, this.particleSystem.textureAnimationModule.numTilesY));
  }
  else {
    this._material.setProperty('frameTile', this.frameTile);
  }
};

ParticleSystemRenderer.prototype._updateModel = function _updateModel () {
  if (!this.particleSystem) {
    return;
  }
  if (this._model === null) {
    this._model = new renderer.ParticleBatchModel(this.particleSystem._app.device, this.particleSystem._capacity);
    this._model.setNode(this.particleSystem._entity);
  }
  this._model.setEffect(this._material ? this._material.effectInst : null);
  if (this._renderMode === 'stretchedBillboard') {
    this._model.enableStretchedBillboard();
    this._vertAttrFlags.color0 = true;
  } else {
    this._model.disableStretchedBillboard();
    this._vertAttrFlags.color0 = false;
  }
};

// internal function
ParticleSystemRenderer.prototype._updateRenderData = function _updateRenderData () {
    var this$1 = this;

  // update vertex buffer
  var idx = 0;
  for (var i = 0; i < this.particleSystem._particles.length; ++i) {
    var p = this$1.particleSystem._particles.data[i];
    if (this$1.particleSystem.textureAnimationModule.enable) {
      _vertAttrsCache.uv.z = p.frameIndex;
    }
    else {
      _vertAttrsCache.uv.z = 0;
    }
    for (var j = 0; j < 4; ++j) { // four verts per particle.
      var attrs = [];
      if (this$1._vertAttrFlags.position) {
        attrs.push(vec3.set(_vertAttrsCache.position, p.position.x, p.position.y, p.position.z));
      }
      if (this$1._vertAttrFlags.uv) {
        _vertAttrsCache.uv.x = _uvs[2 * j];
        _vertAttrsCache.uv.y = _uvs[2 * j + 1];
        attrs.push(_vertAttrsCache.uv);
      }
      if (this$1._vertAttrFlags.uv0) {
        attrs.push(vec2.set(_vertAttrsCache.uv0, p.size.x, p.rotation.x));
      }
      if (this$1._vertAttrFlags.color) {
        attrs.push(vec4.set(_vertAttrsCache.color, p.color.r, p.color.g, p.color.b, p.color.a));
      }
      // TODO: other attrs.
      if (this$1._vertAttrFlags.custom1) {
        attrs.push(this$1._customData1);
      }
      if (this$1._vertAttrFlags.custom2) {
        attrs.push(this$1._customData2);
      }

      if (this$1._vertAttrFlags.color0) {
        attrs.push(vec3.set(_vertAttrsCache.color0, p.ultimateVelocity.x, p.ultimateVelocity.y, p.ultimateVelocity.z));
      }

      this$1._model.addParticleVertexData(idx++, attrs);
    }
  }

  // because we use index buffer, per particle index count = 6.
  this._model.updateIA(this.particleSystem._particles.length * 6);
};

ParticleSystemRenderer.schema = {
  material: {
    type: 'asset',
    default: null,
    set: function set(val) {
      if (this._material === val) {
        return;
      }

      this._material = val;
      this._updateMaterialParams();
      this._updateModel();
    },
    parse: function parse(app, value) {
      if (typeof value === 'string') {
        var matCopy = new Material();
        matCopy.copy(app.assets.get(value));
        return matCopy;
      }
      return value;
    }
  },

  renderMode: {
    type: 'enums',
    default: 'billboard',
    options: [
      'billboard',
      'stretchedBillboard',
      'horizontalBillboard',
      'verticalBillboard',
      'mesh' ],
    set: function set(val) {
      if (this._renderMode === val) {
        return;
      }
      this._renderMode = val;
      this._updateMaterialParams();
      this._updateModel();
    }
  },

  velocityScale: {
    type: 'number',
    default: 1.0,
    set: function set(val) {
      this._velocityScale = val;
      this._updateMaterialParams();
      this._updateModel();
    }
  },

  lengthScale: {
    type: 'number',
    default: 0.4,
    set: function set(val) {
      this._lengthScale = val;
      this._updateMaterialParams();
      this._updateModel();
    }
  }
};

var SizeOvertimeModule = function SizeOvertimeModule () {};

SizeOvertimeModule.prototype.animate = function animate (particle) {
  if (!this._separateAxes) {
    vec3.scale(particle.size, particle.startSize, this._size.evaluate(1 - particle.remainingLifetime / particle.startLifetime, particle.randomSeed));
  }
};

SizeOvertimeModule.schema = {
  enable: {
    type: 'boolean',
    default: false
  },

  separateAxes: {
    type: 'boolean',
    default: false
  },

  size: {
    type: 'CurveRange',
    default: null
  },

  x: {
    type: 'CurveRange',
    default: null
  },

  y: {
    type: 'CurveRange',
    default: null
  },

  z: {
    type: 'CurveRange',
    default: null
  }
};

var ColorOvertimeModule = function ColorOvertimeModule () {};

ColorOvertimeModule.prototype.animate = function animate (particle) {
  if (this._enable) {
    color4.multiply(particle.color, particle.startColor, this._color.evaluate(1.0 - particle.remainingLifetime / particle.startLifetime, particle.randomSeed));
  }
};

ColorOvertimeModule.schema = {
  enable: {
    type: 'boolean',
    default: false
  },

  color: {
    type: 'GradientRange',
    default: null
  }
};

var particleEmitZAxis = vec3.new(0, 0, -1);

function calculateTransform(systemSpace, moduleSpace, worldTransform, outQuat) {
  if (moduleSpace !== systemSpace) {
    if (systemSpace === 'world') {
      mat4.getRotation(outQuat, worldTransform);
    }
    else {
      mat4.invert(worldTransform, worldTransform);
      mat4.getRotation(outQuat, worldTransform);
    }
    return true;
  }
  else {
    quat.identity(outQuat);
    return false;
  }
}

function fixedAngleUnitVector2(out, theta) {
  vec2.set(out, Math.cos(theta), Math.sin(theta));
}



function randomUnitVector(out) {
  var z = randomRange(-1, 1);
  var a = randomRange(0, 2 * Math.PI);
  var r = Math.sqrt(1 - z * z);
  var x = r * Math.cos(a);
  var y = r * Math.sin(a);
  vec3.set(out, x, y, z);
}



function randomPointBetweenSphere(out, minRadius, maxRadius) {
  randomUnitVector(out);
  vec3.scale(out, out, minRadius + (maxRadius - minRadius) * random());
}





function randomPointBetweenCircleAtFixedAngle(out, minRadius, maxRadius, theta) {
  fixedAngleUnitVector2(out, theta);
  vec3.scale(out, out, minRadius + (maxRadius - minRadius) * random());
}

function randomPointInCube(out, extents) {
  vec3.set(out,
    randomRange(-extents.x, extents.x),
    randomRange(-extents.y, extents.y),
    randomRange(-extents.z, extents.z));
}



// FisherYates shuffle
function randomSortArray(arr) {
  for (var i = 0; i < arr.length; i++) {
    var transpose = i + randomRangeInt(0, arr.length - i);
    var val = arr[transpose];
    arr[transpose] = arr[i];
    arr[i] = val;
  }
}

function randomSign() {
  var sgn = randomRange(-1, 1);
  sgn === 0 ? sgn++ : sgn;
  return sign(sgn);
}

var VelocityOvertimeModule = function VelocityOvertimeModule() {
  this.rotation = quat.create();
};

VelocityOvertimeModule.prototype.update = function update (space, worldTransform) {
  this.needTransform = calculateTransform(space, this._space, worldTransform, this.rotation);
};

VelocityOvertimeModule.prototype.animate = function animate (p) {
  var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
  var vel = vec3.new(this._x.evaluate(normalizedTime, p.randomSeed), this._y.evaluate(normalizedTime, p.randomSeed), this._z.evaluate(normalizedTime, p.randomSeed));
  if (this.needTransform) {
    vec3.transformQuat(vel, vel, this.rotation);
  }
  vec3.add(p.animatedVelocity, p.animatedVelocity, vel);
  vec3.add(p.ultimateVelocity, p.velocity, p.animatedVelocity);
  vec3.scale(p.ultimateVelocity, p.ultimateVelocity, this._speedModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, p.randomSeed));
};

VelocityOvertimeModule.schema = {

  enable: {
    type: 'boolean',
    default: false
  },

  x: {
    type: 'CurveRange',
    default: null
  },

  y: {
    type: 'CurveRange',
    default: null
  },

  z: {
    type: 'CurveRange',
    default: null
  },

  speedModifier: {
    type: 'CurveRange',
    default: null
  },

  space: {
    type: 'enums',
    options: [
      'local',
      'world'
    ],
    default: 'local'
  }
};

var ForceOvertimeModule = function ForceOvertimeModule() {
  this.rotation = quat.create();
};

ForceOvertimeModule.prototype.update = function update (space, worldTransform) {
  this.needTransform = calculateTransform(space, this._space, worldTransform, this.rotation);
};

ForceOvertimeModule.prototype.animate = function animate (p, dt) {
  var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
  var force = vec3.new(this._x.evaluate(normalizedTime, p.randomSeed), this._y.evaluate(normalizedTime, p.randomSeed), this._z.evaluate(normalizedTime, p.randomSeed));
  if (this.needTransform) {
    vec3.transformQuat(force, force, this.rotation);
  }
  vec3.scaleAndAdd(p.velocity, p.velocity, force, dt);
};

ForceOvertimeModule.schema = {
  enable: {
    type: 'boolean',
    default: false
  },

  x: {
    type: 'CurveRange',
    default: null
  },

  y: {
    type: 'CurveRange',
    default: null
  },

  z: {
    type: 'CurveRange',
    default: null
  },

  space: {
    type: 'enums',
    default: 'local',
    options: [
      'local',
      'world'
    ]
  },
  // TODO:currently not supported
  randomized: {
    type: 'boolean',
    default: false
  }
};

var LimitVelocityOvertimeModule = function LimitVelocityOvertimeModule() {
};

LimitVelocityOvertimeModule.prototype.animate = function animate (p) {
  var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
  var dampedVel = vec3.zero();
  if (this._separateAxes) {
    vec3.set(dampedVel,
      dampenBeyondLimit(p.ultimateVelocity.x, this._limitX.evaluate(normalizedTime, p.randomSeed), this._dampen),
      dampenBeyondLimit(p.ultimateVelocity.y, this._limitY.evaluate(normalizedTime, p.randomSeed), this._dampen),
      dampenBeyondLimit(p.ultimateVelocity.z, this._limitZ.evaluate(normalizedTime, p.randomSeed), this._dampen));
  }
  else {
    vec3.normalize(dampedVel, p.ultimateVelocity);
    vec3.scale(dampedVel, dampedVel, dampenBeyondLimit(vec3.magnitude(p.ultimateVelocity), this._limit.evaluate(normalizedTime, p.randomSeed), this._dampen));
  }
  vec3.copy(p.ultimateVelocity, dampedVel);
};

function dampenBeyondLimit(vel, limit, dampen) {
  var sgn = Math.sign(vel);
  var abs = Math.abs(vel);
  if (abs > limit) {
    abs = lerp(abs, limit, dampen);
  }
  return abs * sgn;
}

LimitVelocityOvertimeModule.schema = {
  enable: {
    type: 'boolean',
    default: false
  },

  limitX: {
    type: 'CurveRange',
    default: null
  },

  limitY: {
    type: 'CurveRange',
    default: null
  },

  limitZ: {
    type: 'CurveRange',
    default: null
  },

  limit: {
    type: 'CurveRange',
    default: null
  },

  dampen: {
    type: 'number',
    default: 0
  },

  separateAxes: {
    type: 'boolean',
    default: false
  },

  space: {
    type: 'enums',
    default: 'local',
    options: [
      'local',
      'world'
    ]
  },

  // TODO:functions related to drag are temporarily not supported
  drag: {
    type: 'CurveRange',
    default: null
  },

  multiplyDragByParticleSize: {
    type: 'boolean',
    default: false
  },

  multiplyDragByParticleVelocity: {
    type: 'boolean',
    default: false
  }
};

var RotationOvertimeModule = function RotationOvertimeModule() {

};

RotationOvertimeModule.prototype.animate = function animate (p, dt) {
  var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
  if (!this._separateAxes) {
    p.rotation.x += this._z.evaluate(normalizedTime, p.randomSeed) * dt;
  }
  else {
    // TODO: separateAxes is temporarily not supported!
  }
};

RotationOvertimeModule.schema = {

  enable: {
    type: 'boolean',
    default: false
  },

  separateAxes: {
    type: 'boolean',
    default: false,
    set: function set(val) {
      if (!val) {
        this._separateAxes = val;
      }
      else {
        console.error('rotation overtime separateAxes is not supported!');
      }
    }
  },

  x: {
    type: 'CurveRange',
    default: null
  },

  y: {
    type: 'CurveRange',
    default: null
  },

  z: {
    type: 'CurveRange',
    default: null
  }
};

var TextureAnimationModule = function TextureAnimationModule () {};

TextureAnimationModule.prototype.animate = function animate (p) {
  var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
  var startFrame = this._startFrame.evaluate(normalizedTime, p.randomSeed) / (this._numTilesX * this._numTilesY);
  if (this._animation == 'wholeSheet') {
    p.frameIndex = repeat(this._cycleCount * (this._frameOverTime.evaluate(normalizedTime, p.randomSeed) + startFrame), 1);
  }
  else if (this._animation == 'singleRow') {
    var rowLength = 1 / this._numTilesY;
    if (this._randomRow) {
      var f = repeat(this._cycleCount * (this._frameOverTime.evaluate(normalizedTime, p.randomSeed) + startFrame), 1);
      var startRow = Math.floor(Math.random() * this._numTilesY);
      var from = startRow * rowLength;
      var to = from + rowLength;
      p.frameIndex = lerp(from, to, f);
    }
    else {
      var from$1 = this._rowIndex * rowLength;
      var to$1 = from$1 + rowLength;
      p.frameIndex = lerp(from$1, to$1, repeat(this._cycleCount * (this._frameOverTime.evaluate(normalizedTime, p.randomSeed) + startFrame), 1));
    }
  }
};

TextureAnimationModule.schema = {

  enable: {
    type: 'boolean',
    default: false
  },

  mode: {
    type: 'enums',
    options: [
      'grid',
      'sprites'
    ],
    default: 'grid',
    set: function set(val) {
      if (val === 'sprites') {
        console.error("particle texture animation's sprites is not supported!");
        return;
      }
    }
  },

  numTilesX: {
    type: 'number',
    default: 0
  },

  numTilesY: {
    type: 'number',
    default: 0
  },

  animation: {
    type: 'enums',
    options: [
      'wholeSheet',
      'singleRow'
    ],
    default: 'wholeSheet'
  },

  frameOverTime: {
    type: 'CurveRange',
    default: null
  },

  startFrame: {
    type: 'CurveRange',
    default: null
  },

  cycleCount: {
    type: 'number',
    default: 0
  },

  flipU: {
    type: 'number',
    default: 0,
    set: function set(val) {
      console.error("particle texture animation's flipU is not supported!");
    }
  },

  flipV: {
    type: 'number',
    default: 0,
    set: function set(val) {
      console.error("particle texture animation's flipV is not supported!");
    }
  },

  uvChannelMask: {
    type: 'number',
    default: -1,
    set: function set(val) {
      console.error("particle texture animation's uvChannelMask is not supported!");
    }
  },

  randomRow: {
    type: 'boolean',
    default: false
  },

  rowIndex: {
    type: 'number',
    default: 0
  }
};

var _intermediVec = vec3.zero();
var _intermediArr = new Array();
var _unitBoxExtent = vec3.new(0.5, 0.5, 0.5);

var ShapeModule = function ShapeModule() {
  this.mat = mat4.create();
  this.quat = quat.create();
};

ShapeModule.prototype.onInit = function onInit (ps) {
  this.constructMat();
  this.particleSystem = ps;
  this.lastTime = ps._time;
  this.totalAngle = 0;
};

ShapeModule.prototype.constructMat = function constructMat () {
  quat.fromEuler(this.quat, this._rotation.x, this._rotation.y, this._rotation.z);
  mat4.fromRTS(this.mat, this.quat, this._position, this._scale);
};

ShapeModule.prototype.emit = function emit (p) {
  switch (this._shapeType) {
    case 'box':
      boxEmit(this._emitFrom, this._boxThickness, p.position, p.velocity);
      break;
    case 'circle':
      circleEmit(this._radius, this._radiusThickness, this.generateArcAngle(), p.position, p.velocity);
      break;
    case 'cone':
      coneEmit(this._emitFrom, this._radius, this._radiusThickness, this.generateArcAngle(), this._angle, this._length, p.position, p.velocity);
      break;
    case 'sphere':
      sphereEmit(this._emitFrom, this._radius, this._radiusThickness, p.position, p.velocity);
      break;
    case 'hemisphere':
      hemisphereEmit(this._emitFrom, this._radius, this._radiusThickness, p.position, p.velocity);
      break;
    default:
      console.warn(this._shapeType + ' shapeType is not supported by ShapeModule.');
  }
  if (this._randomPositionAmount > 0) {
    p.position.x += randomRange(-this._randomPositionAmount, this._randomPositionAmount);
    p.position.y += randomRange(-this._randomPositionAmount, this._randomPositionAmount);
    p.position.z += randomRange(-this._randomPositionAmount, this._randomPositionAmount);
  }
  vec3.transformQuat(p.velocity, p.velocity, this.quat);
  vec3.transformMat4(p.position, p.position, this.mat);
  if (this._sphericalDirectionAmount > 0) {
    var sphericalVel = vec3.normalize(_intermediVec, p.position);
    vec3.lerp(p.velocity, p.velocity, sphericalVel, this._sphericalDirectionAmount);
  }
  this.lastTime = this.particleSystem._time;
};

ShapeModule.prototype.generateArcAngle = function generateArcAngle () {
  if (this._arcMode === 'random') {
    return randomRange(0, this._arc);
  }
  var angle = this.totalAngle + 2 * Math.PI * this._arcSpeed.evaluate(this.particleSystem._time) * (this.particleSystem._time - this.lastTime);
  this.totalAngle = angle;
  if (this._arcSpread !== 0) {
    angle = Math.floor(angle / (this._arc * this._arcSpread)) * this._arc * this._arcSpread;
  }
  switch (this._arcMode) {
    case 'loop':
      return repeat(angle, this._arc);
    case 'pingPong':
      return pingPong(angle, this._arc);
  }
};

function sphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
  switch (emitFrom) {
    case 'volume':
      randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius);
      vec3.copy(dir, pos);
      vec3.normalize(dir, dir);
      break;
    case 'shell':
      randomUnitVector(pos);
      vec3.scale(pos, radius);
      vec3.copy(dir, pos);
      break;
    default:
      console.warn(emitFrom + ' is not supported for sphere emitter.');
  }
}

function hemisphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
  switch (emitFrom) {
    case 'volume':
      randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius);
      if (pos.z > 0) {
        pos.z *= -1;
      }
      vec3.copy(dir, pos);
      vec3.normalize(dir, dir);
      break;
    case 'shell':
      randomUnitVector(pos);
      vec3.scale(pos, radius);
      if (pos.z < 0) {
        pos.z *= -1;
      }
      vec3.copy(dir, pos);
      break;
    default:
      console.warn(emitFrom + ' is not supported for hemisphere emitter.');
  }
}

function coneEmit(emitFrom, radius, radiusThickness, theta, angle, length, pos, dir) {
  switch (emitFrom) {
    case 'base':
      randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta);
      vec2.scale(dir, pos, Math.sin(angle));
      dir.z = -Math.cos(angle) * radius;
      pos.z = 0;
      break;
    case 'shell':
      fixedAngleUnitVector2(pos, theta);
      vec2.scale(dir, pos, Math.sin(angle));
      dir.z = -Math.cos(angle);
      vec2.scale(pos, pos, radius);
      pos.z = 0;
      break;
    case 'volume':
      randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta);
      vec2.scale(dir, pos, Math.sin(angle));
      dir.z = -Math.cos(angle) * radius;
      vec3.normalize(dir, dir);
      pos.z = 0;
      vec3.add(pos, pos, vec3.scale(_intermediVec, dir, length * random() / -dir.z));
      break;
    default:
      console.warn(emitFrom + ' is not supported for cone emitter.');
  }
}

function boxEmit(emitFrom, boxThickness, pos, dir) {
  switch (emitFrom) {
    case 'volume':
      randomPointInCube(pos, _unitBoxExtent);
      // randomPointBetweenCube(pos, vec3.multiply(_intermediVec, _unitBoxExtent, boxThickness), _unitBoxExtent);
      break;
    case 'shell':
      _intermediArr.splice(0, _intermediArr.length);
      _intermediArr.push(randomRange(-0.5, 0.5));
      _intermediArr.push(randomRange(-0.5, 0.5));
      _intermediArr.push(randomSign() * 0.5);
      randomSortArray(_intermediArr);
      applyBoxThickness(_intermediArr, boxThickness);
      vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
      break;
    case 'edge':
      _intermediArr.splice(0, _intermediArr.length);
      _intermediArr.push(randomRange(-0.5, 0.5));
      _intermediArr.push(randomSign() * 0.5);
      _intermediArr.push(randomSign() * 0.5);
      randomSortArray(_intermediArr);
      applyBoxThickness(_intermediArr, boxThickness);
      vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
      break;
    default:
      console.warn(emitFrom + ' is not supported for box emitter.');
  }
  vec3.copy(dir, particleEmitZAxis);
}

function circleEmit(radius, radiusThickness, theta, pos, dir) {
  randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta);
  vec3.normalize(dir, pos);
}

function applyBoxThickness(pos, thickness) {
  if (thickness.x > 0) {
    pos[0] += 0.5 * randomRange(-thickness.x, thickness.x);
    pos[0] = clamp(pos[0], -0.5, 0.5);
  }
  if (thickness.y > 0) {
    pos[1] += 0.5 * randomRange(-thickness.y, thickness.y);
    pos[1] = clamp(pos[0], -0.5, 0.5);
  }
  if (thickness.z > 0) {
    pos[2] += 0.5 * randomRange(-thickness.z, thickness.z);
    pos[2] = clamp(pos[0], -0.5, 0.5);
  }
}



ShapeModule.schema = {
  enable: {
    type: 'boolean',
    default: false
  },

  shapeType: {
    type: 'enums',
    options: [
      'box',
      'circle',
      'cone',
      'sphere',
      'hemisphere'
    ],
    default: 'box'
  },

  emitFrom: {
    type: 'enums',
    options: [
      'base',
      'edge',
      'shell',
      'volume'
    ],
    default: 'base'
  },

  position: {
    type: 'vec3',
    default: [0, 0, 0],
    set: function set(val) {
      this._position = val;
      this.constructMat();
    }
  },

  rotation: {
    type: 'vec3',
    default: [0, 0, 0],
    set: function set(val) {
      this._rotation = val;
      this.constructMat();
    }
  },

  scale: {
    type: 'vec3',
    default: [1, 1, 1],
    set: function set(val) {
      this._scale = val;
      this.constructMat();
    }
  },

  alignToDirection: {
    type: 'boolean',
    default: false
  },

  randomDirectionAmount: {
    type: 'number',
    default: 0
  },

  sphericalDirectionAmount: {
    type: 'number',
    default: 0
  },

  randomPositionAmount: {
    type: 'number',
    default: 0
  },

  radius: {
    type: 'number',
    default: 0
  },

  radiusThickness: {
    type: 'number',
    default: 1
  },

  arc: {
    type: 'number',
    default: 0
  },

  arcMode: {
    type: 'enums',
    options: [
      'random',
      'loop',
      'pingPong' ],
    default: 'random'
  },

  arcSpread: {
    type: 'number',
    default: 0
  },

  arcSpeed: {
    type: 'CurveRange',
    default: null
  },

  angle: {
    type: 'number',
    default: 0
  },

  length: {
    type: 'number',
    default: 0
  },

  boxThickness: {
    type: 'vec3',
    default: [0, 0, 0]
  }
};

var Burst = function Burst() {
  this._remainingCount = 1;
  this._curTime = 0.0;
};

Burst.prototype.update = function update (psys, dt) {
  if (psys._loop && this._remainingCount === 0) {
    this._remainingCount = this._repeatCount;
    this._curTime = this._time;
  }
  if (this._remainingCount > 0) {
    var preFrameTime = repeat(psys._time - psys._startDelay.evaluate(), psys._duration) - dt;
    preFrameTime = (preFrameTime > 0.0) ? preFrameTime : 0.0;
    var curFrameTime = repeat(psys.time - psys._startDelay.evaluate(), psys._duration);
    if (this._curTime >= preFrameTime && this._curTime < curFrameTime) {
      psys.emit(this._count.evaluate(this._curTime / psys._duration));
      this._curTime += this._repeatInterval;
      --this._remainingCount;
    }
  }
};

Burst.schema = {
  time: {
    type: 'number',
    default: 0.0,
    set: function set(val) {
      this._time = val;
      this._curTime = val;
    }
  },

  minCount: {
    type: 'int',
    default: 30,
  },

  maxCount: {
    type: 'int',
    default: 30,
  },

  repeatCount: {
    type: 'number',
    default: 1,
    set: function set(val) {
      this._repeatCount = val;
      this._remainingCount = val;
    }
  },

  repeatInterval: {
    type: 'number',
    default: 1.0,
  },

  count: {
    type: 'CurveRange',
    default: null
  }
};

// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

registry.registerClass('Burst', Burst);
registry.registerClass('ColorKey', ColorKey);
registry.registerClass('AlphaKey', AlphaKey);
registry.registerClass('Gradient', Gradient);
registry.registerClass('GradientRange', GradientRange);
registry.registerClass('CurveRange', CurveRange);
registry.registerClass('SizeOvertimeModule', SizeOvertimeModule);
registry.registerClass('ColorOverLifetimeModule', ColorOvertimeModule);
registry.registerClass('ParticleSystemRenderer', ParticleSystemRenderer);
registry.registerClass('VelocityOvertimeModule', VelocityOvertimeModule);
registry.registerClass('ForceOvertimeModule', ForceOvertimeModule);
registry.registerClass('LimitVelocityOvertimeModule', LimitVelocityOvertimeModule);
registry.registerClass('RotationOvertimeModule', RotationOvertimeModule);
registry.registerClass('TextureAnimationModule', TextureAnimationModule);
registry.registerClass('ShapeModule', ShapeModule);

var _world_mat = mat4.create();

var ParticleSystemComponent = (function (Component) {
  function ParticleSystemComponent() {
    Component.call(this);

    // internal status
    this._isPlaying = false;
    this._isPaused = false;
    this._isStopped = true;
    this._isEmitting = false;

    this._time = 0.0;  // playback position in seconds.
    this._emitRateTimeCounter = 0.0;
    this._emitRateDistanceCounter = 0.0;
    this._oldWPos = vec3.zero();
    this._curWPos = vec3.zero();

    this._customData1 = vec2.zero();
    this._customData2 = vec2.zero();

    this._subEmitters = []; // array of { emitter: ParticleSystemComponent, type: 'birth', 'collision' or 'death'}
    this._vertAttrs = [];
    this._vertAttrFlags = {
      position: true,
      uv: true,
      uv0: true,
      color: true,
      normal: false,
      tangent: false,
      custom1: false,
      custom2: false,
      color0: false,
    };
  }

  if ( Component ) ParticleSystemComponent.__proto__ = Component;
  ParticleSystemComponent.prototype = Object.create( Component && Component.prototype );
  ParticleSystemComponent.prototype.constructor = ParticleSystemComponent;

  var prototypeAccessors = { isPlaying: { configurable: true },isPaused: { configurable: true },isStopped: { configurable: true },isEmitting: { configurable: true },time: { configurable: true } };

  ParticleSystemComponent.prototype.onInit = function onInit () {
    var this$1 = this;

    this._particles = new RecyclePool(function () {
      return new Particle(this$1);
    }, this._capacity);

    // HACK, TODO
    this._renderer.onInit(this);
    this._shapeModule.onInit(this);

    this._entity.getWorldPos(this._oldWPos);
    vec3.copy(this._curWPos, this._oldWPos);

    this._system.add(this);
  };

  ParticleSystemComponent.prototype.onDestroy = function onDestroy () {
    this._renderer._model.destroy();
    this._system.remove(this);
  };

  ParticleSystemComponent.prototype.onEnable = function onEnable () {
    this._app.scene.addModel(this._renderer._model);
    if (this._playOnAwake) {
      this.play();
    }
  };

  ParticleSystemComponent.prototype.onDisable = function onDisable () {
    this._app.scene.removeModel(this._renderer._model);
  };

  // TODO: fastforward current particle system by simulating particles over given period of time, then pause it.
  // simulate(time, withChildren, restart, fixedTimeStep) {

  // }

  ParticleSystemComponent.prototype.play = function play () {
    if (this._isPaused) {
      this._isPaused = false;
    }
    if (this._isStopped) {
      this._isStopped = false;
    }

    this._time = 0.0;
    this._emitRateTimeCounter = 0.0;
    this._emitRateDistanceCounter = 0.0;

    this._isPlaying = true;

    // prewarm
    if (this._prewarm) {
      this._prewarmSystem();
    }
  };

  ParticleSystemComponent.prototype.pause = function pause () {
    if (this._isStopped) {
      console.warn('pause(): particle system is already stopped.');
      return;
    }
    if (this._isPlaying) {
      this._isPlaying = false;
    }

    this._isPaused = true;
  };

  ParticleSystemComponent.prototype.stop = function stop () {
    if (this._isPlaying) {
      this._isPlaying = false;
    }
    if (this._isPaused) {
      this._isPaused = false;
    }

    this.clear();
    this._time = 0.0;
    this._emitRateTimeCounter = 0.0;
    this._emitRateDistanceCounter = 0.0;

    this._isStopped = true;
  };

  // remove all particles from current particle system.
  ParticleSystemComponent.prototype.clear = function clear () {
    this._particles.reset();
    this._renderer._model.clear();
  };

  ParticleSystemComponent.prototype.emit = function emit (count, emitParams) {
    var this$1 = this;
    if ( emitParams === void 0 ) emitParams = null;

    for (var i = 0; i < count; ++i) {
      if (this$1._particles.length >= this$1._capacity) {
        return;
      }

      var particle = this$1._particles.add();
      var rand = pseudoRandom(randomRangeInt(0, INT_MAX));

      if (this$1._shapeModule.enable) {
        this$1._shapeModule.emit(particle);
      }
      else {
        vec3.set(particle.position, 0, 0, 0);
        vec3.copy(particle.velocity, particleEmitZAxis);
      }

      vec3.scale(particle.velocity, particle.velocity, this$1._startSpeed.evaluate(this$1._time / this$1._duration, rand));

      switch (this$1._simulationSpace) {
        case 'local':
          break;
        case 'world': {
          this$1._entity.getWorldMatrix(_world_mat);
          vec3.transformMat4(particle.position, particle.position, _world_mat);
          var worldRot = quat.create();
          this$1._entity.getWorldRot(worldRot);
          vec3.transformQuat(particle.velocity, particle.velocity, worldRot);
        }
          break;
        case 'custom':
          // TODO:
          break;
      }

      // subEmitter
      // if (this._subEmitters.length > 0) {
      //   for (let idx = 0; idx < this._subEmitters.length; ++idx) {
      //     let subEmitter = this._subEmitters[idx];
      //     if (subEmitter.type === 'birth') {
      //       // TODO: clone subEmitter
      //       vec3.copy(subEmitter.emitter.entity.lpos, particle.position);
      //       subEmitter.emitter.play();
      //     }
      //   }
      // }

      // apply startRotation. now 2D only.
      vec3.set(particle.rotation, this$1._startRotation.evaluate(this$1._time / this$1._duration, rand), 0, 0);

      // apply startSize. now 2D only.
      vec3.set(particle.startSize, this$1._startSize.evaluate(this$1._time / this$1._duration, rand), 0, 0);
      vec3.copy(particle.size, particle.startSize);

      // apply startColor.
      color4.copy(particle.startColor, this$1._startColor.evaluate(this$1._time / this$1._duration, rand));
      color4.copy(particle.color, particle.startColor);

      // apply startLifetime.
      particle.startLifetime = this$1._startLifetime.evaluate(this$1._time / this$1._duration, rand);
      particle.remainingLifetime = particle.startLifetime;

      particle.randomSeed = pseudoRandom(randomRangeInt(0, INT_MAX));

    } // end of particles forLoop.
  };

  // simulation, update particles.
  ParticleSystemComponent.prototype._updateParticles = function _updateParticles (dt) {
    var this$1 = this;

    this._entity.getWorldMatrix(_world_mat);
    if (this._velocityOvertimeModule.enable) {
      this._velocityOvertimeModule.update(this._simulationSpace, _world_mat);
    }
    if (this._forceOvertimeModule.enable) {
      this._forceOvertimeModule.update(this._simulationSpace, _world_mat);
    }
    for (var i = 0; i < this._particles.length; ++i) {
      var p = this$1._particles.data[i];
      p.remainingLifetime -= dt;
      vec3.set(p.animatedVelocity, 0, 0, 0);

      if (p.remainingLifetime < 0.0) {
        // subEmitter
        // if (this._subEmitters.length > 0) {
        //   for (let idx = 0; idx < this._subEmitters.length; ++idx) {
        //     let subEmitter = this._subEmitters[idx];
        //     if (subEmitter.type === 'death') {
        //       vec3.copy(subEmitter.emitter.entity.lpos, p.position);
        //       subEmitter.emitter.play();
        //     }
        //   }
        // }

        this$1._particles.remove(i);
        --i;
        continue;
      }

      p.velocity.y -= this$1._gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, p.randomSeed) * 9.8 * dt; // apply gravity.
      if (this$1._sizeOvertimeModule.enable) {
        this$1._sizeOvertimeModule.animate(p);
      }
      if (this$1._colorOverLifetimeModule.enable) {
        this$1._colorOverLifetimeModule.animate(p);
      }
      if (this$1._forceOvertimeModule.enable) {
        this$1._forceOvertimeModule.animate(p, dt);
      }
      if (this$1._velocityOvertimeModule.enable) {
        this$1._velocityOvertimeModule.animate(p);
      }
      else {
        vec3.copy(p.ultimateVelocity, p.velocity);
      }
      if (this$1._limitVelocityOvertimeModule.enable) {
        this$1._limitVelocityOvertimeModule.animate(p);
      }
      if (this$1._rotationOvertimeModule.enable) {
        this$1._rotationOvertimeModule.animate(p, dt);
      }
      if (this$1._textureAnimationModule.enable) {
        this$1._textureAnimationModule.animate(p);
      }
      vec3.scaleAndAdd(p.position, p.position, p.ultimateVelocity, dt); // apply velocity.
    }
  };

  // initialize particle system as though it had already completed a full cycle.
  ParticleSystemComponent.prototype._prewarmSystem = function _prewarmSystem () {
    var this$1 = this;

    this._startDelay.mode = 'constant'; // clear startDelay.
    this._startDelay.constant = 0;
    var dt = 1.0; // should use varying value?
    var cnt = this._duration / dt;
    for (var i = 0; i < cnt; ++i) {
      this$1._time += dt;
      this$1._emit(dt);
      this$1._updateParticles(dt);
    }
  };

  // internal function
  ParticleSystemComponent.prototype._emit = function _emit (dt) {
    var this$1 = this;

    // emit particles.
    var startDelay = this._startDelay.evaluate();
    if (this._time > startDelay) {
      if (!this._isStopped) {
        this._isEmitting = true;
      }
      if (this._time > (this._duration + startDelay)) {
        // this._time = startDelay; // delay will not be applied from the second loop.(Unity)
        // this._emitRateTimeCounter = 0.0;
        // this._emitRateDistanceCounter = 0.0;
        if (!this._loop) {
          this._isEmitting = false;
          this._isStopped = true;
        }
      }

      // emit by rateOverTime
      this._emitRateTimeCounter += this._rateOverTime.evaluate(this._time / this._duration, 1) * dt;
      if (this._emitRateTimeCounter > 1 && this._isEmitting) {
        var emitNum = Math.floor(this._emitRateTimeCounter);
        this._emitRateTimeCounter -= emitNum;
        this.emit(emitNum);
      }
      // emit by rateOverDistance
      this._entity.getWorldPos(this._curWPos);
      var distance = vec3.distance(this._curWPos, this._oldWPos);
      vec3.copy(this._oldWPos, this._curWPos);
      this._emitRateDistanceCounter += distance * this._rateOverDistance.evaluate(this._time / this._duration, 1);
      if (this._emitRateDistanceCounter > 1 && this._isEmitting) {
        var emitNum$1 = Math.floor(this._emitRateDistanceCounter);
        this._emitRateDistanceCounter -= emitNum$1;
        this.emit(emitNum$1);
      }

      // bursts
      for (var i = 0; i < this._bursts.length; ++i) {
        this$1._bursts[i].update(this$1, dt);
      }
    }
  };

  ParticleSystemComponent.prototype.tick = function tick (dt) {
    var scaledDeltaTime = dt * this._simulationSpeed;
    if (this._isPlaying) {
      this._time += scaledDeltaTime;

      // excute emission
      this._emit(scaledDeltaTime);

      // simulation, update particles.
      this._updateParticles(scaledDeltaTime);

      // update render data
      this.renderer._updateRenderData();
    }
  };

  ParticleSystemComponent.prototype.addSubEmitter = function addSubEmitter (subEmitter) {
    this._subEmitters.push(subEmitter);
  };

  ParticleSystemComponent.prototype.removeSubEmitter = function removeSubEmitter (idx) {
    this._subEmitters.remove(idx);
  };

  ParticleSystemComponent.prototype.addBurst = function addBurst (burst) {
    this._bursts.push(burst);
  };

  ParticleSystemComponent.prototype.removeBurst = function removeBurst (idx) {
    this._bursts.remove(idx);
  };

  ParticleSystemComponent.prototype.getParticleCount = function getParticleCount () {
    return this._particles.length;
  };

  ParticleSystemComponent.prototype.setCustomData1 = function setCustomData1 (x, y) {
    vec2.set(this._customData1, x, y);
  };

  ParticleSystemComponent.prototype.setCustomData2 = function setCustomData2 (x, y) {
    vec2.set(this._customData2, x, y);
  };

  prototypeAccessors.isPlaying.get = function () {
    return this._isPlaying;
  };

  prototypeAccessors.isPaused.get = function () {
    return this._isPaused;
  };

  prototypeAccessors.isStopped.get = function () {
    return this._isStopped;
  };

  prototypeAccessors.isEmitting.get = function () {
    return this._isEmitting;
  };

  prototypeAccessors.time.get = function () {
    return this._time;
  };

  Object.defineProperties( ParticleSystemComponent.prototype, prototypeAccessors );

  return ParticleSystemComponent;
}(Component));

ParticleSystemComponent.schema = {

  // main module properties
  capacity: {
    type: 'int',
    default: 2000,
  },

  startColor: {
    type: 'GradientRange',
    default: {
      'mode': 'color',
      'color': [1, 1, 1, 1]
    }
  },

  startSize: {
    type: 'CurveRange',
    default: {
      'mode': 'constant',
      'constant': 1.0
    }
  },

  startSpeed: {
    type: 'CurveRange',
    default: {
      'mode': 'constant',
      'constant': 5.0
    }
  },

  startRotation: {
    type: 'CurveRange',
    default: {
      'mode': 'constant',
      'constant': 0.0
    }
  },

  startDelay: {
    type: 'CurveRange',
    default: {
      'mode': 'constant',
      'constant': 0.0
    }
  },

  startLifetime: {
    type: 'CurveRange',
    default: {
      'mode': 'constant',
      'constant': 5.0
    }
  },

  duration: {
    type: 'number',
    default: 5.0,
  },

  loop: {
    type: 'boolean',
    default: true,
  },

  prewarm: {
    type: 'boolean',
    default: false,
    set: function set(val) {
      if (val === true && this._loop === false) {
        // console.warn('prewarm only works if loop is also enabled.');
      }
      this._prewarm = val;
    }
  },

  simulationSpace: {
    type: 'enums',
    default: 'local',
    options: [
      'local',
      'world',
      'custom'
    ],
    set: function set(val) {
      if (val === 'world') {
        this._renderer._material.define('USE_WORLD_SPACE', true);
      } else {
        this._renderer._material.define('USE_WORLD_SPACE', false);
      }
      this._simulationSpace = val;
    }
  },

  simulationSpeed: {
    type: 'number',
    default: 1.0,
  },

  playOnAwake: {
    type: 'boolean',
    default: false,
  },

  gravityModifier: {
    type: 'CurveRange',
    default: {
      'mode': 'constant',
      'constant': 0.0
    }
  },

  // emission module
  rateOverTime: {
    type: 'CurveRange',
    default: {
      'mode': 'constant',
      'constant': 10.0
    }
  },

  rateOverDistance: {
    type: 'CurveRange',
    default: {
      'mode': 'constant',
      'constant': 10.0
    }
  },

  bursts: {
    type: 'Burst',
    default: [],
    array: true,
  },

  // color over lifetime module
  colorOverLifetimeModule: {
    type: 'ColorOverLifetimeModule',
    default: null,
  },

  // shpae module
  shapeModule: {
    type: 'ShapeModule',
    default: null
  },

  // particle system renderer
  renderer: {
    type: 'ParticleSystemRenderer',
    default: null
  },

  // size over lifetime module
  sizeOvertimeModule: {
    type: 'SizeOvertimeModule',
    default: null
  },

  velocityOvertimeModule: {
    type: 'VelocityOvertimeModule',
    default: null
  },

  forceOvertimeModule: {
    type: 'ForceOvertimeModule',
    default: null
  },

  limitVelocityOvertimeModule: {
    type: 'LimitVelocityOvertimeModule',
    default: null
  },

  rotationOvertimeModule: {
    type: 'RotationOvertimeModule',
    default: null
  },

  textureAnimationModule: {
    type: 'TextureAnimationModule',
    default: null
  }
};

var _wmat = mat4.create();

var WidgetComponent = (function (Component) {
  function WidgetComponent() {
    Component.call(this);

    // calculated rect
    this._rect = { x: 0, y: 0, w: 0, h: 0 };
  }

  if ( Component ) WidgetComponent.__proto__ = Component;
  WidgetComponent.prototype = Object.create( Component && Component.prototype );
  WidgetComponent.prototype.constructor = WidgetComponent;

  // override functions
  WidgetComponent.prototype._onRectChanged = function _onRectChanged () {
  };

  /**
   * @param {number} l
   * @param {number} b
   * @param {number} r
   * @param {number} t
   */
  WidgetComponent.prototype.setAnchors = function setAnchors (l, b, r, t) {
    this._anchorLeft = l;
    this._anchorRight = r;
    this._anchorBottom = b;
    this._anchorTop = t;
  };

  /**
   * @param {number} x
   * @param {number} y
   */
  WidgetComponent.prototype.setOffset = function setOffset (x, y) {
    this._offsetX = x;
    this._offsetY = y;
  };

  /**
   * @param {number} x
   * @param {number} y
   */
  WidgetComponent.prototype.setSize = function setSize (x, y) {
    this._sizeX = x;
    this._sizeY = y;
  };

  /**
   * @param {number} x
   * @param {number} y
   */
  WidgetComponent.prototype.setPivot = function setPivot (x, y) {
    this._pivotX = x;
    this._pivotY = y;
  };

  WidgetComponent.prototype.getLeft = function getLeft () {
    return this._offsetX - (this._sizeX * this._pivotX);
  };

  WidgetComponent.prototype.getRight = function getRight () {
    return -(this._offsetX + (this._sizeX * (1 - this._pivotX)));
  };

  WidgetComponent.prototype.getBottom = function getBottom () {
    return this._offsetY - (this._sizeY * this._pivotY);
  };

  WidgetComponent.prototype.getTop = function getTop () {
    return -(this._offsetY + (this._sizeY * (1 - this._pivotY)));
  };

  WidgetComponent.prototype.setLeft = function setLeft (val) {
    var offset = val - (this._offsetX - (this._sizeX * this._pivotX));
    this._sizeX -= offset;
    this._offsetX += offset * (1 - this._pivotX);
  };

  WidgetComponent.prototype.setRight = function setRight (val) {
    var offset = -val - (this._offsetX + (this._sizeX * (1 - this._pivotX)));
    this._sizeX += offset;
    this._offsetX += offset * this._pivotX;
  };

  WidgetComponent.prototype.setBottom = function setBottom (val) {
    var offset = val - (this._offsetY - (this._sizeY * this._pivotY));
    this._sizeY -= offset;
    this._offsetY += offset * (1 - this._pivotY);
  };

  WidgetComponent.prototype.setTop = function setTop (val) {
    var offset = -val - (this._offsetY + (this._sizeY * (1 - this._pivotY)));
    this._sizeY += offset;
    this._offsetY += offset * this._pivotY;
  };

  // calculate
  WidgetComponent.prototype.calculate = function calculate (parentX, parentY, parentWidth, parentHeight) {
    var refMinX = parentX + parentWidth * this._anchorLeft;
    var refMinY = parentY + parentHeight * this._anchorBottom;
    var refMaxX = parentX + parentWidth * this._anchorRight;
    var refMaxY = parentY + parentHeight * this._anchorTop;

    // let dx = refMaxX - refMinX;
    // let dy = refMaxY - refMinY;

    var rectX = 0.0;
    var rectY = 0.0;
    var rectWidth = 0.0;
    var rectHeight = 0.0;

    // refWidth = refMax - refMin
    // rectWith = refWidth + sizeX
    rectWidth = refMaxX - refMinX + this._sizeX;
    rectHeight = refMaxY - refMinY + this._sizeY;

    rectX = refMinX + this._offsetX - (this._sizeX * this._pivotX);
    rectY = refMinY + this._offsetY - (this._sizeY * this._pivotY);

    var newPosX = rectX + rectWidth * this._pivotX;
    var newPosY = rectY + rectHeight * this._pivotY;

    vec3.set(
      this._entity.lpos,
      newPosX,
      newPosY,
      this._entity.lpos.z
    );

    rectX = rectX - newPosX;
    rectY = rectY - newPosY;

    // update callbacks
    if (
      rectX !== this._rect.x ||
      rectY !== this._rect.y ||
      rectWidth !== this._rect.w ||
      rectHeight !== this._rect.h
    ) {
      this._onRectChanged();
    }

    this._rect.x = rectX;
    this._rect.y = rectY;
    this._rect.w = rectWidth;
    this._rect.h = rectHeight;

  };

  WidgetComponent.prototype.getWorldCorners = function getWorldCorners (outA, outB, outC, outD) {
    this._entity.getWorldMatrix(_wmat);

    var x = this._rect.x;
    var y = this._rect.y;
    var w = this._rect.w;
    var h = this._rect.h;

    // a
    vec3.set(outA, x, y + h, 0.0);
    vec3.transformMat4(outA, outA, _wmat);

    // b
    vec3.set(outB, x, y, 0.0);
    vec3.transformMat4(outB, outB, _wmat);

    // c
    vec3.set(outC, x + w, y, 0.0);
    vec3.transformMat4(outC, outC, _wmat);

    // d
    vec3.set(outD, x + w, y + h, 0.0);
    vec3.transformMat4(outD, outD, _wmat);
  };

  return WidgetComponent;
}(Component));

WidgetComponent.schema = {
  focusable: {
    type: 'boolean',
    default: false,
  },

  pivotX: {
    type: 'number',
    default: 0.5,
  },

  pivotY: {
    type: 'number',
    default: 0.5,
  },

  anchorLeft: {
    type: 'number',
    default: 0.5,
  },

  anchorBottom: {
    type: 'number',
    default: 0.5,
  },

  anchorRight: {
    type: 'number',
    default: 0.5,
  },

  anchorTop: {
    type: 'number',
    default: 0.5,
  },

  offsetX: {
    type: 'number',
    default: 0.0,
  },

  offsetY: {
    type: 'number',
    default: 0.0,
  },

  sizeX: {
    type: 'number',
    default: 100.0,
  },

  sizeY: {
    type: 'number',
    default: 100.0,
  },
};

var ScreenComponent = (function (WidgetComponent$$1) {
  function ScreenComponent() {
    WidgetComponent$$1.call(this);

    this._view = new renderer.View();
  }

  if ( WidgetComponent$$1 ) ScreenComponent.__proto__ = WidgetComponent$$1;
  ScreenComponent.prototype = Object.create( WidgetComponent$$1 && WidgetComponent$$1.prototype );
  ScreenComponent.prototype.constructor = ScreenComponent;

  ScreenComponent.prototype.onInit = function onInit () {
    this._view._clearFlags = renderer.CLEAR_DEPTH | renderer.CLEAR_STENCIL;
    this._view._cullingByID = true;
    this._view._stages = ['ui'];
    this._view._stencil = 0;
    this._view._priority = this._priority;
    this._system.addScreen(this);
  };

  ScreenComponent.prototype.onDestroy = function onDestroy () {
    this._system.removeScreen(this);
  };

  return ScreenComponent;
}(WidgetComponent));

ScreenComponent.schema = {
  priority: {
    type: 'number',
    default: 0,
    set: function set(val) {
      this._priority = val;
      this._view._priority = val;
    }
  },

  width: {
    type: 'number',
    default: 960,
    set: function set(val) {
      this._width = val;
    }
  },

  height: {
    type: 'number',
    default: 640,
    set: function set(val) {
      this._height = val;
    }
  },

  scaleFactor: {
    type: 'number',
    default: 1.0,
    set: function set(val) {
      this._scaleFactor = val;
      vec3.set(this._entity.lscale, this._scaleFactor, this._scaleFactor, this._scaleFactor);
    }
  }
};

var UIElementComponent = (function (Component) {
  function UIElementComponent () {
    Component.apply(this, arguments);
  }

  if ( Component ) UIElementComponent.__proto__ = Component;
  UIElementComponent.prototype = Object.create( Component && Component.prototype );
  UIElementComponent.prototype.constructor = UIElementComponent;

  UIElementComponent.prototype.onInit = function onInit () {
    this._system.add(this);
  };

  UIElementComponent.prototype.onDestroy = function onDestroy () {
    this._system.remove(this);
  };

  return UIElementComponent;
}(Component));

var ScreenScalerComponent = (function (UIElementComponent$$1) {
  function ScreenScalerComponent () {
    UIElementComponent$$1.apply(this, arguments);
  }

  if ( UIElementComponent$$1 ) ScreenScalerComponent.__proto__ = UIElementComponent$$1;
  ScreenScalerComponent.prototype = Object.create( UIElementComponent$$1 && UIElementComponent$$1.prototype );
  ScreenScalerComponent.prototype.constructor = ScreenScalerComponent;

  ScreenScalerComponent.prototype.tick = function tick () {
    var screen = this._entity && this._entity.getComp('Screen');
    if (!screen) {
      return;
    }

    var canvas = this._app._canvas;
    var aspect = [canvas.width / screen.width, canvas.height / screen.height];
    if (this._adaptionMode === 'match-width-or-height') {
      var w = Math.log2(aspect[0]);
      var h = Math.log2(aspect[1]);
      var p = lerp(w, h, this._match);
      this._scaleFactor = Math.pow(2, p);
    } else if (this._adaptionMode === 'expand') {
      this._scaleFactor = Math.min(aspect[0], aspect[1]);
    } else if (this._adaptionMode === 'shrink') {
      this._scaleFactor = Math.max(aspect[0], aspect[1]);
    }

    screen.scaleFactor = this._scaleFactor;
  };

  return ScreenScalerComponent;
}(UIElementComponent));

ScreenScalerComponent.schema = {
  adaptionMode: {
    type: 'enums',
    default: 'none',
    options: ['none', 'match-width-or-height', 'expand', 'shrink'],
    set: function set(val) {
      if (this._adaptionMode === val) {
        return;
      }

      this._adaptionMode = val;
      this._adaption();
    }
  },

  match: {
    type: 'number',
    default: 0.0,
  },

  scaleFactor: {
    type: 'number',
    default: 1,
    set: function set(val) {
      if (this._scaleFactor === val) {
        return;
      }

      if (this._adaptionMode !== 'none') {
        return;
      }

      this._scaleFactor = val;
    }
  }
};

var _x_tmp = [0.0, 0.0, 0.0, 0.0];
var _y_tmp = [0.0, 0.0, 0.0, 0.0];
var _m4_tmp$4 = mat4.create();

/**
 * v2------v3
 * |       |
 * |       |
 * |       |
 * v0------v1
 */
var _simpleIndices = [
  0, 1, 2, 3, 2, 1
];

/**
 * v12---v13---v14---v15
 * |      |     |     |
 * v08---v09---v10---v11
 * |      |     |     |
 * v04---v05---v06---v07
 * |      |     |     |
 * v00---v01---v02---v03
 */
var _slicedIndices = [
  0, 1, 4, 5, 4, 1,
  1, 2, 5, 6, 5, 2,
  2, 3, 6, 7, 6, 3,
  4, 5, 8, 9, 8, 5,
  5, 6, 9, 10, 9, 6,
  6, 7, 10, 11, 10, 7,
  8, 9, 12, 13, 12, 9,
  9, 10, 13, 14, 13, 10,
  10, 11, 14, 15, 14, 11
];

var _fullRadialIndices = [
  0, 1, 2,
  0, 3, 4,
  0, 5, 6,
  0, 7, 8,
  0, 9, 10
];

function _reallocVertexData(type, fillType) {
  var vertexCount = 4;
  var indices = null;

  if (type === 'simple') {
    vertexCount = 4;
    indices = _simpleIndices;
  } else if (type === 'sliced') {
    vertexCount = 16;
    indices = _slicedIndices;
  } else if (type === 'filled') {
    if (fillType === 'radial') {
      vertexCount = 11;
      // do not specify it coz it may changes
      // indices = _fullRadialIndices;
    } else {
      vertexCount = 4;
      indices = _simpleIndices;
    }
  }

  var lposList = new Array(vertexCount);
  var wposList = new Array(vertexCount);
  var uvs = new Array(vertexCount);
  var color = color4.create();

  for (var i = 0; i < vertexCount; ++i) {
    wposList[i] = vec3.zero();
    lposList[i] = vec3.zero();
    uvs[i] = vec3.zero();
  }

  return {
    wposList: wposList,
    lposList: lposList,
    uvs: uvs,
    color: color,
    indices: indices,
  };
}

function _genSimpleVerts(out, sprite, x, y, w, h) {
  vec3.set(out.lposList[0], x, y, 0);
  vec3.set(out.lposList[1], x + w, y, 0);
  vec3.set(out.lposList[2], x, y + h, 0);
  vec3.set(out.lposList[3], x + w, y + h, 0);

  vec3.copy(out.uvs[0], sprite.uvs[0]);
  vec3.copy(out.uvs[1], sprite.uvs[3]);
  vec3.copy(out.uvs[2], sprite.uvs[12]);
  vec3.copy(out.uvs[3], sprite.uvs[15]);

  return out;
}

function _genSlicedVerts(out, sprite, x, y, w, h) {
  // x0, x1, x2, x3
  var xScale = 1.0;
  var yScale = 1.0;

  if (sprite._left + sprite._right > w) {
    xScale = w / (sprite._left + sprite._right);
  }
  if (sprite._bottom + sprite._top > h) {
    yScale = h / (sprite._bottom + sprite._top);
  }

  _x_tmp[0] = x;
  _x_tmp[1] = x + sprite._left * xScale;
  _x_tmp[2] = x + w - sprite._right * xScale;
  _x_tmp[3] = x + w;

  _y_tmp[0] = y;
  _y_tmp[1] = y + sprite._bottom * yScale;
  _y_tmp[2] = y + h - sprite._top * yScale;
  _y_tmp[3] = y + h;

  for (var row = 0; row < 4; ++row) {
    for (var column = 0; column < 4; ++column) {
      vec3.set(out.lposList[row * 4 + column], _x_tmp[column], _y_tmp[row], 0.0);
    }
  }

  for (var i = 0; i < 16; ++i) {
    vec3.copy(out.uvs[i], sprite.uvs[i]);
  }

  return out;
}

function _genFilledHorizontalVerts(out, sprite, x, y, w, h, start, range) {
  start = start < 0 ? 0 : start;
  start = start > 1 ? 1 : start;
  range = range < 0 ? 0 : range;
  var end = (range + start > 1) ? 1 : (range + start);

  vec3.set(out.lposList[0], w * start + x, y, 0);
  vec3.set(out.lposList[1], w * end + x, y, 0);
  vec3.set(out.lposList[2], w * start + x, y + h, 0);
  vec3.set(out.lposList[3], w * end + x, y + h, 0);

  vec3.lerp(out.uvs[0], sprite.uvs[0], sprite.uvs[3], start);
  vec3.lerp(out.uvs[1], sprite.uvs[0], sprite.uvs[3], end);
  vec3.lerp(out.uvs[2], sprite.uvs[12], sprite.uvs[15], start);
  vec3.lerp(out.uvs[3], sprite.uvs[12], sprite.uvs[15], end);

  return out;
}

function _genFilledVerticalVerts(out, sprite, x, y, w, h, start, range) {
  start = start < 0 ? 0 : start;
  start = start > 1 ? 1 : start;
  range = range < 0 ? 0 : range;
  var end = (range + start > 1) ? 1 : (range + start);

  vec3.set(out.lposList[0], x, y + h * start, 0);
  vec3.set(out.lposList[1], w + x, y + h * start, 0);
  vec3.set(out.lposList[2], x, y + h * end, 0);
  vec3.set(out.lposList[3], w + x, y + h * end, 0);

  vec3.lerp(out.uvs[0], sprite.uvs[0], sprite.uvs[12], start);
  vec3.lerp(out.uvs[1], sprite.uvs[3], sprite.uvs[15], start);
  vec3.lerp(out.uvs[2], sprite.uvs[0], sprite.uvs[12], end);
  vec3.lerp(out.uvs[3], sprite.uvs[3], sprite.uvs[15], end);

  return out;
}

// [0,PI * 2)
function _getVertAngle(start, end) {
  var placementX, placementY;
  placementX = end.x - start.x;
  placementY = end.y - start.y;

  if (placementX === 0 && placementY === 0) {
    return NaN;
  } else if (placementX === 0) {
    if (placementY > 0) {
      return Math.PI * 0.5;
    } else {
      return Math.PI * 1.5;
    }
  } else {
    var angle = Math.atan(placementY / placementX);
    if (placementX < 0) {
      angle += Math.PI;
    }

    return angle;
  }
}

function _getInsectedPoints(quadInfo, center, angle, points, uvs) {
  // left bottom, right, top
  var left = quadInfo.left;
  var right = quadInfo.right;
  var top = quadInfo.top;
  var bottom = quadInfo.bottom;
  var sinAngle = Math.sin(angle);
  var cosAngle = Math.cos(angle);
  var tanAngle, cotAngle;
  if (Math.cos(angle) !== 0) {
    tanAngle = sinAngle / cosAngle;
    // calculate right and left
    if ((left - center.x) * cosAngle > 0) {
      var yleft = center.y + tanAngle * (left - center.x);
      points[3].x = left;
      points[3].y = yleft;

      vec3.lerp(uvs[3], quadInfo.uvbl, quadInfo.uvtl, (yleft - quadInfo.bottom) / (quadInfo.top - quadInfo.bottom));
    }
    if ((right - center.x) * cosAngle > 0) {
      var yright = center.y + tanAngle * (right - center.x);

      points[1].x = right;
      points[1].y = yright;
      vec3.lerp(uvs[1], quadInfo.uvbr, quadInfo.uvtr, (yright - quadInfo.bottom) / (quadInfo.top - quadInfo.bottom));
    }

  }

  if (Math.sin(angle) !== 0) {
    cotAngle = cosAngle / sinAngle;
    // calculate  top and bottom
    if ((top - center.y) * sinAngle > 0) {
      var xtop = center.x + cotAngle * (top - center.y);
      points[2].x = xtop;
      points[2].y = top;

      vec3.lerp(uvs[2], quadInfo.uvtl, quadInfo.uvtr, (xtop - quadInfo.left) / (quadInfo.right - quadInfo.left));
    }
    if ((bottom - center.y) * sinAngle > 0) {
      var xbottom = center.x + cotAngle * (bottom - center.y);
      points[0].x = xbottom;
      points[0].y = bottom;

      vec3.lerp(uvs[0], quadInfo.uvbl, quadInfo.uvbr, (xbottom - quadInfo.left) / (quadInfo.right - quadInfo.left));
    }

  }
}

var _genFilledRadialVerts = (function () {

  var intersectionPoints1 = [vec3.zero(), vec3.zero(), vec3.zero(), vec3.zero()];
  var intersectionPoints2 = [vec3.zero(), vec3.zero(), vec3.zero(), vec3.zero()];
  var intersectionUVs1 = [vec3.zero(), vec3.zero(), vec3.zero(), vec3.zero()];
  var intersectionUVs2 = [vec3.zero(), vec3.zero(), vec3.zero(), vec3.zero()];

  var center = vec3.zero();
  var centerUVs = vec3.zero();
  // quad vert data, in counter clockwise order
  var quadVertPoses = [vec3.zero(), vec3.zero(), vec3.zero(), vec3.zero()];
  var quadVertAngles = [0, 0, 0, 0];
  var uvXaxis = vec3.zero();
  var uvYaxis = vec3.zero();

  // proto of raw quads
  var rawQuad = {
    left: 0,
    right: 100,
    bottom: 0,
    top: 100,
    uvbl: vec3.new(0, 0, 0),
    uvbr: vec3.new(1, 0, 0),
    uvtl: vec3.new(0, 1, 0),
    uvtr: vec3.new(1, 1, 0)
  };

  var quadUVs = new Array(4);

  return function (out, sprite, x, y, w, h, start, range, cx, cy) {

    vec3.sub(uvXaxis, sprite.uvs[3], sprite.uvs[0]);
    vec3.sub(uvYaxis, sprite.uvs[12], sprite.uvs[0]);
    quadUVs[0] = sprite.uvs[0];
    quadUVs[1] = sprite.uvs[3];
    quadUVs[2] = sprite.uvs[15];
    quadUVs[3] = sprite.uvs[12];
    // fast return ,generate simple mesh if range is bigger than 1
    if (range >= 1) {
      _genSimpleVerts(out, sprite, x, y, w, h);
      out.indices = _simpleIndices;
      return out;
    }
    out.indices = _fullRadialIndices;

    // clamp range, center and start
    range = range < 0 ? 0 : range;
    while (start >= 1) {
      start = start - 1;
    }
    while (start < 0) {
      start = start + 1;
    }
    start = start * Math.PI * 2;
    range = range * Math.PI * 2;
    var end = start + range;

    center.x = cx < 0 ? 0 : cx;
    center.y = cy < 0 ? 0 : cy;
    center.x = cx > 1 ? 1 : cx;
    center.y = cy > 1 ? 1 : cy;

    vec3.copy(centerUVs, sprite.uvs[0]);
    centerUVs.x += uvXaxis.x * cx;
    centerUVs.y += uvXaxis.y * cx;
    centerUVs.x += uvYaxis.x * cy;
    centerUVs.y += uvYaxis.y * cy;

    center.x = center.x * w;
    center.y = center.y * h;
    // fill quad vertice
    quadVertPoses[0].x = 0; quadVertPoses[0].y = 0;
    quadVertPoses[1].x = w; quadVertPoses[1].y = 0;
    quadVertPoses[2].x = w; quadVertPoses[2].y = h;
    quadVertPoses[3].x = 0; quadVertPoses[3].y = h;
    for (var index = 0; index < 4; ++index) {
      quadVertAngles[index] = _getVertAngle(center, quadVertPoses[index]);
    }
    rawQuad.left = 0; rawQuad.bottom = 0;
    rawQuad.right = w; rawQuad.top = h;
    rawQuad.uvbl = sprite.uvs[0]; rawQuad.uvbr = sprite.uvs[3];
    rawQuad.uvtl = sprite.uvs[12]; rawQuad.uvtr = sprite.uvs[15];
    _getInsectedPoints(rawQuad, center, start, intersectionPoints1, intersectionUVs1);
    _getInsectedPoints(rawQuad, center, end, intersectionPoints2, intersectionUVs2);
    // iterate each edge
    // center should be added
    var vertCount = 1;
    vec3.copy(out.lposList[0], center);
    vec3.copy(out.uvs[0], centerUVs);

    for (var index$1 = 0; index$1 < 4; ++index$1) {
      var startAngle = quadVertAngles[index$1];
      var endAngle = quadVertAngles[(index$1 + 1) % 4];
      if (endAngle < startAngle) { endAngle += Math.PI * 2; }
      startAngle -= Math.PI * 2;
      endAngle -= Math.PI * 2;

      for (var testIndex = 0; testIndex < 3; ++testIndex) {
        if (startAngle >= end) {
          // all out
        } else if (startAngle >= start) {
          if (endAngle >= end) {
            // startAngle to fillEnd
            vec3.copy(out.lposList[vertCount], quadVertPoses[index$1]);
            vec3.copy(out.lposList[vertCount + 1], intersectionPoints2[index$1]);

            vec3.copy(out.uvs[vertCount], quadUVs[index$1]);
            vec3.copy(out.uvs[vertCount + 1], intersectionUVs2[index$1]);

            vertCount += 2;
            
          } else {

            vec3.copy(out.lposList[vertCount], quadVertPoses[index$1]);
            vec3.copy(out.lposList[vertCount + 1], quadVertPoses[(index$1 + 1) % 4]);

            vec3.copy(out.uvs[vertCount], quadUVs[index$1]);
            vec3.copy(out.uvs[vertCount + 1], quadUVs[(index$1 + 1) % 4]);

            vertCount += 2;
            
          }
        } else {
          // startAngle < fillStarts
          if (endAngle <= start) {
            // all out
          } else if (endAngle <= end) {
            // fillStart to endAngle
            vec3.copy(out.lposList[vertCount], intersectionPoints1[index$1]);
            vec3.copy(out.lposList[vertCount + 1], quadVertPoses[(index$1 + 1) % 4]);

            vec3.copy(out.uvs[vertCount], intersectionUVs1[index$1]);
            vec3.copy(out.uvs[vertCount + 1], quadUVs[(index$1 + 1) % 4]);

            vertCount += 2;
            
          } else {
            // fillStart to fillEnd
            vec3.copy(out.lposList[vertCount], intersectionPoints1[index$1]);
            vec3.copy(out.lposList[vertCount + 1], intersectionPoints2[index$1]);

            vec3.copy(out.uvs[vertCount], intersectionUVs1[index$1]);
            vec3.copy(out.uvs[vertCount + 1], intersectionUVs2[index$1]);

            vertCount += 2;
            
          }
        }
        // add 2 * PI
        startAngle += Math.PI * 2;
        endAngle += Math.PI * 2;
      }
    }

    for (var index$2 = 0; index$2 < vertCount; ++index$2) {
      out.lposList[index$2].x += x;
      out.lposList[index$2].y += y;
    }

    // fill empty verts to generate degraded triangles
    for (var index$3 = vertCount; index$3 < out.lposList.length; ++index$3) {
      vec3.copy(out.lposList[index$3], out.lposList[0]);
    }

    return out;
  };
})();

var ImageComponent = (function (WidgetComponent$$1) {
  function ImageComponent () {
    WidgetComponent$$1.apply(this, arguments);
  }

  if ( WidgetComponent$$1 ) ImageComponent.__proto__ = WidgetComponent$$1;
  ImageComponent.prototype = Object.create( WidgetComponent$$1 && WidgetComponent$$1.prototype );
  ImageComponent.prototype.constructor = ImageComponent;

  ImageComponent.prototype.onInit = function onInit () {
    this._cachedVertexData = _reallocVertexData(this._type, this._fillType);
    this._vertexDataDirty = true;

    if (this._material === null) {
      this._material = this._app.assets.get('builtin-material-sprite');
    }
  };

  ImageComponent.prototype._onRectChanged = function _onRectChanged () {
    this._vertexDataDirty = true;
  };

  ImageComponent.prototype.calcVertexData = function calcVertexData (x, y, w, h) {
    var this$1 = this;

    if (this._vertexDataDirty) {
      this._vertexDataDirty = false;
      var sprite = this._sprite;
      if (sprite === null) {
        sprite = this._app.assets.get('default-sprite');
      }
      color4.copy(this._cachedVertexData.color, this._color);
      if (this._type === 'simple') {
        _genSimpleVerts(this._cachedVertexData, sprite, x, y, w, h);
      } else if (this._type == 'sliced') {
        _genSlicedVerts(this._cachedVertexData, sprite, x, y, w, h);
      } else if (this._type === 'filled') {
        if (this._fillType === 'radial') {
          _genFilledRadialVerts(this._cachedVertexData, sprite, x, y, w, h, this._fillStart, this._fillRange, this._fillCenter.x, this._fillCenter.y);
        } else if (this._fillType === 'vertical') {
          _genFilledVerticalVerts(this._cachedVertexData, sprite, x, y, w, h, this._fillStart, this._fillRange);
        } else {
          _genFilledHorizontalVerts(this._cachedVertexData, sprite, x, y, w, h, this._fillStart, this._fillRange);
        }
      }
    }

    this._entity.getWorldMatrix(_m4_tmp$4);

    for (var i = 0; i < this._cachedVertexData.lposList.length; ++i) {
      var lpos = this$1._cachedVertexData.lposList[i];
      var wpos = this$1._cachedVertexData.wposList[i];

      vec3.transformMat4(wpos, lpos, _m4_tmp$4);
    }

    return this._cachedVertexData;
  };

  return ImageComponent;
}(WidgetComponent));

ImageComponent.schema = {
  material: {
    type: 'asset',
    default: null,
    set: function set(val) {
      if (val === this._material) {
        return;
      }

      this._material = val;
    }
  },

  type: {
    type: 'enums',
    default: 'simple',
    options: ['simple', 'sliced', 'filled'],
    set: function set(val) {
      if (val === this._type) {
        return;
      }

      this._type = val;
      this._cachedVertexData = _reallocVertexData(this._type, this._fillType);
      this._vertexDataDirty = true;
    }
  },

  fillType: {
    type: 'enums',
    default: 'horizontal',
    options: ['horizontal', 'vertical', 'radial'],
    set: function set(val) {
      if (val === this._fillType) {
        return;
      }

      this._fillType = val;
      if (this._type === 'filled') {
        this._cachedVertexData = _reallocVertexData(this._type, this._fillType);
        this._vertexDataDirty = true;
      }
    }
  },

  fillStart: {
    type: 'number',
    default: 0.2,
    set: function set(val) {
      if (val === this._fillStart) {
        return;
      }

      this._fillStart = val;
      if (this._type === 'filled') {
        this._vertexDataDirty = true;
      }
    }
  },

  fillRange: {
    type: 'number',
    default: 0.8,
    set: function set(val) {
      if (val === this._fillRange) {
        return;
      }

      this._fillRange = val;
      if (this._type === 'filled') {
        this._vertexDataDirty = true;
      }
    }
  },

  fillCenter: {
    type: 'vec2',
    default: [0.5, 0.5],
    set: function set(val) {
      if (vec2.equals(this._fillCenter, val)) {
        return;
      }

      this._fillCenter = val;
      if (this._type === 'filled' && this._fillType === 'radial') {
        this._vertexDataDirty = true;
      }
    }
  },

  sprite: {
    type: 'asset',
    default: null,
    set: function set(val) {
      if (val === this._sprite) {
        return;
      }

      this._sprite = val;
      this._vertexDataDirty = true;
    }
  },

  color: {
    type: 'color4',
    default: [1, 1, 1, 1],
    set: function set(val) {
      if (color4.equals(this._color, val)) {
        return;
      }

      color4.copy(this._color, val);
      this._vertexDataDirty = true;
    },
  }
};

var _m4_tmp$5 = mat4.create();
var _tmpCanvas = document.createElement('canvas'); // tmp canvas for measure text
_tmpCanvas.width = _tmpCanvas.height = 1;

function _reallocVertexData$1(textCount) {
  var vertexCount = 4 * textCount;
  var indexCount = 6 * textCount;

  var indices = new Array(indexCount);
  var lposList = new Array(vertexCount);
  var wposList = new Array(vertexCount);
  var uvs = new Array(vertexCount);
  var color = color4.new();

  for (var i = 0; i < vertexCount; ++i) {
    wposList[i] = vec3.zero();
    lposList[i] = vec3.zero();
    uvs[i] = vec2.zero();
  }

  for (var i$1 = 0; i$1 < textCount; ++i$1) {
    indices[6 * i$1 + 0] = 4 * i$1 + 0;
    indices[6 * i$1 + 1] = 4 * i$1 + 1;
    indices[6 * i$1 + 2] = 4 * i$1 + 2;
    indices[6 * i$1 + 3] = 4 * i$1 + 3;
    indices[6 * i$1 + 4] = 4 * i$1 + 2;
    indices[6 * i$1 + 5] = 4 * i$1 + 1;
  }

  return {
    wposList: wposList,
    lposList: lposList,
    uvs: uvs,
    color: color,
    indices: indices,
  };
}


// get width of single line text
function _getTextWidth(textComp, ctx, text) {
  var result = 0;
  if (textComp._font === null) { // system font
    result = ctx.measureText(text).width;
  } else {
    var fontScale = textComp._fontSize / textComp._font._size;
    for (var i = 0; i < text.length; ++i) {
      var charCode = text.charCodeAt(i);
      var glyph = textComp._font._glyphs[charCode] || textComp._font._defaultGlyph;
      result += glyph.xadvance * fontScale;
    }
  }

  return result;
}

function _getWrappedInfos(textComp, text, width) {
  var results = [];
  var words = text.split(textComp._regWordSep);
  var lastIndex = 0;
  var index = 0;
  var accWordsWidth = 0;

  var ctx = _tmpCanvas.getContext('2d');
  if (textComp._font === null) { // system font
    var fontItalic = textComp._italic ? 'italic' : '';
    var fontBold = textComp._bold ? 'bold' : '';
    var fontStyle = fontItalic + " " + fontBold + " " + (textComp._fontSize) + "px " + (textComp._fontFamily);
    ctx.font = fontStyle;
  }

  // sep + word pair
  for (var i = 0; i + 1 < words.length;) {
    var sepWidth = _getTextWidth(textComp, ctx, words[i]);
    var wordWidth = _getTextWidth(textComp, ctx, words[i + 1]);
    if (accWordsWidth + sepWidth + wordWidth < width) {
      if (i !== 0 && accWordsWidth === 0) {
        accWordsWidth += wordWidth;
        lastIndex = lastIndex + words[i].length;
        index += words[i].length + words[i + 1].length;
        // test succeed, increment word index
        i += 2;
      } else {
        accWordsWidth += sepWidth + wordWidth;
        index += words[i].length + words[i + 1].length;
        // test succeed, increment word index
        i += 2;
      }
    } else if (accWordsWidth === 0) {
      // force add one word to line to avoid infinite loop
      results.push({
        start: lastIndex + words[i].length,
        end: lastIndex + words[i].length + words[i + 1].length,
        width: wordWidth
      });
      lastIndex = lastIndex + words[i].length + words[i + 1].length;
      index = lastIndex;
      accWordsWidth = 0;
      // test failed, force add one, increment word index
      i += 2;
    } else {
      // test failed, add wrapped info
      results.push({
        start: lastIndex,
        end: index,
        width: accWordsWidth
      });

      lastIndex = index;
      accWordsWidth = 0;
    }
  }

  // add the last line, do not add the last sep
  if (accWordsWidth > 0) {
    results.push({
      start: lastIndex,
      end: index,
      width: accWordsWidth
    });
  }

  return results;
}

function _genSysFontVertsAndUpdateTexture(textComp, x, y, w, h) {
  function _fillLine(cmd) {
    var curText = cmd.text.slice(cmd.start, cmd.end);
    var curWidth = tmpCtx.measureText(curText).width;
    var cursorX = (w - curWidth) * textComp._alignH;
    fontCtx.fillText(curText, cursorX, cmd.y);
  }

  // set verts
  var out = textComp._cachedVertexData;
  vec3.set(out.lposList[0], x, y, 0);
  vec3.set(out.lposList[1], x + w, y, 0);
  vec3.set(out.lposList[2], x, y + h, 0);
  vec3.set(out.lposList[3], x + w, y + h, 0);
  vec2.set(out.uvs[0], 0, 0);
  vec2.set(out.uvs[1], 1, 0);
  vec2.set(out.uvs[2], 0, 1);
  vec2.set(out.uvs[3], 1, 1);

  // prepare font canvas
  textComp._fontCanvas.width = w;
  textComp._fontCanvas.height = h;
  var fontCtx = textComp._fontCanvas.getContext('2d');
  fontCtx.clearRect(0, 0, w, h);
  fontCtx.fillStyle = '#FFFFFF';

  // apply font style
  var fontItalic = textComp._italic ? 'italic' : '';
  var fontBold = textComp._bold ? 'bold' : '';
  var fontStyle = fontItalic + " " + fontBold + " " + (textComp._fontSize) + "px " + (textComp._fontFamily);
  fontCtx.font = fontStyle;

  // HACK: no good idea to figure out glyph's ascend.
  var startY = textComp._lineHeight * textComp._fontSize * -0.15;
  var cursorY = startY;
  var paragraphs = textComp._text.split('\n');

  var tmpCtx = _tmpCanvas.getContext('2d');
  tmpCtx.font = fontStyle;

  var drawCmd = []; // cache draw command for apply alignV after
  if (textComp._wrap) {
    for (var i = 0; i < paragraphs.length; ++i) {
      var wrapInfos = _getWrappedInfos(textComp, paragraphs[i], w);
      if (wrapInfos.length === 0) { // should not ignore empty line
        cursorY += textComp._lineHeight * textComp._fontSize;
        drawCmd.push({
          text: '',
          start: 0,
          end: 0,
          y: cursorY
        });
      } else {
        for (var j = 0; j < wrapInfos.length; ++j) {
          cursorY += textComp._lineHeight * textComp._fontSize;
          drawCmd.push({
            text: paragraphs[i],
            start: wrapInfos[j].start,
            end: wrapInfos[j].end,
            y: cursorY
          });
        }
      }
    }
  } else {
    for (var i$1 = 0; i$1 < paragraphs.length; ++i$1) {
      cursorY += textComp._lineHeight * textComp._fontSize;
      drawCmd.push({
        text: paragraphs[i$1],
        start: 0,
        end: paragraphs[i$1].length,
        y: cursorY
      });
    }
  }

  var textH = drawCmd[drawCmd.length - 1].y - startY;
  for (var i$2 = 0; i$2 < drawCmd.length; ++i$2) {
    drawCmd[i$2].y += (h - textH) * textComp._alignV;
    _fillLine(drawCmd[i$2]);
  }

  textComp._fontTexture.setImages([textComp._fontCanvas]);
  textComp._fontTexture.commit();
}

function _genFontVerts(textComp, x, y, w, h) {
  var cursorY = 0;
  var paragraphs = textComp._text.split('\n');
  var font = textComp._font;
  var fontScale = textComp._fontSize / font._size;
  var out = textComp._cachedVertexData;
  var totalLines = 0;
  var totalChars = 0;

  function _fillLine(para, start, end) {
    var cursorX = 0;
    for (var i = 0; i < end - start; ++i) {
      var charCode = para.charCodeAt(i + start);
      var glyph = font._glyphs[charCode] || font._defaultGlyph;
      var x0 = cursorX + glyph.xoffset * fontScale;
      var x1 = cursorX + (glyph.width + glyph.xoffset) * fontScale;
      var y0 = cursorY - (glyph.height + glyph.yoffset) * fontScale;
      var y1 = cursorY - glyph.yoffset * fontScale;

      var idx = totalChars + i;

      vec3.set(out.lposList[4 * idx + 0], x0, y0, 0);
      vec3.set(out.lposList[4 * idx + 1], x1, y0, 0);
      vec3.set(out.lposList[4 * idx + 2], x0, y1, 0);
      vec3.set(out.lposList[4 * idx + 3], x1, y1, 0);

      vec2.copy(out.uvs[4 * idx + 0], glyph.uvs[0]);
      vec2.copy(out.uvs[4 * idx + 1], glyph.uvs[1]);
      vec2.copy(out.uvs[4 * idx + 2], glyph.uvs[2]);
      vec2.copy(out.uvs[4 * idx + 3], glyph.uvs[3]);

      cursorX += glyph.xadvance * fontScale;
    }

    // process alignH
    if (cursorX < w) {
      for (var i$1 = 0; i$1 < end - start; ++i$1) {
        var offsetX = (w - cursorX) * textComp._alignH;
        var idx$1 = totalChars + i$1;

        out.lposList[4 * idx$1 + 0].x += offsetX;
        out.lposList[4 * idx$1 + 1].x += offsetX;
        out.lposList[4 * idx$1 + 2].x += offsetX;
        out.lposList[4 * idx$1 + 3].x += offsetX;
      }
    }

    totalChars += end - start;
    ++totalLines;
    cursorY -= textComp._lineHeight * font._lineHeight * fontScale;
  }

  if (textComp._wrap) {
    for (var i = 0; i < paragraphs.length; ++i) {
      var wrapInfos = _getWrappedInfos(textComp, paragraphs[i], w);
      if (wrapInfos.length === 0 && textComp._text.length !== 0) { // should not ignore empty line when wrapped, draw a space
        _fillLine(' ', 0, 1);
      } else {
        for (var j = 0; j < wrapInfos.length; ++j) {
          _fillLine(paragraphs[i], wrapInfos[j].start, wrapInfos[j].end);
        }
      }
    }
  } else {
    for (var i$1 = 0; i$1 < paragraphs.length; ++i$1) {
      _fillLine(paragraphs[i$1], 0, paragraphs[i$1].length);
    }
  }

  // process alignV and move it to [0,0, width, height] rect
  var labelHeight = totalLines * textComp._lineHeight * font._lineHeight * fontScale;
  var alignVOffset = labelHeight < h ? (h - labelHeight) * -textComp._alignV : 0.0;
  var offsetY = y + h + alignVOffset;

  for (var i$2 = 0; i$2 < totalChars; ++i$2) {
    out.lposList[4 * i$2 + 0].x += x;
    out.lposList[4 * i$2 + 1].x += x;
    out.lposList[4 * i$2 + 2].x += x;
    out.lposList[4 * i$2 + 3].x += x;

    out.lposList[4 * i$2 + 0].y += offsetY;
    out.lposList[4 * i$2 + 1].y += offsetY;
    out.lposList[4 * i$2 + 2].y += offsetY;
    out.lposList[4 * i$2 + 3].y += offsetY;
  }
  return totalChars;
}

var TextComponent = (function (WidgetComponent$$1) {
  function TextComponent () {
    WidgetComponent$$1.apply(this, arguments);
  }

  if ( WidgetComponent$$1 ) TextComponent.__proto__ = WidgetComponent$$1;
  TextComponent.prototype = Object.create( WidgetComponent$$1 && WidgetComponent$$1.prototype );
  TextComponent.prototype.constructor = TextComponent;

  TextComponent.prototype.onInit = function onInit () {
    this._alignH = 0.0;
    this._alignV = 0.0;
    this._regWordSep = new RegExp(this._wordSep);

    // system font properties
    this._fontCanvas = document.createElement('canvas');

    if (this._material === null) {
      this._material = this._app.assets.get('builtin-material-font');
    }

    if (this._font === null && this._fontTexture === null) {
      this._fontTexture = new Texture2D$2(this._app.device);
      this._fontTexture.mipmap = false; // TODO: should support mipmap?
      this._fontTexture.wrapS = 'clamp';
      this._fontTexture.wrapT = 'clamp';
      this._fontTexture.premultiplyAlpha = true;
    }

    this._updateFont();
    this._updateAlignHV();
  };

  TextComponent.prototype._onRectChanged = function _onRectChanged () {
    this._vertexDataDirty = true;
  };

  TextComponent.prototype._updateFont = function _updateFont () {
    if (this._font === null) { // system font
      this._cachedVertexData = _reallocVertexData$1(1);
      this._vertexDataDirty = true;
      return;
    }

    if (this._font.type === 'opentype') {
      this._font.addText(this._text);
    } else if (this._font.type === 'bitmap') {
      this._material = this._app.assets.get('builtin-material-sprite');
    }

    this._cachedVertexData = _reallocVertexData$1(this._text.length);
    this._vertexDataDirty = true;
  };

  TextComponent.prototype._updateAlignHV = function _updateAlignHV () {
    if (this._align === 'top-left') {
      this._alignH = 0.0;
      this._alignV = 0.0;
    } else if (this._align === 'top-center') {
      this._alignH = 0.5;
      this._alignV = 0.0;
    } else if (this._align === 'top-right') {
      this._alignH = 1.0;
      this._alignV = 0.0;
    } else if (this._align === 'middle-left') {
      this._alignH = 0.0;
      this._alignV = 0.5;
    } else if (this._align === 'middle-center') {
      this._alignH = 0.5;
      this._alignV = 0.5;
    } else if (this._align === 'middle-right') {
      this._alignH = 1.0;
      this._alignV = 0.5;
    } else if (this._align === 'bottom-left') {
      this._alignH = 0.0;
      this._alignV = 1.0;
    } else if (this._align === 'bottom-center') {
      this._alignH = 0.5;
      this._alignV = 1.0;
    } else if (this._align === 'bottom-right') {
      this._alignH = 1.0;
      this._alignV = 1.0;
    }
  };

  TextComponent.prototype.calcVertexData = function calcVertexData (x, y, w, h) {
    var this$1 = this;

    if (this._vertexDataDirty) {
      this._vertexDataDirty = false;

      color4.copy(this._cachedVertexData.color, this._color);

      if (this._font === null) { // system font
        _genSysFontVertsAndUpdateTexture(this, x, y, w, h);
      } else {
        _genFontVerts(this, x, y, w, h);
      }
    }

    this._entity.getWorldMatrix(_m4_tmp$5);

    for (var i = 0; i < this._cachedVertexData.lposList.length; ++i) {
      var lpos = this$1._cachedVertexData.lposList[i];
      var wpos = this$1._cachedVertexData.wposList[i];

      vec3.transformMat4(wpos, lpos, _m4_tmp$5);
    }

    return this._cachedVertexData;
  };

  return TextComponent;
}(WidgetComponent));

TextComponent.schema = {
  material: {
    type: 'asset',
    default: null,
    set: function set(val) {
      if (val === this._material) {
        return;
      }

      this._material = val;
    }
  },

  font: {
    type: 'asset',
    default: null,
    set: function set(val) {
      if (val === this._font) {
        return;
      }

      this._font = val;
      this._updateFont();
    }
  },

  text: {
    type: 'string',
    default: '',
    set: function set(val) {
      if (this._text === val) {
        return;
      }

      this._text = val;
      this._updateFont();
    }
  },

  align: {
    type: 'enums',
    default: 'top-left',
    options: [
      'top-left',
      'top-center',
      'top-right',
      'middle-left',
      'middle-center',
      'middle-right',
      'bottom-left',
      'bottom-center',
      'bottom-right'
    ],
    set: function set(val) {
      if (this._align === val) {
        return;
      }

      this._align = val;
      this._vertexDataDirty = true;
      this._updateAlignHV();
    }
  },

  wrap: {
    type: 'boolean',
    default: true,
    set: function set(val) {
      if (this._wrap === val) {
        return;
      }

      this._wrap = val;
      this._vertexDataDirty = true;
    }
  },

  fontSize: {
    type: 'int',
    default: 32,
    set: function set(val) {
      if (this._fontSize === val) {
        return;
      }

      this._fontSize = val;
      this._vertexDataDirty = true;
    }
  },

  lineHeight: {
    type: 'number',
    default: 1.0,
    set: function set(val) {
      if (this._lineHeight === val) {
        return;
      }

      this._lineHeight = val;
      this._vertexDataDirty = true;
    }
  },

  color: {
    type: 'color4',
    default: [1, 1, 1, 1],
    set: function set(val) {
      if (color4.equals(this._color, val)) {
        return;
      }

      this._color = val;
      this._vertexDataDirty = true;
    }
  },

  wordSep: {
    type: 'string',
    default: /([a-zA-Z0-9--]+|\S)/,
    set: function set(val) {
      if (this._wordSep === val) {
        return;
      }

      this._wordSep = val;
      this._regWordSep = new RegExp(val);
    }
  },

  fontFamily: {
    type: 'string',
    default: 'Arial',
    set: function set(val) {
      if (this._fontFamily === val) {
        return;
      }

      this._fontFamily = val;
      this._vertexDataDirty = true;
    }
  },

  // only for system font
  italic: {
    type: 'boolean',
    default: false,
    set: function set(val) {
      if (this._italic === val) {
        return;
      }

      this._italic = val;
      this._vertexDataDirty = true;
    }
  },

  // only for system font
  bold: {
    type: 'boolean',
    default: false,
    set: function set(val) {
      if (this._bold === val) {
        return;
      }

      this._bold = val;
      this._vertexDataDirty = true;
    },
  },

  // only for system font
  fontTexture: {
    type: 'asset',
    default: null,
  }
};

var _m4_tmp$6 = mat4.create();

function _reallocVertexData$2() {
  var vertexCount = 4;
  var indices = [
    0, 1, 2, 3, 2, 1
  ];

  var lposList = new Array(vertexCount);
  var wposList = new Array(vertexCount);
  var uvs = new Array(vertexCount);
  var color = color4.new(1, 1, 1, 1);

  uvs[0] = vec2.new(0, 0);
  uvs[1] = vec2.new(1, 0);
  uvs[2] = vec2.new(0, 1);
  uvs[3] = vec2.new(1, 1);

  for (var i = 0; i < vertexCount; ++i) {
    wposList[i] = vec3.zero();
    lposList[i] = vec3.zero();
  }

  return {
    wposList: wposList,
    lposList: lposList,
    uvs: uvs,
    color: color,
    indices: indices,
  };
}

var MaskComponent = (function (WidgetComponent$$1) {
  function MaskComponent () {
    WidgetComponent$$1.apply(this, arguments);
  }

  if ( WidgetComponent$$1 ) MaskComponent.__proto__ = WidgetComponent$$1;
  MaskComponent.prototype = Object.create( WidgetComponent$$1 && WidgetComponent$$1.prototype );
  MaskComponent.prototype.constructor = MaskComponent;

  MaskComponent.prototype.onInit = function onInit () {
    this._cachedVertexData = _reallocVertexData$2();
    this._vertexDataDirty = true;

    if (this._material === null) {
      this._material = this._app.assets.get('builtin-material-sprite');
    }
  };

  MaskComponent.prototype._onRectChanged = function _onRectChanged () {
    this._vertexDataDirty = true;
  };

  MaskComponent.prototype.calcVertexData = function calcVertexData (x, y, w, h) {
    var this$1 = this;

    if (this._vertexDataDirty) {
      this._vertexDataDirty = false;

      vec3.set(this._cachedVertexData.lposList[0], x, y, 0);
      vec3.set(this._cachedVertexData.lposList[1], x + w, y, 0);
      vec3.set(this._cachedVertexData.lposList[2], x, y + h, 0);
      vec3.set(this._cachedVertexData.lposList[3], x + w, y + h, 0);
    }

    this._entity.getWorldMatrix(_m4_tmp$6);

    for (var i = 0; i < this._cachedVertexData.lposList.length; ++i) {
      var lpos = this$1._cachedVertexData.lposList[i];
      var wpos = this$1._cachedVertexData.wposList[i];

      vec3.transformMat4(wpos, lpos, _m4_tmp$6);
    }

    return this._cachedVertexData;
  };

  return MaskComponent;
}(WidgetComponent));

MaskComponent.schema = {
  material: {
    type: 'asset',
    default: null,
    set: function set(val) {
      if (val === this._material) {
        return;
      }

      this._material = val;
    }
  },

  sprite: {
    type: 'asset',
    default: null,
    set: function set(val) {
      if (val !== this._sprite) {
        return;
      }

      this._sprite = val;
    }
  }
};

var UIElementSystem = (function (System) {
  function UIElementSystem() {
    System.call(this);
    this._uiElements = new FixedArray(200);
  }

  if ( System ) UIElementSystem.__proto__ = System;
  UIElementSystem.prototype = Object.create( System && System.prototype );
  UIElementSystem.prototype.constructor = UIElementSystem;

  UIElementSystem.prototype.add = function add (comp) {
    this._uiElements.push(comp);
  };

  UIElementSystem.prototype.remove = function remove (comp) {
    var this$1 = this;

    for (var i = 0; i < this._uiElements.length; ++i) {
      var c = this$1._uiElements.data[i];
      if (c === comp) {
        this$1._uiElements.fastRemove(i);
        break;
      }
    }
  };

  UIElementSystem.prototype.tick = function tick () {
    var this$1 = this;

    for (var i = 0; i < this._uiElements.length; ++i) {
      var uiElement = this$1._uiElements.data[i];
      if (uiElement && uiElement.tick) {
        uiElement.tick();
      }
    }
  };

  UIElementSystem.prototype.postTick = function postTick () {
    var this$1 = this;

    for (var i = 0; i < this._uiElements.length; ++i) {
      var uiElement = this$1._uiElements.data[i];
      if (uiElement && uiElement.postTick) {
        uiElement.postTick();
      }
    }
  };

  return UIElementSystem;
}(System));

var ButtonComponent = (function (UIElementComponent$$1) {
  function ButtonComponent() {
    UIElementComponent$$1.call(this);
    // private
    this._highlighting = false;
    this._pressing = false;
    this._widget = null;
    this._bgImage = null;

    // properties
    this._state = 'none';
    // only support first finger
    this._fingerId = -1;
  }

  if ( UIElementComponent$$1 ) ButtonComponent.__proto__ = UIElementComponent$$1;
  ButtonComponent.prototype = Object.create( UIElementComponent$$1 && UIElementComponent$$1.prototype );
  ButtonComponent.prototype.constructor = ButtonComponent;

  ButtonComponent.prototype.onInit = function onInit () {
    this._widget = this._entity.getComp('Widget');
    this._widget.focusable = true;

    this._bgImage = this._background && this._background.getComp('Image');
    if (!this._bgImage) {
      this._bgImage = this._entity.getComp('Image');
    }
  };

  ButtonComponent.prototype.onDestroy = function onDestroy () {
    this._widget.focusable = false;
  };

  ButtonComponent.prototype._updateState = function _updateState () {
    var state = 'normal';

    if (this._pressing) {
      state = 'pressed';
    } else if (this._highlighting) {
      state = 'highlight';
    }

    if (this._state === state) {
      return;
    }

    var oldState = this._state;
    this._state = state;

    this.dispatch('transition', {
      detail: {
        oldState: oldState,
        newState: this._state
      }
    });

    if (this._bgImage === null) {
      return;
    }

    if (this._transition === 'none') {
      return;
    }

    if (this._transition === 'color') {
      this._bgImage.color = this._transitionColors[state];
    } else if (this._transition === 'sprite') {
      this._bgImage.sprite = this._transitionSprites[state];
    } else {
      // todo: not implemented
      console.warn('Button transition animation is not implemented');
    }
  };

  ButtonComponent.prototype._onMouseEnter = function _onMouseEnter (e) {
    if (this.enabled === false) {
      return;
    }

    var widgetSys = this._widget.system;
    this._highlighting = true;

    if (
      widgetSys.focusedEntity === this._entity &&
      e.buttons & 1 !== 0
    ) {
      this._pressing = true;
    }

    this._updateState();
  };

  ButtonComponent.prototype._onMouseLeave = function _onMouseLeave () {
    if (this.enabled === false) {
      return;
    }

    var widgetSys = this._widget.system;

    this._pressing = false;
    if (
      widgetSys.focusedEntity &&
      widgetSys.focusedEntity === this._entity
    ) {
      this._highlighting = true;
    } else {
      this._highlighting = false;
    }

    this._updateState();
  };

  ButtonComponent.prototype._onMouseDown = function _onMouseDown (e) {
    if (this.enabled === false) {
      return;
    }

    var widgetSys = this._widget.system;
    if (e.button === 'left') {
      e.stop();

      if (widgetSys.focusedEntity !== this._entity) {
        return;
      }

      this._pressing = true;
      this._updateState();
    }
  };

  ButtonComponent.prototype._onMouseUp = function _onMouseUp (e) {
    if (this.enabled === false) {
      return;
    }

    if (e.button === 'left') {
      e.stop();

      this._pressing = false;
      this._updateState();

      this.dispatch('clicked');
    }
  };

  ButtonComponent.prototype._onFocus = function _onFocus () {
    if (this.enabled === false) {
      return;
    }

    this._highlighting = true;
    this._updateState();
  };

  ButtonComponent.prototype._onBlur = function _onBlur () {
    if (this.enabled === false) {
      return;
    }

    this._fingerId = -1;
    this._highlighting = false;
    this._updateState();
  };

  ButtonComponent.prototype._onTouchEnter = function _onTouchEnter (e) {
    if (this.enabled === false) {
      return;
    }

    if (this._fingerId === e.id) {
      e.stop();
      this._pressing = true;
      this._updateState();
    }
  };

  ButtonComponent.prototype._onTouchLeave = function _onTouchLeave (e) {
    if (this.enabled === false) {
      return;
    }

    e.stop();
    this._pressing = false;
    this._updateState();
  };

  ButtonComponent.prototype._onTouchStart = function _onTouchStart (e) {
    if (this.enabled === false) {
      return;
    }

    e.stop();

    this._fingerId = e.id;
    this._pressing = true;
    this._updateState();
  };

  ButtonComponent.prototype._onTouchEnd = function _onTouchEnd (e) {
    if (this.enabled === false) {
      return;
    }

    e.stop();

    this._fingerId = -1;
    this._pressing = false;
    this._updateState();

    this.dispatch('clicked');
  };

  return ButtonComponent;
}(UIElementComponent));

ButtonComponent.events = {
  'mouseenter': '_onMouseEnter',
  'mouseleave': '_onMouseLeave',
  'mousedown': '_onMouseDown',
  'mouseup': '_onMouseUp',
  'focus': '_onFocus',
  'blur': '_onBlur',
  'touchenter': '_onTouchEnter',
  'touchleave': '_onTouchLeave',
  'touchstart': '_onTouchStart',
  'touchend': '_onTouchEnd'
};

ButtonComponent.schema = {
  transitionColors: {
    type: 'object',
    default: {
      normal: color4.create(),
      highlight: color4.create(),
      pressed: color4.create(),
      disabled: color4.create()
    }
  },

  transitionSprites: {
    type: 'object',
    parse: function parse(app, value, propInfo, entities) {
      if (value) {
        var cPropInfo = { normal: null, highlight: null, pressed: null, disabled: null };
        if (value.normal && typeof value.normal === 'string') {
          cPropInfo.normal = app.assets.get(value.normal);
        }

        if (value.highlight && typeof value.highlight === 'string') {
          cPropInfo.highlight = app.assets.get(value.highlight);
        }

        if (value.pressed && typeof value.pressed === 'string') {
          cPropInfo.pressed = app.assets.get(value.pressed);
        }

        if (value.disabled && typeof value.disabled === 'string') {
          cPropInfo.disabled = app.assets.get(value.disabled);
        }

        return cPropInfo;
      }
    },
    default: {
      normal: null,
      highlight: null,
      pressed: null,
      disabled: null
    }
  },

  background: {
    type: 'entity',
    default: null,
    set: function set(val) {
      if (!(val instanceof Entity)) {
        return;
      }

      this._background = val;
      if (this._background) {
        this._bgImage = this._background.getComp('Image');
      }
    }
  },

  transition: {
    type: 'enums',
    default: 'none',
    options: ['none', 'color', 'sprite']
  }
};

var ToggleComponent = (function (UIElementComponent$$1) {
  function ToggleComponent() {
    UIElementComponent$$1.call(this);
    this._state = 'none';
    this._highlighting = false;
    this._pressing = false;
    this._widget = null;
    this._bgImage = null;
    this._toggleGroupComp = null;
    this._checkerImage = null;
    // only support first finger
    this._fingerId = -1;
  }

  if ( UIElementComponent$$1 ) ToggleComponent.__proto__ = UIElementComponent$$1;
  ToggleComponent.prototype = Object.create( UIElementComponent$$1 && UIElementComponent$$1.prototype );
  ToggleComponent.prototype.constructor = ToggleComponent;

  ToggleComponent.prototype.onInit = function onInit () {
    this._widget = this._entity.getComp('Widget');
    this._widget.focusable = true;
    this._bgImage = this._background && this._background.getComp('Image');
    if (!this._bgImage) {
      this._bgImage = this._entity.getComp('Image');
    }

    this._toggleGroupComp = this._toggleGroup && this._toggleGroup.getComp('ToggleGroup');
    if (this._toggleGroupComp) {
      this._toggleGroupComp._addItem(this);
    }

    this._checkerImage = this._checker && this._checker.getComp('Image');
    if (this._checkerImage) {
      this._checkerImage.enabled = this._checked;
    }
  };

  ToggleComponent.prototype.onDestroy = function onDestroy () {
    this._widget.focusable = false;
  };

  ToggleComponent.prototype._updateState = function _updateState () {
    var state = 'normal';

    if (this._pressing) {
      state = 'pressed';
    } else if (this._highlighting) {
      state = 'highlight';
    }

    if (this._state === state) {
      return;
    }

    var oldState = this._state;
    this._state = state;

    this.dispatch('transition', {
      detail: {
        oldState: oldState,
        newState: this._state
      }
    });

    if (this._bgImage === null) {
      return;
    }

    if (this._transition === 'none') {
      return;
    }

    if (this._transition === 'color') {
      this._bgImage.color = this._transitionColors[state];
    } else if (this._transition === 'sprite') {
      this._bgImage.sprite = this._transitionSprites[state];
    } else {
      // todo: not implemented
      console.warn('Button transition animation is not implemented');
    }
  };

  ToggleComponent.prototype._onMouseEnter = function _onMouseEnter (e) {
    if (this.enabled === false) {
      return;
    }

    var widgetSys = this._widget.system;
    this._highlighting = true;

    if (
      widgetSys.focusedEntity === this._entity &&
      e.buttons & 1 !== 0
    ) {
      this._pressing = true;
    }

    this._updateState();
  };

  ToggleComponent.prototype._onMouseLeave = function _onMouseLeave () {
    if (this.enabled === false) {
      return;
    }

    var widgetSys = this._widget.system;

    this._pressing = false;
    if (
      widgetSys.focusedEntity &&
      widgetSys.focusedEntity === this._entity
    ) {
      this._highlighting = true;
    } else {
      this._highlighting = false;
    }

    this._updateState();
  };

  ToggleComponent.prototype._onMouseDown = function _onMouseDown (e) {
    if (this.enabled === false) {
      return;
    }

    var widgetSys = this._widget.system;
    if (e.button === 'left') {
      e.stop();

      if (widgetSys.focusedEntity !== this._entity) {
        return;
      }

      this._pressing = true;
      this._updateState();
    }
  };

  ToggleComponent.prototype._onMouseUp = function _onMouseUp (e) {
    if (this.enabled === false) {
      return;
    }

    var widgetSys = this._widget.system;
    if (e.button === 'left') {
      e.stop();

      if (widgetSys.focusedEntity !== this._entity) {
        return;
      }

      this.checked = !this.checked;
      this.dispatch('change');
      if (this._toggleGroupComp) {
        this._toggleGroupComp._updateCheck(this);
      }

      this._pressing = false;
      this._updateState();
    }
  };

  ToggleComponent.prototype._onFocus = function _onFocus () {
    if (this.enabled === false) {
      return;
    }

    this._highlighting = true;
    this._updateState();
  };

  ToggleComponent.prototype._onBlur = function _onBlur () {
    if (this.enabled === false) {
      return;
    }

    this._fingerId = -1;
    this._highlighting = false;
    this._updateState();
  };

  ToggleComponent.prototype._onTouchEnter = function _onTouchEnter (e) {
    if (this.enabled === false) {
      return;
    }

    if (this._fingerId === e.id) {
      e.stop();
      this._pressing = true;
      this._updateState();
    }
  };

  ToggleComponent.prototype._onTouchLeave = function _onTouchLeave (e) {
    if (this.enabled === false) {
      return;
    }

    e.stop();
    this._pressing = false;
    this._updateState();
  };

  ToggleComponent.prototype._onTouchStart = function _onTouchStart (e) {
    if (this.enabled === false) {
      return;
    }

    e.stop();

    this._fingerId = e.id;
    this._pressing = true;
    this._updateState();
  };

  ToggleComponent.prototype._onTouchEnd = function _onTouchEnd (e) {
    if (this.enabled === false) {
      return;
    }

    e.stop();

    this._fingerId = -1;
    this._pressing = false;
    this._updateState();

    this.checked = !this.checked;
    this.dispatch('change');
    if (this._toggleGroupComp) {
      this._toggleGroupComp._updateCheck(this);
    }
  };

  return ToggleComponent;
}(UIElementComponent));

ToggleComponent.events = {
  'mouseenter': '_onMouseEnter',
  'mouseleave': '_onMouseLeave',
  'mousedown': '_onMouseDown',
  'mouseup': '_onMouseUp',
  'focus': '_onFocus',
  'blur': '_onBlur',
  'touchenter': '_onTouchEnter',
  'touchleave': '_onTouchLeave',
  'touchstart': '_onTouchStart',
  'touchend': '_onTouchEnd'
};

ToggleComponent.schema = {
  checker: {
    type: 'entity',
    default: null,
    set: function set(val) {
      if (!(val instanceof Entity)) {
        return;
      }

      if (this._checker === val) {
        return;
      }

      this._checker = val;
      if (this._checker) {
        this._checkerImage = this._checker.getComp('Image');
        this._checkerImage.enabled = this._checked;
      }
    }
  },

  checked: {
    type: 'boolean',
    default: true,
    set: function set(val) {
      if (this._checked === val) {
        return;
      }

      this._checked = val;
      if (this._checkerImage) {
        this._checkerImage.enabled = this._checked;
      }
    }
  },

  toggleGroup: {
    type: 'entity',
    default: null,
    set: function set(val) {
      if (!(val instanceof Entity)) {
        return;
       }

      if (this._toggleGroup === val) {
        return;
      }

      this._toggleGroup = val;
      if (this._toggleGroupComp) {
        this._toggleGroupComp._removeItem(this);
        this._toggleGroupComp = null;
      }

      if (this._toggleGroup) {
        this._toggleGroupComp = this._toggleGroup.getComp('ToggleGroup');
        if (this._toggleGroupComp) {
          this._toggleGroupComp._addItem(this);
         }
      }
    }
  },

  transitionColors: {
    type: 'object',
    default: {
      normal: color4.create(),
      highlight: color4.create(),
      pressed: color4.create(),
      disabled: color4.create(),
    },
  },

  transitionSprites: {
    type: 'object',
    parse: function parse(app, value, propInfo, entities) {
      if (value) {
        var cPropInfo = { normal: null, highlight: null, pressed: null, disabled: null };
        if (value.normal && typeof value.normal === 'string') {
          cPropInfo.normal = app.assets.get(value.normal);
        }

        if (value.highlight && typeof value.highlight === 'string') {
          cPropInfo.highlight = app.assets.get(value.highlight);
        }

        if (value.pressed && typeof value.pressed === 'string') {
          cPropInfo.pressed = app.assets.get(value.pressed);
        }

        if (value.disabled && typeof value.disabled === 'string') {
          cPropInfo.disabled = app.assets.get(value.disabled);
        }

        return cPropInfo;
      }
    },
    default: {
      normal: null,
      highlight: null,
      pressed: null,
      disabled: null
    },
  },

  background: {
    type: 'entity',
    default: null,
    set: function set(val) {
      if (!(val instanceof Entity)) {
        return;
      }

      if (this._background === val) {
        return;
      }

      this._background = val;
      if (this._background) {
        this._bgImage = this._background.getComp('Image');
      }
    },
  },

  transition: {
    type: 'enums',
    default: 'none',
    options: ['none', 'color', 'sprite'],
  }
};

var ToggleGroupComponent = (function (UIElementComponent$$1) {
  function ToggleGroupComponent() {
    UIElementComponent$$1.call(this);

    this._toggleItems = [];
    // only one toggled item is allowed
    this._activeItem = null;
  }

  if ( UIElementComponent$$1 ) ToggleGroupComponent.__proto__ = UIElementComponent$$1;
  ToggleGroupComponent.prototype = Object.create( UIElementComponent$$1 && UIElementComponent$$1.prototype );
  ToggleGroupComponent.prototype.constructor = ToggleGroupComponent;

  ToggleGroupComponent.prototype._addItem = function _addItem (item) {
    if (this._toggleItems.indexOf(item) === -1) {
      this._toggleItems.push(item);
      if (this._activeItem === null) {
        if (item.checked) {
          this._activeItem = item;
        }
      } else {
        item.checked = false;
      }
    } else {
      console.warn('toggle item already added into toggle groups');
    }
  };

  ToggleGroupComponent.prototype._removeItem = function _removeItem (item) {
    var pos = this._toggleItems.indexOf(item);
    if (pos === -1) {
      console.warn('toggle item not exists in toggle groups');
    } else {
      if (this._activeItem === item) {
        this._activeItem = null;
      }
      this._toggleItems.splice(pos, 1);
    }
  };

  ToggleGroupComponent.prototype._updateCheck = function _updateCheck (item) {
    var pos = this._toggleItems.indexOf(item);
    if (pos === -1) {
      console.warn('toggle item not exists in toggle groups');
      return true;
    } else {
      if (this._activeItem !== item) {
        if (this._activeItem) {
          this._activeItem.checked = false;
        }
        this._activeItem = item;
      } else {
        if (!this._allowSwitchOff) {
          if (this._activeItem && !this._activeItem.checked) {
            this._activeItem.checked = true;
          }
        }
      }
    }
  };

  return ToggleGroupComponent;
}(UIElementComponent));

ToggleGroupComponent.schema = {
  allowSwitchOff: {
    type: 'boolean',
    default: false,
  }
};

var SliderComponent = (function (UIElementComponent$$1) {
  function SliderComponent() {
    var this$1 = this;

    UIElementComponent$$1.call(this);
    this._state = 'none';
    this._calMinValue = 0.0;
    this._calMaxValue = 1.0;
    this._highlighting = false;
    this._pressing = false;
    this._widget = null;
    this._dragging = false;
    this._bgImage = null;
    this._handleWidget = null;
    this._fillWidget = null;
    this._lastAxis = 'horizontal';
    this._normalizedValue = 0.0;// range[0,1]
    this._reverse = false;
    this._fingerId = -1;

    // mouse events
    this._onMouseEnter = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      var widgetSys = this$1._widget.system;
      this$1._highlighting = true;

      if (
        widgetSys.focusedEntity === this$1._entity &&
        e.buttons & 1 !== 0
      ) {
        this$1._pressing = true;
      }

      this$1._updateState();
    };

    this._onMouseLeave = function () {
      if (this$1.enabled === false) {
        return;
      }

      var widgetSys = this$1._widget.system;

      this$1._pressing = false;
      if (
        widgetSys.focusedEntity &&
        widgetSys.focusedEntity === this$1._entity
      ) {
        this$1._highlighting = true;
      } else {
        this$1._highlighting = false;
      }

      this$1._updateState();
    };

    this._onMouseDown = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      var widgetSys = this$1._widget.system;
      if (e.button === 'left') {
        e.stop();

        if (widgetSys.focusedEntity !== this$1._entity) {
          return;
        }

        this$1._pressing = true;
        this$1._updateState();
        // handle only drag move
        if (!this$1._handle || e.target !== this$1._handle) {
          this$1._updateDrag(vec3.new(e.mouseX, e.mouseY, 0));
        }

        this$1._dragging = true;
      }
    };

    this._onMouseMove = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      if (e.button === 0) {
        e.stop();

        if (this$1._dragging) {
          this$1._updateDrag(vec3.new(e.mouseX, e.mouseY, 0));
        }
      }
    };

    this._onMouseUp = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      if (e.button === 'left') {
        e.stop();

        this$1._dragging = false;
        this$1._pressing = false;
        this$1._updateState();
      }
    };

    // touch events
    this._onTouchMove = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      e.stop();
      if (e.id === this$1._fingerId) {
        if (this$1._dragging) {
          this$1._updateDrag(vec3.new(e.x, e.y, 0));
        }
      }
    };

    this._onTouchStart = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      e.stop();
      if (this$1._fingerId !== -1) {
        return;
      }

      this$1._fingerId = e.id;
      this$1._pressing = true;
      this$1._updateState();
      if (!this$1._handle || e.target !== this$1._handle) {
        this$1._updateDrag(vec3.new(e.x, e.y, 0));
      }

      this$1._dragging = true;
    };

    this._onTouchEnd = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      e.stop();
      if (e.id !== this$1._fingerId) {
        return;
      }

      this$1._dragging = false;
      this$1._fingerId = -1;
      this$1._pressing = false;
      this$1._updateState();
    };
  }

  if ( UIElementComponent$$1 ) SliderComponent.__proto__ = UIElementComponent$$1;
  SliderComponent.prototype = Object.create( UIElementComponent$$1 && UIElementComponent$$1.prototype );
  SliderComponent.prototype.constructor = SliderComponent;

  SliderComponent.prototype.onInit = function onInit () {
    UIElementComponent$$1.prototype.onInit.call(this);
    this._widget = this._entity.getComp('Widget');
    this._widget.focusable = true;

    this._bgImage = this._background && this._background.getComp('Image');
    if (!this._bgImage) {
      this._bgImage = this._entity.getComp('Image');
    }

    this._fillWidget = this._fill && this._fill.getComp('Widget');
    this._handleWidget = this._handle && this._handle.getComp('Widget');
    var relativeValue = 0.0;
    if (this._value > 0) {
      relativeValue = (this._value - this._calMinValue) / (this._calMaxValue - this._calMinValue);
      relativeValue = Math.round(relativeValue * 100) / 100;
    }

    this._normalizedValue = this._reverse ? 1 - relativeValue : relativeValue;
    this._updateVisuals();
  };

  SliderComponent.prototype.onDestroy = function onDestroy () {
    this._widget.focusable = false;
    UIElementComponent$$1.prototype.onDestroy.call(this);
  };

  SliderComponent.prototype._updateState = function _updateState () {
    var state = 'normal';

    if (this._pressing) {
      state = 'pressed';
    } else if (this._highlighting) {
      state = 'highlight';
    }

    if (this._state === state) {
      return;
    }

    var oldState = this._state;
    this._state = state;

    this.dispatch('transition', {
      detail: {
        oldState: oldState,
        newState: this._state
      }
    });

    if (this._bgImage === null) {
      return;
    }

    if (this._transition === 'none') {
      return;
    }

    if (this._transition === 'color') {
      this._bgImage.color = this._transitionColors[state];
    } else if (this._transition === 'sprite') {
      this._bgImage.sprite = this._transitionSprites[state];
    } else {
      // todo: not implemented
      console.warn('Button transition animation is not implemented');
    }
  };

  SliderComponent.prototype._set = function _set (value) {
    var num = clamp(value, this._calMinValue, this._calMaxValue);
    if (this._value != num) {
      this._value = num;
      this._updateVisuals();
      this._emitValueChangedEvents();
    }
  };

  SliderComponent.prototype._getReverseValue = function _getReverseValue () {
    return this._maxValue < this._minValue;
  };

  SliderComponent.prototype._updateDrag = function _updateDrag (mousePos) {
    var widget = this._handle ? this._handleWidget : this._fillWidget;
    var containerWidget = widget._entity.parent.getComp('Widget');
    if (containerWidget) {
      var corner = [vec3.zero(), vec3.zero(), vec3.zero(), vec3.zero()];
      containerWidget.getWorldCorners(corner[0], corner[1], corner[2], corner[3]);
      var position = corner[1];
      var containerVec = vec3.zero(), offsetVec = vec3.zero();
      var width = 0.0, value = 0.0;
      if (this._direction === 'horizontal') {
        vec3.subtract(containerVec, corner[2], position);
        vec3.subtract(offsetVec, mousePos, position);
        // ??? widget-component need open width and height
        width = vec3.distance(corner[2], position);
        this._normalizedValue = clamp01(value / width);
      } else {
        vec3.subtract(containerVec, corner[0], position);
        vec3.subtract(offsetVec, mousePos, position);
        // ??? widget-component need open width and height
        width = vec3.distance(corner[0], position);
      }
      value = vec3.dot(containerVec, offsetVec) / width;
      this._normalizedValue = clamp01(value / width);
      this._clampValue();
    }
  };

  SliderComponent.prototype._updateVisuals = function _updateVisuals () {
    var min = [0, 0];
    var max = [1, 1];
    var dirValue = this._direction === 'horizontal' ? 0 : 1;
    if (this._fillWidget) {
      var sprite = this._fill.getComp('Image');
      // NOTE:need to verify
      if (sprite) {
        if (sprite.type === 'filled') {
          sprite.filledStart = this._normalizedValue;
        } else if (this._reverse) {
          min[dirValue] = this._normalizedValue;
        } else {
          max[dirValue] = this._normalizedValue;
        }
      }

      this._fillWidget.setAnchors(min[0], min[1], max[0], max[1]);
    }

    if (this._handleWidget) {
      min = [0, 0];
      max = [1, 1];
      min[dirValue] = this._normalizedValue;
      max[dirValue] = this._normalizedValue;
      this._handleWidget.setAnchors(min[0], min[1], max[0], max[1]);
    }
  };

  SliderComponent.prototype._clampValue = function _clampValue () {
    this.value = (this._reverse ? (1 - this._normalizedValue) : this._normalizedValue) * (this._calMaxValue - this._calMinValue);
  };

  SliderComponent.prototype._getCalculateWidget = function _getCalculateWidget () {
    return this._handle.parent.getComp('Widget');
  };

  SliderComponent.prototype._onFocus = function _onFocus () {
    if (this.enabled === false) {
      return;
    }

    this._highlighting = true;
    this._updateState();
  };

  SliderComponent.prototype._onBlur = function _onBlur () {
    if (this.enabled === false) {
      return;
    }

    this._fingerId = -1;
    this._highlighting = false;
    this._updateState();
  };

  SliderComponent.prototype._onTouchEnter = function _onTouchEnter (e) {
    if (this.enabled === false) {
      return;
    }

    if (this._fingerId !== -1 && this._fingerId === e.id) {
      e.stop();
      this._pressing = true;
      this._updateState();
    }
  };

  SliderComponent.prototype._onTouchLeave = function _onTouchLeave (e) {
    if (this.enabled === false) {
      return;
    }

    if (this._fingerId !== -1 && this._fingerId === e.id) {
      e.stop();
      this._pressing = false;
      this._updateState();
    }
  };

  SliderComponent.prototype._emitValueChangedEvents = function _emitValueChangedEvents () {
    this.dispatch('Slider.onValueChanged');
  };

  return SliderComponent;
}(UIElementComponent));

SliderComponent.events = {
  'mouseenter': '_onMouseEnter',
  'mouseleave': '_onMouseLeave',
  'mousemove': '_onMouseMove',
  'mousedown': '_onMouseDown',
  'mouseup': '_onMouseUp',
  'focus': '_onFocus',
  'blur': '_onBlur',
  'touchenter': '_onTouchEnter',
  'touchleave': '_onTouchLeave',
  'touchstart': '_onTouchStart',
  'touchmove': '_onTouchMove',
  'touchend': '_onTouchEnd'
};

SliderComponent.schema = {
  handle: {
    type: 'entity',
    default: null,
    set: function set(val) {
      if (!(val instanceof Entity)) {
        return;
      }

      if (this._handle === val) {
        return;
      }

      this._handle = val;
      if (this._handle) {
        this._handleWidget = this._handle.getComp('Widget');
      }

      this._updateVisuals();
    }
  },

  fill: {
    type: 'entity',
    default: null,
    set: function set(val) {
      if (!(val instanceof Entity)) {
        return;
      }

      if (this._fill === val) {
        return;
      }

      this._fill = val;
      if (this._fill) {
        this._fillWidget = this._fill.getComp('Widget');
      }

      this._updateVisuals();
    }
  },

  direction: {
    type: 'enums',
    default: 'horizontal',
    options: ['horizontal', 'vertical'],
    set: function set(val) {
      if (this._direction === val) {
        return;
      }

      this._direction = val;
      this._lastAxis = this._direction;
    }
  },

  minValue: {
    type: 'number',
    default: 0.0,
    set: function set(val) {
      if (this._minValue === val) {
        return;
      }

      this._minValue = val;
      this._calMinValue = val;
      if (this._minValue > this._maxValue) {
        this._calMinValue = this._maxValue;
        this._calMaxValue = this._minValue;
      }
    }
  },

  maxValue: {
    type: 'number',
    default: 1.0,
    set: function set(val) {
      if (this._maxValue === val) {
        return;
      }

      this._maxValue = val;
      this._calMaxValue = val;
      if (this._minValue > this._maxValue) {
        this._calMinValue = this._maxValue;
        this._calMaxValue = this._minValue;
      }
    }
  },

  value: {
    type: 'number',
    default: 0.0,
    set: function set(val) {
      if (this._value === val) {
        return;
      }

      this._set(val, false);
    }
  },

  transitionColors: {
    type: 'object',
    default: {
      normal: color4.create(),
      highlight: color4.create(),
      pressed: color4.create(),
      disabled: color4.create(),
    }
  },

  transitionSprites: {
    type: 'object',
    parse: function parse(app, value, propInfo, entities) {
      if (value) {
        var cPropInfo = { normal: null, highlight: null, pressed: null, disabled: null };
        if (value.normal && typeof value.normal === 'string') {
          cPropInfo.normal = app.assets.get(value.normal);
        }

        if (value.highlight && typeof value.highlight === 'string') {
          cPropInfo.highlight = app.assets.get(value.highlight);
        }

        if (value.pressed && typeof value.pressed === 'string') {
          cPropInfo.pressed = app.assets.get(value.pressed);
        }

        if (value.disabled && typeof value.disabled === 'string') {
          cPropInfo.disabled = app.assets.get(value.disabled);
        }

        return cPropInfo;
      }
    },
    default: {
      normal: null,
      highlight: null,
      pressed: null,
      disabled: null
    }
  },

  background: {
    type: 'entity',
    default: null,
    set: function set(val) {
      if (!(val instanceof Entity)) {
        return;
      }

      if (this._background === val) {
        return;
      }

      this._background = val;
      if (this._background) {
        this._bgImage = this._background.getComp('Image');
      }
    }
  },

  transition: {
    type: 'enums',
    default: 'none',
    options: ['none', 'color', 'sprite'],
  },
};

var EditBoxComponent = (function (UIElementComponent$$1) {
  function EditBoxComponent() {
    var this$1 = this;

    UIElementComponent$$1.call(this);
    this._state = 'none';
    this._highlighting = false;
    this._pressing = false;
    this._widget = null;
    this._bgImage = null;
    this._textComp = null;
    this._activeDom = null;
    this._inputText = '';
    this._editMode = false;

    // mouse events
    this._onMouseMove = function () {
      if (this$1._pressing) {
        this$1._flushDom();
      }
    };

    this._onMouseEnter = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      var widgetSys = this$1._widget.system;
      this$1._highlighting = true;

      if (
        widgetSys.focusedEntity === this$1._entity &&
        e.buttons & 1 !== 0
      ) {
        this$1._pressing = true;
      }

      this$1._updateState();
    };

    this._onMouseLeave = function () {
      if (this$1.enabled === false) {
        return;
      }

      var widgetSys = this$1._widget.system;

      this$1._pressing = false;
      if (
        widgetSys.focusedEntity &&
        widgetSys.focusedEntity === this$1._entity
      ) {
        this$1._highlighting = true;
      } else {
        this$1._highlighting = false;
      }

      this$1._updateState();
    };

    this._onMouseDown = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      var widgetSys = this$1._widget.system;
      if (e.button === 'left') {
        e.stop();

        if (widgetSys.focusedEntity !== this$1._entity) {
          return;
        }

        this$1._pressing = true;
        this$1._updateState();
      }
    };

    this._onMouseUp = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      if (e.button === 'left') {
        e.stop();

        this$1._pressing = false;
        this$1._updateState();
        this$1._onClk();
      }
    };

    this._onInput = function () {
      this$1._text = this$1._activeDom.value;
      this$1._emitValueChangedEvents();
    };

    this._onReturnKey = function (e) {
      if (this$1._textComp === null) {
        return;
      }

      if (e.keyCode === 13) {
        if (this$1._returnKeyType === 'new-line') {
          if (this$1._lineType === 'multi-line') {
            this$1._text += '\n';
          }
        } else {
          this$1._endInput();
          if (this$1._returnKeyType === 'submit') {
            this$1._emitSubmitEvents();
          }
        }
      }
    };

    // touch events
    this._onTouchEnd = function (e){
      if (this$1.enabled === false) {
        return;
      }

      e.stop();

      this$1._pressing = false;
      this$1._updateState();

      this$1._onClk();
    };
  }

  if ( UIElementComponent$$1 ) EditBoxComponent.__proto__ = UIElementComponent$$1;
  EditBoxComponent.prototype = Object.create( UIElementComponent$$1 && UIElementComponent$$1.prototype );
  EditBoxComponent.prototype.constructor = EditBoxComponent;

  EditBoxComponent.prototype.onInit = function onInit () {
    UIElementComponent$$1.prototype.onInit.call(this);
    this._widget = this._entity.getComp('Widget');
    this._widget.focusable = true;

    this._bgImage = this._background && this._background.getComp('Image');
    if (!this._bgImage) {
      this._bgImage = this._entity.getComp('Image');
    }

    this._textComp = this._textEnt && this._textEnt.getComp('Text');
    if (this._textComp) {
      var textAlign = this._textComp.align;
      var a = textAlign.split('-');
      if (a.indexOf('middle') === -1) {
        this._textComp.align = 'middle-' + a[1];
      }
    }

    this._dealText(this._text);
    if (this._lineType === 'multi-line') {
      this._createDom('textarea');
    } else {
      this._createDom('input');
    }
  };

  EditBoxComponent.prototype.onDisable = function onDisable () {
    this._endInput();
  };

  EditBoxComponent.prototype.onDestroy = function onDestroy () {
    this._widget.focusable = false;
    this._endInput();
    UIElementComponent$$1.prototype.onDestroy.call(this);
  };

  EditBoxComponent.prototype._updateState = function _updateState () {
    var state = 'normal';

    if (this._pressing) {
      state = 'pressed';
    } else if (this._highlighting) {
      state = 'highlight';
    }

    if (this._state === state) {
      return;
    }

    var oldState = this._state;
    this._state = state;

    this.dispatch('transition', {
      detail: {
        oldState: oldState,
        newState: this._state
      }
    });

    if (this._bgImage === null) {
      return;
    }

    if (this._transition === 'none') {
      return;
    }

    if (this._transition === 'color') {
      this._bgImage.color = this._transitionColors[state];
    } else if (this._transition === 'sprite') {
      this._bgImage.sprite = this._transitionSprites[state];
    } else {
      // todo: not implemented
      console.warn('Button transition animation is not implemented');
    }
  };

  EditBoxComponent.prototype._registerEvent = function _registerEvent () {
    this._activeDom.addEventListener('input', this._onInput);
    this._activeDom.addEventListener('keypress', this._onReturnKey);
  };

  EditBoxComponent.prototype._unregisterEvent = function _unregisterEvent () {
    this._activeDom.removeEventListener('input', this._onInput);
    this._activeDom.removeEventListener('keypress', this._onReturnKey);
  };

  EditBoxComponent.prototype._onClk = function _onClk () {
    if (this._textComp === null) {
      return;
    }

    if (!this._editMode) {
      this._editMode = true;
      this._activeDom.style.display = 'block';
      this._activeDom.value = this._text;
      this._textComp.enabled = false;
      // TODO:settimeout to auto active keyboard failed,need to active manual operation
      this._startFocus();
    }
  };

  EditBoxComponent.prototype._startFocus = function _startFocus () {
    this._activeDom.focus();
    this._flushDom();
  };

  EditBoxComponent.prototype._dealText = function _dealText (val) {
    var this$1 = this;

    if (this._textComp === null) {
      return;
    }

    this._text = '';
    if (this._lineType === 'single-line') {
      val = val.replace('\n', '');
    }

    var num = Math.min(val.length, this._maxLength);
    for (var i = 0; i < num; ++i) {
      var result = this$1._checkChar(val[i], this$1._text.length, this$1._text);
      if (result.length > 0) {
        this$1._text += result;
      }
    }

    this._switchTextState();
    var text = this._text;
    if (this._contentType === 'password') {
      text = this._text.replace(new RegExp('.+?', 'g'), 'V');
    }

    this._textComp.text = text.length > 0 ? text : this.defaultText;
  };

  EditBoxComponent.prototype._switchTextState = function _switchTextState () {
    // the prompt is translucent when there is no text.
    var textCompColor = this._textComp.color;
    if (this._text.length <= 0) {
      this._textComp.color = color4.new(textCompColor.r, textCompColor.g, textCompColor.b, 0.5);
    } else {
      this._textComp.color = color4.new(textCompColor.r, textCompColor.g, textCompColor.b, 1);
    }
  };

  EditBoxComponent.prototype._checkChar = function _checkChar (c, index, text) {
    var isMatch = false;

    if (this._contentType === 'standard') {
      return c;
    }

    if (this._contentType === 'int-number' || this._contentType === 'decimal-number') {
      isMatch = new RegExp('[0-9]').test(c);
      if (isMatch) {
        return c;
      }

      if (c === '-') {
        if (index === 0) {
          return c;
        }
      }

      if (c === '.' && this._contentType === 'decimal-number' && this._text.indexOf('.') < 0) {
        return c;
      }
    } else if (this._contentType === 'alpha-number') {
      isMatch = new RegExp('[0-9a-zA-Z]').test(c);
      if (isMatch) {
        return c;
      }
    } else if (this._contentType === 'caps-all') {
      return c.toUpperCase();
    } else if (this._contentType === 'name') {
      isMatch = new RegExp('[a-zA-Z]').test(c);
      if (isMatch) {
        isMatch = new RegExp('[a-z]').test(c);
        if (isMatch) {
          if (index === 0 || text[index - 1] === ' ') {
            return c.toUpperCase();
          }
        } else {
          if (index > 0 && text[index - 1] !== ' ') {
            return c.toLowerCase();
          }
        }
        return c;
      } else {
        if (c === ' ' && index > 0) {
          if (text[index - 1] !== ' ') {
            return c;
          }
        }
      }
    } else if (this._contentType === 'email') {
      isMatch = new RegExp('[0-9a-zA-Z]').test(c);
      if (isMatch) {
        return c;
      }

      if (c === '@' && this._text.indexOf('@') === -1) {
        return c;
      }

      var str = '!#$%&\'*+-/=?^_`{}|~';
      if (str.indexOf(c) !== -1) {
        return c;
      }

      if (c === '.') {
        if (index > 0 && text[index - 1] !== '.') {
          return c;
        }
      }
    } else {
      return c;
    }

    return '';
  };

  EditBoxComponent.prototype._endInput = function _endInput () {
    if (this._textComp === null) {
      return;
    }

    if (this._editMode) {
      this._editMode = false;
      this._activeDom.style.display = 'none';
      this._dealText(this._text);
      this._textComp.enabled = true;
      if (this._text.length <= 0) {
        this._textComp.text = this.defaultText;
      }
      this._switchTextState();
      this._activeDom.blur();
    }
  };

  EditBoxComponent.prototype._createDom = function _createDom (type) {
    if (this._activeDom) {
      this._unregisterEvent();
      document.body.removeChild(this._activeDom);
    }

    this._activeDom = document.createElement(type);
    document.body.appendChild(this._activeDom);
    if (this._activeDom.type !== 'textarea') {
      this._activeDom.type = this._contentType === 'password' ? 'password' : 'text';
    }
    this._activeDom.style.background = 'transparent';
    this._activeDom.style.position = 'absolute';
    this._activeDom.style.padding = '2px';
    this._activeDom.style.fontSize = this._textComp !== null ? this._textComp.fontSize + 'px' : '10px';
    this._activeDom.style.display = 'none';
    if (this._activeDom.type === 'textarea') {
      this._activeDom.style.active = 0;
      this._activeDom.style.overflowY = 'scroll';
      this._activeDom.style.resize = 'none';
    }

    this._activeDom.maxLength = this._maxLength;
    this._registerEvent();
  };

  EditBoxComponent.prototype._flushDom = function _flushDom () {
    if (this._textComp === null || this._activeDom.style.display === 'none') {
      return;
    }

    var canvas = this._app._canvas;
    var widget = this._textComp.entity.getComp('Widget');
    var corner = [vec3.zero(), vec3.zero(), vec3.zero(), vec3.zero()];
    widget.getWorldCorners(corner[0], corner[1], corner[2], corner[3]);
    var padding = 4;
    var left = corner[0].x + padding;
    var top = canvas.height - corner[0].y + padding;
    var align = this._textComp.align;
    this._activeDom.type === 'textarea' ? 'textarea' : 'input';
    align = align.indexOf('left') !== -1 ? 'left' : align.indexOf('center') !== -1 ? 'center' : 'right';
    this._activeDom.style.textAlign = align;
    this._activeDom.maxLength = this._maxLength;
    this._activeDom.style.width = (widget._rect.w - padding - 2) + 'px';
    this._activeDom.style.height = (widget._rect.h - padding - 2) + 'px';
    this._activeDom.style.top = top + 'px';
    this._activeDom.style.left = left + 'px';
  };

  EditBoxComponent.prototype._onFocus = function _onFocus () {
    if (this.enabled === false) {
      return;
    }

    this._highlighting = true;
    this._updateState();
  };

  EditBoxComponent.prototype._onBlur = function _onBlur () {
    if (this._entity.enabledInHierarchy === false) {
      return;
    }

    this._fingerId = -1;
    this._highlighting = false;
    this._updateState();
    this._endInput();
  };

  EditBoxComponent.prototype._onTouchEnter = function _onTouchEnter (e) {
    if (this.enabled === false) {
      return;
    }

    if (this._fingerId === e.id) {
      e.stop();
      this._pressing = true;
      this._updateState();
    }
  };

  EditBoxComponent.prototype._onTouchLeave = function _onTouchLeave (e) {
    if (this.enabled === false) {
      return;
    }

    e.stop();
    this._pressing = false;
    this._updateState();
  };

  EditBoxComponent.prototype._onTouchStart = function _onTouchStart (e) {
    if (this.enabled === false) {
      return;
    }

    e.stop();

    this._fingerId = e.id;
    this._pressing = true;
    this._updateState();
  };

  EditBoxComponent.prototype._emitValueChangedEvents = function _emitValueChangedEvents () {
    this.dispatch('EditBox.onValueChanged');
  };

  EditBoxComponent.prototype._emitSubmitEvents = function _emitSubmitEvents () {
    this.dispatch('EditBox.onSubmit');
  };

  return EditBoxComponent;
}(UIElementComponent));

EditBoxComponent.events = {
  'mouseenter': '_onMouseEnter',
  'mouseleave': '_onMouseLeave',
  'mousedown': '_onMouseDown',
  'mousemove': '_onMouseMove',
  'mouseup': '_onMouseUp',
  'focus': '_onFocus',
  'blur': '_onBlur',
  'touchenter': '_onTouchEnter',
  'touchleave': '_onTouchLeave',
  'touchstart': '_onTouchStart',
  'touchend': '_onTouchEnd'
};

EditBoxComponent.schema = {
  defaultText: {
    type: 'string',
    default: ''
  },

  textEnt: {
    type: 'entity',
    default: null,
    set: function set(val) {
      if (!(val instanceof Entity)) {
        return;
      }

      if (this._textEnt === val) {
        return;
      }

      this._textEnt = val;
      if (!this._textEnt) {
        console.warn('Text component cannot be null');
      }

      if (this._textEnt) {
        this._textComp = this._textEnt.getComp('Text');
        if (this._textComp) {
          this._activeDom.style.fontSize = this._textComp.fontSize + 'px';
          this._textComp.text = this._defaultText;
          var textAlign = this._textComp.align;
          var a = textAlign.split('-');
          if (a.indexOf('middle') === -1) {
            this._textComp.align = 'middle-' + a[1];
          }
        }
        this._switchTextState();
      }
    }
  },

  text: {
    type: 'string',
    default: '',
    set: function set(val) {
      val = !val ? '' : val;
      if (this._text === val) {
        return;
      }

      this._dealText(val);
    }
  },

  contentType: {
    type: 'enums',
    default: 'standard',
    options: ['standard', 'int-number', 'decimal-number', 'alpha-number', 'caps-all', 'name', 'email', 'password'],
    set: function set(val) {
      if (this._contentType === val) {
        return;
      }

      this._contentType = val;
      if (this._contentType === 'password') {
        this._activeDom.type = 'password';
        this.lineType = 'single-line';
      } else if (this._contentType === 'email') {
        this._activeDom.type = 'email';
        this.lineType = 'single-line';
      } else {
        this._activeDom.type = 'text';
        this.lineType = this._lineType;
      }

      this._dealText(this._text);
    }
  },

  lineType: {
    type: 'enums',
    default: 'single-line',
    options: ['single-line', 'multi-line'],
    set: function set(val) {
      if (this._lineType === val) {
        return;
      }

      if (this._contentType === 'standard') {
        this._lineType = val;
      } else {
        this._lineType = 'single-line';
      }

      if (this._lineType === 'multi-line') {
        this._createDom('textarea');
      } else {
        this._createDom('input');
      }
    }
  },

  returnKeyType: {
    type: 'enums',
    default: 'none',
    options: ['none', 'submit', 'new-line']
  },

  maxLength: {
    type: 'int',
    default: 2147483647,
    set: function set(val) {
      if (this._maxLength === val) {
        return;
      }

      this._maxLength = val;
      if (this._maxLength <= 0) {
        this._maxLength = 2147483647;
      }

      this._activeDom.maxLength = this._maxLength;
      this._dealText(this._text);
    }
  },

  transitionColors: {
    type: 'object',
    default: {
      normal: color4.create(),
      highlight: color4.create(),
      pressed: color4.create(),
      disabled: color4.create(),
    },
  },

  transitionSprites: {
    type: 'object',
    parse: function parse(app, value, propInfo, entities) {
      if (value) {
        var cPropInfo = { normal: null, highlight: null, pressed: null, disabled: null };
        if (value.normal && typeof value.normal === 'string') {
          cPropInfo.normal = app.assets.get(value.normal);
        }

        if (value.highlight && typeof value.highlight === 'string') {
          cPropInfo.highlight = app.assets.get(value.highlight);
        }

        if (value.pressed && typeof value.pressed === 'string') {
          cPropInfo.pressed = app.assets.get(value.pressed);
        }

        if (value.disabled && typeof value.disabled === 'string') {
          cPropInfo.disabled = app.assets.get(value.disabled);
        }

        return cPropInfo;
      }
    },
    default: {
      normal: null,
      highlight: null,
      pressed: null,
      disabled: null
    },
  },

  background: {
    type: 'entity',
    default: null,
    set: function set(val) {
      if (!(val instanceof Entity)) {
        return;
      }

      if (this._background === val) {
        return;
      }

      this._background = val;
      if (this._background) {
        this._bgImage = this._background.getComp('Image');
      }
    }
  },

  transition: {
    type: 'enums',
    default: 'none',
    options: ['none', 'color', 'sprite'],
    set: function set(val) {
      if (this._transition !== val) {
        this._transition = val;
      }
    },
  },
};

var ScrollBarComponent = (function (UIElementComponent$$1) {
  function ScrollBarComponent() {
    var this$1 = this;

    UIElementComponent$$1.call(this);
    this._state = 'none';
    this._highlighting = false;
    this._pressing = false;
    this._widget = null;

    this._dragging = false;
    this._handleWidget = null;
    this._startDistance = 0.0;
    this._fingerId = -1;

    this._onMouseEnter = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      var widgetSys = this$1._widget.system;
      this$1._highlighting = true;

      if (
        widgetSys.focusedEntity === this$1._entity &&
        e.buttons & 1 !== 0
      ) {
        this$1._pressing = true;
      }

      this$1._updateState();
    };

    this._onMouseLeave = function () {
      if (this$1.enabled === false) {
        return;
      }

      var widgetSys = this$1._widget.system;

      this$1._pressing = false;
      if (
        widgetSys.focusedEntity &&
        widgetSys.focusedEntity === this$1._entity
      ) {
        this$1._highlighting = true;
      } else {
        this$1._highlighting = false;
      }

      this$1._updateState();
    };

    this._onMouseDown = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      var widgetSys = this$1._widget.system;
      if (e.button === 'left') {
        e.stop();

        if (widgetSys.focusedEntity !== this$1._entity) {
          return;
        }

        this$1._pressing = true;
        this$1._updateState();
        if (e.target !== this$1._handle) {
          if (!this$1._dragging) {
            this$1._dragging = true;
            this$1._updateValue(vec2.new(e.mouseX, e.mouseY), true);
          }
        } else {
          this$1._dragging = true;
          this$1._startOffset(vec2.new(e.mouseX, e.mouseY));
        }
      }
    };

    this._onMouseMove = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      if (e.button === 0) {
        e.stop();

        if (this$1._dragging) {
          this$1._updateValue(vec3.new(e.mouseX, e.mouseY, 0));
        }
      }
    };

    this._onMouseUp = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      if (e.button === 'left') {
        e.stop();

        this$1._dragging = false;
        this$1._pressing = false;
        this$1._updateState();
      }
    };

    // touch events
    this._onTouchStart = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      e.stop();
      if (this$1._fingerId !== -1) {
        return;
      }

      this$1._fingerId = e.id;
      this$1._pressing = true;
      this$1._updateState();
      this$1._startPos = vec3.new(e.x, e.y, 0);
      this$1._offsetValue = 0.0;
      if (e.target !== this$1._handle) {
        if (!this$1._dragging) {
          this$1._dragging = true;
          this$1._clkBar(vec3.new(e.x, e.y, 0), true);
        }
      } else {
        this$1._dragging = true;
        this$1._startOffset(vec2.new(e.x, e.y));
      }
    };

    this._onTouchMove = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      e.stop();
      if (e.id === this$1._fingerId) {
        if (this$1._dragging) {
          this$1._updateValue(vec3.new(e.x, e.y, 0));
        }
      }
    };

    this._onTouchEnd = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      e.stop();
      if (e.id !== this$1._fingerId) {
        return;
      }

      this$1._dragging = false;
      this$1._fingerId = -1;
      this$1._pressing = false;
      this$1._updateState();
    };
  }

  if ( UIElementComponent$$1 ) ScrollBarComponent.__proto__ = UIElementComponent$$1;
  ScrollBarComponent.prototype = Object.create( UIElementComponent$$1 && UIElementComponent$$1.prototype );
  ScrollBarComponent.prototype.constructor = ScrollBarComponent;

  ScrollBarComponent.prototype.onInit = function onInit () {
    this._widget = this._entity.getComp('Widget');
    this._widget.focusable = true;

    this._bgImage = this._background && this._background.getComp('Image');
    if (!this._bgImage) {
      this._bgImage = this._entity.getComp('Image');
    }

    this._handleWidget = this._handle && this._handle.getComp('Widget');

    UIElementComponent$$1.prototype.onInit.call(this);
  };

  ScrollBarComponent.prototype.onEnable = function onEnable () {
    this._updateHandle();
  };

  ScrollBarComponent.prototype.onDestroy = function onDestroy () {
    this._widget.focusable = false;
    UIElementComponent$$1.prototype.onDestroy.call(this);
  };

  ScrollBarComponent.prototype._updateState = function _updateState () {
    var state = 'normal';

    if (this._pressing) {
      state = 'pressed';
    } else if (this._highlighting) {
      state = 'highlight';
    }

    if (this._state === state) {
      return;
    }

    var oldState = this._state;
    this._state = state;

    this.dispatch('transition', {
      detail: {
        oldState: oldState,
        newState: this._state
      }
    });

    if (this._background === null) {
      return;
    }

    if (this._transition === 'none') {
      return;
    }

    if (this._transition === 'color') {
      this._background.color = this._transitionColors[state];
    } else if (this._transition === 'sprite') {
      this._background.sprite = this._transitionSprites[state];
    } else {
      // todo: not implemented
      console.warn('Button transition animation is not implemented');
    }
  };

  ScrollBarComponent.prototype._set = function _set (val) {
    var value = this._value;
    if (val === value) {
      return;
    }

    this._value = clamp01(val);
    this._emitValueChangedEvents();
  };

  ScrollBarComponent.prototype._updateValue = function _updateValue (mouse, isClk) {
    if ( isClk === void 0 ) isClk = false;

    if (!this._handle || !this._handle) {
      return;
    }

    var calWidget = this._getCalculateWidget();
    var corners = [vec3.zero(), vec3.zero(), vec3.zero(), vec3.zero()];
    calWidget.getWorldCorners(corners[0], corners[1], corners[2], corners[3]);
    var position = vec2.new(corners[1].x, corners[1].y);
    var calVec = vec2.zero(), mouseVec = vec2.zero();
    var calPos = this._direction === 'horizontal' ? vec2.new(corners[2].x, corners[2].y) : vec2.new(corners[0].x, corners[0].y);
    vec2.subtract(calVec, calPos, position);
    vec2.subtract(mouseVec, mouse, position);
    // ditance current center to origin center
    var offset = [calWidget._rect.w * this._size / 2, calWidget._rect.h * this._size / 2];
    var value = vec2.dot(calVec, mouseVec) / (this._direction === 'horizontal' ? calWidget._rect.w : calWidget._rect.h);
    if (this._direction === 'horizontal') {
      value -= (offset[0] + (isClk ? 0 : this._startDistance));
      value = clamp01(value / (calWidget._rect.w * (1 - this._size)));
    } else {
      value -= (offset[1] + (isClk ? 0 : this._startDistance));
      value = clamp01(value / (calWidget._rect.h * (1 - this._size)));
    }

    this.value = this._reverse ? 1 - value : value;
  };

  ScrollBarComponent.prototype._startOffset = function _startOffset (mouse) {
    var parentCorners = [vec3.zero(), vec3.zero(), vec3.zero(), vec3.zero()];
    var calWidget = this._getCalculateWidget();
    calWidget.getWorldCorners(parentCorners[0], parentCorners[1], parentCorners[2], parentCorners[3]);
    var calVec = vec3.zero();
    if (this._direction === 'horizontal') {
      vec3.subtract(calVec, parentCorners[2], parentCorners[1]);
    } else {
      vec3.subtract(calVec, parentCorners[3], parentCorners[2]);
    }

    var corners = [vec3.zero(), vec3.zero(), vec3.zero(), vec3.zero()];
    this._handleWidget.getWorldCorners(corners[0], corners[1], corners[2], corners[3]);
    // get handle center
    var center = vec3.zero(), delta = vec2.zero();
    vec3.add(center, corners[3], corners[1]);
    vec3.divide(center, center, vec3.new(2, 2, 2));
    // get distance from mouse to center
    vec2.subtract(delta, mouse, vec2.new(center.x, center.y));
    var distance = vec2.dot(delta, vec2.new(calVec.x, calVec.y)) / (this._direction === 'horizontal' ? calWidget._rect.w : calWidget._rect.h);
    return distance;
  };

  ScrollBarComponent.prototype._updateHandle = function _updateHandle () {
    if (!this._handle || !this._handle) {
      return;
    }

    var min = { 0: 0, 1: 0 };
    var max = { 0: 1, 1: 1 };
    var num = this._value * (1 - this._size);
    num = Math.round(parseFloat(num) * 100) / 100;
    var dirValue = this._direction === 'horizontal' ? 0 : 1;
    if (this._reverse) {
      min[dirValue] = 1.0 - num - this._size;
      max[dirValue] = 1.0 - num;
    } else {
      min[dirValue] = num;
      max[dirValue] = num + this._size;
    }

    this._handleWidget.setAnchors(min[0], min[1], max[0], max[1]);
  };

  ScrollBarComponent.prototype._getCalculateWidget = function _getCalculateWidget () {
    if (!this._handle || !this._handle) {
      return null;
    }

    var container = this._handle.parent.getComp('Widget');
    return container;
  };

  ScrollBarComponent.prototype._onFocus = function _onFocus () {
    if (this.enabled === false) {
      return;
    }

    this._highlighting = true;
    this._updateState();
  };

  ScrollBarComponent.prototype._onBlur = function _onBlur () {
    if (this.enabled === false) {
      return;
    }

    this._fingerId = -1;
    this._highlighting = false;
    this._updateState();
  };

  ScrollBarComponent.prototype._onTouchEnter = function _onTouchEnter (e) {
    if (this.enabled === false) {
      return;
    }

    if (this._fingerId !== -1 && this._fingerId === e.id) {
      e.stop();
      this._pressing = true;
      this._updateState();
    }
  };

  ScrollBarComponent.prototype._onTouchLeave = function _onTouchLeave (e) {
    if (this.enabled === false) {
      return;
    }

    if (this._fingerId !== -1 && this._fingerId === e.id) {
      e.stop();
      this._pressing = false;
      this._updateState();
    }
  };

  ScrollBarComponent.prototype._emitValueChangedEvents = function _emitValueChangedEvents () {
    this.dispatch('ScrollBar.onValueChanged');
  };

  return ScrollBarComponent;
}(UIElementComponent));

ScrollBarComponent.events = {
  'mouseenter': '_onMouseEnter',
  'mouseleave': '_onMouseLeave',
  'mousedown': '_onMouseDown',
  'mousemove': '_onMouseMove',
  'mouseup': '_onMouseUp',
  'focus': '_onFocus',
  'blur': '_onBlur',
  'touchenter': '_onTouchEnter',
  'touchleave': '_onTouchLeave',
  'touchstart': '_onTouchStart',
  'touchmove': '_onTouchMove',
  'touchend': '_onTouchEnd'
};

ScrollBarComponent.schema = {
  direction: {
    type: 'enums',
    default: 'horizontal',
    options: ['horizontal', 'vertical'],
    set: function set(val) {
      if (val === this._direction) {
        return;
      }

      this._direction = val;
    }
  },

  size: {
    type: 'number',
    default: 0.0,
    set: function set(val) {
      if (this._size === val) {
        return;
      }

      this._size = clamp01(val);
      this._updateHandle();
    },
    get: function get() {
      this._size = Math.round(parseFloat(this._size) * 100) / 100;
      return this._size;
    }
  },

  value: {
    type: 'number',
    default: 0.0,
    set: function set(val) {
      if (this._value === val) {
        return;
      }

      this._set(val);
      this._updateHandle();
    },
    get: function get() {
      this._value = Math.round(parseFloat(this._value) * 100) / 100;
      return this._value;
    }
  },

  reverse: {
    type: 'boolean',
    default: false,
  },

  handle: {
    type: 'entity',
    default: null,
    set: function set(val) {
      if (!(val instanceof Entity)) {
        return;
      }

      if (this._handle === val) {
        return;
      }

      this._handle = val;
      if (this._handle) {
        this._handleWidget = this._handle.getComp('Widget');
      }
    }
  },

  transitionColors: {
    type: 'object',
    default: {
      normal: color4.create(),
      highlight: color4.create(),
      pressed: color4.create(),
      disabled: color4.create(),
    }
  },

  transitionSprites: {
    type: 'object',
    parse: function parse(app, value, propInfo, entities) {
      if (value) {
        var cPropInfo = { normal: null, highlight: null, pressed: null, disabled: null };
        if (value.normal && typeof value.normal === 'string') {
          cPropInfo.normal = app.assets.get(value.normal);
        }

        if (value.highlight && typeof value.highlight === 'string') {
          cPropInfo.highlight = app.assets.get(value.highlight);
        }

        if (value.pressed && typeof value.pressed === 'string') {
          cPropInfo.pressed = app.assets.get(value.pressed);
        }

        if (value.disabled && typeof value.disabled === 'string') {
          cPropInfo.disabled = app.assets.get(value.disabled);
        }

        return cPropInfo;
      }
    },
    default: {
      normal: null,
      highlight: null,
      pressed: null,
      disabled: null
    }
  },

  background: {
    type: 'entity',
    default: null,
    set: function set(val) {
      if (!(val instanceof Entity)) {
        return;
      }

      if (this._background === val) {
        return;
      }

      this._background = val;
      if (this._background) {
        this._bgImage = this._background.getComp('Image');
      }
    }
  },

  transition: {
    type: 'enums',
    default: 'none',
    options: ['none', 'color', 'sprite']
  },
};

var Bounds = function Bounds(center, size) {
  this._center = vec3.zero();
  vec3.copy(this._center, center);
  this._extents = vec3.zero();
  vec3.mul(this._extents,size, vec3.new(0.5, 0.5, 0.5));
  this._size = vec3.zero();
  this._min = vec3.zero();
  this._max = vec3.zero();
};

var prototypeAccessors$19 = { center: { configurable: true },size: { configurable: true },min: { configurable: true },max: { configurable: true } };

prototypeAccessors$19.center.set = function (val) {
  this._center = val;
};

prototypeAccessors$19.center.get = function () {
  return this._center;
};

prototypeAccessors$19.size.set = function (val) {
  vec3.mul(this._extents, val, vec3.new(0.5, 0.5, 0.5));
};

prototypeAccessors$19.size.get = function () {
  var value = vec3.zero();
  vec3.mul(value, this._extents, vec3.new(2, 2, 2));
  return value;
};

prototypeAccessors$19.min.set = function (val) {
  this.setMinMax(val, this._max);
};

prototypeAccessors$19.min.get = function () {
  var value = vec3.zero();
  vec3.subtract(value, this._center, this._extents);
  return value;
};

prototypeAccessors$19.max.set = function (val) {
  this.setMinMax(this._min, val);
};

prototypeAccessors$19.max.get = function () {
  var value = vec3.zero();
  vec3.add(value, this._center, this._extents);
  return value;
};

Bounds.prototype.setMinMax = function setMinMax (min, max) {
  var value = vec3.zero();
  vec3.subtract(value, max, min);
  vec3.mul(value, value, vec3.new(0.5, 0.5, 0.5));
  vec3.set(this._extents, value.x, value.y, value.z);
  vec3.add(this._center, min, this._extents);
};

Bounds.prototype.encapsulate = function encapsulate (point) {
  var min = vec3.zero(), max = vec3.zero();
  vec3.min(min, this.min, point);
  vec3.max(max, this.max, point);
  this.setMinMax(min, max);
};

Object.defineProperties( Bounds.prototype, prototypeAccessors$19 );

var ScrollViewComponent = (function (UIElementComponent$$1) {
  function ScrollViewComponent() {
    var this$1 = this;

    UIElementComponent$$1.call(this);
    this._widget = null;
    this._viewBound = null;
    this._contentBound = null;
    this._contentWidget = null;
    this._viewPortWidget = null;
    this._hScrollBarComp = null;
    this._vScrollBarComp = null;
    this._dragging = false;
    this._velocity = vec2.zero();
    this._startPos = vec2.zero();
    this._startPoint = vec2.zero();
    this._fingerId = -1;
    this._correctInited = false;
    this._prevContentBound = null;
    this._prevViewBound = null;
    this._prevPosition = vec2.zero();

    this._onMouseDown = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      e.stop();
      this$1._dragging = true;
      this$1._startPos = vec2.new(this$1._contentWidget.offsetX, this$1._contentWidget.offsetY);
      this$1._startPoint = vec2.new(e.mouseX, e.mouseY);
    };

    this._onMouseUp = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      e.stop();
      this$1._dragging = false;
    };

    this._onMouseMove = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      e.stop();
      if (this$1._dragging) {
        this$1._onDrag(vec2.new(e.mouseX, e.mouseY));
      }
    };

    // touch events
    this._onTouchStart = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      e.stop();
      if (this$1._fingerId !== -1) {
        return;
      }

      this$1._fingerId = e.id;
      this$1._dragging = true;
      this$1._startPos = vec2.new(this$1._contentWidget.offsetX, this$1._contentWidget.offsetY);
      this$1._startPoint = vec2.new(e.x, e.y);
    };

    this._onTouchMove = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      e.stop();
      if (e.id === this$1._fingerId) {
        if (this$1._dragging) {
          this$1._onDrag(vec2.new(e.x, e.y));
        }
      }
    };

    this._onTouchEnd = function (e) {
      if (this$1.enabled === false) {
        return;
      }

      e.stop();

      if (e.id !== this$1._fingerId) {
        return;
      }

      this$1._fingerId = -1;
      this$1._dragging = false;
    };

    this._updateScrollView = function (e) {
      if (e.component._dragging === false) {
        return;
      }

      this$1._updateBound();
      var calculateValue = e.component.reverse ? 1 - e.component.value : e.component.value;
      if (e.component.direction === 'horizontal') {
        var sizeDelta = this$1._contentBound.size.x - this$1._viewBound.size.x;
        var realMove = sizeDelta * calculateValue;
        var currentPos = this$1._viewBound.min.x - this$1._contentBound.min.x;
        this$1._contentWidget.offsetX += currentPos - realMove;
      } else {
        var sizeDelta$1 = this$1._contentBound.size.y - this$1._viewBound.size.y;
        var realMove$1 = sizeDelta$1 * calculateValue;
        var currentPos$1 = this$1._viewBound.min.y - this$1._contentBound.min.y;
        this$1._contentWidget.offsetY += currentPos$1 - realMove$1;
      }

      this$1._updateBound();
    };
  }

  if ( UIElementComponent$$1 ) ScrollViewComponent.__proto__ = UIElementComponent$$1;
  ScrollViewComponent.prototype = Object.create( UIElementComponent$$1 && UIElementComponent$$1.prototype );
  ScrollViewComponent.prototype.constructor = ScrollViewComponent;

  ScrollViewComponent.prototype.onInit = function onInit () {
    UIElementComponent$$1.prototype.onInit.call(this);
    this._widget = this._entity.getComp('Widget');
    this._viewPortWidget = this._viewPort && this._viewPort.getComp('Widget');
    this._contentWidget = this._content && this._content.getComp('Widget');

    if (this._vScrollBarComp) {
      this._vScrollBar.off('ScrollBar.onValueChanged', this._updateScrollView);
    }

    this._vScrollBarComp = this._vScrollBar && this._vScrollBar.getComp('ScrollBar');
    if (this._vScrollBarComp) {
      this._vScrollBar._reverse = true;
      this._vScrollBar.on('ScrollBar.onValueChanged', this._updateScrollView);
    }

    if (this._hScrollBarComp) {
      this._hScrollBar.off('ScrollBar.onValueChanged', this._updateScrollView);
    }

    this._hScrollBarComp = this._hScrollBar && this._hScrollBar.getComp('ScrollBar');
    if (this._hScrollBarComp) {
      this._hScrollBar.on('ScrollBar.onValueChanged', this._updateScrollView);
    }
  };

  ScrollViewComponent.prototype.onDestroy = function onDestroy () {
    this._vScrollBar._entity.off('ScrollBar.onValueChanged', this._updateScrollView);
    this._hScrollBar._entity.off('ScrollBar.onValueChanged', this._updateScrollView);

    UIElementComponent$$1.prototype.onDestroy.call(this);
  };

  ScrollViewComponent.prototype.tick = function tick () {
    // maybe let the editor do it
    if (this._viewPortWidget) {
      if (this._viewPortWidget.anchorLeft !== 0 ||
        this._viewPortWidget.anchorRight !== 1 ||
        this._viewPortWidget.anchorBottom !== 0 ||
        this._viewPortWidget.anchorTop !== 1
      ) {
        this._viewPortWidget.setAnchors(0, 0, 1, 1);
      }
    }

    if (this._correctInited === false) {
      this._correctVisual();
     }
  };

  ScrollViewComponent.prototype._correctVisual = function _correctVisual () {
    this._getBound();
    if (
      this._viewBound && !vec3.equals(this._viewBound.size, vec3.zero()) &&
      this._contentBound && !vec3.equals(this._contentBound.size, vec3.zero())
    ) {
      this._correctInited = true;
      if (this._viewBound.size.x >= this._contentBound.size.x) {
        if (this._hScrollBar && this._hScrollBar.active) {
          this._hScrollBar.active = false;
        }

        if (this._viewPortWidget) {
          this._viewPortWidget.offsetY = 0;
          this._viewPortWidget.sizeY = 0;
        }
      } else {
        if (this._hScrollBar) {
          if (this._hScrollBar.active === false) {
            this._hScrollBar.active = true;
          }
          var hWidget = this._hScrollBar.getComp('Widget');
          if (this._viewPortWidget) {
            this._viewPortWidget.offsetY = hWidget._rect.h * (1 - this._viewPortWidget.pivotY);
            this._viewPortWidget.sizeY = -hWidget._rect.h;
          }
          hWidget.setAnchors(0, 0, 1, 0);
          if (this._vScrollBar) {
            if (this._vScrollBar.active) {
              var vWidget = this._vScrollBar.getComp('Widget');
              hWidget.sizeX = -vWidget._rect.w;
              hWidget.offsetX = -vWidget._rect.w * hWidget.pivotX;
            } else {
              hWidget.sizeX = 0;
              hWidget.offsetX = 0;
            }
          }
        }
      }

      if (this._viewBound.size.y >= this._contentBound.size.y) {
        if (this._vScrollBar && this._vScrollBar.active) {
          this._vScrollBar.active = false;
        }

        if (this._viewPortWidget) {
          this._viewPortWidget.offsetX = 0;
          this._viewPortWidget.sizeX = 0;
        }
      } else {
        if (this._vScrollBar) {
          if (this._vScrollBar.active === false) {
            this._vScrollBar.active = true;
          }

          var vWdiget = this._vScrollBar.getComp('Widget');
          if (this._viewPortWidget) {
            this._viewPortWidget.offsetX = -vWdiget._rect.w * this._viewPortWidget.pivotX;
            this._viewPortWidget.sizeX = -vWdiget._rect.w;
          }

          vWdiget.setAnchors(1, 0, 1, 1);
          if (this._hScrollBar) {
            if (this._hScrollBar.active) {
              var hWidget$1 = this._hScrollBar.getComp('Widget');
              vWdiget.sizeY = -hWidget$1._rect.h;
              vWdiget.offsetY = hWidget$1._rect.h * (1 - vWdiget.pivotY);
            } else {
              vWdiget.sizeY = 0;
              vWdiget.offsetY = 0;
            }
          }
        }
      }
    }
  };

  ScrollViewComponent.prototype.postTick = function postTick () {
    this._lateUpdate();
  };

  ScrollViewComponent.prototype._onDrag = function _onDrag (mouse) {
    if (!this._contentWidget) {
      return;
    }

    this._updateBound();
    var delta = vec2.zero(), currentPos = vec2.zero();
    // get delta from calculate content offset to content offset
    vec2.subtract(delta, mouse, this._startPoint);
    vec2.add(currentPos, delta, this._startPos);
    vec2.subtract(delta, currentPos, vec2.new(this._contentWidget.offsetX, this._contentWidget.offsetY));
    var offset = this._calculateOffset(delta);
    vec2.add(currentPos, currentPos, offset);

    var contentOffset = [currentPos.x, currentPos.y];
    if (this._movementType == 'elastic') {
      var viewBoundSize = this._viewBound.size;
      // higher offset higher rubber
      if (offset.x !== 0) {
        contentOffset[0] -= (1.0 - 1.0 / (Math.abs(offset.x) * 0.5 / viewBoundSize.x + 1.0)) * viewBoundSize.x * this._sign(offset.x);
      }

      if (offset.y !== 0) {
        contentOffset[1] -= (1.0 - 1.0 / (Math.abs(offset.y) * 0.5 / viewBoundSize.y + 1.0)) * viewBoundSize.y * this._sign(offset.y);
      }
    }

    this._setContentOffset(vec2.new(contentOffset[0], contentOffset[1]));
  };

  ScrollViewComponent.prototype._sign = function _sign (value) {
    if (value >= 0) {
      return 1;
    }
    return -1;
  };

  ScrollViewComponent.prototype._getBound = function _getBound () {
    if (!this._contentWidget) {
      return new Bounds(vec3.zero(), vec3.zero());
    }

    // get parent bound
    var pCorners = [vec3.zero(), vec3.zero(), vec3.zero(), vec3.zero()];
    this._viewPortWidget.getWorldCorners(pCorners[0], pCorners[1], pCorners[2], pCorners[3]);
    var center = vec3.zero();
    vec3.add(center, pCorners[0], pCorners[2]);
    vec3.divide(center, center, vec3.new(2, 2, 2));
    var viewRect = this._viewPortWidget._rect;
    this._viewBound = new Bounds(center, vec3.new(viewRect.w, viewRect.h, 0));

    // get content bound
    var corners = [vec3.zero(), vec3.zero(), vec3.zero(), vec3.zero()];
    this._contentWidget.getWorldCorners(corners[0], corners[1], corners[2], corners[3]);

    var min$$1 = vec3.new(3.40E+38, 3.40E+38, 3.40E+38);
    var max$$1 = vec3.new(-3.40E+38, -3.40E+38, -3.40E+38);
    for (var i = 0; i < 4; i++) {
      vec3.min(min$$1, min$$1, corners[i]);
      vec3.max(max$$1, max$$1, corners[i]);
    }

    this._contentBound = new Bounds(min$$1, vec3.zero());
    this._contentBound.encapsulate(max$$1);
  };

  ScrollViewComponent.prototype._adjustBound = function _adjustBound (contentBoundSize, contentBoundCenter) {
    var size = [contentBoundSize.x, contentBoundSize.y];
    var center = [contentBoundCenter.x, contentBoundCenter.y];
    var offset = vec3.zero();
    vec3.subtract(offset, this._viewBound.size, this._contentBound.size);
    if (offset.x > 0) {
      center[0] -= offset.x * (this._contentWidget.pivotX - 0.5);
      size[0] = this._viewBound.size.x;
    }

    if (offset.y > 0) {
      center[1] -= offset.y * (this._contentWidget.pivotY - 0.5);
      size[1] = this._viewBound.size.y;
    }

    return {
      'size': vec3.new(size[0], size[1], 0),
      'center': vec3.new(center[0], center[1], 0),
    };
  };

  ScrollViewComponent.prototype._updateBound = function _updateBound () {
    this._getBound();
    if (!this._contentWidget) {
      return;
    }

    var size = this._contentBound.size;
    var center = this._contentBound.center;
    var offset = this._adjustBound(size, center);
    this._contentBound.size = offset.size;
    this._contentBound.center = offset.center;
    if (this._movementType === 'clamp') {
      var zero = [0, 0];
      if (this._viewBound.max.x > this._contentBound.max.y) {
        zero[0] = Math.min(this._viewBound.max.x - this._contentBound.max.x, this._viewBound.min.x - this._contentBound.min.x);
      } else if (this._viewBound.min.x < this._contentBound.min.x) {
        zero[0] = Math.max(this._viewBound.max.x - this._contentBound.max.x, this._viewBound.min.x - this._contentBound.min.x);
      }

      if (this._viewBound.max.y > this._contentBound.max.y) {
        zero[1] = Math.min(this._viewBound.max.y - this._contentBound.max.y, this._viewBound.min.y - this._contentBound.min.y);
      } else if (this._viewBound.min.y < this._contentBound.min.y) {
        zero[1] = Math.max(this._viewBound.max.y - this._contentBound.max.y, this._viewBound.min.y - this._contentBound.min.y);
      }

      if (!vec2.equals(vec2.new(zero.x, zero.y), vec2.zero())) {
        center = [];
        center[0] = this._contentWidget.offsetX + zero[0];
        center[1] = this._contentWidget.offsetY + zero[1];

        if (!this._horizontal) {
          center[0] = this._contentWidget.offsetX;
        }

        if (!this._vertical) {
          center[1] = this._contentWidget.offsetX;
        }

        // this._adjustBound(size, center);
        this._setContentOffset(vec2.new(center[0], center[1]));
      }
    }
  };

  ScrollViewComponent.prototype._calculateOffset = function _calculateOffset (val) {
    var offset = [0, 0];
    if (this._movementType === 'unrestricted') {
      return vec2.zero();
    } else {
      var min$$1 = [this._contentBound.min.x, this._contentBound.min.y];
      var max$$1 = [this._contentBound.max.x, this._contentBound.max.y];
      if (this._horizontal) {
        min$$1[0] += val.x;
        max$$1[0] += val.x;
        if (min$$1[0] > this._viewBound.min.x) {
          offset[0] = this._viewBound.min.x - min$$1[0];
        } else if (max$$1[0] < this._viewBound.max.x) {
          offset[0] = this._viewBound.max.x - max$$1[0];
        }
      }

      if (this._vertical) {
        min$$1[1] += val.y;
        max$$1[1] += val.y;
        if (min$$1[1] > this._viewBound.min.y) {
          offset[1] = this._viewBound.min.y - min$$1[1];
        } else if (max$$1[1] < this._viewBound.max.y) {
          offset[1] = this._viewBound.max.y - max$$1[1];
        }
      }
    }

    return vec2.new(offset[0], offset[1]);
  };

  ScrollViewComponent.prototype._lateUpdate = function _lateUpdate () {
    var this$1 = this;

    if (!this._contentWidget) {
      return;
    }

    this._getBound();
    var outOffset = this._calculateOffset(vec2.zero());
    var isOut = !vec2.equals(outOffset, vec2.zero());
    var isAdd = !vec2.equals(this._velocity, vec2.zero());
    if (!this._dragging && (isOut || isAdd)) {
      var pos = [this._contentWidget.offsetX, this._contentWidget.offsetY];
      var offset = [outOffset.x, outOffset.y];
      var num = [this._velocity.x, this._velocity.y];
      for (var i = 0; i < 2; i++) {
        if (this$1._movementType === 'elastic' && offset[i] !== 0) {
          var backValue = this$1._smoothBack(pos[i], pos[i] + offset[i], num[i]);
          pos[i] = backValue.value;
          num[i] = backValue.velocity;
          if (Math.abs(num[i]) < 1) {
            num[i] = 0;
          }
        } else if (this$1._inertia) {
          num[i] = num[i] * Math.pow(this$1._brake, this$1._app.deltaTime);
          if (Math.abs(num[i]) < 1) {
            num[i] = 0;
          }

          pos[i] += num[i] * this$1._app.deltaTime;
        } else {
          num[i] = 0;
        }
      }

      this._velocity = vec2.new(num[0], num[1]);
      if (!vec2.equals(this._velocity, vec2.zero())) {
        if (this._movementType === 'clamped') {
          var delta = vec2.zero();
          vec2.subtract(delta, vec2.new(pos.x, pos.y), vec2.new(this._contentWidget.offsetX, this._contentWidget.offsetY));
          outOffset = this._calculateOffset(delta);
          pos[0] += outOffset.x;
          pos[1] += outOffset.y;
        }

        this._setContentOffset(vec2.new(pos[0], pos[1]));
      } else if (!vec2.equals(outOffset, vec2.zero())) {
        this._setContentOffset(vec2.new(pos[0] + outOffset.x, pos[1] + outOffset.y));
      }
    }

    var anchorOffset = vec2.new(this._contentWidget.offsetX, this._contentWidget.offsetY);
    if (this._dragging && this._inertia) {
      var b = vec2.zero();
      vec2.subtract(b, anchorOffset, this._prevPosition);
      vec2.divide(b, b, vec2.new(this._app.deltaTime, this._app.deltaTime));
      vec2.lerp(this._velocity, this._velocity, b, this._app.deltaTime * 10);
    }

    if ((this._prevPosition.x - anchorOffset.x) > 0.01 ||
      (this._prevPosition.y > anchorOffset.y) > 0.01 ||
      this._viewBound !== this._prevViewBound ||
      this._contentBound !== this._prevContentBound) {
      this._updateScrollBar();
      this._emitValueChangedEvents();
      this._updatePrevData();
    }
  };

  ScrollViewComponent.prototype._smoothBack = function _smoothBack (current, target, currentVelocity) {
    var deltaTime = this._app.deltaTime;
    this._elasticityDuration = Math.max(0.0001, this._elasticityDuration);
    var num = 2 / this._elasticityDuration;
    var num2 = num * deltaTime;
    var num3 = 1 / (1 + num2 + 0.48 * Math.pow(num2, 2) + 0.235 * Math.pow(num2, 3));
    var num4 = current - target;
    var num5 = target;
    var num6 = INT_MAX * this._elasticityDuration;
    num4 = clamp(num4, -num6, num6);
    target = current - num4;
    var num7 = (currentVelocity + num * num4) * deltaTime;
    currentVelocity = (currentVelocity - num * num7) * num3;
    var num8 = target + (num4 + num7) * num3;
    if (num5 - current > 0 === num8 > num5) {
      num8 = num5;
      currentVelocity = (num8 - num5) / deltaTime;
    }

    return { 'value': num8, 'velocity': currentVelocity };
  };

  ScrollViewComponent.prototype._setContentOffset = function _setContentOffset (val) {
    var position = [val.x, val.y];
    if (!this._contentWidget) {
      return;
    }

    if (!this._horizontal) {
      position[0] = this._contentWidget.offsetX;
    }

    if (!this._vertical) {
      position[1] = this._contentWidget.offsetY;
    }

    if (!vec2.equals(val, vec2.new(this._contentWidget.offsetX, this._contentWidget.offsetY))) {
      this._contentWidget.setOffset(position[0], position[1]);
      this._updateBound();
    }
  };

  ScrollViewComponent.prototype._updatePrevData = function _updatePrevData () {
    this._prevPosition = vec2.new(this._contentWidget.offsetX, this._contentWidget.offsetY);
    this._prevContentBound = this._contentBound;
    this._prevViewBound = this._viewBound;
  };

  ScrollViewComponent.prototype._updateScrollBar = function _updateScrollBar () {
    var outOffset = this._calculateOffset(vec2.zero());
    if (this._hScrollBarComp && this._hScrollBar.active && this._hScrollBarComp.handle) {
      this._hScrollBarComp.size = clamp01(this._viewBound.size.x / (this._contentBound.size.x + Math.abs(outOffset.x)));
      if (this._contentBound.size.x <= this._viewBound.size.x) {
        this._hScrollBarComp.value = this._viewBound.min.x <= this._contentBound.min.x ? 0 : 1;
      } else {
        var scrollAnchor = (this._viewBound.min.x - this._contentBound.min.x) / (this._contentBound.size.x - this._viewBound.size.x);
        this._hScrollBarComp.value = this._hScrollBarComp.reverse ? 1 - clamp01(scrollAnchor, 0, 1) : clamp01(scrollAnchor, 0, 1);
      }
    }

    if (this._vScrollBarComp && this._vScrollBar.active && this._vScrollBarComp.handle) {
      this._vScrollBarComp.size = clamp01(this._viewBound.size.y / (this._contentBound.size.y + Math.abs(outOffset.y)));
      if (this._contentBound.size.y <= this._viewBound.size.y) {
        this._vScrollBarComp.value = this._viewBound.min.x <= this._contentBound.min.x ? 0 : 1;
      } else {
        var scrollAnchor$1 = (this._viewBound.min.y - this._contentBound.min.y) / (this._contentBound.size.y - this._viewBound.size.y);
        this._vScrollBarComp.value = this._vScrollBarComp.reverse ? 1 - clamp01(scrollAnchor$1, 0, 1) : clamp01(scrollAnchor$1, 0, 1);
      }
    }
  };

  ScrollViewComponent.prototype._emitValueChangedEvents = function _emitValueChangedEvents () {
    this.dispatch('ScrollView.onValueChanged');
  };

  return ScrollViewComponent;
}(UIElementComponent));

ScrollViewComponent.events = {
  'mousedown': '_onMouseDown',
  'mousemove': '_onMouseMove',
  'mouseup': '_onMouseUp',
  'touchstart': '_onTouchStart',
  'touchmove': '_onTouchMove',
  'touchend': '_onTouchEnd'
};

ScrollViewComponent.schema = {
  horizontal: {
    type: 'boolean',
    default: true,
  },

  vertical: {
    type: 'boolean',
    default: true,
  },

  viewPort: {
    type: 'entity',
    default: null,
    set: function set(val) {
      if (!(val instanceof Entity)) {
        return;
      }

      if (this._viewPort === val) {
        return;
      }

      this._viewPort = val;
      if (!this._viewPort) {
        console.warn('ViewPort cannot be null');
      }

      if (this._viewPort) {
        this._viewPortWidget = this._viewPort.getComp('Widget');
      }
    }
  },

  content: {
    type: 'entity',
    default: null,
    set: function set(val) {
      if (!(val instanceof Entity)) {
        return;
      }

      if (this._content === val) {
        return;
      }

      this._content = val;
      if (!this._content) {
        console.warn('Content cannot be null');
        return;
      }

      if (this._content) {
        this._contentWidget = this._content.getComp('Widget');
      }
    }
  },

  movementType: {
    type: 'enums',
    default: 'clamped',
    options: ['unrestricted', 'elastic', 'clamped'],
  },

  elasticityDuration: {
    type: 'number',
    default: 0.1,
  },

  inertia: {
    type: 'boolean',
    default: true,
  },

  brake: {
    type: 'number',
    default: 0.135,
  },

  vScrollBar: {
    type: 'entity',
    default: null,
    set: function set(val) {
      if (!(val instanceof Entity)) {
        return;
      }

      if (this._vScrollBar === val) {
        return;
      }

      if (this._vScrollBarComp) {
        this._vScrollBar.off('ScrollBar.onValueChanged', this._updateScrollView);
      }

      this._vScrollBar = val;
      if (this._vScrollBar) {
        this._vScrollBar.on('ScrollBar.onValueChanged', this._updateScrollView);
        this._vScrollBarComp = this._vScrollBar.getComp('ScrollBar');
        this._vScrollBarComp.reverse = true;
        this._correctVisual();
      }
    }
  },

  hScrollBar: {
    type: 'entity',
    default: null,
    set: function set(val) {
      if (!(val instanceof Entity)) {
        return;
      }

      if (this._hScrollBar === val) {
        return;
      }

      if (this._hScrollBarComp) {
        this._hScrollBar.off('ScrollBar.onValueChanged', this._updateScrollView);
      }

      this._hScrollBar = val;
      if (this._hScrollBar) {
        this._hScrollBar.on('ScrollBar.onValueChanged', this._updateScrollView);
        this._hScrollBarComp = this._hScrollBar.getComp('ScrollBar');
        this._correctVisual();
      }
    }
  },
};

var GridLayoutComponent = (function (UIElementComponent$$1) {
  function GridLayoutComponent() {
    UIElementComponent$$1.call(this);

    this._childManager = [];
    this._childAlignEnum = 0;
    this._cornerEnum = 0;
    this._lastSize = vec2.zero();

    this._dirty = false;
  }

  if ( UIElementComponent$$1 ) GridLayoutComponent.__proto__ = UIElementComponent$$1;
  GridLayoutComponent.prototype = Object.create( UIElementComponent$$1 && UIElementComponent$$1.prototype );
  GridLayoutComponent.prototype.constructor = GridLayoutComponent;

  GridLayoutComponent.prototype.onInit = function onInit () {
    UIElementComponent$$1.prototype.onInit.call(this);
    this._widget = this._entity.getComp('Widget');
    var options = ['upper-left', 'upper-center', 'upper-right', 'middle-left', 'middle-center', 'middle-right', 'lower-left', 'lower-center', 'lower-right'];
    this._childAlignEnum = options.indexOf(this._childAlign);
    if (this._childAlignEnum === -1) {
      this._childAlignEnum = 0;
    }

    options = ['upper-left', 'upper-right', 'lower-left', 'lower-right'];
    this._cornerEnum = options.indexOf(this._corner);
    if (this._cornerEnum === -1) {
      this._cornerEnum = 0;
    }

    this._lastSize = vec2.new(this._widget._rect.w, this._widget._rect.h);
  };

  GridLayoutComponent.prototype.tick = function tick () {
    var this$1 = this;

    if (!vec2.equals(this._lastSize, vec2.new(this._widget._rect.w, this._widget._rect.h))) {
      this._lastSize = vec2.new(this._widget._rect.w, this._widget._rect.h);
      this._dirty = true;
    }

    if (!this._dirty) {
      if (this._childManager.length !== this._entity.children.length) {
        this._dirty = true;
      } else {
        for (var i = 0; i < this._entity.children.length; ++i) {
          var child = this$1._entity.children[i];
          if (child.enabled !== this$1._childManager[i].enabled) {
            this$1._dirty = true;
            break;
          }
        }
      }
    }

    if (this._dirty) {
      this._calculate();
      this._dirty = false;
    }
  };

  GridLayoutComponent.prototype.reset = function reset () {
    this._setSpacing(0, 0);
    this._setPadding(0, 0, 0, 0);
    this._setCellSize(100, 100);
    this._axisDirection = 'horizontal';
    var options = ['upper-left', 'upper-right', 'lower-left', 'lower-right'];
    this._corner = 'upper-left';
    this._cornerEnum = options.indexOf(this._corner);
    options = ['upper-left', 'upper-center', 'upper-right', 'middle-left', 'middle-center', 'middle-right', 'lower-left', 'lower-center', 'lower-right'];
    this._childAlign = 'upper-left';
    this._childAlignEnum = options.indexOf(this._childAlign);
    this._constraint = 'flexible';
    this._constraintCount = 2;
    this._dirty = true;
  };

  GridLayoutComponent.prototype._calculate = function _calculate () {
    var this$1 = this;

    if (!this._widget) {
      return;
    }

    this._childManager = [];
    var width = this._widget._rect.w, height = this._widget._rect.h;
    var childCount = this._entity.children.length;

    var row, col;
    if (this._constraint === 'fixed-row') {
      row = clamp(this._constraintCount, 1, childCount);
      col = Math.max(1, Math.ceil(childCount / (1.0 * row)));
    } else if (this._constraint === 'fixed-col') {
      col = clamp(this._constraintCount, 1, childCount);
      row = Math.max(1, Math.ceil(childCount / (1.0 * col)));
    } else {
      if (this._cellWidth + this._spacingX <= 0) {
        col = 65535;
      } else {
        col = Math.floor((width - this._getPaddingHorizontal() + this._spacingX) / (this._cellWidth + this._spacingX));
        col = Math.max(1, col);
      }

      if (this._cellHeight + this._spacingY <= 0) {
        row = 65535;
      } else {
        row = Math.floor((height - this._getPaddingVertical() + this._spacingY) / (this._cellHeight + this._spacingY));
        row = Math.max(1, row);
      }
    }

    var actualX, actualY, contentCount;
    if (this._axisDirection === 'horizontal') {
      contentCount = col;
      actualX = clamp(col, 1, childCount);
      actualY = clamp(row, 1, Math.ceil(childCount / (1.0 * contentCount)));
    } else {
      contentCount = row;
      actualY = clamp(row, 1, childCount);
      actualX = clamp(col, 1, Math.ceil(childCount / (1.0 * contentCount)));
    }

    var contentSize = vec2.new(
      this._cellWidth * actualX + this._spacingX * (actualX - 1),
      this._cellHeight * actualY + this._spacingY * (actualY - 1)
    );
    var starOffset = vec2.new(this._getStartOffset('horizontal', contentSize.x), this._getStartOffset('vertical', contentSize.y));
    var cornerX = this._cornerEnum % 2, cornerY = parseInt(this._cornerEnum / 2);

    var index = 0;
    for (var i = 0; i < childCount; ++i) {
      var child = this$1._entity.children[i];
      if (child.enabled === false) {
        continue;
      }

      var widget = child.getComp('Widget');
      widget.setSize(this$1._cellWidth, this$1._cellHeight);
      widget.setAnchors(0, 1, 0, 1);

      var x = (void 0), y = (void 0);
      if (this$1._axisDirection === 'horizontal') {
        x = index % contentCount;
        y = parseInt(index / contentCount);
      } else {
        x = parseInt(index / contentCount);
        y = index % contentCount;
      }

      var xpos = (void 0), ypos = (void 0);
      if (cornerX === 1) {
        x = actualX - x - 1;
      }

      if (cornerY === 1) {
        y = actualY - y - 1;
      }

      xpos = starOffset.x + (this$1._cellWidth + this$1._spacingX) * x + widget.pivotX * this$1._cellWidth;
      ypos = starOffset.y + (this$1._cellHeight + this$1._spacingY) * y + (1 - widget.pivotY) * this$1._cellHeight;
      widget.setOffset(xpos, -ypos);
      this$1._childManager.push(child);
      index++;
    }
  };

  GridLayoutComponent.prototype._getStartOffset = function _getStartOffset (axis, contentSpace) {
    var addPaddingContentSpace = contentSpace + (axis === 'horizontal' ? this._getPaddingHorizontal() : this._getPaddingVertical());
    var offset = (axis === 'horizontal' ? this._widget._rect.w : this._widget._rect.h) - addPaddingContentSpace;
    var align = axis === 'horizontal' ? (this._childAlignEnum % 3) * 0.5 : parseInt(this._childAlignEnum / 3) * 0.5;
    return (axis === 'horizontal' ? this._paddingLeft : this._paddingTop) + offset * align;
  };

  GridLayoutComponent.prototype._getPaddingHorizontal = function _getPaddingHorizontal () {
    return this._paddingLeft + this._paddingRight;
  };

  GridLayoutComponent.prototype._getPaddingVertical = function _getPaddingVertical () {
    return this._paddingTop + this._paddingBottom;
  };

  GridLayoutComponent.prototype._setPadding = function _setPadding (l, b, r, t) {
    this._paddingLeft = l;
    this._paddingRight = r;
    this._paddingBottom = b;
    this._paddingTop = t;
  };

  GridLayoutComponent.prototype._setSpacing = function _setSpacing (x, y) {
    this._spacingX = x;
    this._spacingY = y;
  };

  GridLayoutComponent.prototype._setCellSize = function _setCellSize (w, h) {
    this._cellWidth = w;
    this._cellHeight = h;
  };

  GridLayoutComponent.prototype.getItems = function getItems () {
    return this._childManager;
  };

  return GridLayoutComponent;
}(UIElementComponent));

GridLayoutComponent.schema = {
  axisDirection: {
    type: 'enums',
    default: 'horizontal',
    options: ['horizontal', 'vertical'],
    set: function set(val) {
      if (this._axisDirection === val) {
        return;
      }

      this._axisDirection = val;
      this._dirty = true;
    },
  },

  paddingLeft: {
    type: 'number',
    default: 0.0,
    set: function set(val) {
      if (this._paddingLeft === val) {
        return;
      }

      this._paddingLeft = val;
      this._dirty = true;
    },
  },

  paddingRight: {
    type: 'number',
    default: 0.0,
    set: function set(val) {
      if (this._paddingRight === val) {
        return;
      }

      this._paddingRight = val;
      this._dirty = true;
    },
  },

  paddingBottom: {
    type: 'number',
    default: 0.0,
    set: function set(val) {
      if (this._paddingBottom === val) {
        return;
      }

      this._paddingBottom = val;
      this._dirty = true;
    },
  },

  paddingTop: {
    type: 'number',
    default: 0.0,
    set: function set(val) {
      if (this._paddingTop === val) {
        return;
      }

      this._paddingTop = val;
      this._dirty = true;
    },
  },

  cellWidth: {
    type: 'number',
    default: 100.0,
    set: function set(val) {
      if (this._cellWidth === val) {
        return;
      }

      this._cellWidth = val;
      this._dirty = true;
    },
  },

  cellHeight: {
    type: 'number',
    default: 100.0,
    set: function set(val) {
      if (this._cellHeight === val) {
        return;
      }

      this._cellHeight = val;
      this._dirty = true;
    },
  },

  spacingX: {
    type: 'number',
    default: 0.0,
    set: function set(val) {
      if (this._spacingX === val) {
        return;
      }

      this._spacingX = val;
      this._dirty = true;
    },
  },

  spacingY: {
    type: 'number',
    default: 0.0,
    set: function set(val) {
      if (this._spacingY === val) {
        return;
      }

      this._spacingY = val;
      this._dirty = true;
    },
  },

  corner: {
    // arrange towards
    type: 'enums',
    default: 'upper-left',
    options: ['upper-left', 'upper-right', 'lower-left', 'lower-right'],
    set: function set(val) {
      if (this._corner === val) {
        return;
      }

      var options = ['upper-left', 'upper-right', 'lower-left', 'lower-right'];
      this._cornerEnum = options.indexOf(val);
      if (this._cornerEnum !== -1) {
        this._corner = val;
        this._dirty = true;
      } else {
        this._cornerEnum = 0;
      }
    },
  },

  childAlign: {
    // distribution of the rest of the content
    type: 'enums',
    default: 'upper-left',
    options: ['upper-left', 'upper-center', 'upper-right', 'middle-left', 'middle-center', 'middle-right', 'lower-left', 'lower-center', 'lower-right'],
    set: function set(val) {
      if (this._childAlign === val) {
        return;
      }

      var options = ['upper-left', 'upper-center', 'upper-right', 'middle-left', 'middle-center', 'middle-right', 'lower-left', 'lower-center', 'lower-right'];
      this._childAlignEnum = options.indexOf(val);
      if (this._childAlignEnum !== -1) {
        this._childAlign = val;
        this._dirty = true;
      } else {
        this._childAlignEnum = 0;
      }
    },
  },

  constraint: {
    type: 'enums',
    default: 'flexible',
    options: ['flexible', 'fixed-row', 'fixed-col'],
    set: function set(val) {
      if (this._constraint === val) {
        return;
      }

      this._constraint = val;
      this._dirty = true;
    },
  },

  constraintCount: {
    type: 'int',
    default: 2,
    set: function set(val) {
      if (this._constraintCount === val) {
        return;
      }

      this._constraintCount = val;
      this._dirty = true;
    },
  },
};

var ScriptSystem = (function (System) {
  function ScriptSystem() {
    System.call(this);

    this._scripts = new FixedArray(200);
  }

  if ( System ) ScriptSystem.__proto__ = System;
  ScriptSystem.prototype = Object.create( System && System.prototype );
  ScriptSystem.prototype.constructor = ScriptSystem;

  ScriptSystem.prototype.add = function add (comp) {
    this._scripts.push(comp);
    comp.awake();

    // TODO: sort script by priority
  };

  ScriptSystem.prototype.remove = function remove (comp) {
    var this$1 = this;

    for (var i = 0; i < this._scripts.length; ++i) {
      var c = this$1._scripts.data[i];
      if (c === comp) {
        this$1._scripts.fastRemove(i);
        comp.end();
        break;
      }
    }
  };

  ScriptSystem.prototype.tick = function tick () {
    var this$1 = this;

    for (var i = 0; i < this._scripts.length; ++i) {
      var script = this$1._scripts.data[i];

      // skip if entity is not ready, or the component is destroyed, or is disabled
      if (script.destroyed || !script.enabled) {
        continue;
      }

      // start script
      if (script._startedFlag === 0) {
        script._startedFlag = 1;
        script.start();
        continue;
      }

      script.tick();
    }
  };

  ScriptSystem.prototype.postTick = function postTick () {
    var this$1 = this;

    for (var i = 0; i < this._scripts.length; ++i) {
      var script = this$1._scripts.data[i];

      if (script._startedFlag === 1) {
        script._startedFlag = 2;
        continue;
      }

      // skip if entity is not ready, or the component is destroyed, or is disabled
      if (script.destroyed || !script.enabled) {
        continue;
      }

      script.postTick();
    }
  };

  return ScriptSystem;
}(System));

var SkinningModelSystem = (function (System) {
  function SkinningModelSystem() {
    System.call(this);

    this._comps = new FixedArray(200);
  }

  if ( System ) SkinningModelSystem.__proto__ = System;
  SkinningModelSystem.prototype = Object.create( System && System.prototype );
  SkinningModelSystem.prototype.constructor = SkinningModelSystem;

  SkinningModelSystem.prototype.add = function add (comp) {
    this._comps.push(comp);
  };

  SkinningModelSystem.prototype.remove = function remove (comp) {
    var this$1 = this;

    for (var i = 0; i < this._comps.length; ++i) {
      var c = this$1._comps.data[i];
      if (c === comp) {
        this$1._comps.fastRemove(i);
        break;
      }
    }
  };

  SkinningModelSystem.prototype.tick = function tick () {
    var this$1 = this;

    for (var i = 0; i < this._comps.length; ++i) {
      var comp = this$1._comps.data[i];
      if (comp.enabled === false) {
        continue;
      }

      comp._updateMatrices();
    }
  };

  return SkinningModelSystem;
}(System));

var AnimationSystem = (function (System) {
  function AnimationSystem() {
    System.call(this);

    this._anims = new FixedArray(200);
  }

  if ( System ) AnimationSystem.__proto__ = System;
  AnimationSystem.prototype = Object.create( System && System.prototype );
  AnimationSystem.prototype.constructor = AnimationSystem;

  AnimationSystem.prototype.add = function add (comp) {
    this._anims.push(comp);
  };

  AnimationSystem.prototype.remove = function remove (comp) {
    var this$1 = this;

    for (var i = 0; i < this._anims.length; ++i) {
      var c = this$1._anims.data[i];
      if (c === comp) {
        this$1._anims.fastRemove(i);
        break;
      }
    }
  };

  AnimationSystem.prototype.tick = function tick () {
    var this$1 = this;

    for (var i = 0; i < this._anims.length; ++i) {
      var anim = this$1._anims.data[i];
      anim._animCtrl.tick(this$1._app.deltaTime);
    }
  };

  return AnimationSystem;
}(System));

var AudioSystem = (function (System) {
  function AudioSystem() {
    System.call(this);
    /**
     * @private
     */
    this.instanceID = 0;
    /**
     * @private
     */
    this.id2audio = {};
    /**
     * @private
     */
    this.url2id = {};

    var sys = {};
    var DEBUG = false;

    var version = sys.browserVersion;

    // check if browser supports Web Audio
    // check Web Audio's context
    var supportWebAudio = !!(window.AudioContext || window.webkitAudioContext || window.mozAudioContext);

    var __audioSupport = { ONLY_ONE: false, WEB_AUDIO: supportWebAudio, DELAY_CREATE_CTX: false };

    if (sys.os === sys.OS_IOS) {
      // IOS no event that used to parse completed callback
      // this time is not complete, can not play
      //
      __audioSupport.USE_LOADER_EVENT = 'loadedmetadata';
    }

    if (sys.browserType === sys.BROWSER_TYPE_FIREFOX) {
      __audioSupport.DELAY_CREATE_CTX = true;
      __audioSupport.USE_LOADER_EVENT = 'canplay';
    }

    if (sys.os === sys.OS_ANDROID) {
      if (sys.browserType === sys.BROWSER_TYPE_UC) {
        __audioSupport.ONE_SOURCE = true;
      }
    }

    if(DEBUG){
      setTimeout(function(){
        console.log('browse type: ' + sys.browserType);
        console.log('browse version: ' + version);
        console.log('MULTI_CHANNEL: ' + __audioSupport.MULTI_CHANNEL);
        console.log('WEB_AUDIO: ' + __audioSupport.WEB_AUDIO);
        console.log('AUTOPLAY: ' + __audioSupport.AUTOPLAY);
      }, 0);
    }

    try {
      if (__audioSupport.WEB_AUDIO) {
        __audioSupport.context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();
        if(__audioSupport.DELAY_CREATE_CTX) {
          setTimeout(function(){ __audioSupport.context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)(); }, 0);
        }
      }
    } catch(error) {
      __audioSupport.WEB_AUDIO = false;
      console.log(error);
    }

    function detectAudioFormat () {
      var formatSupport = [];
      var audio = document.createElement('audio');
      if(audio.canPlayType) {
        var ogg = audio.canPlayType('audio/ogg; codecs="vorbis"');
        if (ogg) { formatSupport.push('.ogg'); }
        var mp3 = audio.canPlayType('audio/mpeg');
        if (mp3) { formatSupport.push('.mp3'); }
        var wav = audio.canPlayType('audio/wav; codecs="1"');
        if (wav) { formatSupport.push('.wav'); }
        var mp4 = audio.canPlayType('audio/mp4');
        if (mp4) { formatSupport.push('.mp4'); }
        var m4a = audio.canPlayType('audio/x-m4a');
        if (m4a) { formatSupport.push('.m4a'); }
      }
      return formatSupport;
    }
    __audioSupport.format = detectAudioFormat();
    this.__audioSupport = __audioSupport;
    this._audios = new FixedArray(200);
  }

  if ( System ) AudioSystem.__proto__ = System;
  AudioSystem.prototype = Object.create( System && System.prototype );
  AudioSystem.prototype.constructor = AudioSystem;

  /**
   * Register a new {@link AudioSourceComponent}
   * @param {AudioSourceComponent} comp the new component
   */
  AudioSystem.prototype.add = function add (comp) {
    this._audios.push(comp);
  };

  /**
   * Remove the {@link AudioSourceComponent}
   * @param {AudioSourceComponent} comp the cmponent to remove
   */
  AudioSystem.prototype.remove = function remove (comp) {
    var this$1 = this;

    for (var i = 0; i < this._audios.length; ++i) {
      var c = this$1._audios.data[i];
      if (c === comp) {
        this$1._audios.fastRemove(i);
        break;
      }
    }
  };

  /**
   * Register a new {@link AudioClip}
   * @param {string} url audio clip URL
   * @param {AudioClip} clip the new clip
   */
  AudioSystem.prototype.addClip = function addClip (url, clip) {
    this.instanceID++;
    this.url2id[url] = this.instanceID;
    this.id2audio[this.instanceID] = clip;
    return this.instanceID;
  };

  /**
   * Get the ID of a clip by URL
   * @param {string} url audio clip url
   */
  AudioSystem.prototype.getIDByURL = function getIDByURL (url) {
    return this.url2id[url];
  };

  /**
   * Remove a clip by URL
   * @param {string|{url:string}} clip url of the clip to be removed
   */
  AudioSystem.prototype.removeClip = function removeClip (clip) {
    var url = null;
    if (!clip) {
      return;
    }
    else if (typeof clip === 'string') {
      url = clip;
    }
    else {
      url = clip.url;
    }
    var id = this.url2id[url];
    delete this.url2id[url];
    var audio = this.id2audio[id];
    if (audio) {
      audio.stop();
      audio.destroy();
      delete this.id2audio[id];
    }
  };

  /**
   * Set volume for all the registered clip
   * @param {number} volume the new volume
   */
  AudioSystem.prototype.setVolumeForAll = function setVolumeForAll (volume) {
    var this$1 = this;

    for (var i = 0; i < this._audios.length; i++) {
      this$1._audios.data[i].setVolume(volume);
    }
  };
 
  /**
   * Pause all the registered clip
   */
  AudioSystem.prototype.pauseAll = function pauseAll () {
    var this$1 = this;

    for (var i = 0; i < this._audios.length; i++) {
      this$1._audios.data[i].pause();
    }
  };

  /**
   * Stop all the registered clip
   */
  AudioSystem.prototype.stopAll = function stopAll () {
    var this$1 = this;

    for (var i = 0; i < this._audios.length; i++) {
      this$1._audios.data[i].stop();
    }
  };

  /**
   * Resume all the registered clip
   */
  AudioSystem.prototype.resumeAll = function resumeAll () {
    var this$1 = this;

    for (var i = 0; i < this._audios.length; i++) {
      this$1._audios.data[i].resume();
    }
  };

  AudioSystem.prototype._getClipByURL = function _getClipByURL (url) {
    return this.id2audio[this.url2id[url]];
  };

  AudioSystem.prototype._getClipByID = function _getClipByID (clipID) {
    return this.id2audio[clipID];
  };

  return AudioSystem;
}(System));

var MouseEvent = (function (Event) {
  function MouseEvent(name, opts) {
    Event.call(this, name, opts);
    this.reset();
  }

  if ( Event ) MouseEvent.__proto__ = Event;
  MouseEvent.prototype = Object.create( Event && Event.prototype );
  MouseEvent.prototype.constructor = MouseEvent;

  /**
   * @method reset
   *
   * reset mouse value
   */
  MouseEvent.prototype.reset = function reset () {
    this._stopped = false;
    this.target = null;
    this.bubbles = false;

    this.dx = 0.0;
    this.dy = 0.0;
    this.mouseX = 0.0;
    this.mouseY = 0.0;
    this.button = 0;
    this.buttons = 0;
  };

  return MouseEvent;
}(Event));

var KeyboardEvent = (function (Event) {
  function KeyboardEvent(name, opts) {
    Event.call(this, name, opts);
    this.reset();
  }

  if ( Event ) KeyboardEvent.__proto__ = Event;
  KeyboardEvent.prototype = Object.create( Event && Event.prototype );
  KeyboardEvent.prototype.constructor = KeyboardEvent;

  /**
   * @method reset
   *
   * reset mouse value
   */
  KeyboardEvent.prototype.reset = function reset () {
    this._stopped = false;
    this.target = null;
    this.bubbles = false;

    this.key = '';
  };

  return KeyboardEvent;
}(Event));

var TouchEvent = (function (Event) {
  function TouchEvent(name, opts) {
    Event.call(this, name, opts);
    this.reset();
  }

  if ( Event ) TouchEvent.__proto__ = Event;
  TouchEvent.prototype = Object.create( Event && Event.prototype );
  TouchEvent.prototype.constructor = TouchEvent;

  /**
   * @method reset
   *
   * reset mouse value
   */
  TouchEvent.prototype.reset = function reset () {
    this._stopped = false;
    this.target = null;
    this.bubbles = false;

    this.dx = 0.0;
    this.dy = 0.0;
    this.x = 0.0;
    this.y = 0.0;
  };

  return TouchEvent;
}(Event));

var FocusEvent = (function (Event) {
  function FocusEvent(name, opts) {
    Event.call(this, name, opts);
    this.reset();
  }

  if ( Event ) FocusEvent.__proto__ = Event;
  FocusEvent.prototype = Object.create( Event && Event.prototype );
  FocusEvent.prototype.constructor = FocusEvent;

  /**
   * @method reset
   *
   * reset mouse value
   */
  FocusEvent.prototype.reset = function reset () {
    this._stopped = false;
    this.target = null;
    this.bubbles = false;

    this.relatedTarget = null;
  };

  return FocusEvent;
}(Event));

var MAX_STENCIL_LEVEL = 8;

function _setStencil(mat, enabled, func, ref, mask, failOp, zFailOp, zPassOp, writeMask) {
  var tech = mat.effectInst.getTechnique('ui');
  for (var i = 0; i < tech.passes.length; ++i) {
    var pass = tech.passes[i];
    pass.setStencilFront(
      enabled, func, ref, mask, failOp, zFailOp, zPassOp, writeMask
    );
    pass.setStencilBack(
      enabled, func, ref, mask, failOp, zFailOp, zPassOp, writeMask
    );
  }
}

var ScreenRenderHelper = function ScreenRenderHelper(app) {
  // internal states
  this._app = app;
  this._screen = null;
  this._curMaterail = null;
  this._curTexture = null;
  this._curSpriteBatch = null;
  this._curStencilLevel = 0;
  this._curUserKey = 0;
  this._dummyNode = new Node();

  // pools
  this._materialPool = new RecyclePool(function () {
    return new Material();
  }, 100);
  this._spriteBatchModelPool = new RecyclePool(function () {
    return new renderer.SpriteBatchModel();
  }, 100);
};

ScreenRenderHelper.prototype.reset = function reset () {
    var this$1 = this;

  for (var i = 0; i < this._spriteBatchModelPool.length; ++i) {
    var spriteBatch = this$1._spriteBatchModelPool.data[i];
    spriteBatch.clear();
    this$1._app.scene.removeModel(spriteBatch);
  }

  this._materialPool.reset();
  this._spriteBatchModelPool.reset();
};

ScreenRenderHelper.prototype.resetScreen = function resetScreen (screen) {
  this._screen = screen;
  this._curMaterail = null;
  this._curTexture = null;
  this._curSpriteBatch = null;
  this._curStencilLevel = 0;
  this._curUserKey = 0;
};

ScreenRenderHelper.prototype._stencilWriteMask = function _stencilWriteMask () {
  return 0x01 << (this._curStencilLevel - 1);
};

ScreenRenderHelper.prototype._stencilRef = function _stencilRef () {
  var result = 0;
  for (var i = 0; i < this._curStencilLevel; ++i) {
    result += (0x01 << i);
  }
  return result;
};

ScreenRenderHelper.prototype._cloneMaterial = function _cloneMaterial (rawMaterial) {
  var mat = this._materialPool.add();
  mat.copy(rawMaterial);

  return mat;
};

ScreenRenderHelper.prototype._getSpriteBatchModel = function _getSpriteBatchModel (material, texture) {
  if (
    this._curSpriteBatch !== null &&
    this._curMaterail === material &&
    this._curTexture === texture
  ) {
    return this._curSpriteBatch;
  }

  var mat = this._cloneMaterial(material);
  mat.setProperty('mainTexture', texture);

  if (this._curStencilLevel !== 0) {
    var stencilRef = this._stencilRef();
    _setStencil(
      mat,
      true,
      gfx.DS_FUNC_EQUAL,
      stencilRef,
      stencilRef,
      gfx.STENCIL_OP_KEEP,
      gfx.STENCIL_OP_KEEP,
      gfx.STENCIL_OP_KEEP,
      0
    );
  } else {
    _setStencil(
      mat,
      false,
      gfx.DS_FUNC_ALWAYS,
      0,
      0,
      gfx.STENCIL_OP_KEEP,
      gfx.STENCIL_OP_KEEP,
      gfx.STENCIL_OP_KEEP,
      0
    );
  }

  var spriteBatch = this._spriteBatchModelPool.add();
  spriteBatch.setNode(this._dummyNode);
  spriteBatch.setEffect(mat.effectInst);
  spriteBatch._viewID = this._screen._view._id;
  spriteBatch.setUserKey(this._curUserKey++);

  this._app.scene.addModel(spriteBatch);

  //
  this._curMaterail = material;
  this._curTexture = texture;
  this._curSpriteBatch = spriteBatch;

  return spriteBatch;
};

ScreenRenderHelper.prototype.addImage = function addImage (image) {
  var vdata = image.calcVertexData(
    image._rect.x,
    image._rect.y,
    image._rect.w,
    image._rect.h
  );

  var sprite = image.sprite;
  if (image.sprite === null) {
    sprite = this._app.assets.get('default-sprite');
  }

  var spriteBatch = this._getSpriteBatchModel(image.material, sprite.texture);
  spriteBatch.addSprite(
    vdata.wposList,
    vdata.uvs,
    vdata.color,
    vdata.indices
  );
};

ScreenRenderHelper.prototype.addText = function addText (text) {
  var vdata = text.calcVertexData(
    text._rect.x,
    text._rect.y,
    text._rect.w,
    text._rect.h
  );

  var fontTexture = (text.font === null) ? text.fontTexture : text.font.texture;
  var spriteBatch = this._getSpriteBatchModel(text.material, fontTexture);
  spriteBatch.addSprite(
    vdata.wposList,
    vdata.uvs,
    vdata.color,
    vdata.indices
  );
};

ScreenRenderHelper.prototype.pushMask = function pushMask (mask) {
  if (this._curStencilLevel + 1 > MAX_STENCIL_LEVEL) {
    console.error(("Stencil level exceeed, we only support " + MAX_STENCIL_LEVEL + " level in this device."));
    return;
  }
  this._curStencilLevel++;

  var vdata = mask.calcVertexData(
    mask._rect.x,
    mask._rect.y,
    mask._rect.w,
    mask._rect.h
  );

  // break batch
  this._curSpriteBatch = null;

  // setup mask material
  var sprite = mask.sprite;
  if (mask.sprite === null) {
    sprite = this._app.assets.get('default-sprite');
  }

  var mat = this._cloneMaterial(mask.material);
  mat.setProperty('mainTexture', sprite.texture);
  var stencilRef = this._stencilRef();
  var stencilWriteMask = this._stencilWriteMask();
  _setStencil(
    mat,
    true,
    gfx.DS_FUNC_NEVER,
    stencilRef,
    stencilWriteMask,
    gfx.STENCIL_OP_REPLACE,
    gfx.STENCIL_OP_KEEP,
    gfx.STENCIL_OP_KEEP,
    stencilWriteMask
  );

  // setup mask model
  var spriteBatch = this._spriteBatchModelPool.add();
  spriteBatch.setNode(this._dummyNode);
  spriteBatch.setEffect(mat.effectInst);
  spriteBatch._viewID = this._screen._view._id;
  spriteBatch.setUserKey(this._curUserKey++);

  spriteBatch.addSprite(
    vdata.wposList,
    vdata.uvs,
    vdata.color,
    vdata.indices
  );

  this._app.scene.addModel(spriteBatch);
};

ScreenRenderHelper.prototype.popMask = function popMask (mask) {
  if (this._curStencilLevel - 1 < 0) {
    console.error('popMask being called more than once');
    return;
  }

  // break batch
  this._curSpriteBatch = null;

  var vdata = mask.calcVertexData(
    mask._rect.x,
    mask._rect.y,
    mask._rect.w,
    mask._rect.h
  );

  // setup mask material
  var sprite = mask.sprite;
  if (mask.sprite === null) {
    sprite = this._app.assets.get('default-sprite');
  }

  var mat = this._cloneMaterial(mask.material);
  mat.setProperty('mainTexture', sprite.texture);
  var stencilWriteMask = this._stencilWriteMask();
  _setStencil(
    mat,
    true,
    gfx.DS_FUNC_NEVER,
    0,
    stencilWriteMask,
    gfx.STENCIL_OP_REPLACE,
    gfx.STENCIL_OP_KEEP,
    gfx.STENCIL_OP_KEEP,
    stencilWriteMask
  );

  // setup mask model
  var spriteBatch = this._spriteBatchModelPool.add();
  spriteBatch.setNode(this._dummyNode);
  spriteBatch.setEffect(mat.effectInst);
  spriteBatch._viewID = this._screen._view._id;
  spriteBatch.setUserKey(this._curUserKey++);

  spriteBatch.addSprite(
    vdata.wposList,
    vdata.uvs,
    vdata.color,
    vdata.indices
  );

  this._app.scene.addModel(spriteBatch);

  this._curStencilLevel--;
};

var _entities = new FixedArray(100);
var _mouseBtns = ['left', 'middle', 'right'];

var _getWidgetAt = (function () {
  var p = vec3.zero();
  var q = vec3.zero();
  var a = vec3.zero();
  var b = vec3.zero();
  var c = vec3.zero();
  var d = vec3.zero();

  return function (screen, entities, x, y) {
    // TEMP DISABLE:
    // let view = screen._view;
    // let cx = view._rect.x;
    // let cy = view._rect.y;
    // let cw = view._rect.w;
    // let ch = view._rect.h;

    // // calculate screen pos in far clip plane
    // let wx = (x - cx) * 2.0 / cw - 1.0;
    // let wy = (y - cy) * 2.0 / ch - 1.0;
    // vec3.set(_v3_tmp, wx, wy, 0);

    // // transform to world
    // vec3.transformMat4(_v3_tmp, _v3_tmp, view._matInvViewProj);

    vec3.set(p, x, y, 1);
    vec3.set(q, x, y, -1);

    //
    for (var i = entities.length - 1; i >= 0; --i) {
      var ent = entities.data[i];
      var widget = ent.getComp('Widget');
      widget.getWorldCorners(a, b, c, d);

      if (intersect.line_quad(p, q, a, b, c, d)) {
        // check if we have mask, and if mask contains the intersect entity
        var parent = ent.parent;
        var parentWidget = parent.getComp('Widget');
        var skip = false;

        // NOTE: we must test all masks
        while (parentWidget) {
          if (parent.getComp('Mask')) {
            parentWidget.getWorldCorners(a, b, c, d);
            if (intersect.line_quad(p, q, a, b, c, d) === false) {
              skip = true;
            }
          }

          parent = parent.parent;
          parentWidget = parent.getComp('Widget');
        }

        if (skip) {
          continue;
        }

        return ent;
      }
    }

    return null;
  };
})();

var WidgetSystem = (function (System) {
  function WidgetSystem() {
    System.call(this);

    this._screens = [];
    this._screenRenderHelper = null;

    this._hoveringEntity = null;
    this._focusedEntity = null;
    this._capturingEntities = [];
    this._mouseEventPool = new RecyclePool(function () {
      return new MouseEvent('unknown');
    }, 8);
    this._keyboardEventPool = new RecyclePool(function () {
      return new KeyboardEvent('unknown');
    }, 8);
    this._touchEventPool = new RecyclePool(function () {
      return new TouchEvent('unknown');
    }, 8);
    this._focusEventPool = new RecyclePool(function () {
      return new FocusEvent('unknown');
    }, 8);
  }

  if ( System ) WidgetSystem.__proto__ = System;
  WidgetSystem.prototype = Object.create( System && System.prototype );
  WidgetSystem.prototype.constructor = WidgetSystem;

  var prototypeAccessors = { hoveringEntity: { configurable: true },focusedEntity: { configurable: true } };

  prototypeAccessors.hoveringEntity.get = function () {
    return this._hoveringEntity;
  };

  prototypeAccessors.focusedEntity.get = function () {
    return this._focusedEntity;
  };

  WidgetSystem.prototype.init = function init () {
    this._screenRenderHelper = new ScreenRenderHelper(this._app);
  };

  WidgetSystem.prototype.addScreen = function addScreen (comp) {
    this._screens.push(comp);
    this._app.scene.addView(comp._view);
  };

  WidgetSystem.prototype.removeScreen = function removeScreen (comp) {
    var idx = this._screens.indexOf(comp);
    if (idx !== -1) {
      this._screens.splice(idx, 1);
      this._app.scene.removeView(comp._view);
    }
  };

  WidgetSystem.prototype.tick = function tick () {
    var this$1 = this;

    this._mouseEventPool.reset();
    this._keyboardEventPool.reset();
    this._touchEventPool.reset();
    this._focusEventPool.reset();
    this._screenRenderHelper.reset();

    // collect all entities (used in input & layout)
    _entities.reset();
    for (var index = 0; index < this._screens.length; ++index) {
      var screen = this$1._screens[index];

      if (!screen.enabled) {
        continue;
      }

      // skipt nested screen
      var nested = false;
      var parent = screen._entity.parent;
      while (parent) {
        if (parent.getComp('Screen')) {
          nested = true;
          break;
        }
        parent = parent.parent;
      }
      if (nested) {
        continue;
      }

      _entities.push(screen._entity);
      utils.walkSibling(screen._entity, function (ent) {
        if (ent.active === true) {
          _entities.push(ent);
          return true;
        } else {
          return false;
        }
      });
    }

    // // process inputs
    this._processInputs(_entities);

    // // process layout
    this._processLayout(_entities);

    // render screen elements (in the order of hierarchy)
    this._renderScreens();
  };

  WidgetSystem.prototype._processInputs = function _processInputs (entities) {
    var this$1 = this;

    var input = this._app.input;
    var targetEnt = null;
    var originTargetEnt = null;

    // ==========================
    // handle touches
    // ==========================

    if (input.hasTouch) {
      for (var i = 0; i < input.touchCount; ++i) {
        var touchInfo = input.getTouchInfo(i);
        originTargetEnt = _getWidgetAt(screen, entities, touchInfo.x, touchInfo.y);
        targetEnt = this$1._capturingEntities[i] ? this$1._capturingEntities[i] : originTargetEnt;

        if (targetEnt === null) {
          continue;
        }

        var touchEvent = this$1._touchEventPool.add();
        touchEvent.reset();
        touchEvent.id = touchInfo.id;
        touchEvent.dx = touchInfo.dx;
        touchEvent.dy = touchInfo.dy;
        touchEvent.x = touchInfo.x;
        touchEvent.y = touchInfo.y;
        touchEvent.target = targetEnt;

        if (touchInfo.phase === 'start') {
          // NOTE: only first element can focus
          if (i === 0) {
            this$1._focus(targetEnt);
          }

          touchEvent.name = 'touchstart';
          touchEvent.bubbles = true;
          targetEnt.dispatch(touchEvent);
          this$1._capturingEntities[i] = targetEnt;
          // NOTE: only first element can hover
          if (i === 0) {
            this$1._hover(originTargetEnt, true);
          }
        } else if (touchInfo.phase === 'pressing') {
          if (touchInfo.dx !== 0 || touchInfo.dy !== 0) {
            if (i === 0) {
              this$1._hover(originTargetEnt, true);
            }

            touchEvent.name = 'touchmove';
            touchEvent.bubbles = true;
            targetEnt.dispatch(touchEvent);
          }
        } else if (touchInfo.phase === 'end') {
          if (i === 0) {
            this$1._hover(null, true);
          }

          touchEvent.name = 'touchend';
          touchEvent.bubbles = true;
          targetEnt.dispatch(touchEvent);
          this$1._capturingEntities[i] = null;
        } else if (touchInfo.phase === 'cancel') {
          if (i === 0) {
            this$1._hover(null, true);
          }

          touchEvent.name = 'touchcancel';
          touchEvent.bubbles = true;
          targetEnt.dispatch(touchEvent);
          this$1._capturingEntities[i] = null;
        }
      }

      return;
    }

    // ==========================
    // handle mouse input
    // ==========================

    var mousedown = input.hasMouseDown;
    var mouseup = input.hasMouseUp;
    var mousemoved = input.mouseDeltaX !== 0 || input.mouseDeltaY !== 0;

    if (
      mousemoved || mousedown || mouseup
    ) {
      originTargetEnt = _getWidgetAt(screen, entities, input.mouseX, input.mouseY);
      targetEnt = this._capturingEntities[0] ? this._capturingEntities[0] : originTargetEnt;
    }

    // ==========================
    // handle focus
    // ==========================

    if (mousedown) {
      this._focus(targetEnt);
      this._capturingEntities[0] = targetEnt;
    }

    if (targetEnt) {
      // emit mousedown
      if (mousedown) {
        for (var i$1 = 0; i$1 < _mouseBtns.length; ++i$1) {
          var btn = _mouseBtns[i$1];
          if (input.mousedown(btn)) {
            var mouseEvent = this$1._mouseEventPool.add();
            mouseEvent.reset();
            mouseEvent.name = 'mousedown';
            mouseEvent.bubbles = true;
            mouseEvent.dx = input.mouseDeltaX;
            mouseEvent.dy = input.mouseDeltaY;
            mouseEvent.mouseX = input.mouseX;
            mouseEvent.mouseY = input.mouseY;
            mouseEvent.target = targetEnt;
            mouseEvent.button = btn;
            mouseEvent.buttons = input.mouseButtons;

            targetEnt.dispatch(mouseEvent);
          }
        }
      }

      // emit mouseup
      if (mouseup) {
        for (var i$2 = 0; i$2 < _mouseBtns.length; ++i$2) {
          var btn$1 = _mouseBtns[i$2];
          if (input.mouseup(btn$1)) {
            var mouseEvent$1 = this$1._mouseEventPool.add();
            mouseEvent$1.reset();
            mouseEvent$1.name = 'mouseup';
            mouseEvent$1.bubbles = true;
            mouseEvent$1.dx = input.mouseDeltaX;
            mouseEvent$1.dy = input.mouseDeltaY;
            mouseEvent$1.mouseX = input.mouseX;
            mouseEvent$1.mouseY = input.mouseY;
            mouseEvent$1.target = targetEnt;
            mouseEvent$1.button = btn$1;
            mouseEvent$1.buttons = input.mouseButtons;

            targetEnt.dispatch(mouseEvent$1);
          }
        }
        this._capturingEntities[0] = null;
      }
    }

    if (mousemoved) {
      this._hover(originTargetEnt, false);

      // emit mousemove
      if (targetEnt) {
        var mouseEvent$2 = this._mouseEventPool.add();
        mouseEvent$2.reset();
        mouseEvent$2.name = 'mousemove';
        mouseEvent$2.bubbles = true;
        mouseEvent$2.dx = input.mouseDeltaX;
        mouseEvent$2.dy = input.mouseDeltaY;
        mouseEvent$2.mouseX = input.mouseX;
        mouseEvent$2.mouseY = input.mouseY;
        mouseEvent$2.target = targetEnt;
        mouseEvent$2.button = 0;
        mouseEvent$2.buttons = input.mouseButtons;

        targetEnt.dispatch(mouseEvent$2);
      }
    }

    // ==========================
    // handle keyboard input
    // ==========================

    if (this._focusedEntity) {
      input._keys.forEach(function (keyInfo) {
        if (keyInfo.state === 'down') {
          var keyboardEvent = this$1._keyboardEventPool.add();
          keyboardEvent.reset();
          keyboardEvent.name = 'keydown';
          keyboardEvent.bubbles = true;
          keyboardEvent.key = keyInfo.key;
          keyboardEvent.target = this$1._focusedEntity;

          this$1._focusedEntity.dispatch(keyboardEvent);
        }

        if (keyInfo.state === 'up') {
          var keyboardEvent$1 = this$1._keyboardEventPool.add();
          keyboardEvent$1.reset();
          keyboardEvent$1.name = 'keyup';
          keyboardEvent$1.bubbles = true;
          keyboardEvent$1.key = keyInfo.key;
          keyboardEvent$1.target = this$1._focusedEntity;

          this$1._focusedEntity.dispatch(keyboardEvent$1);
        }
      });
    }
  };

  WidgetSystem.prototype._focus = function _focus (ent) {
    // get focusable entity
    var focusableEnt = ent;
    if (focusableEnt && focusableEnt._destroyed) {
      focusableEnt = null;
    }
    var focusableWidget = focusableEnt ? focusableEnt.getComp('Widget') : null;
    while (focusableWidget) {
      if (focusableWidget.focusable) {
        break;
      }

      focusableEnt = focusableEnt.parent;
      focusableWidget = focusableEnt.getComp('Widget');
    }

    if (this._focusedEntity === focusableEnt) {
      return;
    }

    var lastFocused = this._focusedEntity;
    this._focusedEntity = focusableEnt;

    // blur
    if (lastFocused) {
      var focusEvent = this._focusEventPool.add();
      focusEvent.reset();
      focusEvent.name = 'blur';
      focusEvent.bubbles = false;
      focusEvent.target = lastFocused;
      focusEvent.relatedTarget = focusableEnt;

      lastFocused.dispatch(focusEvent);
    }

    // focus
    if (focusableEnt) {
      var focusEvent$1 = this._focusEventPool.add();
      focusEvent$1.reset();
      focusEvent$1.name = 'focus';
      focusEvent$1.bubbles = false;
      focusEvent$1.target = focusableEnt;
      focusEvent$1.relatedTarget = lastFocused;

      focusableEnt.dispatch(focusEvent$1);
    }
  };

  WidgetSystem.prototype._hover = function _hover (targetEnt, isTouch) {
    var this$1 = this;

    if (this._hoveringEntity === targetEnt) {
      return;
    }

    var input = this._app.input;
    var lastHovering = this._hoveringEntity;
    this._hoveringEntity = targetEnt;

    var leaves = [];
    var enters = [];

    // get leaves
    var ent = lastHovering;
    if (ent && ent._destroyed) {
      ent = null;
    }
    var widget = ent ? ent.getComp('Widget') : null;
    while (widget) {
      leaves.push(ent);
      ent = ent.parent;
      widget = ent.getComp('Widget');
    }

    // get enters
    ent = targetEnt;
    widget = ent ? ent.getComp('Widget') : null;
    while (widget) {
      enters.push(ent);
      ent = ent.parent;
      widget = ent.getComp('Widget');
    }

    var lcnt = leaves.length;
    var ecnt = enters.length;
    var stop = false;

    for (var i = 0; i < leaves.length; ++i) {
      var leave = leaves[i];

      for (var j = 0; j < enters.length; ++j) {
        var enter = enters[i];
        if (enter === leave) {
          lcnt = i;
          ecnt = j;
          stop = true;
        }
      }

      if (stop) {
        break;
      }
    }

    if (!isTouch) {
      // emit mouseleave
      for (var i$1 = 0; i$1 < lcnt; ++i$1) {
        var ent$1 = leaves[i$1];
        var mouseEvent = this$1._mouseEventPool.add();
        mouseEvent.reset();
        mouseEvent.name = 'mouseleave';
        mouseEvent.bubbles = false;
        mouseEvent.dx = input.mouseDeltaX;
        mouseEvent.dy = input.mouseDeltaY;
        mouseEvent.mouseX = input.mouseX;
        mouseEvent.mouseY = input.mouseY;
        mouseEvent.target = ent$1;
        mouseEvent.button = 0;
        mouseEvent.buttons = input.mouseButtons;

        ent$1.emit('mouseleave', mouseEvent);
      }

      // emit mouseenter
      for (var i$2 = ecnt - 1; i$2 >= 0; --i$2) {
        var ent$2 = enters[i$2];
        var mouseEvent$1 = this$1._mouseEventPool.add();
        mouseEvent$1.reset();
        mouseEvent$1.name = 'mouseenter';
        mouseEvent$1.bubbles = false;
        mouseEvent$1.dx = input.mouseDeltaX;
        mouseEvent$1.dy = input.mouseDeltaY;
        mouseEvent$1.mouseX = input.mouseX;
        mouseEvent$1.mouseY = input.mouseY;
        mouseEvent$1.target = ent$2;
        mouseEvent$1.button = 0;
        mouseEvent$1.buttons = input.mouseButtons;

        ent$2.emit('mouseenter', mouseEvent$1);
      }
    } else {
      var touchInfo = input.getTouchInfo(0);

      // emit touchleave
      for (var i$3 = 0; i$3 < lcnt; ++i$3) {
        var ent$3 = leaves[i$3];
        var touchEvent = this$1._touchEventPool.add();
        touchEvent.reset();
        touchEvent.name = 'touchleave';
        touchEvent.bubbles = false;
        touchEvent.id = touchInfo.id;
        touchEvent.dx = touchInfo.dx;
        touchEvent.dy = touchInfo.dy;
        touchEvent.x = touchInfo.x;
        touchEvent.y = touchInfo.y;
        touchEvent.target = ent$3;

        ent$3.emit('touchleave', touchEvent);
      }

      // emit touchenter
      for (var i$4 = ecnt - 1; i$4 >= 0; --i$4) {
        var ent$4 = enters[i$4];
        var touchEvent$1 = this$1._touchEventPool.add();
        touchEvent$1.reset();
        touchEvent$1.name = 'touchenter';
        touchEvent$1.bubbles = false;
        touchEvent$1.id = touchInfo.id;
        touchEvent$1.dx = touchInfo.dx;
        touchEvent$1.dy = touchInfo.dy;
        touchEvent$1.x = touchInfo.x;
        touchEvent$1.y = touchInfo.y;
        touchEvent$1.target = ent$4;

        ent$4.emit('touchenter', touchEvent$1);
      }
    }
  };

  WidgetSystem.prototype._processLayout = function _processLayout (entities) {
    var this$1 = this;

    for (var i = 0; i < entities.length; ++i) {
      var entity = entities.data[i];
      var widget = entity.getComp('Widget');
      var parent = entity.parent;
      var parentWidget = parent.getComp('Widget');
      var parentX = 0, parentY = 0;
      var parentWidth = 0, parentHeight = 0;

      // we are at root
      if (parentWidget === null) {
        // TODO:
        // let screen = parent.getComp('Screen');
        // width = screen.width;
        // height = screen.height;

        parentX = 0.0;
        parentY = 0.0;
        // the widget is the screen if parent widget is null
        parentWidth = this$1._app._canvas.width / widget.scaleFactor;
        parentHeight = this$1._app._canvas.height / widget.scaleFactor;
        widget.setOffset(0, 0);
        widget.setAnchors(0, 0, 0, 0);
        widget.setSize(parentWidth, parentHeight);
        widget.setPivot(0, 0);
      } else {
        parentX = parentWidget._rect.x;
        parentY = parentWidget._rect.y;
        parentWidth = parentWidget._rect.w;
        parentHeight = parentWidget._rect.h;
      }

      //
      widget.calculate(parentX, parentY, parentWidth, parentHeight);
    }
  };

  WidgetSystem.prototype._renderScreens = function _renderScreens () {
    var this$1 = this;

    for (var index = 0; index < this._screens.length; ++index) {
      var screen = this$1._screens[index];

      if (!screen.enabled) {
        continue;
      }

      // TODO: we don't need to do this all the time. Just do it when canvas resized.
      // reset view matrix
      var view = screen._view;
      var canvasWidth = this$1._app._canvas.width;
      var canvasHeight = this$1._app._canvas.height;
      mat4.ortho(view._matProj, 0, canvasWidth, 0, canvasHeight, -100, 100);
      mat4.copy(view._matViewProj, view._matProj);
      mat4.invert(view._matInvViewProj, view._matProj);
      view._rect.x = view._rect.y = 0;
      view._rect.w = canvasWidth;
      view._rect.h = canvasHeight;

      // reset screen states in renderer helper
      this$1._screenRenderHelper.resetScreen(screen);

      // render screen elements
      utils.walk2(screen._entity, function (entity) {
        var mask = entity.getComp('Mask');
        if (mask && mask.enabled) {
          this$1._screenRenderHelper.pushMask(mask);
        }

        var image = entity.getComp('Image');
        if (image && image.enabled) {
          this$1._screenRenderHelper.addImage(image);
        }

        var text = entity.getComp('Text');
        if (text && text.enabled) {
          this$1._screenRenderHelper.addText(text);
        }

      }, function (entity) {
        var mask = entity.getComp('Mask');
        if (mask && mask.enabled) {
          this$1._screenRenderHelper.popMask(mask);
        }
      });
    }
  };

  Object.defineProperties( WidgetSystem.prototype, prototypeAccessors );

  return WidgetSystem;
}(System));

var ParticleSystemManager = (function (System) {
  function ParticleSystemManager() {
    System.call(this);

    this._particleSystems = new FixedArray(10);
  }

  if ( System ) ParticleSystemManager.__proto__ = System;
  ParticleSystemManager.prototype = Object.create( System && System.prototype );
  ParticleSystemManager.prototype.constructor = ParticleSystemManager;

  ParticleSystemManager.prototype.add = function add (comp) {
    this._particleSystems.push(comp);
  };

  ParticleSystemManager.prototype.remove = function remove (comp) {
    var this$1 = this;

    for (var i = 0; i < this._particleSystems.length; ++i) {
      var c = this$1._particleSystems.data[i];
      if (c === comp) {
        this$1._particleSystems.fastRemove(i);
        break;
      }
    }
  };

  ParticleSystemManager.prototype.tick = function tick () {
    var this$1 = this;

    for (var i = 0; i < this._particleSystems.length; ++i) {
      var particleSystem = this$1._particleSystems.data[i];
      particleSystem.tick(this$1._app.deltaTime);
    }
  };

  return ParticleSystemManager;
}(System));

function _normalize (url) {
  return url
  .replace(/\\/g, '/')
  .replace(/[\/]+/g, '/')
  .replace(/\/\?/g, '?')
  .replace(/\/\#/g, '#')
  .replace(/\:\//g, '://');
}

var path = {
  /**
   * @method normalize
   * @param {string} url
   */
  normalize: function normalize(url) {
    return _normalize(url);
  },

  /**
   * @method join
   */
  join: function join() {
    var joined = [].slice.call(arguments, 0).join('/');
    return _normalize(joined);
  },
};

registry.registerLoader('mesh', meshLoader);
registry.registerLoader('material', materialLoader);
registry.registerLoader('texture', textureLoader);
registry.registerLoader('prefab', prefabLoader);
registry.registerLoader('gltf', gltfLoader);
registry.registerLoader('animation', animationLoader);
registry.registerLoader('audio', audioLoader);
registry.registerLoader('bmfont', bmfontLoader);
registry.registerLoader('otfont', otfontLoader);
registry.registerLoader('effect', effectLoader);
registry.registerLoader('program', programLoader);

// register builtin types
for (var name in types) {
  registry.registerType(name, types[name]);
}

// register builtin components
registry.registerClass('Script', ScriptComponent);
registry.registerClass('Camera', CameraComponent);
registry.registerClass('Light', LightComponent);
registry.registerClass('Model', ModelComponent);
registry.registerClass('SkinningModel', SkinningModelComponent);
registry.registerClass('Animation', AnimationComponent);
registry.registerClass('AudioSource', AudioSourceComponent);
registry.registerClass('Collider', ColliderComponent);
registry.registerClass('Skybox', SkyboxComponent);
registry.registerClass('Screen', ScreenComponent);
registry.registerClass('ScreenScaler', ScreenScalerComponent);
registry.registerClass('Widget', WidgetComponent);
registry.registerClass('Mask', MaskComponent);
registry.registerClass('Image', ImageComponent);
registry.registerClass('Text', TextComponent);
registry.registerClass('UIElement', UIElementComponent);
registry.registerClass('Button', ButtonComponent);
registry.registerClass('Toggle', ToggleComponent);
registry.registerClass('ToggleGroup', ToggleGroupComponent);
registry.registerClass('Slider', SliderComponent);
registry.registerClass('EditBox', EditBoxComponent);
registry.registerClass('ScrollBar', ScrollBarComponent);
registry.registerClass('ScrollView', ScrollViewComponent);
registry.registerClass('GridLayout', GridLayoutComponent);
registry.registerClass('ParticleSystem', ParticleSystemComponent);

// register builtin systems
registry.registerSystem('script', ScriptSystem, 'Script', 0);
registry.registerSystem('skinning-model', SkinningModelSystem, 'SkinningModel', 100);
registry.registerSystem('animation', AnimationSystem, 'Animation', 200);
registry.registerSystem('audio', AudioSystem, 'AudioSource', 200);
registry.registerSystem('physics', PhysicsSystem, 'Collider', 200);
registry.registerSystem('widget', WidgetSystem, 'Widget', 100);
registry.registerSystem('ui-element', UIElementSystem, 'UIElement', 101);
registry.registerSystem('particle-system', ParticleSystemManager, 'ParticleSystem', 100);

// register other classes
registry.registerClass('Keyframe', Keyframe);
registry.registerClass('AnimationCurve', AnimationCurve);

function _makeTick(app_) {
  var app = app_;

  return function (timestamp) {
    app._tickID = requestAnimationFrame(app._tick);

    // update timer
    if (timestamp === undefined) {
      timestamp = 0;
    }
    app.deltaTime = (timestamp - app._lasttime) / 1000;
    app.totalTime = timestamp / 1000;
    app._lasttime = timestamp;

    // tick debugger
    app._debugger.tick();

    // emit tick event
    app.emit('tick');

    // tick systems
    app.tick();

    // commit debugger commands
    app._debugger.postTick();

    // render the scene
    app._forward.render(app.scene);

    // TODO
    // app.lstats.tick();

    // reset internal states
    app._input.reset();
    app._scene.reset();
  };
}

var App$1 = (function (AppBase) {
  function App$$1(canvas, opts) {
    var this$1 = this;
    if ( opts === void 0 ) opts = {};

    AppBase.call(this, {
      poolSize: opts.poolSize || 100,
    });
    this.__initEventEmitter();

    // sub-modules (canvas)
    this._canvas = canvas;
    this._input = new Input(canvas, {
      lock: false,
      invertY: true,
    });
    this._device = new gfx.Device(canvas, opts);
    var builtins = initBuiltins(this._device);

    // sub-modules (renderer)
    renderer.addStage('opaque');
    renderer.addStage('transparent');
    renderer.addStage('ui');
    renderer.addStage('shadowcast');

    this._forward = new renderer.ForwardRenderer(this._device, {
      defaultTexture: builtins['default-texture']._texture,
      defaultTextureCube: builtins['default-texture-cube']._texture,
    });
    this._scene = new renderer.Scene();

    // sub-modules (engine)
    this._assetMng = new AssetMng(this);
    this._debugger = new Debugger(this);

    // register builtin assets
    for (var name in builtins) {
      var asset = builtins[name];
      this$1._assetMng.add(asset._uuid, asset);
    }

    // register extensions
    registry._init(this);

    // sort systems
    this._sortSystems();

    // life callback
    this._tick = _makeTick(this);

    // public
    this.deltaTime = 0;
    this.totalTime = 0;

    // internal
    this._tickID = null;
    this._lasttime = 0;
    this._activeCamera = null;

    window.addEventListener('resize', function () {
      this$1.resize();
    });
  }

  if ( AppBase ) App$$1.__proto__ = AppBase;
  App$$1.prototype = Object.create( AppBase && AppBase.prototype );
  App$$1.prototype.constructor = App$$1;

  var prototypeAccessors = { device: { configurable: true },scene: { configurable: true },input: { configurable: true },assets: { configurable: true },debugger: { configurable: true } };

  prototypeAccessors.device.get = function () {
    return this._device;
  };

  prototypeAccessors.scene.get = function () {
    return this._scene;
  };

  prototypeAccessors.input.get = function () {
    return this._input;
  };

  prototypeAccessors.assets.get = function () {
    return this._assetMng;
  };

  prototypeAccessors.debugger.get = function () {
    return this._debugger;
  };

  App$$1.prototype.run = function run () {
    if (!this._activeLevel) {
      console.warn('There is no level to run, please load it first');
      return;
    }

    this._tickID = requestAnimationFrame(this._tick);
  };

  App$$1.prototype.resize = function resize () {
    if (!this._canvas) {
      return;
    }

    var bcr = this._canvas.parentElement.getBoundingClientRect();
    this._canvas.width = bcr.width;
    this._canvas.height = bcr.height;

    this._input.resize();
  };

  App$$1.prototype.destroy = function destroy () {
    this._canvas = null;
    this._input.destroy();
    this._activeLevel.destroy();
    this._activeLevel = null;
    if (this._tickID) {
      cancelAnimationFrame(this._tickID);
    }
  };

  App$$1.prototype.find = function find (path$$1, refNode) {
    if (!path$$1) {
      return null;
    }

    refNode = refNode || this._activeLevel;
    return utils.find(refNode, path$$1);
  };

  App$$1.prototype.loadGameConfig = function loadGameConfig (baseUrl, gameConfig) {
    var this$1 = this;

    var assetInfos = gameConfig.assets;
    var scenes = gameConfig.scenes;
    // todo loadEntryScene
    var entryName = gameConfig.entry;

    for (var uuid in assetInfos) {
      var info = assetInfos[uuid];
      for (var item in info.urls) {
        info.urls[item] = path.join(baseUrl, info.urls[item]);
      }

      this$1.assets.registerAsset(uuid, info);
    }

    for (var sceneName in scenes) {
      this$1.assets.registerLevel(sceneName, path.join(baseUrl, scenes[sceneName]));
    }
  };

  Object.defineProperties( App$$1.prototype, prototypeAccessors );

  return App$$1;
}(App));

EventEmitter.mixin(App$1);



var physics = Object.freeze({
	CANNON: cannon
});

var index = {
  // registry
  registerLoader: registry.registerLoader,
  registerClass: registry.registerClass,
  registerSystem: registry.registerSystem,

  // ecs.js
  Node: Node,

  // assets
  Asset: Asset,
  Mesh: Mesh,
  Joints: Joints,
  Material: Material,
  Prefab: Prefab,
  AnimationClip: AnimationClip,
  AudioClip: AudioClip,
  Gltf: Gltf,
  Texture: Texture$2,
  Texture2D: Texture2D$2,
  TextureCube: TextureCube$2,
  Sprite: Sprite,

  // framework
  App: App$1,
  Level: Level,
  System: System,
  Component: Component,

  // components
  ScriptComponent: ScriptComponent,
  CameraComponent: CameraComponent,
  LightComponent: LightComponent,
  ModelComponent: ModelComponent,
  SkinningModelComponent: SkinningModelComponent,
  AnimationComponent: AnimationComponent,
  AudioSourceComponent: AudioSourceComponent,
  SkyboxComponent: SkyboxComponent,
  ParticleSystemComponent: ParticleSystemComponent,

  // ui-widget components
  ScreenComponent: ScreenComponent,
  ScreenScalerComponent: ScreenScalerComponent,
  WidgetComponent: WidgetComponent,
  ImageComponent: ImageComponent,
  TextComponent: TextComponent,
  MaskComponent: MaskComponent,
  UIElementComponent: UIElementComponent,
  ButtonComponent: ButtonComponent,
  ToggleComponent: ToggleComponent,
  ToggleGroupComponent: ToggleGroupComponent,
  SliderComponent: SliderComponent,
  EditBoxComponent: EditBoxComponent,
  ScrollBarComponent: ScrollBarComponent,
  BoundComponent: Bounds,
  ScrollViewComponent: ScrollViewComponent,
  GridLayoutComponent: GridLayoutComponent,

  // modules
  math: math,
  geometry: geometry,
  memop: memop,
  primitives: primitives,
  renderer: renderer,
  gfx: gfx,

  // misc
  utils: utils$1,
  resl: resl,
  path: path,
  input: Input,
  physics: physics,
  async: async,
};

return index;

}());
//# sourceMappingURL=engine.dev.js.map
